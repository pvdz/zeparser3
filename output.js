// <from> /home/qfox/apps/babel/babel.config.js

"use strict";
module.exports = function(api) {
  const env = api.env();
  const includeCoverage = process.env.BABEL_COVERAGE === "true";
  const envOpts = {
    loose: true,
    modules: false,
    exclude: ["transform-typeof-symbol"],
  };
  let convertESM = true;
  let ignoreLib = true;
  let includeRuntime = false;
  switch (env) {
    // Configs used during bundling builds.
    case "babel-parser":
      convertESM = false;
      ignoreLib = false;
      break;
    case "standalone":
      convertESM = false;
      ignoreLib = false;
      includeRuntime = true;
      break;
    case "production":
      // Config during builds before publish.
      envOpts.targets = {
        node: "6.9",
      };
      break;
    case "development":
      envOpts.debug = true;
      envOpts.targets = {
        node: "current",
      };
      break;
    case "test":
      envOpts.targets = {
        node: "current",
      };
      break;
  }
  const config = {
    // Our dependencies are all standard CommonJS, along with all sorts of
    // other random files in Babel's codebase, so we use script as the default,
    // and then mark actual modules as modules farther down.
    sourceType: "script",
    comments: false,
    ignore: [
      // These may not be strictly necessary with the newly-limited scope of
      // babelrc searching, but including them for now because we had them
      // in our .babelignore before.
      "packages/*/test/fixtures",
      ignoreLib ? "packages/*/lib" : null,
      "packages/babel-standalone/babel.js",
      "packages/babel-preset-env-standalone/babel-preset-env.js",
    ].filter(Boolean),
    presets: [["@babel/env", envOpts]],
    plugins: [
      // TODO: Use @babel/preset-flow when
      // https://github.com/babel/babel/issues/7233 is fixed
      "@babel/plugin-transform-flow-strip-types",
      ["@babel/proposal-class-properties", { loose: true }],
      "@babel/proposal-export-namespace-from",
      "@babel/proposal-numeric-separator",
      [
        "@babel/proposal-object-rest-spread",
        { useBuiltIns: true, loose: true },
      ],
      // Explicitly use the lazy version of CommonJS modules.
      convertESM ? ["@babel/transform-modules-commonjs", { lazy: true }] : null,
    ].filter(Boolean),
    overrides: [
      {
        test: "packages/babel-parser",
        plugins: [
          "babel-plugin-transform-charcodes",
          ["@babel/transform-for-of", { assumeArray: true }],
        ],
      },
      {
        test: "./packages/babel-register",
        plugins: [
          // Override the root options to disable lazy imports for babel-register
          // because otherwise the require hook will try to lazy-import things
          // leading to dependency cycles.
          convertESM ? "@babel/transform-modules-commonjs" : null,
        ].filter(Boolean),
      },
      {
        // The vast majority of our src files are modules, but we use
        // unambiguous to keep things simple until we get around to renaming
        // the modules to be more easily distinguished from CommonJS
        test: [
          "packages/*/src",
          "packages/*/test",
          "codemods/*/src",
          "codemods/*/test",
        ],
        sourceType: "unambiguous",
      },
      {
        // The runtime transform shouldn't process its own runtime or core-js.
        exclude: [
          "packages/babel-runtime",
          /[\\/]node_modules[\\/](?:@babel\/runtime|babel-runtime|core-js)[\\/]/,
        ],
        plugins: [includeRuntime ? "@babel/transform-runtime" : null].filter(
          Boolean
        ),
      },
    ].filter(Boolean),
  };
  // we need to do this as long as we do not test everything from source
  if (includeCoverage) {
    config.auxiliaryCommentBefore = "istanbul ignore next";
    config.plugins.push("babel-plugin-istanbul");
  }
  return config;
};

// </from> /home/qfox/apps/babel/babel.config.js

// <from> /home/qfox/apps/babel/eslint-local-rules.js

"use strict";
const noDeprecatedClone = require("./scripts/eslint_rules/no-deprecated-clone");
const noUndefinedIdentifier = require("./scripts/eslint_rules/no-undefined-identifier");
module.exports = {
  "no-deprecated-clone": noDeprecatedClone,
  "no-undefined-identifier": noUndefinedIdentifier,
};

// </from> /home/qfox/apps/babel/eslint-local-rules.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-proposal-class-properties/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import nameFunction from "@babel/helper-function-name";
import syntaxClassProperties from "@babel/plugin-syntax-class-properties";
import { template, traverse, types as t } from "@babel/core";
import { environmentVisitor } from "@babel/helper-replace-supers";
import memberExpressionToFunctions from "@babel/helper-member-expression-to-functions";
import optimiseCall from "@babel/helper-optimise-call-expression";
export default declare((api, options) => {
  api.assertVersion(7);
  const { loose } = options;
  const findBareSupers = traverse.visitors.merge([
    {
      Super(path) {
        const { node, parentPath } = path;
        if (parentPath.isCallExpression({ callee: node })) {
          this.push(parentPath);
        }
      },
    },
    environmentVisitor,
  ]);
  const referenceVisitor = {
    "TSTypeAnnotation|TypeAnnotation"(path) {
      path.skip();
    },
    ReferencedIdentifier(path) {
      if (this.scope.hasOwnBinding(path.node.name)) {
        this.scope.rename(path.node.name);
        path.skip();
      }
    },
  };
  const classFieldDefinitionEvaluationTDZVisitor = traverse.visitors.merge([
    {
      ReferencedIdentifier(path) {
        if (
          this.classBinding &&
          this.classBinding === path.scope.getBinding(path.node.name)
        ) {
          const classNameTDZError = this.file.addHelper("classNameTDZError");
          const throwNode = t.callExpression(classNameTDZError, [
            t.stringLiteral(path.node.name),
          ]);
          path.replaceWith(t.sequenceExpression([throwNode, path.node]));
          path.skip();
        }
      },
    },
    environmentVisitor,
  ]);
  // Traverses the class scope, handling private name references.  If an inner
  // class redeclares the same private name, it will hand off traversal to the
  // restricted visitor (which doesn't traverse the inner class's inner scope).
  const privateNameVisitor = {
    PrivateName(path) {
      const { name } = this;
      const { node, parentPath } = path;
      if (!parentPath.isMemberExpression({ property: node })) return;
      if (node.id.name !== name) return;
      this.handle(parentPath);
    },
    Class(path) {
      const { name } = this;
      const body = path.get("body.body");
      for (const prop of body) {
        if (!prop.isClassPrivateProperty()) continue;
        if (prop.node.key.id.name !== name) continue;
        // This class redeclares the private name.
        // So, we can only evaluate the things in the outer scope.
        path.traverse(privateNameInnerVisitor, this);
        path.skip();
        break;
      }
    },
  };
  // Traverses the outer portion of a class, without touching the class's inner
  // scope, for private names.
  const privateNameInnerVisitor = traverse.visitors.merge([
    {
      PrivateName: privateNameVisitor.PrivateName,
    },
    environmentVisitor,
  ]);
  const privateNameHandlerSpec = {
    memoise(member, count) {
      const { scope } = member;
      const { object } = member.node;
      const memo = scope.maybeGenerateMemoised(object);
      if (!memo) {
        return;
      }
      this.memoiser.set(object, memo, count);
    },
    receiver(member) {
      const { object } = member.node;
      if (this.memoiser.has(object)) {
        return t.cloneNode(this.memoiser.get(object));
      }
      return t.cloneNode(object);
    },
    get(member) {
      const { map, file } = this;
      return t.callExpression(file.addHelper("classPrivateFieldGet"), [
        this.receiver(member),
        t.cloneNode(map),
      ]);
    },
    set(member, value) {
      const { map, file } = this;
      return t.callExpression(file.addHelper("classPrivateFieldSet"), [
        this.receiver(member),
        t.cloneNode(map),
        value,
      ]);
    },
    call(member, args) {
      // The first access (the get) should do the memo assignment.
      this.memoise(member, 1);
      return optimiseCall(this.get(member), this.receiver(member), args);
    },
  };
  const privateNameHandlerLoose = {
    handle(member) {
      const { prop, file } = this;
      const { object } = member.node;
      member.replaceWith(
        template.expression`BASE(REF, PROP)[PROP]`({
          BASE: file.addHelper("classPrivateFieldLooseBase"),
          REF: object,
          PROP: prop,
        }),
      );
    },
  };
  const staticPrivatePropertyHandlerSpec = {
    ...privateNameHandlerSpec,
    get(member) {
      const { file, privateId, classRef } = this;
      return t.callExpression(
        file.addHelper("classStaticPrivateFieldSpecGet"),
        [this.receiver(member), t.cloneNode(classRef), t.cloneNode(privateId)],
      );
    },
    set(member, value) {
      const { file, privateId, classRef } = this;
      return t.callExpression(
        file.addHelper("classStaticPrivateFieldSpecSet"),
        [
          this.receiver(member),
          t.cloneNode(classRef),
          t.cloneNode(privateId),
          value,
        ],
      );
    },
  };
  function buildClassPropertySpec(ref, path, state) {
    const { scope } = path;
    const { key, value, computed } = path.node;
    return t.expressionStatement(
      t.callExpression(state.addHelper("defineProperty"), [
        ref,
        computed || t.isLiteral(key) ? key : t.stringLiteral(key.name),
        value || scope.buildUndefinedNode(),
      ]),
    );
  }
  function buildClassPropertyLoose(ref, path) {
    const { scope } = path;
    const { key, value, computed } = path.node;
    return t.expressionStatement(
      t.assignmentExpression(
        "=",
        t.memberExpression(ref, key, computed || t.isLiteral(key)),
        value || scope.buildUndefinedNode(),
      ),
    );
  }
  function buildClassPrivatePropertySpec(ref, path, initNodes, state) {
    const { parentPath, scope } = path;
    const { name } = path.node.key.id;
    const map = scope.generateUidIdentifier(name);
    memberExpressionToFunctions(parentPath, privateNameVisitor, {
      name,
      map,
      file: state,
      ...privateNameHandlerSpec,
    });
    initNodes.push(
      template.statement`var MAP = new WeakMap();`({
        MAP: map,
      }),
    );
    // Must be late evaluated in case it references another private field.
    return () =>
      template.statement`
        MAP.set(REF, {
          // configurable is always false for private elements
          // enumerable is always false for private elements
          writable: true,
          value: VALUE
        });
      `({
        MAP: map,
        REF: ref,
        VALUE: path.node.value || scope.buildUndefinedNode(),
      });
  }
  function buildClassPrivatePropertyLooseHelper(ref, path, state) {
    const { parentPath, scope } = path;
    const { name } = path.node.key.id;
    const prop = scope.generateUidIdentifier(name);
    parentPath.traverse(privateNameVisitor, {
      name,
      prop,
      file: state,
      ...privateNameHandlerLoose,
    });
    return {
      keyDecl: template.statement`var PROP = HELPER(NAME);`({
        PROP: prop,
        HELPER: state.addHelper("classPrivateFieldLooseKey"),
        NAME: t.stringLiteral(name),
      }),
      // Must be late evaluated in case it references another private field.
      buildInit: () =>
        template.statement.ast`
          Object.defineProperty(${ref}, ${prop}, {
            // configurable is false by default
            // enumerable is false by default
            writable: true,
            value: ${path.node.value || scope.buildUndefinedNode()}
          });
        `,
    };
  }
  function buildClassInstancePrivatePropertyLoose(ref, path, initNodes, state) {
    const { keyDecl, buildInit } = buildClassPrivatePropertyLooseHelper(
      ref,
      path,
      state,
    );
    initNodes.push(keyDecl);
    return buildInit;
  }
  function buildClassStaticPrivatePropertyLoose(ref, path, state) {
    const { keyDecl, buildInit } = buildClassPrivatePropertyLooseHelper(
      ref,
      path,
      state,
    );
    return [keyDecl, buildInit()];
  }
  function buildClassStaticPrivatePropertySpec(ref, path, state) {
    const { parentPath, scope } = path;
    const { name } = path.node.key.id;
    const privateId = scope.generateUidIdentifier(name);
    memberExpressionToFunctions(parentPath, privateNameVisitor, {
      name,
      privateId,
      classRef: ref,
      file: state,
      ...staticPrivatePropertyHandlerSpec,
    });
    return [
      template.statement.ast`
        var ${privateId} = {
          // configurable is always false for private elements
          // enumerable is always false for private elements
          writable: true,
          value: ${path.node.value || scope.buildUndefinedNode()}
        }
      `,
    ];
  }
  const buildClassProperty = loose
    ? buildClassPropertyLoose
    : buildClassPropertySpec;
  const buildClassPrivateProperty = loose
    ? buildClassInstancePrivatePropertyLoose
    : buildClassPrivatePropertySpec;
  const buildClassStaticPrivateProperty = loose
    ? buildClassStaticPrivatePropertyLoose
    : buildClassStaticPrivatePropertySpec;
  return {
    inherits: syntaxClassProperties,
    visitor: {
      Class(path, state) {
        const isDerived = !!path.node.superClass;
        let constructor;
        const props = [];
        const computedPaths = [];
        const privateNames = new Set();
        const body = path.get("body");
        for (const path of body.get("body")) {
          const { computed, decorators } = path.node;
          if (computed) {
            computedPaths.push(path);
          }
          if (decorators && decorators.length > 0) {
            throw path.buildCodeFrameError(
              "Decorators transform is necessary.",
            );
          }
          if (path.isClassPrivateProperty()) {
            const {
              key: {
                id: { name },
              },
            } = path.node;
            if (privateNames.has(name)) {
              throw path.buildCodeFrameError("Duplicate private field");
            }
            privateNames.add(name);
          }
          if (path.isProperty()) {
            props.push(path);
          } else if (path.isClassMethod({ kind: "constructor" })) {
            constructor = path;
          }
        }
        if (!props.length) return;
        let ref;
        if (path.isClassExpression() || !path.node.id) {
          nameFunction(path);
          ref = path.scope.generateUidIdentifier("class");
        } else {
          // path.isClassDeclaration() && path.node.id
          ref = path.node.id;
        }
        const computedNodes = [];
        const staticNodes = [];
        const instanceBody = [];
        for (const computedPath of computedPaths) {
          computedPath.traverse(classFieldDefinitionEvaluationTDZVisitor, {
            classBinding:
              path.node.id && path.scope.getBinding(path.node.id.name),
            file: this.file,
          });
          const computedNode = computedPath.node;
          // Make sure computed property names are only evaluated once (upon class definition)
          // and in the right order in combination with static properties
          if (!computedPath.get("key").isConstantExpression()) {
            const ident = path.scope.generateUidIdentifierBasedOnNode(
              computedNode.key,
            );
            computedNodes.push(
              t.variableDeclaration("var", [
                t.variableDeclarator(ident, computedNode.key),
              ]),
            );
            computedNode.key = t.cloneNode(ident);
          }
        }
        // Transform private props before publics.
        const privateMaps = [];
        const privateMapInits = [];
        for (const prop of props) {
          if (prop.isPrivate() && !prop.node.static) {
            const inits = [];
            privateMapInits.push(inits);
            privateMaps.push(
              buildClassPrivateProperty(t.thisExpression(), prop, inits, state),
            );
          }
        }
        let p = 0;
        for (const prop of props) {
          if (prop.node.static) {
            if (prop.isPrivate()) {
              staticNodes.push(
                ...buildClassStaticPrivateProperty(
                  t.cloneNode(ref),
                  prop,
                  state,
                ),
              );
            } else {
              staticNodes.push(
                buildClassProperty(t.cloneNode(ref), prop, state),
              );
            }
          } else if (prop.isPrivate()) {
            instanceBody.push(privateMaps[p]());
            staticNodes.push(...privateMapInits[p]);
            p++;
          } else {
            instanceBody.push(
              buildClassProperty(t.thisExpression(), prop, state),
            );
          }
        }
        if (instanceBody.length) {
          if (!constructor) {
            const newConstructor = t.classMethod(
              "constructor",
              t.identifier("constructor"),
              [],
              t.blockStatement([]),
            );
            if (isDerived) {
              newConstructor.params = [t.restElement(t.identifier("args"))];
              newConstructor.body.body.push(
                t.expressionStatement(
                  t.callExpression(t.super(), [
                    t.spreadElement(t.identifier("args")),
                  ]),
                ),
              );
            }
            [constructor] = body.unshiftContainer("body", newConstructor);
          }
          const state = { scope: constructor.scope };
          for (const prop of props) {
            if (prop.node.static) continue;
            prop.traverse(referenceVisitor, state);
          }
          //
          if (isDerived) {
            const bareSupers = [];
            constructor.traverse(findBareSupers, bareSupers);
            for (const bareSuper of bareSupers) {
              bareSuper.insertAfter(instanceBody);
            }
          } else {
            constructor.get("body").unshiftContainer("body", instanceBody);
          }
        }
        for (const prop of props) {
          prop.remove();
        }
        if (computedNodes.length === 0 && staticNodes.length === 0) return;
        if (path.isClassExpression()) {
          path.scope.push({ id: ref });
          path.replaceWith(
            t.assignmentExpression("=", t.cloneNode(ref), path.node),
          );
        } else if (!path.node.id) {
          // Anonymous class declaration
          path.node.id = ref;
        }
        path.insertBefore(computedNodes);
        path.insertAfter(staticNodes);
      },
      PrivateName(path) {
        throw path.buildCodeFrameError(`Unknown PrivateName "${path}"`);
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-proposal-class-properties/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-cli/index.js

throw new Error("Use the `@babel/core` package instead of `@babel/cli`.");

// </from> /home/qfox/apps/babel/packages/babel-cli/index.js

// <from> /home/qfox/apps/babel/packages/babel-cli/src/babel/index.js

#!/usr/bin/env node
import parseArgv from "./options";
import dirCommand from "./dir";
import fileCommand from "./file";
const opts = parseArgv(process.argv);
const fn = opts.cliOptions.outDir ? dirCommand : fileCommand;
fn(opts).catch(err => {
  console.error(err);
  process.exit(1);
});

// </from> /home/qfox/apps/babel/packages/babel-cli/src/babel/index.js

// <from> /home/qfox/apps/babel/packages/babel-cli/src/babel/dir.js

import defaults from "lodash/defaults";
import outputFileSync from "output-file-sync";
import { sync as mkdirpSync } from "mkdirp";
import slash from "slash";
import path from "path";
import fs from "fs";
import * as util from "./util";
export default async function({ cliOptions, babelOptions }) {
  const filenames = cliOptions.filenames;
  async function write(src, base) {
    let relative = path.relative(base, src);
    if (!util.isCompilableExtension(relative, cliOptions.extensions)) {
      return false;
    }
    // remove extension and then append back on .js
    relative = util.adjustRelative(relative, cliOptions.keepFileExtension);
    const dest = getDest(relative, base);
    try {
      const res = await util.compile(
        src,
        defaults(
          {
            sourceFileName: slash(path.relative(dest + "/..", src)),
          },
          babelOptions,
        ),
      );
      if (!res) return false;
      // we've requested explicit sourcemaps to be written to disk
      if (
        res.map &&
        babelOptions.sourceMaps &&
        babelOptions.sourceMaps !== "inline"
      ) {
        const mapLoc = dest + ".map";
        res.code = util.addSourceMappingUrl(res.code, mapLoc);
        res.map.file = path.basename(relative);
        outputFileSync(mapLoc, JSON.stringify(res.map));
      }
      outputFileSync(dest, res.code);
      util.chmod(src, dest);
      if (cliOptions.verbose) {
        console.log(src + " -> " + dest);
      }
      return true;
    } catch (err) {
      if (cliOptions.watch) {
        console.error(err);
        return false;
      }
      throw err;
    }
  }
  function getDest(filename, base) {
    if (cliOptions.relative) {
      return path.join(base, cliOptions.outDir, filename);
    }
    return path.join(cliOptions.outDir, filename);
  }
  async function handleFile(src, base) {
    const written = await write(src, base);
    if (!written && cliOptions.copyFiles) {
      const filename = path.relative(base, src);
      const dest = getDest(filename, base);
      outputFileSync(dest, fs.readFileSync(src));
      util.chmod(src, dest);
    }
    return written;
  }
  async function handle(filenameOrDir) {
    if (!fs.existsSync(filenameOrDir)) return 0;
    const stat = fs.statSync(filenameOrDir);
    if (stat.isDirectory()) {
      const dirname = filenameOrDir;
      let count = 0;
      const files = util.readdir(dirname, cliOptions.includeDotfiles);
      for (const filename of files) {
        const src = path.join(dirname, filename);
        const written = await handleFile(src, dirname);
        if (written) count += 1;
      }
      return count;
    } else {
      const filename = filenameOrDir;
      const written = await handleFile(filename, path.dirname(filename));
      return written ? 1 : 0;
    }
  }
  if (!cliOptions.skipInitialBuild) {
    if (cliOptions.deleteDirOnStart) {
      util.deleteDir(cliOptions.outDir);
    }
    mkdirpSync(cliOptions.outDir);
    let compiledFiles = 0;
    for (const filename of cliOptions.filenames) {
      compiledFiles += await handle(filename);
    }
    console.log(
      `Successfully compiled ${compiledFiles} ${
        compiledFiles !== 1 ? "files" : "file"
      } with Babel.`,
    );
  }
  if (cliOptions.watch) {
    const chokidar = util.requireChokidar();
    filenames.forEach(function(filenameOrDir) {
      const watcher = chokidar.watch(filenameOrDir, {
        persistent: true,
        ignoreInitial: true,
        awaitWriteFinish: {
          stabilityThreshold: 50,
          pollInterval: 10,
        },
      });
      ["add", "change"].forEach(function(type) {
        watcher.on(type, function(filename) {
          handleFile(
            filename,
            filename === filenameOrDir
              ? path.dirname(filenameOrDir)
              : filenameOrDir,
          ).catch(err => {
            console.error(err);
          });
        });
      });
    });
  }
}

// </from> /home/qfox/apps/babel/packages/babel-cli/src/babel/dir.js

// <from> /home/qfox/apps/babel/packages/babel-cli/src/babel/file.js

import convertSourceMap from "convert-source-map";
import defaults from "lodash/defaults";
import sourceMap from "source-map";
import slash from "slash";
import path from "path";
import fs from "fs";
import * as util from "./util";
export default async function({ cliOptions, babelOptions }) {
  function buildResult(fileResults) {
    const map = new sourceMap.SourceMapGenerator({
      file:
        cliOptions.sourceMapTarget ||
        path.basename(cliOptions.outFile || "") ||
        "stdout",
      sourceRoot: babelOptions.sourceRoot,
    });
    let code = "";
    let offset = 0;
    for (const result of fileResults) {
      if (!result) continue;
      code += result.code + "\n";
      if (result.map) {
        const consumer = new sourceMap.SourceMapConsumer(result.map);
        const sources = new Set();
        consumer.eachMapping(function(mapping) {
          if (mapping.source != null) sources.add(mapping.source);
          map.addMapping({
            generated: {
              line: mapping.generatedLine + offset,
              column: mapping.generatedColumn,
            },
            source: mapping.source,
            original:
              mapping.source == null
                ? null
                : {
                    line: mapping.originalLine,
                    column: mapping.originalColumn,
                  },
          });
        });
        sources.forEach(source => {
          const content = consumer.sourceContentFor(source, true);
          if (content !== null) {
            map.setSourceContent(source, content);
          }
        });
        offset = code.split("\n").length - 1;
      }
    }
    // add the inline sourcemap comment if we've either explicitly asked for inline source
    // maps, or we've requested them without any output file
    if (
      babelOptions.sourceMaps === "inline" ||
      (!cliOptions.outFile && babelOptions.sourceMaps)
    ) {
      code += "\n" + convertSourceMap.fromObject(map).toComment();
    }
    return {
      map: map,
      code: code,
    };
  }
  function output(fileResults) {
    const result = buildResult(fileResults);
    if (cliOptions.outFile) {
      // we've requested for a sourcemap to be written to disk
      if (babelOptions.sourceMaps && babelOptions.sourceMaps !== "inline") {
        const mapLoc = cliOptions.outFile + ".map";
        result.code = util.addSourceMappingUrl(result.code, mapLoc);
        fs.writeFileSync(mapLoc, JSON.stringify(result.map));
      }
      fs.writeFileSync(cliOptions.outFile, result.code);
    } else {
      process.stdout.write(result.code + "\n");
    }
  }
  function readStdin() {
    return new Promise((resolve, reject) => {
      let code = "";
      process.stdin.setEncoding("utf8");
      process.stdin.on("readable", function() {
        const chunk = process.stdin.read();
        if (chunk !== null) code += chunk;
      });
      process.stdin.on("end", function() {
        resolve(code);
      });
      process.stdin.on("error", reject);
    });
  }
  async function stdin() {
    const code = await readStdin();
    const res = await util.transform(
      cliOptions.filename,
      code,
      defaults(
        {
          sourceFileName: "stdin",
        },
        babelOptions,
      ),
    );
    output([res]);
  }
  async function walk(filenames) {
    const _filenames = [];
    filenames.forEach(function(filename) {
      if (!fs.existsSync(filename)) return;
      const stat = fs.statSync(filename);
      if (stat.isDirectory()) {
        const dirname = filename;
        util
          .readdirForCompilable(filename, cliOptions.includeDotfiles)
          .forEach(function(filename) {
            _filenames.push(path.join(dirname, filename));
          });
      } else {
        _filenames.push(filename);
      }
    });
    const results = await Promise.all(
      _filenames.map(async function(filename) {
        let sourceFilename = filename;
        if (cliOptions.outFile) {
          sourceFilename = path.relative(
            path.dirname(cliOptions.outFile),
            sourceFilename,
          );
        }
        sourceFilename = slash(sourceFilename);
        try {
          return await util.compile(
            filename,
            defaults(
              {
                sourceFileName: sourceFilename,
                // Since we're compiling everything to be merged together,
                // "inline" applies to the final output file, but to the individual
                // files being concatenated.
                sourceMaps:
                  babelOptions.sourceMaps === "inline"
                    ? true
                    : babelOptions.sourceMaps,
              },
              babelOptions,
            ),
          );
        } catch (err) {
          if (!cliOptions.watch) {
            throw err;
          }
          console.error(err);
          return null;
        }
      }),
    );
    output(results);
  }
  async function files(filenames) {
    if (!cliOptions.skipInitialBuild) {
      await walk(filenames);
    }
    if (cliOptions.watch) {
      const chokidar = util.requireChokidar();
      chokidar
        .watch(filenames, {
          persistent: true,
          ignoreInitial: true,
          awaitWriteFinish: {
            stabilityThreshold: 50,
            pollInterval: 10,
          },
        })
        .on("all", function(type, filename) {
          if (!util.isCompilableExtension(filename, cliOptions.extensions)) {
            return;
          }
          if (type === "add" || type === "change") {
            if (cliOptions.verbose) {
              console.log(type + " " + filename);
            }
            walk(filenames).catch(err => {
              console.error(err);
            });
          }
        });
    }
  }
  if (cliOptions.filenames.length) {
    await files(cliOptions.filenames);
  } else {
    await stdin();
  }
}

// </from> /home/qfox/apps/babel/packages/babel-cli/src/babel/file.js

// <from> /home/qfox/apps/babel/packages/babel-cli/src/babel/util.js

import readdirRecursive from "fs-readdir-recursive";
import * as babel from "@babel/core";
import includes from "lodash/includes";
import path from "path";
import fs from "fs";
export function chmod(src, dest) {
  fs.chmodSync(dest, fs.statSync(src).mode);
}
type ReaddirFilter = (filename: string) => boolean;
export function readdir(
  dirname: string,
  includeDotfiles: boolean,
  filter: ReaddirFilter,
) {
  return readdirRecursive(dirname, (filename, _index, currentDirectory) => {
    const stat = fs.statSync(path.join(currentDirectory, filename));
    if (stat.isDirectory()) return true;
    return (
      (includeDotfiles || filename[0] !== ".") && (!filter || filter(filename))
    );
  });
}
export function readdirForCompilable(
  dirname: string,
  includeDotfiles: boolean,
) {
  return readdir(dirname, includeDotfiles, isCompilableExtension);
}
/**
 * Test if a filename ends with a compilable extension.
 */
export function isCompilableExtension(
  filename: string,
  altExts?: Array<string>,
): boolean {
  const exts = altExts || babel.DEFAULT_EXTENSIONS;
  const ext = path.extname(filename);
  return includes(exts, ext);
}
export function addSourceMappingUrl(code, loc) {
  return code + "\n//# sourceMappingURL=" + path.basename(loc);
}
const CALLER = {
  name: "@babel/cli",
};
export function transform(filename, code, opts) {
  opts = {
    ...opts,
    caller: CALLER,
    filename,
  };
  return new Promise((resolve, reject) => {
    babel.transform(code, opts, (err, result) => {
      if (err) reject(err);
      else resolve(result);
    });
  });
}
export function compile(filename, opts) {
  opts = {
    ...opts,
    caller: CALLER,
  };
  return new Promise((resolve, reject) => {
    babel.transformFile(filename, opts, (err, result) => {
      if (err) reject(err);
      else resolve(result);
    });
  });
}
export function deleteDir(path) {
  if (fs.existsSync(path)) {
    fs.readdirSync(path).forEach(function(file) {
      const curPath = path + "/" + file;
      if (fs.lstatSync(curPath).isDirectory()) {
        // recurse
        deleteDir(curPath);
      } else {
        // delete file
        fs.unlinkSync(curPath);
      }
    });
    fs.rmdirSync(path);
  }
}
process.on("uncaughtException", function(err) {
  console.error(err);
  process.exit(1);
});
export function requireChokidar() {
  try {
    return require("chokidar");
  } catch (err) {
    console.error(
      "The optional dependency chokidar failed to install and is required for " +
        "--watch. Chokidar is likely not supported on your platform.",
    );
    throw err;
  }
}
export function adjustRelative(relative, keepFileExtension) {
  if (keepFileExtension) {
    return relative;
  }
  return relative.replace(/\.(\w*?)$/, "") + ".js";
}

// </from> /home/qfox/apps/babel/packages/babel-cli/src/babel/util.js

// <from> /home/qfox/apps/babel/packages/babel-cli/src/babel/options.js

import fs from "fs";
import commander from "commander";
import { version } from "@babel/core";
import uniq from "lodash/uniq";
import glob from "glob";
import pkg from "../../package.json";
// Standard Babel input configs.
commander.option(
  "-f, --filename [filename]",
  "filename to use when reading from stdin - this will be used in source-maps, errors etc",
);
commander.option(
  "--presets [list]",
  "comma-separated list of preset names",
  collect,
);
commander.option(
  "--plugins [list]",
  "comma-separated list of plugin names",
  collect,
);
commander.option("--config-file [path]", "Path a to .babelrc file to use");
commander.option(
  "--env-name [name]",
  "The name of the 'env' to use when loading configs and plugins. " +
    "Defaults to the value of BABEL_ENV, or else NODE_ENV, or else 'development'.",
);
commander.option(
  "--root-mode [mode]",
  "The project-root resolution mode. " +
    "One of 'root' (the default), 'upward', or 'upward-optional'.",
);
// Basic file input configuration.
commander.option("--source-type [script|module]", "");
commander.option(
  "--no-babelrc",
  "Whether or not to look up .babelrc and .babelignore files",
);
commander.option(
  "--ignore [list]",
  "list of glob paths to **not** compile",
  collect,
);
commander.option(
  "--only [list]",
  "list of glob paths to **only** compile",
  collect,
);
// Misc babel config.
commander.option(
  "--no-highlight-code",
  "enable/disable ANSI syntax highlighting of code frames (on by default)",
);
// General output formatting.
commander.option(
  "--no-comments",
  "write comments to generated output (true by default)",
);
commander.option(
  "--retain-lines",
  "retain line numbers - will result in really ugly code",
);
commander.option(
  "--compact [true|false|auto]",
  "do not include superfluous whitespace characters and line terminators",
  booleanify,
);
commander.option("--minified", "save as much bytes when printing [true|false]");
commander.option(
  "--auxiliary-comment-before [string]",
  "print a comment before any injected non-user code",
);
commander.option(
  "--auxiliary-comment-after [string]",
  "print a comment after any injected non-user code",
);
// General soucemap formatting.
commander.option("-s, --source-maps [true|false|inline|both]", "", booleanify);
commander.option(
  "--source-map-target [string]",
  "set `file` on returned source map",
);
commander.option(
  "--source-file-name [string]",
  "set `sources[0]` on returned source map",
);
commander.option(
  "--source-root [filename]",
  "the root from which all sources are relative",
);
// Config params for certain module output formats.
commander.option(
  "--module-root [filename]",
  "optional prefix for the AMD module formatter that will be prepend to the filename on module definitions",
);
commander.option("-M, --module-ids", "insert an explicit id for modules");
commander.option(
  "--module-id [string]",
  "specify a custom name for module ids",
);
// "babel" command specific arguments that are not passed to @babel/core.
commander.option(
  "-x, --extensions [extensions]",
  "List of extensions to compile when a directory has been input [.es6,.js,.es,.jsx,.mjs]",
  collect,
);
commander.option(
  "--keep-file-extension",
  "Preserve the file extensions of the input files",
);
commander.option("-w, --watch", "Recompile files on changes");
commander.option(
  "--skip-initial-build",
  "Do not compile files before watching",
);
commander.option(
  "-o, --out-file [out]",
  "Compile all input files into a single file",
);
commander.option(
  "-d, --out-dir [out]",
  "Compile an input directory of modules into an output directory",
);
commander.option(
  "--relative",
  "Compile into an output directory relative to input directory or file. Requires --out-dir [out]",
);
commander.option(
  "-D, --copy-files",
  "When compiling a directory copy over non-compilable files",
);
commander.option(
  "--include-dotfiles",
  "Include dotfiles when compiling and copying non-compilable files",
);
commander.option("--verbose", "Log everything");
commander.option(
  "--delete-dir-on-start",
  "Delete the out directory before compilation",
);
commander.version(pkg.version + " (@babel/core " + version + ")");
commander.usage("[options] <files ...>");
export default function parseArgv(args: Array<string>) {
  //
  commander.parse(args);
  const errors = [];
  let filenames = commander.args.reduce(function(globbed, input) {
    let files = glob.sync(input);
    if (!files.length) files = [input];
    return globbed.concat(files);
  }, []);
  filenames = uniq(filenames);
  filenames.forEach(function(filename) {
    if (!fs.existsSync(filename)) {
      errors.push(filename + " does not exist");
    }
  });
  if (commander.outDir && !filenames.length) {
    errors.push("--out-dir requires filenames");
  }
  if (commander.outFile && commander.outDir) {
    errors.push("--out-file and --out-dir cannot be used together");
  }
  if (commander.relative && !commander.outDir) {
    errors.push("--relative requires --out-dir usage");
  }
  if (commander.watch) {
    if (!commander.outFile && !commander.outDir) {
      errors.push("--watch requires --out-file or --out-dir");
    }
    if (!filenames.length) {
      errors.push("--watch requires filenames");
    }
  }
  if (commander.skipInitialBuild && !commander.watch) {
    errors.push("--skip-initial-build requires --watch");
  }
  if (commander.deleteDirOnStart && !commander.outDir) {
    errors.push("--delete-dir-on-start requires --out-dir");
  }
  if (
    !commander.outDir &&
    filenames.length === 0 &&
    typeof commander.filename !== "string" &&
    commander.babelrc !== false
  ) {
    errors.push(
      "stdin compilation requires either -f/--filename [filename] or --no-babelrc",
    );
  }
  if (errors.length) {
    console.error("babel:");
    errors.forEach(function(e) {
      console.error("  " + e);
    });
    process.exit(2);
  }
  const opts = commander.opts();
  const babelOptions = {
    presets: opts.presets,
    plugins: opts.plugins,
    rootMode: opts.rootMode,
    configFile: opts.configFile,
    envName: opts.envName,
    sourceType: opts.sourceType,
    ignore: opts.ignore,
    only: opts.only,
    retainLines: opts.retainLines,
    compact: opts.compact,
    minified: opts.minified,
    auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
    auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
    sourceMaps: opts.sourceMaps,
    sourceFileName: opts.sourceFileName,
    sourceRoot: opts.sourceRoot,
    moduleRoot: opts.moduleRoot,
    moduleIds: opts.moduleIds,
    moduleId: opts.moduleId,
    // Commander will default the "--no-" arguments to true, but we want to
    // leave them undefined so that @babel/core can handle the
    // default-assignment logic on its own.
    babelrc: opts.babelrc === true ? undefined : opts.babelrc,
    highlightCode: opts.highlightCode === true ? undefined : opts.highlightCode,
    comments: opts.comments === true ? undefined : opts.comments,
  };
  // If the @babel/cli version is newer than the @babel/core version, and we have added
  // new options for @babel/core, we'll potentially get option validation errors from
  // @babel/core. To avoid that, we delete undefined options, so @babel/core will only
  // give the error if users actually pass an unsupported CLI option.
  for (const key of Object.keys(babelOptions)) {
    if (babelOptions[key] === undefined) {
      delete babelOptions[key];
    }
  }
  return {
    babelOptions,
    cliOptions: {
      filename: opts.filename,
      filenames,
      extensions: opts.extensions,
      keepFileExtension: opts.keepFileExtension,
      watch: opts.watch,
      skipInitialBuild: opts.skipInitialBuild,
      outFile: opts.outFile,
      outDir: opts.outDir,
      relative: opts.relative,
      copyFiles: opts.copyFiles,
      includeDotfiles: opts.includeDotfiles,
      verbose: opts.verbose,
      deleteDirOnStart: opts.deleteDirOnStart,
      sourceMapTarget: opts.sourceMapTarget,
    },
  };
}
function booleanify(val: any): boolean | any {
  if (val === "true" || val == 1) {
    return true;
  }
  if (val === "false" || val == 0 || !val) {
    return false;
  }
  return val;
}
function collect(value, previousValue): Array<string> {
  // If the user passed the option with no value, like "babel file.js --presets", do nothing.
  if (typeof value !== "string") return previousValue;
  const values = value.split(",");
  return previousValue ? previousValue.concat(values) : values;
}

// </from> /home/qfox/apps/babel/packages/babel-cli/src/babel/options.js

// <from> /home/qfox/apps/babel/packages/babel-cli/src/babel-external-helpers.js

import commander from "commander";
import { buildExternalHelpers } from "@babel/core";
function collect(value, previousValue): Array<string> {
  // If the user passed the option with no value, like "babel-external-helpers --whitelist", do nothing.
  if (typeof value !== "string") return previousValue;
  const values = value.split(",");
  return previousValue ? previousValue.concat(values) : values;
}
commander.option(
  "-l, --whitelist [whitelist]",
  "Whitelist of helpers to ONLY include",
  collect,
);
commander.option(
  "-t, --output-type [type]",
  "Type of output (global|umd|var)",
  "global",
);
commander.usage("[options]");
commander.parse(process.argv);
console.log(buildExternalHelpers(commander.whitelist, commander.outputType));

// </from> /home/qfox/apps/babel/packages/babel-cli/src/babel-external-helpers.js

// <from> /home/qfox/apps/babel/packages/babel-cli/bin/babel-external-helpers.js

#!/usr/bin/env node
require("../lib/babel-external-helpers");

// </from> /home/qfox/apps/babel/packages/babel-cli/bin/babel-external-helpers.js

// <from> /home/qfox/apps/babel/packages/babel-cli/bin/babel.js

#!/usr/bin/env node
require("../lib/babel");

// </from> /home/qfox/apps/babel/packages/babel-cli/bin/babel.js

// <from> /home/qfox/apps/babel/packages/babel-preset-react/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import transformReactJSX from "@babel/plugin-transform-react-jsx";
import transformReactDisplayName from "@babel/plugin-transform-react-display-name";
import transformReactJSXSource from "@babel/plugin-transform-react-jsx-source";
import transformReactJSXSelf from "@babel/plugin-transform-react-jsx-self";
export default declare((api, opts) => {
  api.assertVersion(7);
  const pragma = opts.pragma || "React.createElement";
  const pragmaFrag = opts.pragmaFrag || "React.Fragment";
  const throwIfNamespace =
    opts.throwIfNamespace === undefined ? true : !!opts.throwIfNamespace;
  const development = !!opts.development;
  const useBuiltIns = !!opts.useBuiltIns;
  if (typeof development !== "boolean") {
    throw new Error(
      "@babel/preset-react 'development' option must be a boolean.",
    );
  }
  return {
    plugins: [
      [
        transformReactJSX,
        { pragma, pragmaFrag, throwIfNamespace, useBuiltIns },
      ],
      transformReactDisplayName,
      development && transformReactJSXSource,
      development && transformReactJSXSelf,
    ].filter(Boolean),
  };
});

// </from> /home/qfox/apps/babel/packages/babel-preset-react/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-destructuring/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import { types as t } from "@babel/core";
export default declare((api, options) => {
  api.assertVersion(7);
  const { loose = false, useBuiltIns = false } = options;
  if (typeof loose !== "boolean") {
    throw new Error(`.loose must be a boolean or undefined`);
  }
  const arrayOnlySpread = loose;
  function getExtendsHelper(file) {
    return useBuiltIns
      ? t.memberExpression(t.identifier("Object"), t.identifier("assign"))
      : file.addHelper("extends");
  }
  /**
   * Test if a VariableDeclaration's declarations contains any Patterns.
   */
  function variableDeclarationHasPattern(node) {
    for (const declar of (node.declarations: Array)) {
      if (t.isPattern(declar.id)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Test if an ArrayPattern's elements contain any RestElements.
   */
  function hasRest(pattern) {
    for (const elem of (pattern.elements: Array)) {
      if (t.isRestElement(elem)) {
        return true;
      }
    }
    return false;
  }
  const STOP_TRAVERSAL = {};
  // NOTE: This visitor is meant to be used via t.traverse
  const arrayUnpackVisitor = (node, ancestors, state) => {
    if (!ancestors.length) {
      // Top-level node: this is the array literal.
      return;
    }
    if (
      t.isIdentifier(node) &&
      t.isReferenced(node, ancestors[ancestors.length - 1]) &&
      state.bindings[node.name]
    ) {
      state.deopt = true;
      throw STOP_TRAVERSAL;
    }
  };
  class DestructuringTransformer {
    constructor(opts) {
      this.blockHoist = opts.blockHoist;
      this.operator = opts.operator;
      this.arrays = {};
      this.nodes = opts.nodes || [];
      this.scope = opts.scope;
      this.kind = opts.kind;
      this.arrayOnlySpread = opts.arrayOnlySpread;
      this.addHelper = opts.addHelper;
    }
    buildVariableAssignment(id, init) {
      let op = this.operator;
      if (t.isMemberExpression(id)) op = "=";
      let node;
      if (op) {
        node = t.expressionStatement(
          t.assignmentExpression(op, id, t.cloneNode(init)),
        );
      } else {
        node = t.variableDeclaration(this.kind, [
          t.variableDeclarator(id, t.cloneNode(init)),
        ]);
      }
      node._blockHoist = this.blockHoist;
      return node;
    }
    buildVariableDeclaration(id, init) {
      const declar = t.variableDeclaration("var", [
        t.variableDeclarator(t.cloneNode(id), t.cloneNode(init)),
      ]);
      declar._blockHoist = this.blockHoist;
      return declar;
    }
    push(id, _init) {
      const init = t.cloneNode(_init);
      if (t.isObjectPattern(id)) {
        this.pushObjectPattern(id, init);
      } else if (t.isArrayPattern(id)) {
        this.pushArrayPattern(id, init);
      } else if (t.isAssignmentPattern(id)) {
        this.pushAssignmentPattern(id, init);
      } else {
        this.nodes.push(this.buildVariableAssignment(id, init));
      }
    }
    toArray(node, count) {
      if (
        this.arrayOnlySpread ||
        (t.isIdentifier(node) && this.arrays[node.name])
      ) {
        return node;
      } else {
        return this.scope.toArray(node, count);
      }
    }
    pushAssignmentPattern({ left, right }, valueRef) {
      // we need to assign the current value of the assignment to avoid evaluating
      // it more than once
      const tempId = this.scope.generateUidIdentifierBasedOnNode(valueRef);
      this.nodes.push(this.buildVariableDeclaration(tempId, valueRef));
      const tempConditional = t.conditionalExpression(
        t.binaryExpression(
          "===",
          t.cloneNode(tempId),
          this.scope.buildUndefinedNode(),
        ),
        right,
        t.cloneNode(tempId),
      );
      if (t.isPattern(left)) {
        let patternId;
        let node;
        if (this.kind === "const") {
          patternId = this.scope.generateUidIdentifier(tempId.name);
          node = this.buildVariableDeclaration(patternId, tempConditional);
        } else {
          patternId = tempId;
          node = t.expressionStatement(
            t.assignmentExpression("=", t.cloneNode(tempId), tempConditional),
          );
        }
        this.nodes.push(node);
        this.push(left, patternId);
      } else {
        this.nodes.push(this.buildVariableAssignment(left, tempConditional));
      }
    }
    pushObjectRest(pattern, objRef, spreadProp, spreadPropIndex) {
      // get all the keys that appear in this object before the current spread
      const keys = [];
      let allLiteral = true;
      for (let i = 0; i < pattern.properties.length; i++) {
        const prop = pattern.properties[i];
        // we've exceeded the index of the spread property to all properties to the
        // right need to be ignored
        if (i >= spreadPropIndex) break;
        // ignore other spread properties
        if (t.isRestElement(prop)) continue;
        const key = prop.key;
        if (t.isIdentifier(key) && !prop.computed) {
          keys.push(t.stringLiteral(key.name));
        } else if (t.isLiteral(key)) {
          keys.push(t.stringLiteral(String(key.value)));
        } else {
          keys.push(t.cloneNode(key));
          allLiteral = false;
        }
      }
      let value;
      if (keys.length === 0) {
        value = t.callExpression(getExtendsHelper(this), [
          t.objectExpression([]),
          t.cloneNode(objRef),
        ]);
      } else {
        let keyExpression = t.arrayExpression(keys);
        if (!allLiteral) {
          keyExpression = t.callExpression(
            t.memberExpression(keyExpression, t.identifier("map")),
            [this.addHelper("toPropertyKey")],
          );
        }
        value = t.callExpression(
          this.addHelper(`objectWithoutProperties${loose ? "Loose" : ""}`),
          [t.cloneNode(objRef), keyExpression],
        );
      }
      this.nodes.push(this.buildVariableAssignment(spreadProp.argument, value));
    }
    pushObjectProperty(prop, propRef) {
      if (t.isLiteral(prop.key)) prop.computed = true;
      const pattern = prop.value;
      const objRef = t.memberExpression(
        t.cloneNode(propRef),
        prop.key,
        prop.computed,
      );
      if (t.isPattern(pattern)) {
        this.push(pattern, objRef);
      } else {
        this.nodes.push(this.buildVariableAssignment(pattern, objRef));
      }
    }
    pushObjectPattern(pattern, objRef) {
      // https://github.com/babel/babel/issues/681
      if (!pattern.properties.length) {
        this.nodes.push(
          t.expressionStatement(
            t.callExpression(this.addHelper("objectDestructuringEmpty"), [
              objRef,
            ]),
          ),
        );
      }
      // if we have more than one properties in this pattern and the objectRef is a
      // member expression then we need to assign it to a temporary variable so it's
      // only evaluated once
      if (pattern.properties.length > 1 && !this.scope.isStatic(objRef)) {
        const temp = this.scope.generateUidIdentifierBasedOnNode(objRef);
        this.nodes.push(this.buildVariableDeclaration(temp, objRef));
        objRef = temp;
      }
      //
      for (let i = 0; i < pattern.properties.length; i++) {
        const prop = pattern.properties[i];
        if (t.isRestElement(prop)) {
          this.pushObjectRest(pattern, objRef, prop, i);
        } else {
          this.pushObjectProperty(prop, objRef);
        }
      }
    }
    canUnpackArrayPattern(pattern, arr) {
      // not an array so there's no way we can deal with this
      if (!t.isArrayExpression(arr)) return false;
      // pattern has less elements than the array and doesn't have a rest so some
      // elements wont be evaluated
      if (pattern.elements.length > arr.elements.length) return;
      if (pattern.elements.length < arr.elements.length && !hasRest(pattern)) {
        return false;
      }
      for (const elem of (pattern.elements: Array)) {
        // deopt on holes
        if (!elem) return false;
        // deopt on member expressions as they may be included in the RHS
        if (t.isMemberExpression(elem)) return false;
      }
      for (const elem of (arr.elements: Array)) {
        // deopt on spread elements
        if (t.isSpreadElement(elem)) return false;
        // deopt call expressions as they might change values of LHS variables
        if (t.isCallExpression(elem)) return false;
        // deopt on member expressions as they may be getter/setters and have side-effects
        if (t.isMemberExpression(elem)) return false;
      }
      // deopt on reference to left side identifiers
      const bindings = t.getBindingIdentifiers(pattern);
      const state = { deopt: false, bindings };
      try {
        t.traverse(arr, arrayUnpackVisitor, state);
      } catch (e) {
        if (e !== STOP_TRAVERSAL) throw e;
      }
      return !state.deopt;
    }
    pushUnpackedArrayPattern(pattern, arr) {
      for (let i = 0; i < pattern.elements.length; i++) {
        const elem = pattern.elements[i];
        if (t.isRestElement(elem)) {
          this.push(elem.argument, t.arrayExpression(arr.elements.slice(i)));
        } else {
          this.push(elem, arr.elements[i]);
        }
      }
    }
    pushArrayPattern(pattern, arrayRef) {
      if (!pattern.elements) return;
      // optimise basic array destructuring of an array expression
      //
      // we can't do this to a pattern of unequal size to it's right hand
      // array expression as then there will be values that wont be evaluated
      //
      // eg: let [a, b] = [1, 2];
      if (this.canUnpackArrayPattern(pattern, arrayRef)) {
        return this.pushUnpackedArrayPattern(pattern, arrayRef);
      }
      // if we have a rest then we need all the elements so don't tell
      // `scope.toArray` to only get a certain amount
      const count = !hasRest(pattern) && pattern.elements.length;
      // so we need to ensure that the `arrayRef` is an array, `scope.toArray` will
      // return a locally bound identifier if it's been inferred to be an array,
      // otherwise it'll be a call to a helper that will ensure it's one
      const toArray = this.toArray(arrayRef, count);
      if (t.isIdentifier(toArray)) {
        // we've been given an identifier so it must have been inferred to be an
        // array
        arrayRef = toArray;
      } else {
        arrayRef = this.scope.generateUidIdentifierBasedOnNode(arrayRef);
        this.arrays[arrayRef.name] = true;
        this.nodes.push(this.buildVariableDeclaration(arrayRef, toArray));
      }
      //
      for (let i = 0; i < pattern.elements.length; i++) {
        let elem = pattern.elements[i];
        // hole
        if (!elem) continue;
        let elemRef;
        if (t.isRestElement(elem)) {
          elemRef = this.toArray(arrayRef);
          elemRef = t.callExpression(
            t.memberExpression(elemRef, t.identifier("slice")),
            [t.numericLiteral(i)],
          );
          // set the element to the rest element argument since we've dealt with it
          // being a rest already
          elem = elem.argument;
        } else {
          elemRef = t.memberExpression(arrayRef, t.numericLiteral(i), true);
        }
        this.push(elem, elemRef);
      }
    }
    init(pattern, ref) {
      // trying to destructure a value that we can't evaluate more than once so we
      // need to save it to a variable
      if (!t.isArrayExpression(ref) && !t.isMemberExpression(ref)) {
        const memo = this.scope.maybeGenerateMemoised(ref, true);
        if (memo) {
          this.nodes.push(
            this.buildVariableDeclaration(memo, t.cloneNode(ref)),
          );
          ref = memo;
        }
      }
      //
      this.push(pattern, ref);
      return this.nodes;
    }
  }
  return {
    visitor: {
      ExportNamedDeclaration(path) {
        const declaration = path.get("declaration");
        if (!declaration.isVariableDeclaration()) return;
        if (!variableDeclarationHasPattern(declaration.node)) return;
        const specifiers = [];
        for (const name in path.getOuterBindingIdentifiers(path)) {
          specifiers.push(
            t.exportSpecifier(t.identifier(name), t.identifier(name)),
          );
        }
        // Split the declaration and export list into two declarations so that the variable
        // declaration can be split up later without needing to worry about not being a
        // top-level statement.
        path.replaceWith(declaration.node);
        path.insertAfter(t.exportNamedDeclaration(null, specifiers));
      },
      ForXStatement(path) {
        const { node, scope } = path;
        const left = node.left;
        if (t.isPattern(left)) {
          // for ({ length: k } in { abc: 3 });
          const temp = scope.generateUidIdentifier("ref");
          node.left = t.variableDeclaration("var", [
            t.variableDeclarator(temp),
          ]);
          path.ensureBlock();
          node.body.body.unshift(
            t.variableDeclaration("var", [t.variableDeclarator(left, temp)]),
          );
          return;
        }
        if (!t.isVariableDeclaration(left)) return;
        const pattern = left.declarations[0].id;
        if (!t.isPattern(pattern)) return;
        const key = scope.generateUidIdentifier("ref");
        node.left = t.variableDeclaration(left.kind, [
          t.variableDeclarator(key, null),
        ]);
        const nodes = [];
        const destructuring = new DestructuringTransformer({
          kind: left.kind,
          scope: scope,
          nodes: nodes,
          arrayOnlySpread,
          addHelper: name => this.addHelper(name),
        });
        destructuring.init(pattern, key);
        path.ensureBlock();
        const block = node.body;
        block.body = nodes.concat(block.body);
      },
      CatchClause({ node, scope }) {
        const pattern = node.param;
        if (!t.isPattern(pattern)) return;
        const ref = scope.generateUidIdentifier("ref");
        node.param = ref;
        const nodes = [];
        const destructuring = new DestructuringTransformer({
          kind: "let",
          scope: scope,
          nodes: nodes,
          arrayOnlySpread,
          addHelper: name => this.addHelper(name),
        });
        destructuring.init(pattern, ref);
        node.body.body = nodes.concat(node.body.body);
      },
      AssignmentExpression(path) {
        const { node, scope } = path;
        if (!t.isPattern(node.left)) return;
        const nodes = [];
        const destructuring = new DestructuringTransformer({
          operator: node.operator,
          scope: scope,
          nodes: nodes,
          arrayOnlySpread,
          addHelper: name => this.addHelper(name),
        });
        let ref;
        if (
          path.isCompletionRecord() ||
          !path.parentPath.isExpressionStatement()
        ) {
          ref = scope.generateUidIdentifierBasedOnNode(node.right, "ref");
          nodes.push(
            t.variableDeclaration("var", [
              t.variableDeclarator(ref, node.right),
            ]),
          );
          if (t.isArrayExpression(node.right)) {
            destructuring.arrays[ref.name] = true;
          }
        }
        destructuring.init(node.left, ref || node.right);
        if (ref) {
          nodes.push(t.expressionStatement(t.cloneNode(ref)));
        }
        path.replaceWithMultiple(nodes);
      },
      VariableDeclaration(path) {
        const { node, scope, parent } = path;
        if (t.isForXStatement(parent)) return;
        if (!parent || !path.container) return; // i don't know why this is necessary - TODO
        if (!variableDeclarationHasPattern(node)) return;
        const nodeKind = node.kind;
        const nodes = [];
        let declar;
        for (let i = 0; i < node.declarations.length; i++) {
          declar = node.declarations[i];
          const patternId = declar.init;
          const pattern = declar.id;
          const destructuring = new DestructuringTransformer({
            blockHoist: node._blockHoist,
            nodes: nodes,
            scope: scope,
            kind: node.kind,
            arrayOnlySpread,
            addHelper: name => this.addHelper(name),
          });
          if (t.isPattern(pattern)) {
            destructuring.init(pattern, patternId);
            if (+i !== node.declarations.length - 1) {
              // we aren't the last declarator so let's just make the
              // last transformed node inherit from us
              t.inherits(nodes[nodes.length - 1], declar);
            }
          } else {
            nodes.push(
              t.inherits(
                destructuring.buildVariableAssignment(
                  declar.id,
                  t.cloneNode(declar.init),
                ),
                declar,
              ),
            );
          }
        }
        let tail = null;
        const nodesOut = [];
        for (const node of nodes) {
          if (tail !== null && t.isVariableDeclaration(node)) {
            // Create a single compound declarations
            tail.declarations.push(...node.declarations);
          } else {
            // Make sure the original node kind is used for each compound declaration
            node.kind = nodeKind;
            nodesOut.push(node);
            tail = t.isVariableDeclaration(node) ? node : null;
          }
        }
        // Need to unmark the current binding to this var as a param, or other hoists
        // could be placed above this ref.
        // https://github.com/babel/babel/issues/4516
        for (const nodeOut of nodesOut) {
          if (!nodeOut.declarations) continue;
          for (const declaration of nodeOut.declarations) {
            const { name } = declaration.id;
            if (scope.bindings[name]) {
              scope.bindings[name].kind = nodeOut.kind;
            }
          }
        }
        if (nodesOut.length === 1) {
          path.replaceWith(nodesOut[0]);
        } else {
          path.replaceWithMultiple(nodesOut);
        }
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-destructuring/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-syntax-object-rest-spread/src/index.js

import { declare } from "@babel/helper-plugin-utils";
export default declare(api => {
  api.assertVersion(7);
  return {
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("objectRestSpread");
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-syntax-object-rest-spread/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-syntax-optional-catch-binding/src/index.js

import { declare } from "@babel/helper-plugin-utils";
export default declare(api => {
  api.assertVersion(7);
  return {
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("optionalCatchBinding");
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-syntax-optional-catch-binding/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-sticky-regex/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import * as regex from "@babel/helper-regex";
import { types as t } from "@babel/core";
export default declare(api => {
  api.assertVersion(7);
  return {
    visitor: {
      RegExpLiteral(path) {
        const { node } = path;
        if (!regex.is(node, "y")) return;
        path.replaceWith(
          t.newExpression(t.identifier("RegExp"), [
            t.stringLiteral(node.pattern),
            t.stringLiteral(node.flags),
          ]),
        );
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-sticky-regex/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-exponentiation-operator/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import build from "@babel/helper-builder-binary-assignment-operator-visitor";
import { types as t } from "@babel/core";
export default declare(api => {
  api.assertVersion(7);
  return {
    visitor: build({
      operator: "**",
      build(left, right) {
        return t.callExpression(
          t.memberExpression(t.identifier("Math"), t.identifier("pow")),
          [left, right],
        );
      },
    }),
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-exponentiation-operator/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-helper-remap-async-to-generator/src/index.js

/* @noflow */
import wrapFunction from "@babel/helper-wrap-function";
import annotateAsPure from "@babel/helper-annotate-as-pure";
import * as t from "@babel/types";
const awaitVisitor = {
  Function(path) {
    path.skip();
  },
  AwaitExpression(path, { wrapAwait }) {
    const argument = path.get("argument");
    if (path.parentPath.isYieldExpression()) {
      path.replaceWith(argument.node);
      return;
    }
    path.replaceWith(
      t.yieldExpression(
        wrapAwait
          ? t.callExpression(t.cloneNode(wrapAwait), [argument.node])
          : argument.node,
      ),
    );
  },
};
export default function(
  path: NodePath,
  helpers: { wrapAsync: Object, wrapAwait: Object },
) {
  path.traverse(awaitVisitor, {
    wrapAwait: helpers.wrapAwait,
  });
  const isIIFE = checkIsIIFE(path);
  path.node.async = false;
  path.node.generator = true;
  wrapFunction(path, t.cloneNode(helpers.wrapAsync));
  const isProperty =
    path.isObjectMethod() ||
    path.isClassMethod() ||
    path.parentPath.isObjectProperty() ||
    path.parentPath.isClassProperty();
  if (!isProperty && !isIIFE && path.isExpression()) {
    annotateAsPure(path);
  }
  function checkIsIIFE(path: NodePath) {
    if (path.parentPath.isCallExpression({ callee: path.node })) {
      return true;
    }
    // try to catch calls to Function#bind, as emitted by arrowFunctionToExpression in spec mode
    // this may also catch .bind(this) written by users, but does it matter? 
    const { parentPath } = path;
    if (
      parentPath.isMemberExpression() &&
      t.isIdentifier(parentPath.node.property, { name: "bind" })
    ) {
      const { parentPath: bindCall } = parentPath;
      // (function () { ... }).bind(this)()
      return (
        // first, check if the .bind is actually being called
        bindCall.isCallExpression() &&
        // and whether its sole argument is 'this'
        bindCall.node.arguments.length === 1 &&
        t.isThisExpression(bindCall.node.arguments[0]) &&
        // and whether the result of the .bind(this) is being called
        bindCall.parentPath.isCallExpression({ callee: bindCall.node })
      );
    }
    return false;
  }
}

// </from> /home/qfox/apps/babel/packages/babel-helper-remap-async-to-generator/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-proposal-optional-catch-binding/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import syntaxOptionalCatchBinding from "@babel/plugin-syntax-optional-catch-binding";
export default declare(api => {
  api.assertVersion(7);
  return {
    inherits: syntaxOptionalCatchBinding,
    visitor: {
      CatchClause(path) {
        if (!path.node.param) {
          const uid = path.scope.generateUidIdentifier("unused");
          const paramPath = path.get("param");
          paramPath.replaceWith(uid);
        }
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-proposal-optional-catch-binding/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-helper-plugin-utils/src/index.js

export function declare(builder) {
  return (api, options, dirname) => {
    if (!api.assertVersion) {
      // Inject a custom version of 'assertVersion' for Babel 6 and early
      // versions of Babel 7's beta that didn't have it.
      api = Object.assign(copyApiObject(api), {
        assertVersion(range) {
          throwVersionError(range, api.version);
        },
      });
    }
    return builder(api, options || {}, dirname);
  };
}
function copyApiObject(api) {
  // Babel >= 7 <= beta.41 passed the API as a new object that had
  // babel/core as the prototype. While slightly faster, it also
  // means that the Object.assign copy below fails. Rather than
  // keep complexity, the Babel 6 behavior has been reverted and this
  // normalizes all that for Babel 7.
  let proto = null;
  if (typeof api.version === "string" && /^7\./.test(api.version)) {
    proto = Object.getPrototypeOf(api);
    if (
      proto &&
      (!has(proto, "version") ||
        !has(proto, "transform") ||
        !has(proto, "template") ||
        !has(proto, "types"))
    ) {
      proto = null;
    }
  }
  return {
    ...proto,
    ...api,
  };
}
function has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function throwVersionError(range, version) {
  if (typeof range === "number") {
    if (!Number.isInteger(range)) {
      throw new Error("Expected string or integer value.");
    }
    range = `^${range}.0.0-0`;
  }
  if (typeof range !== "string") {
    throw new Error("Expected string or integer value.");
  }
  const limit = Error.stackTraceLimit;
  if (typeof limit === "number" && limit < 25) {
    // Bump up the limit if needed so that users are more likely
    // to be able to see what is calling Babel.
    Error.stackTraceLimit = 25;
  }
  let err;
  if (version.slice(0, 2) === "7.") {
    err = new Error(
      `Requires Babel "^7.0.0-beta.41", but was loaded with "${version}". ` +
        `You'll need to update your @babel/core version.`,
    );
  } else {
    err = new Error(
      `Requires Babel "${range}", but was loaded with "${version}". ` +
        `If you are sure you have a compatible version of @babel/core, ` +
        `it is likely that something in your build process is loading the ` +
        `wrong version. Inspect the stack trace of this error to look for ` +
        `the first entry that doesn't mention "@babel/core" or "babel-core" ` +
        `to see what is calling Babel.`,
    );
  }
  if (typeof limit === "number") {
    Error.stackTraceLimit = limit;
  }
  throw Object.assign(
    err,
    ({
      code: "BABEL_VERSION_UNSUPPORTED",
      version,
      range,
    }: any),
  );
}

// </from> /home/qfox/apps/babel/packages/babel-helper-plugin-utils/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-preset-stage-1/src/index.js

export default function() {
  throw new Error(`
As of v7.0.0-beta.55, we've removed Babel's Stage presets.
Please consider reading our blog post on this decision at
https://babeljs.io/blog/2018/07/27/removing-babels-stage-presets
for more details. TL;DR is that it's more beneficial in the
  long run to explicitly add which proposals to use.
For a more automatic migration, we have updated babel-upgrade,
https://github.com/babel/babel-upgrade to do this for you with
"npx babel-upgrade".
If you want the same configuration as before:
{
  "plugins": [
    // Stage 1
    "@babel/plugin-proposal-export-default-from",
    "@babel/plugin-proposal-logical-assignment-operators",
    ["@babel/plugin-proposal-optional-chaining", { "loose": false }],
    ["@babel/plugin-proposal-pipeline-operator", { "proposal": "minimal" }],
    ["@babel/plugin-proposal-nullish-coalescing-operator", { "loose": false }],
    "@babel/plugin-proposal-do-expressions",
    // Stage 2
    ["@babel/plugin-proposal-decorators", { "legacy": true }],
    "@babel/plugin-proposal-function-sent",
    "@babel/plugin-proposal-export-namespace-from",
    "@babel/plugin-proposal-numeric-separator",
    "@babel/plugin-proposal-throw-expressions",
    // Stage 3
    "@babel/plugin-syntax-dynamic-import",
    "@babel/plugin-syntax-import-meta",
    ["@babel/plugin-proposal-class-properties", { "loose": false }],
    "@babel/plugin-proposal-json-strings"
  ]
}
If you're using the same configuration across many separate projects,
keep in mind that you can also create your own custom presets with
whichever plugins and presets you're looking to use.
module.exports = function() {
  return {
    plugins: [
      require("@babel/plugin-syntax-dynamic-import"),
      [require("@babel/plugin-proposal-decorators"), { "legacy": true }],
      [require("@babel/plugin-proposal-class-properties"), { "loose": false }],
    ],
    presets: [
      // ...
    ],
  };
};
`);
}

// </from> /home/qfox/apps/babel/packages/babel-preset-stage-1/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-flow-comments/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import syntaxFlow from "@babel/plugin-syntax-flow";
import { types as t } from "@babel/core";
export default declare(api => {
  api.assertVersion(7);
  function wrapInFlowComment(path, parent) {
    let attach = path.getPrevSibling();
    let where = "trailing";
    if (!attach.node) {
      attach = path.parentPath;
      where = "inner";
    }
    attach.addComment(where, generateComment(path, parent));
    path.remove();
  }
  function generateComment(path, parent) {
    let comment = path
      .getSource()
      .replace(/\*-\//g, "*-ESCAPED/")
      .replace(/\*\//g, "*-/");
    if (parent && parent.optional) comment = "?" + comment;
    if (comment[0] !== ":") comment = ":: " + comment;
    return comment;
  }
  return {
    inherits: syntaxFlow,
    visitor: {
      TypeCastExpression(path) {
        const { node } = path;
        path
          .get("expression")
          .addComment("trailing", generateComment(path.get("typeAnnotation")));
        path.replaceWith(t.parenthesizedExpression(node.expression));
      },
      // support function a(b?) {}
      Identifier(path) {
        if (path.parentPath.isFlow()) {
          return;
        }
        const { node } = path;
        if (node.typeAnnotation) {
          const typeAnnotation = path.get("typeAnnotation");
          path.addComment("trailing", generateComment(typeAnnotation, node));
          typeAnnotation.remove();
          if (node.optional) {
            node.optional = false;
          }
        } else if (node.optional) {
          path.addComment("trailing", ":: ?");
          node.optional = false;
        }
      },
      AssignmentPattern: {
        exit({ node }) {
          const { left } = node;
          if (left.optional) {
            left.optional = false;
          }
        },
      },
      // strip optional property from function params - facebook/fbjs#17
      Function(path) {
        if (path.isDeclareFunction()) return;
        const { node } = path;
        if (node.returnType) {
          const returnType = path.get("returnType");
          const typeAnnotation = returnType.get("typeAnnotation");
          const block = path.get("body");
          block.addComment(
            "leading",
            generateComment(returnType, typeAnnotation.node),
          );
          returnType.remove();
        }
        if (node.typeParameters) {
          const typeParameters = path.get("typeParameters");
          const id = path.get("id");
          id.addComment(
            "trailing",
            generateComment(typeParameters, typeParameters.node),
          );
          typeParameters.remove();
        }
      },
      // support for `class X { foo: string }` - #4622
      ClassProperty(path) {
        const { node, parent } = path;
        if (!node.value) {
          wrapInFlowComment(path, parent);
        } else if (node.typeAnnotation) {
          const typeAnnotation = path.get("typeAnnotation");
          path
            .get("key")
            .addComment(
              "trailing",
              generateComment(typeAnnotation, typeAnnotation.node),
            );
          typeAnnotation.remove();
        }
      },
      // support `export type a = {}` - #8 Error: You passed path.replaceWith() a falsy node
      ExportNamedDeclaration(path) {
        const { node, parent } = path;
        if (node.exportKind !== "type" && !t.isFlow(node.declaration)) {
          return;
        }
        wrapInFlowComment(path, parent);
      },
      // support `import type A` and `import typeof A` #10
      ImportDeclaration(path) {
        const { node, parent } = path;
        if (node.importKind !== "type" && node.importKind !== "typeof") {
          return;
        }
        wrapInFlowComment(path, parent);
      },
      Flow(path) {
        const { parent } = path;
        wrapInFlowComment(path, parent);
      },
      Class(path) {
        const { node } = path;
        if (node.typeParameters) {
          const typeParameters = path.get("typeParameters");
          const block = path.get("body");
          block.addComment(
            "leading",
            generateComment(typeParameters, typeParameters.node),
          );
          typeParameters.remove();
        }
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-flow-comments/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-helper-function-name/src/index.js

import getFunctionArity from "@babel/helper-get-function-arity";
import template from "@babel/template";
import * as t from "@babel/types";
const buildPropertyMethodAssignmentWrapper = template(`
  (function (FUNCTION_KEY) {
    function FUNCTION_ID() {
      return FUNCTION_KEY.apply(this, arguments);
    }
    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    }
    return FUNCTION_ID;
  })(FUNCTION)
`);
const buildGeneratorPropertyMethodAssignmentWrapper = template(`
  (function (FUNCTION_KEY) {
    function* FUNCTION_ID() {
      return yield* FUNCTION_KEY.apply(this, arguments);
    }
    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    };
    return FUNCTION_ID;
  })(FUNCTION)
`);
const visitor = {
  "ReferencedIdentifier|BindingIdentifier"(path, state) {
    // check if this node matches our function id
    if (path.node.name !== state.name) return;
    // check that we don't have a local variable declared as that removes the need
    // for the wrapper
    const localDeclar = path.scope.getBindingIdentifier(state.name);
    if (localDeclar !== state.outerDeclar) return;
    state.selfReference = true;
    path.stop();
  },
};
function getNameFromLiteralId(id) {
  if (t.isNullLiteral(id)) {
    return "null";
  }
  if (t.isRegExpLiteral(id)) {
    return `_${id.pattern}_${id.flags}`;
  }
  if (t.isTemplateLiteral(id)) {
    return id.quasis.map(quasi => quasi.value.raw).join("");
  }
  if (id.value !== undefined) {
    return id.value + "";
  }
  return "";
}
function wrap(state, method, id, scope) {
  if (state.selfReference) {
    if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {
      // we can just munge the local binding
      scope.rename(id.name);
    } else {
      // we don't currently support wrapping class expressions
      if (!t.isFunction(method)) return;
      // need to add a wrapper since we can't change the references
      let build = buildPropertyMethodAssignmentWrapper;
      if (method.generator) {
        build = buildGeneratorPropertyMethodAssignmentWrapper;
      }
      const template = build({
        FUNCTION: method,
        FUNCTION_ID: id,
        FUNCTION_KEY: scope.generateUidIdentifier(id.name),
      }).expression;
      // shim in dummy params to retain function arity, if you try to read the
      // source then you'll get the original since it's proxied so it's all good
      const params = template.callee.body.body[0].params;
      for (let i = 0, len = getFunctionArity(method); i < len; i++) {
        params.push(scope.generateUidIdentifier("x"));
      }
      return template;
    }
  }
  method.id = id;
  scope.getProgramParent().references[id.name] = true;
}
function visit(node, name, scope) {
  const state = {
    selfAssignment: false,
    selfReference: false,
    outerDeclar: scope.getBindingIdentifier(name),
    references: [],
    name: name,
  };
  // check to see if we have a local binding of the id we're setting inside of
  // the function, this is important as there are caveats associated
  const binding = scope.getOwnBinding(name);
  if (binding) {
    if (binding.kind === "param") {
      // safari will blow up in strict mode with code like:
      //
      //   let t = function t(t) {};
      //
      // with the error:
      //
      //   Cannot declare a parameter named 't' as it shadows the name of a
      //   strict mode function.
      //
      // this isn't to the spec and they've invented this behaviour which is
      // **extremely** annoying so we avoid setting the name if it has a param
      // with the same id
      state.selfReference = true;
    } else {
      // otherwise it's defined somewhere in scope like:
      //
      //   let t = function () {
      //     let t = 2;
      //   };
      //
      // so we can safely just set the id and move along as it shadows the
      // bound function id
    }
  } else if (state.outerDeclar || scope.hasGlobal(name)) {
    scope.traverse(node, visitor, state);
  }
  return state;
}
/**
 * @param {NodePath} param0
 * @param {Boolean} localBinding whether a name could shadow a self-reference (e.g. converting arrow function)
 */
export default function({ node, parent, scope, id }, localBinding = false) {
  // has an `id` so we don't need to infer one
  if (node.id) return;
  if (
    (t.isObjectProperty(parent) ||
      t.isObjectMethod(parent, { kind: "method" })) &&
    (!parent.computed || t.isLiteral(parent.key))
  ) {
    // { foo() {} };
    id = parent.key;
  } else if (t.isVariableDeclarator(parent)) {
    // let foo = function () {};
    id = parent.id;
    // but not "let foo = () => {};" being converted to function expression
    if (t.isIdentifier(id) && !localBinding) {
      const binding = scope.parent.getBinding(id.name);
      if (
        binding &&
        binding.constant &&
        scope.getBinding(id.name) === binding
      ) {
        // always going to reference this method
        node.id = t.cloneNode(id);
        node.id[t.NOT_LOCAL_BINDING] = true;
        return;
      }
    }
  } else if (t.isAssignmentExpression(parent)) {
    // foo = function () {};
    id = parent.left;
  } else if (!id) {
    return;
  }
  let name;
  if (id && t.isLiteral(id)) {
    name = getNameFromLiteralId(id);
  } else if (id && t.isIdentifier(id)) {
    name = id.name;
  }
  if (name === undefined) {
    return;
  }
  name = t.toBindingIdentifierName(name);
  id = t.identifier(name);
  // The id shouldn't be considered a local binding to the function because
  // we are simply trying to set the function name and not actually create
  // a local binding.
  id[t.NOT_LOCAL_BINDING] = true;
  const state = visit(node, name, scope);
  return wrap(state, node, id, scope) || node;
}

// </from> /home/qfox/apps/babel/packages/babel-helper-function-name/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-reserved-words/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import { types as t } from "@babel/core";
export default declare(api => {
  api.assertVersion(7);
  return {
    visitor: {
      "BindingIdentifier|ReferencedIdentifier"(path) {
        if (!t.isValidES3Identifier(path.node.name)) {
          path.scope.rename(path.node.name);
        }
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-reserved-words/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-runtime/src/index.js

import path from "path";
import resolve from "resolve";
import { declare } from "@babel/helper-plugin-utils";
import { addDefault, isModule } from "@babel/helper-module-imports";
import { types as t } from "@babel/core";
import getDefinitions from "./definitions";
function resolveAbsoluteRuntime(moduleName: string, dirname: string) {
  try {
    return path.dirname(
      resolve.sync(`${moduleName}/package.json`, { basedir: dirname }),
    );
  } catch (err) {
    if (err.code !== "MODULE_NOT_FOUND") throw err;
    throw Object.assign(
      new Error(`Failed to resolve "${moduleName}" relative to "${dirname}"`),
      {
        code: "BABEL_RUNTIME_NOT_FOUND",
        runtime: moduleName,
        dirname,
      },
    );
  }
}
function supportsStaticESM(caller) {
  return !!(caller && caller.supportsStaticESM);
}
export default declare((api, options, dirname) => {
  api.assertVersion(7);
  const {
    corejs: corejsVersion = false,
    helpers: useRuntimeHelpers = true,
    regenerator: useRuntimeRegenerator = true,
    useESModules = false,
    version: runtimeVersion = "7.0.0-beta.0",
    absoluteRuntime = false,
  } = options;
  const definitions = getDefinitions(runtimeVersion);
  if (typeof useRuntimeRegenerator !== "boolean") {
    throw new Error(
      "The 'regenerator' option must be undefined, or a boolean.",
    );
  }
  if (typeof useRuntimeHelpers !== "boolean") {
    throw new Error("The 'helpers' option must be undefined, or a boolean.");
  }
  if (typeof useESModules !== "boolean" && useESModules !== "auto") {
    throw new Error(
      "The 'useESModules' option must be undefined, or a boolean, or 'auto'.",
    );
  }
  if (
    typeof absoluteRuntime !== "boolean" &&
    typeof absoluteRuntime !== "string"
  ) {
    throw new Error(
      "The 'absoluteRuntime' option must be undefined, a boolean, or a string.",
    );
  }
  if (
    corejsVersion !== false &&
    (typeof corejsVersion !== "number" || corejsVersion !== 2) &&
    (typeof corejsVersion !== "string" || corejsVersion !== "2")
  ) {
    throw new Error(
      `The 'corejs' option must be undefined, false, 2 or '2', ` +
        `but got ${JSON.stringify(corejsVersion)}.`,
    );
  }
  if (typeof runtimeVersion !== "string") {
    throw new Error(`The 'version' option must be a version string.`);
  }
  function has(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
  if (has(options, "useBuiltIns")) {
    if (options.useBuiltIns) {
      throw new Error(
        "The 'useBuiltIns' option has been removed. The @babel/runtime " +
          "module now uses builtins by default.",
      );
    } else {
      throw new Error(
        "The 'useBuiltIns' option has been removed. Use the 'corejs'" +
          "option with value '2' to polyfill with CoreJS 2.x via @babel/runtime.",
      );
    }
  }
  if (has(options, "polyfill")) {
    if (options.polyfill === false) {
      throw new Error(
        "The 'polyfill' option has been removed. The @babel/runtime " +
          "module now skips polyfilling by default.",
      );
    } else {
      throw new Error(
        "The 'polyfill' option has been removed. Use the 'corejs'" +
          "option with value '2' to polyfill with CoreJS 2.x via @babel/runtime.",
      );
    }
  }
  if (has(options, "moduleName")) {
    throw new Error(
      "The 'moduleName' option has been removed. @babel/transform-runtime " +
        "no longer supports arbitrary runtimes. If you were using this to " +
        "set an absolute path for Babel's standard runtimes, please use the " +
        "'absoluteRuntime' option.",
    );
  }
  const esModules =
    useESModules === "auto" ? api.caller(supportsStaticESM) : useESModules;
  const injectCoreJS2 = `${corejsVersion}` === "2";
  const moduleName = injectCoreJS2
    ? "@babel/runtime-corejs2"
    : "@babel/runtime";
  const HEADER_HELPERS = ["interopRequireWildcard", "interopRequireDefault"];
  let modulePath = moduleName;
  if (absoluteRuntime !== false) {
    modulePath = resolveAbsoluteRuntime(
      moduleName,
      path.resolve(dirname, absoluteRuntime === true ? "." : absoluteRuntime),
    );
  }
  return {
    pre(file) {
      if (useRuntimeHelpers) {
        file.set("helperGenerator", name => {
          // If the helper didn't exist yet at the version given, we bail
          // out and let Babel either insert it directly, or throw an error
          // so that plugins can handle that case properly.
          if (
            file.availableHelper &&
            !file.availableHelper(name, runtimeVersion)
          ) {
            return;
          }
          const isInteropHelper = HEADER_HELPERS.indexOf(name) !== -1;
          // Explicitly set the CommonJS interop helpers to their reserve
          // blockHoist of 4 so they are guaranteed to exist
          // when other things used them to import.
          const blockHoist =
            isInteropHelper && !isModule(file.path) ? 4 : undefined;
          const helpersDir =
            esModules && file.path.node.sourceType === "module"
              ? "helpers/esm"
              : "helpers";
          return this.addDefaultImport(
            `${modulePath}/${helpersDir}/${name}`,
            name,
            blockHoist,
          );
        });
      }
      const cache = new Map();
      this.addDefaultImport = (source, nameHint, blockHoist) => {
        // If something on the page adds a helper when the file is an ES6
        // file, we can't reused the cached helper name after things have been
        // transformed because it has almost certainly been renamed.
        const cacheKey = isModule(file.path);
        const key = `${source}:${nameHint}:${cacheKey || ""}`;
        let cached = cache.get(key);
        if (cached) {
          cached = t.cloneNode(cached);
        } else {
          cached = addDefault(file.path, source, {
            importedInterop: "uncompiled",
            nameHint,
            blockHoist,
          });
          cache.set(key, cached);
        }
        return cached;
      };
    },
    visitor: {
      ReferencedIdentifier(path) {
        const { node, parent, scope } = path;
        if (node.name === "regeneratorRuntime" && useRuntimeRegenerator) {
          path.replaceWith(
            this.addDefaultImport(
              `${modulePath}/regenerator`,
              "regeneratorRuntime",
            ),
          );
          return;
        }
        if (!injectCoreJS2) return;
        if (t.isMemberExpression(parent)) return;
        if (!has(definitions.builtins, node.name)) return;
        if (scope.getBindingIdentifier(node.name)) return;
        // Symbol() -> _core.Symbol(); new Promise -> new _core.Promise
        path.replaceWith(
          this.addDefaultImport(
            `${modulePath}/core-js/${definitions.builtins[node.name]}`,
            node.name,
          ),
        );
      },
      // arr[Symbol.iterator]() -> _core.$for.getIterator(arr)
      CallExpression(path) {
        if (!injectCoreJS2) return;
        // we can't compile this
        if (path.node.arguments.length) return;
        const callee = path.node.callee;
        if (!t.isMemberExpression(callee)) return;
        if (!callee.computed) return;
        if (!path.get("callee.property").matchesPattern("Symbol.iterator")) {
          return;
        }
        path.replaceWith(
          t.callExpression(
            this.addDefaultImport(
              `${modulePath}/core-js/get-iterator`,
              "getIterator",
            ),
            [callee.object],
          ),
        );
      },
      // Symbol.iterator in arr -> core.$for.isIterable(arr)
      BinaryExpression(path) {
        if (!injectCoreJS2) return;
        if (path.node.operator !== "in") return;
        if (!path.get("left").matchesPattern("Symbol.iterator")) return;
        path.replaceWith(
          t.callExpression(
            this.addDefaultImport(
              `${modulePath}/core-js/is-iterable`,
              "isIterable",
            ),
            [path.node.right],
          ),
        );
      },
      // Array.from -> _core.Array.from
      MemberExpression: {
        enter(path) {
          if (!injectCoreJS2) return;
          if (!path.isReferenced()) return;
          const { node } = path;
          const obj = node.object;
          const prop = node.property;
          if (!t.isReferenced(obj, node)) return;
          if (node.computed) return;
          if (!has(definitions.methods, obj.name)) return;
          const methods = definitions.methods[obj.name];
          if (!has(methods, prop.name)) return;
          // doesn't reference the global
          if (path.scope.getBindingIdentifier(obj.name)) return;
          // special case Object.defineProperty to not use core-js when using string keys
          if (
            obj.name === "Object" &&
            prop.name === "defineProperty" &&
            path.parentPath.isCallExpression()
          ) {
            const call = path.parentPath.node;
            if (call.arguments.length === 3 && t.isLiteral(call.arguments[1])) {
              return;
            }
          }
          path.replaceWith(
            this.addDefaultImport(
              `${modulePath}/core-js/${methods[prop.name]}`,
              `${obj.name}$${prop.name}`,
            ),
          );
        },
        exit(path) {
          if (!injectCoreJS2) return;
          if (!path.isReferenced()) return;
          const { node } = path;
          const obj = node.object;
          if (!has(definitions.builtins, obj.name)) return;
          if (path.scope.getBindingIdentifier(obj.name)) return;
          path.replaceWith(
            t.memberExpression(
              this.addDefaultImport(
                `${modulePath}/core-js/${definitions.builtins[obj.name]}`,
                obj.name,
              ),
              node.property,
              node.computed,
            ),
          );
        },
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-runtime/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-runtime/src/definitions.js

import semver from "semver";
function hasMinVersion(minVersion, runtimeVersion) {
  // If the range is unavailable, we're running the script during Babel's
  // build process, and we want to assume that all versions are satisfied so
  // that the built output will include all definitions.
  if (!runtimeVersion) return true;
  // semver.intersects() has some surprising behavior with comparing ranges
  // with preprelease versions. We add '^' to ensure that we are always
  // comparing ranges with ranges, which sidesteps this logic.
  // For example:
  //
  //   semver.intersects(`<7.0.1`, "7.0.0-beta.0") // false - surprising
  //   semver.intersects(`<7.0.1`, "^7.0.0-beta.0") // true - expected
  //
  // This is because the first falls back to
  //
  //   semver.satisfies("7.0.0-beta.0", `<7.0.1`) // false - surprising
  //
  // and this fails because a prerelease version can only satisfy a range
  // if it is a prerelease within the same major/minor/patch range.
  //
  // Note: If this is found to have issues, please also revist the logic in
  // babel-core's availableHelper() API.
  if (semver.valid(runtimeVersion)) runtimeVersion = `^${runtimeVersion}`;
  return (
    !semver.intersects(`<${minVersion}`, runtimeVersion) &&
    !semver.intersects(`>=8.0.0`, runtimeVersion)
  );
}
export default runtimeVersion => {
  // Conditionally include 'Math' because it was not included in the 7.0.0
  // release of '@babel/runtime'. See issue https://github.com/babel/babel/pull/8616.
  const includeMathModule = hasMinVersion("7.0.1", runtimeVersion);
  return {
    builtins: {
      Symbol: "symbol",
      Promise: "promise",
      Map: "map",
      WeakMap: "weak-map",
      Set: "set",
      WeakSet: "weak-set",
      setImmediate: "set-immediate",
      clearImmediate: "clear-immediate",
      parseFloat: "parse-float",
      parseInt: "parse-int",
    },
    methods: {
      Array: {
        from: "array/from",
        isArray: "array/is-array",
        of: "array/of",
      },
      JSON: {
        stringify: "json/stringify",
      },
      Object: {
        assign: "object/assign",
        create: "object/create",
        defineProperties: "object/define-properties",
        defineProperty: "object/define-property",
        entries: "object/entries",
        freeze: "object/freeze",
        getOwnPropertyDescriptor: "object/get-own-property-descriptor",
        getOwnPropertyDescriptors: "object/get-own-property-descriptors",
        getOwnPropertyNames: "object/get-own-property-names",
        getOwnPropertySymbols: "object/get-own-property-symbols",
        getPrototypeOf: "object/get-prototype-of",
        isExtensible: "object/is-extensible",
        isFrozen: "object/is-frozen",
        isSealed: "object/is-sealed",
        is: "object/is",
        keys: "object/keys",
        preventExtensions: "object/prevent-extensions",
        seal: "object/seal",
        setPrototypeOf: "object/set-prototype-of",
        values: "object/values",
      },
      ...(includeMathModule
        ? {
            Math: {
              acosh: "math/acosh",
              asinh: "math/asinh",
              atanh: "math/atanh",
              cbrt: "math/cbrt",
              clz32: "math/clz32",
              cosh: "math/cosh",
              expm1: "math/expm1",
              fround: "math/fround",
              hypot: "math/hypot",
              imul: "math/imul",
              log10: "math/log10",
              log1p: "math/log1p",
              log2: "math/log2",
              sign: "math/sign",
              sinh: "math/sinh",
              tanh: "math/tanh",
              trunc: "math/trunc",
            },
          }
        : {}),
      Symbol: {
        asyncIterator: "symbol/async-iterator",
        for: "symbol/for",
        hasInstance: "symbol/has-instance",
        isConcatSpreadable: "symbol/is-concat-spreadable",
        iterator: "symbol/iterator",
        keyFor: "symbol/key-for",
        match: "symbol/match",
        replace: "symbol/replace",
        search: "symbol/search",
        species: "symbol/species",
        split: "symbol/split",
        toPrimitive: "symbol/to-primitive",
        toStringTag: "symbol/to-string-tag",
        unscopables: "symbol/unscopables",
      },
      String: {
        at: "string/at",
        fromCodePoint: "string/from-code-point",
        raw: "string/raw",
      },
      Number: {
        EPSILON: "number/epsilon",
        isFinite: "number/is-finite",
        isInteger: "number/is-integer",
        isNaN: "number/is-nan",
        isSafeInteger: "number/is-safe-integer",
        MAX_SAFE_INTEGER: "number/max-safe-integer",
        MIN_SAFE_INTEGER: "number/min-safe-integer",
        parseFloat: "number/parse-float",
        parseInt: "number/parse-int",
      },
      Reflect: {
        apply: "reflect/apply",
        construct: "reflect/construct",
        defineProperty: "reflect/define-property",
        deleteProperty: "reflect/delete-property",
        getOwnPropertyDescriptor: "reflect/get-own-property-descriptor",
        getPrototypeOf: "reflect/get-prototype-of",
        get: "reflect/get",
        has: "reflect/has",
        isExtensible: "reflect/is-extensible",
        ownKeys: "reflect/own-keys",
        preventExtensions: "reflect/prevent-extensions",
        setPrototypeOf: "reflect/set-prototype-of",
        set: "reflect/set",
      },
      Date: {
        now: "date/now",
      },
    },
  };
};

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-runtime/src/definitions.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-runtime/scripts/build-dist.js

"use strict";
const path = require("path");
const outputFile = require("output-file-sync");
const helpers = require("@babel/helpers");
const babel = require("@babel/core");
const template = require("@babel/template");
const t = require("@babel/types");
const transformRuntime = require("../");
const getCorejs2Definitions = require("../lib/definitions").default;
const corejs2Definitions = getCorejs2Definitions();
writeHelpers("@babel/runtime");
writeCoreJS2("@babel/runtime-corejs2");
writeHelpers("@babel/runtime-corejs2", { corejs: 2 });
function writeCoreJS2(runtimeName) {
  const pkgDirname = getRuntimeRoot(runtimeName);
  const paths = ["is-iterable", "get-iterator"];
  Object.keys(corejs2Definitions.builtins).forEach(key => {
    const path = corejs2Definitions.builtins[key];
    paths.push(path);
  });
  Object.keys(corejs2Definitions.methods).forEach(key => {
    const props = corejs2Definitions.methods[key];
    Object.keys(props).forEach(key2 => {
      paths.push(props[key2]);
    });
  });
  paths.forEach(function(corePath) {
    outputFile(
      path.join(pkgDirname, "core-js", `${corePath}.js`),
      `module.exports = require("core-js/library/fn/${corePath}");`
    );
  });
}
function writeHelpers(runtimeName, { corejs } = {}) {
  writeHelperFiles(runtimeName, { corejs, esm: false });
  writeHelperFiles(runtimeName, { corejs, esm: true });
}
function writeHelperFiles(runtimeName, { esm, corejs }) {
  const pkgDirname = getRuntimeRoot(runtimeName);
  for (const helperName of helpers.list) {
    const helperFilename = path.join(
      pkgDirname,
      "helpers",
      esm ? "esm" : "",
      `${helperName}.js`
    );
    outputFile(
      helperFilename,
      buildHelper(runtimeName, pkgDirname, helperFilename, helperName, {
        esm,
        corejs,
      })
    );
  }
}
function getRuntimeRoot(runtimeName) {
  return path.resolve(
    __dirname,
    "..",
    "..",
    runtimeName.replace(/^@babel\//, "babel-")
  );
}
function buildHelper(
  runtimeName,
  pkgDirname,
  helperFilename,
  helperName,
  { esm, corejs }
) {
  const tree = t.program([], [], esm ? "module" : "script");
  const dependencies = {};
  let bindings = null;
  if (!esm) {
    bindings = [];
    for (const dep of helpers.getDependencies(helperName)) {
      const id = (dependencies[dep] = t.identifier(t.toIdentifier(dep)));
      tree.body.push(template.statement.ast`
        var ${id} = require("${`./${dep}`}");
      `);
      bindings.push(id.name);
    }
  }
  const helper = helpers.get(
    helperName,
    dep => dependencies[dep],
    esm ? null : template.expression.ast`module.exports`,
    bindings
  );
  tree.body.push(...helper.nodes);
  return babel.transformFromAst(tree, null, {
    presets: [[require("@babel/preset-env"), { modules: false }]],
    plugins: [
      [transformRuntime, { corejs, useESModules: esm }],
      buildRuntimeRewritePlugin(
        runtimeName,
        path.relative(path.dirname(helperFilename), pkgDirname),
        helperName
      ),
    ],
  }).code;
}
function buildRuntimeRewritePlugin(runtimeName, relativePath, helperName) {
  function adjustImportPath(node, relativePath) {
    node.value =
      helpers.list.indexOf(node.value) !== -1
        ? `./${node.value}`
        : node.value.replace(runtimeName + "/", relativePath + "/");
  }
  return {
    pre(file) {
      const original = file.get("helperGenerator");
      file.set("helperGenerator", name => {
        // make sure that helpers won't insert circular references to themselves
        if (name === helperName) return false;
        return original(name);
      });
    },
    visitor: {
      ImportDeclaration(path) {
        adjustImportPath(path.get("source").node, relativePath);
      },
      CallExpression(path) {
        if (
          !path.get("callee").isIdentifier({ name: "require" }) ||
          path.get("arguments").length !== 1 ||
          !path.get("arguments")[0].isStringLiteral()
        ) {
          return;
        }
        // replace any reference to @babel/runtime and other helpers
        // with a relative path
        adjustImportPath(path.get("arguments")[0].node, relativePath);
      },
    },
  };
}

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-runtime/scripts/build-dist.js

// <from> /home/qfox/apps/babel/packages/babel-helper-simple-access/src/index.js

import * as t from "@babel/types";
export default function simplifyAccess(path: NodePath, bindingNames) {
  path.traverse(simpleAssignmentVisitor, {
    scope: path.scope,
    bindingNames,
    seen: new WeakSet(),
  });
}
const simpleAssignmentVisitor = {
  UpdateExpression: {
    exit(path) {
      const { scope, bindingNames } = this;
      const arg = path.get("argument");
      if (!arg.isIdentifier()) return;
      const localName = arg.node.name;
      if (!bindingNames.has(localName)) return;
      // redeclared in this scope
      if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {
        return;
      }
      if (
        path.parentPath.isExpressionStatement() &&
        !path.isCompletionRecord()
      ) {
        // ++i => (i += 1);
        const operator = path.node.operator == "++" ? "+=" : "-=";
        path.replaceWith(
          t.assignmentExpression(operator, arg.node, t.numericLiteral(1)),
        );
      } else if (path.node.prefix) {
        // ++i => (i = (+i) + 1);
        path.replaceWith(
          t.assignmentExpression(
            "=",
            t.identifier(localName),
            t.binaryExpression(
              path.node.operator[0],
              t.unaryExpression("+", arg.node),
              t.numericLiteral(1),
            ),
          ),
        );
      } else {
        const old = path.scope.generateUidIdentifierBasedOnNode(
          arg.node,
          "old",
        );
        const varName = old.name;
        path.scope.push({ id: old });
        const binary = t.binaryExpression(
          path.node.operator[0],
          t.identifier(varName),
          t.numericLiteral(1),
        );
        // i++ => (_old = (+i), i = _old + 1, _old)
        path.replaceWith(
          t.sequenceExpression([
            t.assignmentExpression(
              "=",
              t.identifier(varName),
              t.unaryExpression("+", arg.node),
            ),
            t.assignmentExpression("=", t.cloneNode(arg.node), binary),
            t.identifier(varName),
          ]),
        );
      }
    },
  },
  AssignmentExpression: {
    exit(path) {
      const { scope, seen, bindingNames } = this;
      if (path.node.operator === "=") return;
      if (seen.has(path.node)) return;
      seen.add(path.node);
      const left = path.get("left");
      if (!left.isIdentifier()) return;
      // Simple update-assign foo += 1;
      // =>   exports.foo =  (foo += 1);
      const localName = left.node.name;
      if (!bindingNames.has(localName)) return;
      // redeclared in this scope
      if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {
        return;
      }
      path.node.right = t.binaryExpression(
        path.node.operator.slice(0, -1),
        t.cloneNode(path.node.left),
        path.node.right,
      );
      path.node.operator = "=";
    },
  },
};

// </from> /home/qfox/apps/babel/packages/babel-helper-simple-access/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-arrow-functions/src/index.js

import { declare } from "@babel/helper-plugin-utils";
export default declare((api, options) => {
  api.assertVersion(7);
  const { spec } = options;
  return {
    visitor: {
      ArrowFunctionExpression(
        path: NodePath<BabelNodeArrowFunctionExpression>,
      ) {
        // In some conversion cases, it may have already been converted to a function while this callback
        // was queued up.
        if (!path.isArrowFunctionExpression()) return;
        path.arrowFunctionToExpression({
          // While other utils may be fine inserting other arrows to make more transforms possible,
          // the arrow transform itself absolutely cannot insert new arrow functions.
          allowInsertArrow: false,
          specCompliant: !!spec,
        });
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-arrow-functions/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-react-jsx-source/src/index.js

/**
 * This adds {fileName, lineNumber} annotations to React component definitions
 * and to jsx tag literals.
 *
 *
 * == JSX Literals ==
 *
 * <sometag />
 *
 * becomes:
 *
 * var __jsxFileName = 'this/file.js';
 * <sometag __source={{fileName: __jsxFileName, lineNumber: 10}}/>
 */
import { declare } from "@babel/helper-plugin-utils";
import { types as t } from "@babel/core";
const TRACE_ID = "__source";
const FILE_NAME_VAR = "_jsxFileName";
export default declare(api => {
  api.assertVersion(7);
  function makeTrace(fileNameIdentifier, lineNumber) {
    const fileLineLiteral =
      lineNumber != null ? t.numericLiteral(lineNumber) : t.nullLiteral();
    const fileNameProperty = t.objectProperty(
      t.identifier("fileName"),
      fileNameIdentifier,
    );
    const lineNumberProperty = t.objectProperty(
      t.identifier("lineNumber"),
      fileLineLiteral,
    );
    return t.objectExpression([fileNameProperty, lineNumberProperty]);
  }
  const visitor = {
    JSXOpeningElement(path, state) {
      const id = t.jsxIdentifier(TRACE_ID);
      const location = path.container.openingElement.loc;
      if (!location) {
        // the element was generated and doesn't have location information
        return;
      }
      const attributes = path.container.openingElement.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const name = attributes[i].name;
        if (name && name.name === TRACE_ID) {
          // The __source attibute already exists
          return;
        }
      }
      if (!state.fileNameIdentifier) {
        const fileName = state.filename || "";
        const fileNameIdentifier = path.scope.generateUidIdentifier(
          FILE_NAME_VAR,
        );
        const scope = path.hub.getScope();
        if (scope) {
          scope.push({
            id: fileNameIdentifier,
            init: t.stringLiteral(fileName),
          });
        }
        state.fileNameIdentifier = fileNameIdentifier;
      }
      const trace = makeTrace(state.fileNameIdentifier, location.start.line);
      attributes.push(t.jsxAttribute(id, t.jsxExpressionContainer(trace)));
    },
  };
  return {
    visitor,
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-react-jsx-source/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-property-mutators/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import * as defineMap from "@babel/helper-define-map";
import { types as t } from "@babel/core";
export default declare(api => {
  api.assertVersion(7);
  return {
    visitor: {
      ObjectExpression(path, file) {
        const { node } = path;
        let hasAny = false;
        for (const prop of (node.properties: Array)) {
          if (prop.kind === "get" || prop.kind === "set") {
            hasAny = true;
            break;
          }
        }
        if (!hasAny) return;
        const mutatorMap = {};
        node.properties = node.properties.filter(function(prop) {
          if (!prop.computed && (prop.kind === "get" || prop.kind === "set")) {
            defineMap.push(mutatorMap, prop, null, file);
            return false;
          } else {
            return true;
          }
        });
        path.replaceWith(
          t.callExpression(
            t.memberExpression(
              t.identifier("Object"),
              t.identifier("defineProperties"),
            ),
            [node, defineMap.toDefineObject(mutatorMap)],
          ),
        );
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-property-mutators/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-literals/src/index.js

import { declare } from "@babel/helper-plugin-utils";
export default declare(api => {
  api.assertVersion(7);
  return {
    visitor: {
      NumericLiteral({ node }) {
        // number octal like 0b10 or 0o70
        if (node.extra && /^0[ob]/i.test(node.extra.raw)) {
          node.extra = undefined;
        }
      },
      StringLiteral({ node }) {
        // unicode escape
        if (node.extra && /\\[u]/gi.test(node.extra.raw)) {
          node.extra = undefined;
        }
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-literals/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-spread/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import { types as t } from "@babel/core";
export default declare((api, options) => {
  api.assertVersion(7);
  const { loose } = options;
  function getSpreadLiteral(spread, scope) {
    if (loose && !t.isIdentifier(spread.argument, { name: "arguments" })) {
      return spread.argument;
    } else {
      return scope.toArray(spread.argument, true);
    }
  }
  function hasSpread(nodes) {
    for (let i = 0; i < nodes.length; i++) {
      if (t.isSpreadElement(nodes[i])) {
        return true;
      }
    }
    return false;
  }
  function push(_props, nodes) {
    if (!_props.length) return _props;
    nodes.push(t.arrayExpression(_props));
    return [];
  }
  function build(props: Array, scope) {
    const nodes = [];
    let _props = [];
    for (const prop of props) {
      if (t.isSpreadElement(prop)) {
        _props = push(_props, nodes);
        nodes.push(getSpreadLiteral(prop, scope));
      } else {
        _props.push(prop);
      }
    }
    push(_props, nodes);
    return nodes;
  }
  return {
    visitor: {
      ArrayExpression(path) {
        const { node, scope } = path;
        const elements = node.elements;
        if (!hasSpread(elements)) return;
        const nodes = build(elements, scope);
        const first = nodes.shift();
        if (nodes.length === 0 && first !== elements[0].argument) {
          path.replaceWith(first);
          return;
        }
        path.replaceWith(
          t.callExpression(
            t.memberExpression(first, t.identifier("concat")),
            nodes,
          ),
        );
      },
      CallExpression(path) {
        const { node, scope } = path;
        const args = node.arguments;
        if (!hasSpread(args)) return;
        const calleePath = path.get("callee");
        if (calleePath.isSuper()) return;
        let contextLiteral = scope.buildUndefinedNode();
        node.arguments = [];
        let nodes;
        if (args.length === 1 && args[0].argument.name === "arguments") {
          nodes = [args[0].argument];
        } else {
          nodes = build(args, scope);
        }
        const first = nodes.shift();
        if (nodes.length) {
          node.arguments.push(
            t.callExpression(
              t.memberExpression(first, t.identifier("concat")),
              nodes,
            ),
          );
        } else {
          node.arguments.push(first);
        }
        const callee = node.callee;
        if (calleePath.isMemberExpression()) {
          const temp = scope.maybeGenerateMemoised(callee.object);
          if (temp) {
            callee.object = t.assignmentExpression("=", temp, callee.object);
            contextLiteral = temp;
          } else {
            contextLiteral = t.cloneNode(callee.object);
          }
          t.appendToMemberExpression(callee, t.identifier("apply"));
        } else {
          node.callee = t.memberExpression(node.callee, t.identifier("apply"));
        }
        if (t.isSuper(contextLiteral)) {
          contextLiteral = t.thisExpression();
        }
        node.arguments.unshift(t.cloneNode(contextLiteral));
      },
      NewExpression(path) {
        const { node, scope } = path;
        let args = node.arguments;
        if (!hasSpread(args)) return;
        const nodes = build(args, scope);
        const first = nodes.shift();
        if (nodes.length) {
          args = t.callExpression(
            t.memberExpression(first, t.identifier("concat")),
            nodes,
          );
        } else {
          args = first;
        }
        path.replaceWith(
          t.callExpression(path.hub.addHelper("construct"), [
            node.callee,
            args,
          ]),
        );
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-spread/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-proposal-export-default-from/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import syntaxExportDefaultFrom from "@babel/plugin-syntax-export-default-from";
import { types as t } from "@babel/core";
export default declare(api => {
  api.assertVersion(7);
  return {
    inherits: syntaxExportDefaultFrom,
    visitor: {
      ExportNamedDeclaration(path) {
        const { node, scope } = path;
        const { specifiers } = node;
        if (!t.isExportDefaultSpecifier(specifiers[0])) return;
        const specifier = specifiers.shift();
        const { exported } = specifier;
        const uid = scope.generateUidIdentifier(exported.name);
        const nodes = [
          t.importDeclaration(
            [t.importDefaultSpecifier(uid)],
            t.cloneNode(node.source),
          ),
          t.exportNamedDeclaration(null, [
            t.exportSpecifier(t.cloneNode(uid), exported),
          ]),
        ];
        if (specifiers.length >= 1) {
          nodes.push(node);
        }
        path.replaceWithMultiple(nodes);
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-proposal-export-default-from/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-proposal-export-namespace-from/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import syntaxExportNamespaceFrom from "@babel/plugin-syntax-export-namespace-from";
import { types as t } from "@babel/core";
export default declare(api => {
  api.assertVersion(7);
  return {
    inherits: syntaxExportNamespaceFrom,
    visitor: {
      ExportNamedDeclaration(path) {
        const { node, scope } = path;
        const { specifiers } = node;
        const index = t.isExportDefaultSpecifier(specifiers[0]) ? 1 : 0;
        if (!t.isExportNamespaceSpecifier(specifiers[index])) return;
        const nodes = [];
        if (index === 1) {
          nodes.push(
            t.exportNamedDeclaration(null, [specifiers.shift()], node.source),
          );
        }
        const specifier = specifiers.shift();
        const { exported } = specifier;
        const uid = scope.generateUidIdentifier(exported.name);
        nodes.push(
          t.importDeclaration(
            [t.importNamespaceSpecifier(uid)],
            t.cloneNode(node.source),
          ),
          t.exportNamedDeclaration(null, [
            t.exportSpecifier(t.cloneNode(uid), exported),
          ]),
        );
        if (node.specifiers.length >= 1) {
          nodes.push(node);
        }
        path.replaceWithMultiple(nodes);
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-proposal-export-namespace-from/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-helper-wrap-function/src/index.js

import nameFunction from "@babel/helper-function-name";
import template from "@babel/template";
import * as t from "@babel/types";
const buildExpressionWrapper = template.expression(`
  (function () {
    var REF = FUNCTION;
    return function NAME(PARAMS) {
      return REF.apply(this, arguments);
    };
  })()
`);
const buildDeclarationWrapper = template(`
  function NAME(PARAMS) { return REF.apply(this, arguments); }
  function REF() {
    REF = FUNCTION;
    return REF.apply(this, arguments);
  }
`);
function classOrObjectMethod(path: NodePath, callId: Object) {
  const node = path.node;
  const body = node.body;
  const container = t.functionExpression(
    null,
    [],
    t.blockStatement(body.body),
    true,
  );
  body.body = [
    t.returnStatement(
      t.callExpression(t.callExpression(callId, [container]), []),
    ),
  ];
  // Regardless of whether or not the wrapped function is a an async method
  // or generator the outer function should not be
  node.async = false;
  node.generator = false;
  // Unwrap the wrapper IIFE's environment so super and this and such still work.
  path
    .get("body.body.0.argument.callee.arguments.0")
    .unwrapFunctionEnvironment();
}
function plainFunction(path: NodePath, callId: Object) {
  const node = path.node;
  const isDeclaration = path.isFunctionDeclaration();
  const functionId = node.id;
  const wrapper = isDeclaration
    ? buildDeclarationWrapper
    : buildExpressionWrapper;
  if (path.isArrowFunctionExpression()) {
    path.arrowFunctionToExpression();
  }
  node.id = null;
  if (isDeclaration) {
    node.type = "FunctionExpression";
  }
  const built = t.callExpression(callId, [node]);
  const container = wrapper({
    NAME: functionId || null,
    REF: path.scope.generateUidIdentifier(functionId ? functionId.name : "ref"),
    FUNCTION: built,
    PARAMS: node.params.reduce(
      (acc, param) => {
        acc.done =
          acc.done || t.isAssignmentPattern(param) || t.isRestElement(param);
        if (!acc.done) {
          acc.params.push(path.scope.generateUidIdentifier("x"));
        }
        return acc;
      },
      {
        params: [],
        done: false,
      },
    ).params,
  });
  if (isDeclaration) {
    path.replaceWith(container[0]);
    path.insertAfter(container[1]);
  } else {
    const retFunction = container.callee.body.body[1].argument;
    if (!functionId) {
      nameFunction({
        node: retFunction,
        parent: path.parent,
        scope: path.scope,
      });
    }
    if (!retFunction || retFunction.id || node.params.length) {
      // we have an inferred function id or params so we need this wrapper
      path.replaceWith(container);
    } else {
      // we can omit this wrapper as the conditions it protects for do not apply
      path.replaceWith(built);
    }
  }
}
export default function wrapFunction(path: NodePath, callId: Object) {
  if (path.isClassMethod() || path.isObjectMethod()) {
    classOrObjectMethod(path, callId);
  } else {
    plainFunction(path, callId);
  }
}

// </from> /home/qfox/apps/babel/packages/babel-helper-wrap-function/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-preset-typescript/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import transformTypeScript from "@babel/plugin-transform-typescript";
export default declare(
  (api, { jsxPragma, allExtensions = false, isTSX = false }) => {
    api.assertVersion(7);
    if (typeof allExtensions !== "boolean") {
      throw new Error(".allExtensions must be a boolean, or undefined");
    }
    if (typeof isTSX !== "boolean") {
      throw new Error(".isTSX must be a boolean, or undefined");
    }
    if (isTSX && !allExtensions) {
      throw new Error("isTSX:true requires allExtensions:true");
    }
    return {
      overrides: allExtensions
        ? [
            {
              plugins: [[transformTypeScript, { jsxPragma, isTSX }]],
            },
          ]
        : [
            {
              // Only set 'test' if explicitly requested, since it requires that
              // Babel is being called`
              test: /\.ts$/,
              plugins: [[transformTypeScript, { jsxPragma }]],
            },
            {
              // Only set 'test' if explicitly requested, since it requires that
              // Babel is being called`
              test: /\.tsx$/,
              plugins: [[transformTypeScript, { jsxPragma, isTSX: true }]],
            },
          ],
    };
  },
);

// </from> /home/qfox/apps/babel/packages/babel-preset-typescript/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-external-helpers/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import { types as t } from "@babel/core";
export default declare((api, options) => {
  api.assertVersion(7);
  const { helperVersion = "7.0.0-beta.0", whitelist = false } = options;
  if (
    whitelist !== false &&
    (!Array.isArray(whitelist) || whitelist.some(w => typeof w !== "string"))
  ) {
    throw new Error(
      ".whitelist must be undefined, false, or an array of strings",
    );
  }
  const helperWhitelist = whitelist ? new Set(whitelist) : null;
  return {
    pre(file) {
      file.set("helperGenerator", name => {
        // If the helper didn't exist yet at the version given, we bail
        // out and let Babel either insert it directly, or throw an error
        // so that plugins can handle that case properly.
        if (
          file.availableHelper &&
          !file.availableHelper(name, helperVersion)
        ) {
          return;
        }
        // babelCore.buildExternalHelpers() allows a whitelist of helpers that
        // will be inserted into the external helpers list. That same whitelist
        // should be passed into the plugin here in that case, so that we can
        // avoid referencing 'babelHelpers.XX' when the helper does not exist.
        if (helperWhitelist && !helperWhitelist.has(name)) return;
        return t.memberExpression(
          t.identifier("babelHelpers"),
          t.identifier(name),
        );
      });
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-external-helpers/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-proposal-unicode-property-regex/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import rewritePattern from "regexpu-core";
import * as regex from "@babel/helper-regex";
export default declare((api, options) => {
  api.assertVersion(7);
  const { useUnicodeFlag = true } = options;
  if (typeof useUnicodeFlag !== "boolean") {
    throw new Error(".useUnicodeFlag must be a boolean, or undefined");
  }
  return {
    visitor: {
      RegExpLiteral(path) {
        const node = path.node;
        if (!regex.is(node, "u")) {
          return;
        }
        node.pattern = rewritePattern(node.pattern, node.flags, {
          unicodePropertyEscape: true,
          useUnicodeFlag,
        });
        if (!useUnicodeFlag) {
          regex.pullFlag(node, "u");
        }
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-proposal-unicode-property-regex/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-proposal-nullish-coalescing-operator/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import syntaxNullishCoalescingOperator from "@babel/plugin-syntax-nullish-coalescing-operator";
import { types as t } from "@babel/core";
export default declare((api, { loose = false }) => {
  api.assertVersion(7);
  return {
    inherits: syntaxNullishCoalescingOperator,
    visitor: {
      LogicalExpression(path) {
        const { node, scope } = path;
        if (node.operator !== "??") {
          return;
        }
        const ref = scope.generateUidIdentifierBasedOnNode(node.left);
        scope.push({ id: ref });
        const assignment = t.assignmentExpression(
          "=",
          t.cloneNode(ref),
          node.left,
        );
        path.replaceWith(
          t.conditionalExpression(
            // We cannot use `!= null` in spec mode because
            // `document.all == null` and `document.all` is not "nullish".
            loose
              ? t.binaryExpression("!=", assignment, t.nullLiteral())
              : t.logicalExpression(
                  "&&",
                  t.binaryExpression("!==", assignment, t.nullLiteral()),
                  t.binaryExpression(
                    "!==",
                    t.cloneNode(ref),
                    scope.buildUndefinedNode(),
                  ),
                ),
            t.cloneNode(ref),
            node.right,
          ),
        );
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-proposal-nullish-coalescing-operator/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-proposal-object-rest-spread/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import syntaxObjectRestSpread from "@babel/plugin-syntax-object-rest-spread";
import { types as t } from "@babel/core";
export default declare((api, opts) => {
  api.assertVersion(7);
  const { useBuiltIns = false, loose = false } = opts;
  if (typeof loose !== "boolean") {
    throw new Error(".loose must be a boolean, or undefined");
  }
  function getExtendsHelper(file) {
    return useBuiltIns
      ? t.memberExpression(t.identifier("Object"), t.identifier("assign"))
      : file.addHelper("extends");
  }
  function hasRestElement(path) {
    let foundRestElement = false;
    visitRestElements(path, () => {
      foundRestElement = true;
      path.stop();
    });
    return foundRestElement;
  }
  function visitRestElements(path, visitor) {
    path.traverse({
      Expression(path) {
        const parentType = path.parent.type;
        if (
          (parentType == "AssignmentPattern" && path.key === "right") ||
          (parentType == "ObjectProperty" &&
            path.parent.computed &&
            path.key === "key")
        ) {
          path.skip();
        }
      },
      RestElement: visitor,
    });
  }
  function hasSpread(node) {
    for (const prop of node.properties) {
      if (t.isSpreadElement(prop)) {
        return true;
      }
    }
    return false;
  }
  // returns an array of all keys of an object, and a status flag indicating if all extracted keys
  // were converted to stringLiterals or not
  // e.g. extracts {keys: ["a", "b", "3", ++x], allLiteral: false }
  // from ast of {a: "foo", b, 3: "bar", [++x]: "baz"}
  function extractNormalizedKeys(path) {
    const props = path.node.properties;
    const keys = [];
    let allLiteral = true;
    for (const prop of props) {
      if (t.isIdentifier(prop.key) && !prop.computed) {
        // since a key {a: 3} is equivalent to {"a": 3}, use the latter
        keys.push(t.stringLiteral(prop.key.name));
      } else if (t.isLiteral(prop.key)) {
        keys.push(t.stringLiteral(String(prop.key.value)));
      } else {
        keys.push(t.cloneNode(prop.key));
        allLiteral = false;
      }
    }
    return { keys, allLiteral };
  }
  // replaces impure computed keys with new identifiers
  // and returns variable declarators of these new identifiers
  function replaceImpureComputedKeys(path) {
    const impureComputedPropertyDeclarators = [];
    for (const propPath of path.get("properties")) {
      const key = propPath.get("key");
      if (propPath.node.computed && !key.isPure()) {
        const name = path.scope.generateUidBasedOnNode(key.node);
        const declarator = t.variableDeclarator(t.identifier(name), key.node);
        impureComputedPropertyDeclarators.push(declarator);
        key.replaceWith(t.identifier(name));
      }
    }
    return impureComputedPropertyDeclarators;
  }
  function removeUnusedExcludedKeys(path) {
    const bindings = path.getOuterBindingIdentifierPaths();
    Object.keys(bindings).forEach(bindingName => {
      const bindingParentPath = bindings[bindingName].parentPath;
      if (
        path.scope.getBinding(bindingName).references > 1 ||
        !bindingParentPath.isObjectProperty()
      ) {
        return;
      }
      bindingParentPath.remove();
    });
  }
  //expects path to an object pattern
  function createObjectSpread(path, file, objRef) {
    const props = path.get("properties");
    const last = props[props.length - 1];
    t.assertRestElement(last.node);
    const restElement = t.cloneNode(last.node);
    last.remove();
    const impureComputedPropertyDeclarators = replaceImpureComputedKeys(path);
    const { keys, allLiteral } = extractNormalizedKeys(path);
    if (keys.length === 0) {
      return [
        impureComputedPropertyDeclarators,
        restElement.argument,
        t.callExpression(getExtendsHelper(file), [
          t.objectExpression([]),
          t.cloneNode(objRef),
        ]),
      ];
    }
    let keyExpression;
    if (!allLiteral) {
      // map to toPropertyKey to handle the possible non-string values
      keyExpression = t.callExpression(
        t.memberExpression(t.arrayExpression(keys), t.identifier("map")),
        [file.addHelper("toPropertyKey")],
      );
    } else {
      keyExpression = t.arrayExpression(keys);
    }
    return [
      impureComputedPropertyDeclarators,
      restElement.argument,
      t.callExpression(
        file.addHelper(`objectWithoutProperties${loose ? "Loose" : ""}`),
        [t.cloneNode(objRef), keyExpression],
      ),
    ];
  }
  function replaceRestElement(parentPath, paramPath, i, numParams) {
    if (paramPath.isAssignmentPattern()) {
      replaceRestElement(parentPath, paramPath.get("left"), i, numParams);
      return;
    }
    if (paramPath.isArrayPattern() && hasRestElement(paramPath)) {
      const elements = paramPath.get("elements");
      for (let i = 0; i < elements.length; i++) {
        replaceRestElement(parentPath, elements[i], i, elements.length);
      }
    }
    if (paramPath.isObjectPattern() && hasRestElement(paramPath)) {
      const uid = parentPath.scope.generateUidIdentifier("ref");
      const declar = t.variableDeclaration("let", [
        t.variableDeclarator(paramPath.node, uid),
      ]);
      parentPath.ensureBlock();
      parentPath.get("body").unshiftContainer("body", declar);
      paramPath.replaceWith(t.cloneNode(uid));
    }
  }
  return {
    inherits: syntaxObjectRestSpread,
    visitor: {
      // taken from transform-parameters/src/destructuring.js
      // function a({ b, ...c }) {}
      Function(path) {
        const params = path.get("params");
        for (let i = params.length - 1; i >= 0; i--) {
          replaceRestElement(params[i].parentPath, params[i], i, params.length);
        }
      },
      // adapted from transform-destructuring/src/index.js#pushObjectRest
      // const { a, ...b } = c;
      VariableDeclarator(path, file) {
        if (!path.get("id").isObjectPattern()) {
          return;
        }
        let insertionPath = path;
        const originalPath = path;
        visitRestElements(path.get("id"), path => {
          if (!path.parentPath.isObjectPattern()) {
            // Return early if the parent is not an ObjectPattern, but
            // (for example) an ArrayPattern or Function, because that
            // means this RestElement is an not an object property.
            return;
          }
          if (
            // skip single-property case, e.g.
            // const { ...x } = foo();
            // since the RHS will not be duplicated
            originalPath.node.id.properties.length > 1 &&
            !t.isIdentifier(originalPath.node.init)
          ) {
            // const { a, ...b } = foo();
            // to avoid calling foo() twice, as a first step convert it to:
            // const _foo = foo(),
            //       { a, ...b } = _foo;
            const initRef = path.scope.generateUidIdentifierBasedOnNode(
              originalPath.node.init,
              "ref",
            );
            // insert _foo = foo()
            originalPath.insertBefore(
              t.variableDeclarator(initRef, originalPath.node.init),
            );
            // replace foo() with _foo
            originalPath.replaceWith(
              t.variableDeclarator(originalPath.node.id, t.cloneNode(initRef)),
            );
            return;
          }
          let ref = originalPath.node.init;
          const refPropertyPath = [];
          let kind;
          path.findParent(path => {
            if (path.isObjectProperty()) {
              refPropertyPath.unshift(path.node.key.name);
            } else if (path.isVariableDeclarator()) {
              kind = path.parentPath.node.kind;
              return true;
            }
          });
          if (refPropertyPath.length) {
            refPropertyPath.forEach(prop => {
              ref = t.memberExpression(ref, t.identifier(prop));
            });
          }
          const objectPatternPath = path.findParent(path =>
            path.isObjectPattern(),
          );
          const [
            impureComputedPropertyDeclarators,
            argument,
            callExpression,
          ] = createObjectSpread(objectPatternPath, file, ref);
          if (loose) {
            removeUnusedExcludedKeys(objectPatternPath);
          }
          t.assertIdentifier(argument);
          insertionPath.insertBefore(impureComputedPropertyDeclarators);
          insertionPath.insertAfter(
            t.variableDeclarator(argument, callExpression),
          );
          insertionPath = insertionPath.getSibling(insertionPath.key + 1);
          path.scope.registerBinding(kind, insertionPath);
          if (objectPatternPath.node.properties.length === 0) {
            objectPatternPath
              .findParent(
                path => path.isObjectProperty() || path.isVariableDeclarator(),
              )
              .remove();
          }
        });
      },
      // taken from transform-destructuring/src/index.js#visitor
      // export var { a, ...b } = c;
      ExportNamedDeclaration(path) {
        const declaration = path.get("declaration");
        if (!declaration.isVariableDeclaration()) return;
        const hasRest = declaration
          .get("declarations")
          .some(path => hasRestElement(path.get("id")));
        if (!hasRest) return;
        const specifiers = [];
        for (const name in path.getOuterBindingIdentifiers(path)) {
          specifiers.push(
            t.exportSpecifier(t.identifier(name), t.identifier(name)),
          );
        }
        // Split the declaration and export list into two declarations so that the variable
        // declaration can be split up later without needing to worry about not being a
        // top-level statement.
        path.replaceWith(declaration.node);
        path.insertAfter(t.exportNamedDeclaration(null, specifiers));
      },
      // try {} catch ({a, ...b}) {}
      CatchClause(path) {
        const paramPath = path.get("param");
        replaceRestElement(paramPath.parentPath, paramPath);
      },
      // ({a, ...b} = c);
      AssignmentExpression(path, file) {
        const leftPath = path.get("left");
        if (leftPath.isObjectPattern() && hasRestElement(leftPath)) {
          const nodes = [];
          const refName = path.scope.generateUidBasedOnNode(
            path.node.right,
            "ref",
          );
          nodes.push(
            t.variableDeclaration("var", [
              t.variableDeclarator(t.identifier(refName), path.node.right),
            ]),
          );
          const [
            impureComputedPropertyDeclarators,
            argument,
            callExpression,
          ] = createObjectSpread(leftPath, file, t.identifier(refName));
          if (impureComputedPropertyDeclarators.length > 0) {
            nodes.push(
              t.variableDeclaration("var", impureComputedPropertyDeclarators),
            );
          }
          const nodeWithoutSpread = t.cloneNode(path.node);
          nodeWithoutSpread.right = t.identifier(refName);
          nodes.push(t.expressionStatement(nodeWithoutSpread));
          nodes.push(
            t.toStatement(
              t.assignmentExpression("=", argument, callExpression),
            ),
          );
          nodes.push(t.expressionStatement(t.identifier(refName)));
          path.replaceWithMultiple(nodes);
        }
      },
      // taken from transform-destructuring/src/index.js#visitor
      ForXStatement(path) {
        const { node, scope } = path;
        const leftPath = path.get("left");
        const left = node.left;
        // for ({a, ...b} of []) {}
        if (t.isObjectPattern(left) && hasRestElement(leftPath)) {
          const temp = scope.generateUidIdentifier("ref");
          node.left = t.variableDeclaration("var", [
            t.variableDeclarator(temp),
          ]);
          path.ensureBlock();
          node.body.body.unshift(
            t.variableDeclaration("var", [
              t.variableDeclarator(left, t.cloneNode(temp)),
            ]),
          );
          return;
        }
        if (!t.isVariableDeclaration(left)) return;
        const pattern = left.declarations[0].id;
        if (!t.isObjectPattern(pattern)) return;
        const key = scope.generateUidIdentifier("ref");
        node.left = t.variableDeclaration(left.kind, [
          t.variableDeclarator(key, null),
        ]);
        path.ensureBlock();
        node.body.body.unshift(
          t.variableDeclaration(node.left.kind, [
            t.variableDeclarator(pattern, t.cloneNode(key)),
          ]),
        );
      },
      // var a = { ...b, ...c }
      ObjectExpression(path, file) {
        if (!hasSpread(path.node)) return;
        const args = [];
        let props = [];
        function push() {
          if (!props.length) return;
          args.push(t.objectExpression(props));
          props = [];
        }
        if (t.isSpreadElement(path.node.properties[0])) {
          args.push(t.objectExpression([]));
        }
        for (const prop of (path.node.properties: Array)) {
          if (t.isSpreadElement(prop)) {
            push();
            args.push(prop.argument);
          } else {
            props.push(prop);
          }
        }
        push();
        let helper;
        if (loose) {
          helper = getExtendsHelper(file);
        } else {
          helper = file.addHelper("objectSpread");
        }
        path.replaceWith(t.callExpression(helper, args));
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-proposal-object-rest-spread/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-syntax-dynamic-import/src/index.js

import { declare } from "@babel/helper-plugin-utils";
export default declare(api => {
  api.assertVersion(7);
  return {
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("dynamicImport");
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-syntax-dynamic-import/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-strict-mode/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import { types as t } from "@babel/core";
export default declare(api => {
  api.assertVersion(7);
  return {
    visitor: {
      Program(path) {
        const { node } = path;
        for (const directive of (node.directives: Array<Object>)) {
          if (directive.value.value === "use strict") return;
        }
        path.unshiftContainer(
          "directives",
          t.directive(t.directiveLiteral("use strict")),
        );
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-strict-mode/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-proposal-function-bind/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import syntaxFunctionBind from "@babel/plugin-syntax-function-bind";
import { types as t } from "@babel/core";
export default declare(api => {
  api.assertVersion(7);
  function getTempId(scope) {
    let id = scope.path.getData("functionBind");
    if (id) return id;
    id = scope.generateDeclaredUidIdentifier("context");
    return scope.path.setData("functionBind", id);
  }
  function getStaticContext(bind, scope) {
    const object = bind.object || bind.callee.object;
    return scope.isStatic(object) && object;
  }
  function inferBindContext(bind, scope) {
    const staticContext = getStaticContext(bind, scope);
    if (staticContext) return t.cloneNode(staticContext);
    const tempId = getTempId(scope);
    if (bind.object) {
      bind.callee = t.sequenceExpression([
        t.assignmentExpression("=", tempId, bind.object),
        bind.callee,
      ]);
    } else {
      bind.callee.object = t.assignmentExpression(
        "=",
        tempId,
        bind.callee.object,
      );
    }
    return tempId;
  }
  return {
    inherits: syntaxFunctionBind,
    visitor: {
      CallExpression({ node, scope }) {
        const bind = node.callee;
        if (!t.isBindExpression(bind)) return;
        const context = inferBindContext(bind, scope);
        node.callee = t.memberExpression(bind.callee, t.identifier("call"));
        node.arguments.unshift(context);
      },
      BindExpression(path) {
        const { node, scope } = path;
        const context = inferBindContext(node, scope);
        path.replaceWith(
          t.callExpression(
            t.memberExpression(node.callee, t.identifier("bind")),
            [context],
          ),
        );
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-proposal-function-bind/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-parser/src/index.js

// @flow
import { type Options } from "./options";
import {
  hasPlugin,
  validatePlugins,
  mixinPluginNames,
  mixinPlugins,
  type PluginList,
} from "./plugin-utils";
import Parser from "./parser";
import { types as tokTypes } from "./tokenizer/types";
import "./tokenizer/context";
export function parse(input: string, options?: Options): File {
  if (options && options.sourceType === "unambiguous") {
    options = {
      ...options,
    };
    try {
      options.sourceType = "module";
      const parser = getParser(options, input);
      const ast = parser.parse();
      // Rather than try to parse as a script first, we opt to parse as a module and convert back
      // to a script where possible to avoid having to do a full re-parse of the input content.
      if (!parser.sawUnambiguousESM) ast.program.sourceType = "script";
      return ast;
    } catch (moduleError) {
      try {
        options.sourceType = "script";
        return getParser(options, input).parse();
      } catch (scriptError) {}
      throw moduleError;
    }
  } else {
    return getParser(options, input).parse();
  }
}
export function parseExpression(input: string, options?: Options): Expression {
  const parser = getParser(options, input);
  if (parser.options.strictMode) {
    parser.state.strict = true;
  }
  return parser.getExpression();
}
export { tokTypes };
function getParser(options: ?Options, input: string): Parser {
  let cls = Parser;
  if (options && options.plugins) {
    validatePlugins(options.plugins);
    cls = getParserClass(options.plugins);
  }
  return new cls(options, input);
}
const parserClassCache: { [key: string]: Class<Parser> } = {};
/** Get a Parser class with plugins applied. */
function getParserClass(pluginsFromOptions: PluginList): Class<Parser> {
  const pluginList = mixinPluginNames.filter(name =>
    hasPlugin(pluginsFromOptions, name),
  );
  const key = pluginList.join("/");
  let cls = parserClassCache[key];
  if (!cls) {
    cls = Parser;
    for (const plugin of pluginList) {
      cls = mixinPlugins[plugin](cls);
    }
    parserClassCache[key] = cls;
  }
  return cls;
}

// </from> /home/qfox/apps/babel/packages/babel-parser/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-parser/src/plugins/flow.js

// @flow
import { types as tt, type TokenType } from "../tokenizer/types";
import * as N from "../types";
import * as charCodes from "charcodes";
import { isIteratorStart } from "../util/identifier";
const primitiveTypes = [
  "any",
  "bool",
  "boolean",
  "empty",
  "false",
  "mixed",
  "null",
  "number",
  "static",
  "string",
  "true",
  "typeof",
  "void",
];
function isEsModuleType(bodyElement: N.Node): boolean {
  return (
    bodyElement.type === "DeclareExportAllDeclaration" ||
    (bodyElement.type === "DeclareExportDeclaration" &&
      (!bodyElement.declaration ||
        (bodyElement.declaration.type !== "TypeAlias" &&
          bodyElement.declaration.type !== "InterfaceDeclaration")))
  );
}
function hasTypeImportKind(node: N.Node): boolean {
  return node.importKind === "type" || node.importKind === "typeof";
}
function isMaybeDefaultImport(state: State): boolean {
  return (
    (state.type === tt.name || !!state.type.keyword) && state.value !== "from"
  );
}
const exportSuggestions = {
  const: "declare export var",
  let: "declare export var",
  type: "export type",
  interface: "export interface",
};
// Like Array#filter, but returns a tuple [ acceptedElements, discardedElements ]
function partition<T>(
  list: T[],
  test: (T, number, T[]) => ?boolean,
): [T[], T[]] {
  const list1 = [];
  const list2 = [];
  for (let i = 0; i < list.length; i++) {
    (test(list[i], i, list) ? list1 : list2).push(list[i]);
  }
  return [list1, list2];
}
const FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
export default (superClass: Class<Parser>): Class<Parser> =>
  class extends superClass {
    // The value of the @flow/@noflow pragma. Initially undefined, transitions
    // to "@flow" or "@noflow" if we see a pragma. Transitions to null if we are
    // past the initial comment.
    flowPragma: void | null | "flow" | "noflow";
    constructor(options: ?Options, input: string) {
      super(options, input);
      this.flowPragma = undefined;
    }
    shouldParseTypes(): boolean {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    addComment(comment: N.Comment): void {
      if (this.flowPragma === undefined) {
        // Try to parse a flow pragma.
        const matches = FLOW_PRAGMA_REGEX.exec(comment.value);
        if (!matches) {
          this.flowPragma = null;
        } else if (matches[1] === "flow") {
          this.flowPragma = "flow";
        } else if (matches[1] === "noflow") {
          this.flowPragma = "noflow";
        } else {
          throw new Error("Unexpected flow pragma");
        }
      }
      return super.addComment(comment);
    }
    flowParseTypeInitialiser(tok?: TokenType): N.FlowType {
      const oldInType = this.state.inType;
      this.state.inType = true;
      this.expect(tok || tt.colon);
      const type = this.flowParseType();
      this.state.inType = oldInType;
      return type;
    }
    flowParsePredicate(): N.FlowType {
      const node = this.startNode();
      const moduloLoc = this.state.startLoc;
      const moduloPos = this.state.start;
      this.expect(tt.modulo);
      const checksLoc = this.state.startLoc;
      this.expectContextual("checks");
      // Force '%' and 'checks' to be adjacent
      if (
        moduloLoc.line !== checksLoc.line ||
        moduloLoc.column !== checksLoc.column - 1
      ) {
        this.raise(
          moduloPos,
          "Spaces between % and checks are not allowed here.",
        );
      }
      if (this.eat(tt.parenL)) {
        node.value = this.parseExpression();
        this.expect(tt.parenR);
        return this.finishNode(node, "DeclaredPredicate");
      } else {
        return this.finishNode(node, "InferredPredicate");
      }
    }
    flowParseTypeAndPredicateInitialiser(): [?N.FlowType, ?N.FlowPredicate] {
      const oldInType = this.state.inType;
      this.state.inType = true;
      this.expect(tt.colon);
      let type = null;
      let predicate = null;
      if (this.match(tt.modulo)) {
        this.state.inType = oldInType;
        predicate = this.flowParsePredicate();
      } else {
        type = this.flowParseType();
        this.state.inType = oldInType;
        if (this.match(tt.modulo)) {
          predicate = this.flowParsePredicate();
        }
      }
      return [type, predicate];
    }
    flowParseDeclareClass(node: N.FlowDeclareClass): N.FlowDeclareClass {
      this.next();
      this.flowParseInterfaceish(node, /*isClass*/ true);
      return this.finishNode(node, "DeclareClass");
    }
    flowParseDeclareFunction(
      node: N.FlowDeclareFunction,
    ): N.FlowDeclareFunction {
      this.next();
      const id = (node.id = this.parseIdentifier());
      const typeNode = this.startNode();
      const typeContainer = this.startNode();
      if (this.isRelational("<")) {
        typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
      } else {
        typeNode.typeParameters = null;
      }
      this.expect(tt.parenL);
      const tmp = this.flowParseFunctionTypeParams();
      typeNode.params = tmp.params;
      typeNode.rest = tmp.rest;
      this.expect(tt.parenR);
      [
        // $FlowFixMe (destructuring not supported yet)
        typeNode.returnType,
        // $FlowFixMe (destructuring not supported yet)
        node.predicate,
      ] = this.flowParseTypeAndPredicateInitialiser();
      typeContainer.typeAnnotation = this.finishNode(
        typeNode,
        "FunctionTypeAnnotation",
      );
      id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
      this.finishNode(id, id.type);
      this.semicolon();
      return this.finishNode(node, "DeclareFunction");
    }
    flowParseDeclare(
      node: N.FlowDeclare,
      insideModule?: boolean,
    ): N.FlowDeclare {
      if (this.match(tt._class)) {
        return this.flowParseDeclareClass(node);
      } else if (this.match(tt._function)) {
        return this.flowParseDeclareFunction(node);
      } else if (this.match(tt._var)) {
        return this.flowParseDeclareVariable(node);
      } else if (this.isContextual("module")) {
        if (this.lookahead().type === tt.dot) {
          return this.flowParseDeclareModuleExports(node);
        } else {
          if (insideModule) {
            this.unexpected(
              null,
              "`declare module` cannot be used inside another `declare module`",
            );
          }
          return this.flowParseDeclareModule(node);
        }
      } else if (this.isContextual("type")) {
        return this.flowParseDeclareTypeAlias(node);
      } else if (this.isContextual("opaque")) {
        return this.flowParseDeclareOpaqueType(node);
      } else if (this.isContextual("interface")) {
        return this.flowParseDeclareInterface(node);
      } else if (this.match(tt._export)) {
        return this.flowParseDeclareExportDeclaration(node, insideModule);
      } else {
        throw this.unexpected();
      }
    }
    flowParseDeclareVariable(
      node: N.FlowDeclareVariable,
    ): N.FlowDeclareVariable {
      this.next();
      node.id = this.flowParseTypeAnnotatableIdentifier(
        /*allowPrimitiveOverride*/ true,
      );
      this.semicolon();
      return this.finishNode(node, "DeclareVariable");
    }
    flowParseDeclareModule(node: N.FlowDeclareModule): N.FlowDeclareModule {
      this.next();
      if (this.match(tt.string)) {
        node.id = this.parseExprAtom();
      } else {
        node.id = this.parseIdentifier();
      }
      const bodyNode = (node.body = this.startNode());
      const body = (bodyNode.body = []);
      this.expect(tt.braceL);
      while (!this.match(tt.braceR)) {
        let bodyNode = this.startNode();
        if (this.match(tt._import)) {
          const lookahead = this.lookahead();
          if (lookahead.value !== "type" && lookahead.value !== "typeof") {
            this.unexpected(
              null,
              "Imports within a `declare module` body must always be `import type` or `import typeof`",
            );
          }
          this.next();
          this.parseImport(bodyNode);
        } else {
          this.expectContextual(
            "declare",
            "Only declares and type imports are allowed inside declare module",
          );
          bodyNode = this.flowParseDeclare(bodyNode, true);
        }
        body.push(bodyNode);
      }
      this.expect(tt.braceR);
      this.finishNode(bodyNode, "BlockStatement");
      let kind = null;
      let hasModuleExport = false;
      const errorMessage =
        "Found both `declare module.exports` and `declare export` in the same module. " +
        "Modules can only have 1 since they are either an ES module or they are a CommonJS module";
      body.forEach(bodyElement => {
        if (isEsModuleType(bodyElement)) {
          if (kind === "CommonJS") {
            this.unexpected(bodyElement.start, errorMessage);
          }
          kind = "ES";
        } else if (bodyElement.type === "DeclareModuleExports") {
          if (hasModuleExport) {
            this.unexpected(
              bodyElement.start,
              "Duplicate `declare module.exports` statement",
            );
          }
          if (kind === "ES") this.unexpected(bodyElement.start, errorMessage);
          kind = "CommonJS";
          hasModuleExport = true;
        }
      });
      node.kind = kind || "CommonJS";
      return this.finishNode(node, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(
      node: N.FlowDeclareExportDeclaration,
      insideModule: ?boolean,
    ): N.FlowDeclareExportDeclaration {
      this.expect(tt._export);
      if (this.eat(tt._default)) {
        if (this.match(tt._function) || this.match(tt._class)) {
          // declare export default class ...
          // declare export default function ...
          node.declaration = this.flowParseDeclare(this.startNode());
        } else {
          // declare export default [type];
          node.declaration = this.flowParseType();
          this.semicolon();
        }
        node.default = true;
        return this.finishNode(node, "DeclareExportDeclaration");
      } else {
        if (
          this.match(tt._const) ||
          this.match(tt._let) ||
          ((this.isContextual("type") || this.isContextual("interface")) &&
            !insideModule)
        ) {
          const label = this.state.value;
          const suggestion = exportSuggestions[label];
          this.unexpected(
            this.state.start,
            `\`declare export ${label}\` is not supported. Use \`${suggestion}\` instead`,
          );
        }
        if (
          this.match(tt._var) || // declare export var ...
          this.match(tt._function) || // declare export function ...
          this.match(tt._class) || // declare export class ...
          this.isContextual("opaque") // declare export opaque ..
        ) {
          node.declaration = this.flowParseDeclare(this.startNode());
          node.default = false;
          return this.finishNode(node, "DeclareExportDeclaration");
        } else if (
          this.match(tt.star) || // declare export * from ''
          this.match(tt.braceL) || // declare export {} ...
          this.isContextual("interface") || // declare export interface ...
          this.isContextual("type") || // declare export type ...
          this.isContextual("opaque") // declare export opaque type ...
        ) {
          node = this.parseExport(node);
          if (node.type === "ExportNamedDeclaration") {
            // flow does not support the ExportNamedDeclaration
            // $FlowIgnore
            node.type = "ExportDeclaration";
            // $FlowFixMe
            node.default = false;
            delete node.exportKind;
          }
          // $FlowIgnore
          node.type = "Declare" + node.type;
          return node;
        }
      }
      throw this.unexpected();
    }
    flowParseDeclareModuleExports(
      node: N.FlowDeclareModuleExports,
    ): N.FlowDeclareModuleExports {
      this.expectContextual("module");
      this.expect(tt.dot);
      this.expectContextual("exports");
      node.typeAnnotation = this.flowParseTypeAnnotation();
      this.semicolon();
      return this.finishNode(node, "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(
      node: N.FlowDeclareTypeAlias,
    ): N.FlowDeclareTypeAlias {
      this.next();
      this.flowParseTypeAlias(node);
      return this.finishNode(node, "DeclareTypeAlias");
    }
    flowParseDeclareOpaqueType(
      node: N.FlowDeclareOpaqueType,
    ): N.FlowDeclareOpaqueType {
      this.next();
      this.flowParseOpaqueType(node, true);
      return this.finishNode(node, "DeclareOpaqueType");
    }
    flowParseDeclareInterface(
      node: N.FlowDeclareInterface,
    ): N.FlowDeclareInterface {
      this.next();
      this.flowParseInterfaceish(node);
      return this.finishNode(node, "DeclareInterface");
    }
    // Interfaces
    flowParseInterfaceish(
      node: N.FlowDeclare,
      isClass?: boolean = false,
    ): void {
      node.id = this.flowParseRestrictedIdentifier(/*liberal*/ !isClass);
      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      } else {
        node.typeParameters = null;
      }
      node.extends = [];
      node.implements = [];
      node.mixins = [];
      if (this.eat(tt._extends)) {
        do {
          node.extends.push(this.flowParseInterfaceExtends());
        } while (!isClass && this.eat(tt.comma));
      }
      if (this.isContextual("mixins")) {
        this.next();
        do {
          node.mixins.push(this.flowParseInterfaceExtends());
        } while (this.eat(tt.comma));
      }
      if (this.isContextual("implements")) {
        this.next();
        do {
          node.implements.push(this.flowParseInterfaceExtends());
        } while (this.eat(tt.comma));
      }
      node.body = this.flowParseObjectType(isClass, false, false, isClass);
    }
    flowParseInterfaceExtends(): N.FlowInterfaceExtends {
      const node = this.startNode();
      node.id = this.flowParseQualifiedTypeIdentifier();
      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterInstantiation();
      } else {
        node.typeParameters = null;
      }
      return this.finishNode(node, "InterfaceExtends");
    }
    flowParseInterface(node: N.FlowInterface): N.FlowInterface {
      this.flowParseInterfaceish(node);
      return this.finishNode(node, "InterfaceDeclaration");
    }
    checkReservedType(word: string, startLoc: number) {
      if (primitiveTypes.indexOf(word) > -1) {
        this.raise(startLoc, `Cannot overwrite primitive type ${word}`);
      }
    }
    flowParseRestrictedIdentifier(liberal?: boolean): N.Identifier {
      this.checkReservedType(this.state.value, this.state.start);
      return this.parseIdentifier(liberal);
    }
    // Type aliases
    flowParseTypeAlias(node: N.FlowTypeAlias): N.FlowTypeAlias {
      node.id = this.flowParseRestrictedIdentifier();
      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      } else {
        node.typeParameters = null;
      }
      node.right = this.flowParseTypeInitialiser(tt.eq);
      this.semicolon();
      return this.finishNode(node, "TypeAlias");
    }
    flowParseOpaqueType(
      node: N.FlowOpaqueType,
      declare: boolean,
    ): N.FlowOpaqueType {
      this.expectContextual("type");
      node.id = this.flowParseRestrictedIdentifier(/*liberal*/ true);
      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      } else {
        node.typeParameters = null;
      }
      // Parse the supertype
      node.supertype = null;
      if (this.match(tt.colon)) {
        node.supertype = this.flowParseTypeInitialiser(tt.colon);
      }
      node.impltype = null;
      if (!declare) {
        node.impltype = this.flowParseTypeInitialiser(tt.eq);
      }
      this.semicolon();
      return this.finishNode(node, "OpaqueType");
    }
    // Type annotations
    flowParseTypeParameter(
      allowDefault?: boolean = true,
      requireDefault?: boolean = false,
    ): N.TypeParameter {
      if (!allowDefault && requireDefault) {
        throw new Error(
          "Cannot disallow a default value (`allowDefault`) while also requiring it (`requireDefault`).",
        );
      }
      const nodeStart = this.state.start;
      const node = this.startNode();
      const variance = this.flowParseVariance();
      const ident = this.flowParseTypeAnnotatableIdentifier();
      node.name = ident.name;
      node.variance = variance;
      node.bound = ident.typeAnnotation;
      if (this.match(tt.eq)) {
        if (allowDefault) {
          this.eat(tt.eq);
          node.default = this.flowParseType();
        } else {
          this.unexpected();
        }
      } else {
        if (requireDefault) {
          this.unexpected(
            nodeStart,
            // eslint-disable-next-line max-len
            "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
          );
        }
      }
      return this.finishNode(node, "TypeParameter");
    }
    flowParseTypeParameterDeclaration(
      allowDefault?: boolean = true,
    ): N.TypeParameterDeclaration {
      const oldInType = this.state.inType;
      const node = this.startNode();
      node.params = [];
      this.state.inType = true;
      // istanbul ignore else: this condition is already checked at all call sites
      if (this.isRelational("<") || this.match(tt.jsxTagStart)) {
        this.next();
      } else {
        this.unexpected();
      }
      let defaultRequired = false;
      do {
        const typeParameter = this.flowParseTypeParameter(
          allowDefault,
          defaultRequired,
        );
        node.params.push(typeParameter);
        if (typeParameter.default) {
          defaultRequired = true;
        }
        if (!this.isRelational(">")) {
          this.expect(tt.comma);
        }
      } while (!this.isRelational(">"));
      this.expectRelational(">");
      this.state.inType = oldInType;
      return this.finishNode(node, "TypeParameterDeclaration");
    }
    flowParseTypeParameterInstantiation(): N.TypeParameterInstantiation {
      const node = this.startNode();
      const oldInType = this.state.inType;
      node.params = [];
      this.state.inType = true;
      this.expectRelational("<");
      while (!this.isRelational(">")) {
        node.params.push(this.flowParseType());
        if (!this.isRelational(">")) {
          this.expect(tt.comma);
        }
      }
      this.expectRelational(">");
      this.state.inType = oldInType;
      return this.finishNode(node, "TypeParameterInstantiation");
    }
    flowParseInterfaceType(): N.FlowInterfaceType {
      const node = this.startNode();
      this.expectContextual("interface");
      node.extends = [];
      if (this.eat(tt._extends)) {
        do {
          node.extends.push(this.flowParseInterfaceExtends());
        } while (this.eat(tt.comma));
      }
      node.body = this.flowParseObjectType(false, false, false, false);
      return this.finishNode(node, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey(): N.Expression {
      return this.match(tt.num) || this.match(tt.string)
        ? this.parseExprAtom()
        : this.parseIdentifier(true);
    }
    flowParseObjectTypeIndexer(
      node: N.FlowObjectTypeIndexer,
      isStatic: boolean,
      variance: ?N.FlowVariance,
    ): N.FlowObjectTypeIndexer {
      node.static = isStatic;
      // Note: bracketL has already been consumed
      if (this.lookahead().type === tt.colon) {
        node.id = this.flowParseObjectPropertyKey();
        node.key = this.flowParseTypeInitialiser();
      } else {
        node.id = null;
        node.key = this.flowParseType();
      }
      this.expect(tt.bracketR);
      node.value = this.flowParseTypeInitialiser();
      node.variance = variance;
      return this.finishNode(node, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(
      node: N.FlowObjectTypeInternalSlot,
      isStatic: boolean,
    ): N.FlowObjectTypeInternalSlot {
      node.static = isStatic;
      // Note: both bracketL have already been consumed
      node.id = this.flowParseObjectPropertyKey();
      this.expect(tt.bracketR);
      this.expect(tt.bracketR);
      if (this.isRelational("<") || this.match(tt.parenL)) {
        node.method = true;
        node.optional = false;
        node.value = this.flowParseObjectTypeMethodish(
          this.startNodeAt(node.start, node.loc.start),
        );
      } else {
        node.method = false;
        if (this.eat(tt.question)) {
          node.optional = true;
        }
        node.value = this.flowParseTypeInitialiser();
      }
      return this.finishNode(node, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(
      node: N.FlowFunctionTypeAnnotation,
    ): N.FlowFunctionTypeAnnotation {
      node.params = [];
      node.rest = null;
      node.typeParameters = null;
      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterDeclaration(
          /* allowDefault */ false,
        );
      }
      this.expect(tt.parenL);
      while (!this.match(tt.parenR) && !this.match(tt.ellipsis)) {
        node.params.push(this.flowParseFunctionTypeParam());
        if (!this.match(tt.parenR)) {
          this.expect(tt.comma);
        }
      }
      if (this.eat(tt.ellipsis)) {
        node.rest = this.flowParseFunctionTypeParam();
      }
      this.expect(tt.parenR);
      node.returnType = this.flowParseTypeInitialiser();
      return this.finishNode(node, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(
      node: N.FlowObjectTypeCallProperty,
      isStatic: boolean,
    ): N.FlowObjectTypeCallProperty {
      const valueNode = this.startNode();
      node.static = isStatic;
      node.value = this.flowParseObjectTypeMethodish(valueNode);
      return this.finishNode(node, "ObjectTypeCallProperty");
    }
    flowParseObjectType(
      allowStatic: boolean,
      allowExact: boolean,
      allowSpread: boolean,
      allowProto: boolean,
    ): N.FlowObjectTypeAnnotation {
      const oldInType = this.state.inType;
      this.state.inType = true;
      const nodeStart = this.startNode();
      nodeStart.callProperties = [];
      nodeStart.properties = [];
      nodeStart.indexers = [];
      nodeStart.internalSlots = [];
      let endDelim;
      let exact;
      if (allowExact && this.match(tt.braceBarL)) {
        this.expect(tt.braceBarL);
        endDelim = tt.braceBarR;
        exact = true;
      } else {
        this.expect(tt.braceL);
        endDelim = tt.braceR;
        exact = false;
      }
      nodeStart.exact = exact;
      while (!this.match(endDelim)) {
        let isStatic = false;
        let protoStart: ?number = null;
        const node = this.startNode();
        if (allowProto && this.isContextual("proto")) {
          const lookahead = this.lookahead();
          if (lookahead.type !== tt.colon && lookahead.type !== tt.question) {
            this.next();
            protoStart = this.state.start;
            allowStatic = false;
          }
        }
        if (allowStatic && this.isContextual("static")) {
          const lookahead = this.lookahead();
          // static is a valid identifier name
          if (lookahead.type !== tt.colon && lookahead.type !== tt.question) {
            this.next();
            isStatic = true;
          }
        }
        const variance = this.flowParseVariance();
        if (this.eat(tt.bracketL)) {
          if (protoStart != null) {
            this.unexpected(protoStart);
          }
          if (this.eat(tt.bracketL)) {
            if (variance) {
              this.unexpected(variance.start);
            }
            nodeStart.internalSlots.push(
              this.flowParseObjectTypeInternalSlot(node, isStatic),
            );
          } else {
            nodeStart.indexers.push(
              this.flowParseObjectTypeIndexer(node, isStatic, variance),
            );
          }
        } else if (this.match(tt.parenL) || this.isRelational("<")) {
          if (protoStart != null) {
            this.unexpected(protoStart);
          }
          if (variance) {
            this.unexpected(variance.start);
          }
          nodeStart.callProperties.push(
            this.flowParseObjectTypeCallProperty(node, isStatic),
          );
        } else {
          let kind = "init";
          if (this.isContextual("get") || this.isContextual("set")) {
            const lookahead = this.lookahead();
            if (
              lookahead.type === tt.name ||
              lookahead.type === tt.string ||
              lookahead.type === tt.num
            ) {
              kind = this.state.value;
              this.next();
            }
          }
          nodeStart.properties.push(
            this.flowParseObjectTypeProperty(
              node,
              isStatic,
              protoStart,
              variance,
              kind,
              allowSpread,
            ),
          );
        }
        this.flowObjectTypeSemicolon();
      }
      this.expect(endDelim);
      const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
      this.state.inType = oldInType;
      return out;
    }
    flowParseObjectTypeProperty(
      node: N.FlowObjectTypeProperty | N.FlowObjectTypeSpreadProperty,
      isStatic: boolean,
      protoStart: ?number,
      variance: ?N.FlowVariance,
      kind: string,
      allowSpread: boolean,
    ): N.FlowObjectTypeProperty | N.FlowObjectTypeSpreadProperty {
      if (this.match(tt.ellipsis)) {
        if (!allowSpread) {
          this.unexpected(
            null,
            "Spread operator cannot appear in class or interface definitions",
          );
        }
        if (protoStart != null) {
          this.unexpected(protoStart);
        }
        if (variance) {
          this.unexpected(
            variance.start,
            "Spread properties cannot have variance",
          );
        }
        this.expect(tt.ellipsis);
        node.argument = this.flowParseType();
        return this.finishNode(node, "ObjectTypeSpreadProperty");
      } else {
        node.key = this.flowParseObjectPropertyKey();
        node.static = isStatic;
        node.proto = protoStart != null;
        node.kind = kind;
        let optional = false;
        if (this.isRelational("<") || this.match(tt.parenL)) {
          // This is a method property
          node.method = true;
          if (protoStart != null) {
            this.unexpected(protoStart);
          }
          if (variance) {
            this.unexpected(variance.start);
          }
          node.value = this.flowParseObjectTypeMethodish(
            this.startNodeAt(node.start, node.loc.start),
          );
          if (kind === "get" || kind === "set") {
            this.flowCheckGetterSetterParams(node);
          }
        } else {
          if (kind !== "init") this.unexpected();
          node.method = false;
          if (this.eat(tt.question)) {
            optional = true;
          }
          node.value = this.flowParseTypeInitialiser();
          node.variance = variance;
        }
        node.optional = optional;
        return this.finishNode(node, "ObjectTypeProperty");
      }
    }
    // This is similar to checkGetterSetterParams, but as
    // @babel/parser uses non estree properties we cannot reuse it here
    flowCheckGetterSetterParams(
      property: N.FlowObjectTypeProperty | N.FlowObjectTypeSpreadProperty,
    ): void {
      const paramCount = property.kind === "get" ? 0 : 1;
      const start = property.start;
      const length =
        property.value.params.length + (property.value.rest ? 1 : 0);
      if (length !== paramCount) {
        if (property.kind === "get") {
          this.raise(start, "getter must not have any formal parameters");
        } else {
          this.raise(start, "setter must have exactly one formal parameter");
        }
      }
      if (property.kind === "set" && property.value.rest) {
        this.raise(
          start,
          "setter function argument must not be a rest parameter",
        );
      }
    }
    flowObjectTypeSemicolon(): void {
      if (
        !this.eat(tt.semi) &&
        !this.eat(tt.comma) &&
        !this.match(tt.braceR) &&
        !this.match(tt.braceBarR)
      ) {
        this.unexpected();
      }
    }
    flowParseQualifiedTypeIdentifier(
      startPos?: number,
      startLoc?: Position,
      id?: N.Identifier,
    ): N.FlowQualifiedTypeIdentifier {
      startPos = startPos || this.state.start;
      startLoc = startLoc || this.state.startLoc;
      let node = id || this.parseIdentifier();
      while (this.eat(tt.dot)) {
        const node2 = this.startNodeAt(startPos, startLoc);
        node2.qualification = node;
        node2.id = this.parseIdentifier();
        node = this.finishNode(node2, "QualifiedTypeIdentifier");
      }
      return node;
    }
    flowParseGenericType(
      startPos: number,
      startLoc: Position,
      id: N.Identifier,
    ): N.FlowGenericTypeAnnotation {
      const node = this.startNodeAt(startPos, startLoc);
      node.typeParameters = null;
      node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);
      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterInstantiation();
      }
      return this.finishNode(node, "GenericTypeAnnotation");
    }
    flowParseTypeofType(): N.FlowTypeofTypeAnnotation {
      const node = this.startNode();
      this.expect(tt._typeof);
      node.argument = this.flowParsePrimaryType();
      return this.finishNode(node, "TypeofTypeAnnotation");
    }
    flowParseTupleType(): N.FlowTupleTypeAnnotation {
      const node = this.startNode();
      node.types = [];
      this.expect(tt.bracketL);
      // We allow trailing commas
      while (this.state.pos < this.input.length && !this.match(tt.bracketR)) {
        node.types.push(this.flowParseType());
        if (this.match(tt.bracketR)) break;
        this.expect(tt.comma);
      }
      this.expect(tt.bracketR);
      return this.finishNode(node, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(): N.FlowFunctionTypeParam {
      let name = null;
      let optional = false;
      let typeAnnotation = null;
      const node = this.startNode();
      const lh = this.lookahead();
      if (lh.type === tt.colon || lh.type === tt.question) {
        name = this.parseIdentifier();
        if (this.eat(tt.question)) {
          optional = true;
        }
        typeAnnotation = this.flowParseTypeInitialiser();
      } else {
        typeAnnotation = this.flowParseType();
      }
      node.name = name;
      node.optional = optional;
      node.typeAnnotation = typeAnnotation;
      return this.finishNode(node, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(
      type: N.FlowType,
    ): N.FlowFunctionTypeParam {
      const node = this.startNodeAt(type.start, type.loc.start);
      node.name = null;
      node.optional = false;
      node.typeAnnotation = type;
      return this.finishNode(node, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(
      params: N.FlowFunctionTypeParam[] = [],
    ): { params: N.FlowFunctionTypeParam[], rest: ?N.FlowFunctionTypeParam } {
      let rest: ?N.FlowFunctionTypeParam = null;
      while (!this.match(tt.parenR) && !this.match(tt.ellipsis)) {
        params.push(this.flowParseFunctionTypeParam());
        if (!this.match(tt.parenR)) {
          this.expect(tt.comma);
        }
      }
      if (this.eat(tt.ellipsis)) {
        rest = this.flowParseFunctionTypeParam();
      }
      return { params, rest };
    }
    flowIdentToTypeAnnotation(
      startPos: number,
      startLoc: Position,
      node: N.FlowTypeAnnotation,
      id: N.Identifier,
    ): N.FlowTypeAnnotation {
      switch (id.name) {
        case "any":
          return this.finishNode(node, "AnyTypeAnnotation");
        case "void":
          return this.finishNode(node, "VoidTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(node, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(node, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(node, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(node, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(node, "StringTypeAnnotation");
        default:
          return this.flowParseGenericType(startPos, startLoc, id);
      }
    }
    // The parsing of types roughly parallels the parsing of expressions, and
    // primary types are kind of like primary expressions...they're the
    // primitives with which other types are constructed.
    flowParsePrimaryType(): N.FlowTypeAnnotation {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      const node = this.startNode();
      let tmp;
      let type;
      let isGroupedType = false;
      const oldNoAnonFunctionType = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case tt.name:
          if (this.isContextual("interface")) {
            return this.flowParseInterfaceType();
          }
          return this.flowIdentToTypeAnnotation(
            startPos,
            startLoc,
            node,
            this.parseIdentifier(),
          );
        case tt.braceL:
          return this.flowParseObjectType(false, false, true, false);
        case tt.braceBarL:
          return this.flowParseObjectType(false, true, true, false);
        case tt.bracketL:
          return this.flowParseTupleType();
        case tt.relational:
          if (this.state.value === "<") {
            node.typeParameters = this.flowParseTypeParameterDeclaration(
              /* allowDefault */ false,
            );
            this.expect(tt.parenL);
            tmp = this.flowParseFunctionTypeParams();
            node.params = tmp.params;
            node.rest = tmp.rest;
            this.expect(tt.parenR);
            this.expect(tt.arrow);
            node.returnType = this.flowParseType();
            return this.finishNode(node, "FunctionTypeAnnotation");
          }
          break;
        case tt.parenL:
          this.next();
          // Check to see if this is actually a grouped type
          if (!this.match(tt.parenR) && !this.match(tt.ellipsis)) {
            if (this.match(tt.name)) {
              const token = this.lookahead().type;
              isGroupedType = token !== tt.question && token !== tt.colon;
            } else {
              isGroupedType = true;
            }
          }
          if (isGroupedType) {
            this.state.noAnonFunctionType = false;
            type = this.flowParseType();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
            // A `,` or a `) =>` means this is an anonymous function type
            if (
              this.state.noAnonFunctionType ||
              !(
                this.match(tt.comma) ||
                (this.match(tt.parenR) && this.lookahead().type === tt.arrow)
              )
            ) {
              this.expect(tt.parenR);
              return type;
            } else {
              // Eat a comma if there is one
              this.eat(tt.comma);
            }
          }
          if (type) {
            tmp = this.flowParseFunctionTypeParams([
              this.reinterpretTypeAsFunctionTypeParam(type),
            ]);
          } else {
            tmp = this.flowParseFunctionTypeParams();
          }
          node.params = tmp.params;
          node.rest = tmp.rest;
          this.expect(tt.parenR);
          this.expect(tt.arrow);
          node.returnType = this.flowParseType();
          node.typeParameters = null;
          return this.finishNode(node, "FunctionTypeAnnotation");
        case tt.string:
          return this.parseLiteral(
            this.state.value,
            "StringLiteralTypeAnnotation",
          );
        case tt._true:
        case tt._false:
          node.value = this.match(tt._true);
          this.next();
          return this.finishNode(node, "BooleanLiteralTypeAnnotation");
        case tt.plusMin:
          if (this.state.value === "-") {
            this.next();
            if (!this.match(tt.num)) {
              this.unexpected(null, `Unexpected token, expected "number"`);
            }
            return this.parseLiteral(
              -this.state.value,
              "NumberLiteralTypeAnnotation",
              node.start,
              node.loc.start,
            );
          }
          this.unexpected();
        case tt.num:
          return this.parseLiteral(
            this.state.value,
            "NumberLiteralTypeAnnotation",
          );
        case tt._null:
          this.next();
          return this.finishNode(node, "NullLiteralTypeAnnotation");
        case tt._this:
          this.next();
          return this.finishNode(node, "ThisTypeAnnotation");
        case tt.star:
          this.next();
          return this.finishNode(node, "ExistsTypeAnnotation");
        default:
          if (this.state.type.keyword === "typeof") {
            return this.flowParseTypeofType();
          }
      }
      throw this.unexpected();
    }
    flowParsePostfixType(): N.FlowTypeAnnotation {
      const startPos = this.state.start,
        startLoc = this.state.startLoc;
      let type = this.flowParsePrimaryType();
      while (!this.canInsertSemicolon() && this.match(tt.bracketL)) {
        const node = this.startNodeAt(startPos, startLoc);
        node.elementType = type;
        this.expect(tt.bracketL);
        this.expect(tt.bracketR);
        type = this.finishNode(node, "ArrayTypeAnnotation");
      }
      return type;
    }
    flowParsePrefixType(): N.FlowTypeAnnotation {
      const node = this.startNode();
      if (this.eat(tt.question)) {
        node.typeAnnotation = this.flowParsePrefixType();
        return this.finishNode(node, "NullableTypeAnnotation");
      } else {
        return this.flowParsePostfixType();
      }
    }
    flowParseAnonFunctionWithoutParens(): N.FlowTypeAnnotation {
      const param = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(tt.arrow)) {
        // TODO: This should be a type error. Passing in a SourceLocation, and it expects a Position.
        const node = this.startNodeAt(param.start, param.loc.start);
        node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
        node.rest = null;
        node.returnType = this.flowParseType();
        node.typeParameters = null;
        return this.finishNode(node, "FunctionTypeAnnotation");
      }
      return param;
    }
    flowParseIntersectionType(): N.FlowTypeAnnotation {
      const node = this.startNode();
      this.eat(tt.bitwiseAND);
      const type = this.flowParseAnonFunctionWithoutParens();
      node.types = [type];
      while (this.eat(tt.bitwiseAND)) {
        node.types.push(this.flowParseAnonFunctionWithoutParens());
      }
      return node.types.length === 1
        ? type
        : this.finishNode(node, "IntersectionTypeAnnotation");
    }
    flowParseUnionType(): N.FlowTypeAnnotation {
      const node = this.startNode();
      this.eat(tt.bitwiseOR);
      const type = this.flowParseIntersectionType();
      node.types = [type];
      while (this.eat(tt.bitwiseOR)) {
        node.types.push(this.flowParseIntersectionType());
      }
      return node.types.length === 1
        ? type
        : this.finishNode(node, "UnionTypeAnnotation");
    }
    flowParseType(): N.FlowTypeAnnotation {
      const oldInType = this.state.inType;
      this.state.inType = true;
      const type = this.flowParseUnionType();
      this.state.inType = oldInType;
      // Ensure that a brace after a function generic type annotation is a
      // statement, except in arrow functions (noAnonFunctionType)
      this.state.exprAllowed =
        this.state.exprAllowed || this.state.noAnonFunctionType;
      return type;
    }
    flowParseTypeAnnotation(): N.FlowTypeAnnotation {
      const node = this.startNode();
      node.typeAnnotation = this.flowParseTypeInitialiser();
      return this.finishNode(node, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(
      allowPrimitiveOverride?: boolean,
    ): N.Identifier {
      const ident = allowPrimitiveOverride
        ? this.parseIdentifier()
        : this.flowParseRestrictedIdentifier();
      if (this.match(tt.colon)) {
        ident.typeAnnotation = this.flowParseTypeAnnotation();
        this.finishNode(ident, ident.type);
      }
      return ident;
    }
    typeCastToParameter(node: N.Node): N.Node {
      node.expression.typeAnnotation = node.typeAnnotation;
      return this.finishNodeAt(
        node.expression,
        node.expression.type,
        node.typeAnnotation.end,
        node.typeAnnotation.loc.end,
      );
    }
    flowParseVariance(): ?N.FlowVariance {
      let variance = null;
      if (this.match(tt.plusMin)) {
        variance = this.startNode();
        if (this.state.value === "+") {
          variance.kind = "plus";
        } else {
          variance.kind = "minus";
        }
        this.next();
        this.finishNode(variance, "Variance");
      }
      return variance;
    }
    // ==================================
    // Overrides
    // ==================================
    parseFunctionBody(node: N.Function, allowExpressionBody: ?boolean): void {
      if (allowExpressionBody) {
        return this.forwardNoArrowParamsConversionAt(node, () =>
          super.parseFunctionBody(node, true),
        );
      }
      return super.parseFunctionBody(node, false);
    }
    parseFunctionBodyAndFinish(
      node: N.BodilessFunctionOrMethodBase,
      type: string,
      allowExpressionBody?: boolean,
    ): void {
      // For arrow functions, `parseArrow` handles the return type itself.
      if (!allowExpressionBody && this.match(tt.colon)) {
        const typeNode = this.startNode();
        [
          // $FlowFixMe (destructuring not supported yet)
          typeNode.typeAnnotation,
          // $FlowFixMe (destructuring not supported yet)
          node.predicate,
        ] = this.flowParseTypeAndPredicateInitialiser();
        node.returnType = typeNode.typeAnnotation
          ? this.finishNode(typeNode, "TypeAnnotation")
          : null;
      }
      super.parseFunctionBodyAndFinish(node, type, allowExpressionBody);
    }
    // interfaces
    parseStatement(declaration: boolean, topLevel?: boolean): N.Statement {
      // strict mode handling of `interface` since it's a reserved word
      if (
        this.state.strict &&
        this.match(tt.name) &&
        this.state.value === "interface"
      ) {
        const node = this.startNode();
        this.next();
        return this.flowParseInterface(node);
      } else {
        const stmt = super.parseStatement(declaration, topLevel);
        // We will parse a flow pragma in any comment before the first statement.
        if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {
          this.flowPragma = null;
        }
        return stmt;
      }
    }
    // declares, interfaces and type aliases
    parseExpressionStatement(
      node: N.ExpressionStatement,
      expr: N.Expression,
    ): N.ExpressionStatement {
      if (expr.type === "Identifier") {
        if (expr.name === "declare") {
          if (
            this.match(tt._class) ||
            this.match(tt.name) ||
            this.match(tt._function) ||
            this.match(tt._var) ||
            this.match(tt._export)
          ) {
            return this.flowParseDeclare(node);
          }
        } else if (this.match(tt.name)) {
          if (expr.name === "interface") {
            return this.flowParseInterface(node);
          } else if (expr.name === "type") {
            return this.flowParseTypeAlias(node);
          } else if (expr.name === "opaque") {
            return this.flowParseOpaqueType(node, false);
          }
        }
      }
      return super.parseExpressionStatement(node, expr);
    }
    // export type
    shouldParseExportDeclaration(): boolean {
      return (
        this.isContextual("type") ||
        this.isContextual("interface") ||
        this.isContextual("opaque") ||
        super.shouldParseExportDeclaration()
      );
    }
    isExportDefaultSpecifier(): boolean {
      if (
        this.match(tt.name) &&
        (this.state.value === "type" ||
          this.state.value === "interface" ||
          this.state.value == "opaque")
      ) {
        return false;
      }
      return super.isExportDefaultSpecifier();
    }
    parseConditional(
      expr: N.Expression,
      noIn: ?boolean,
      startPos: number,
      startLoc: Position,
      refNeedsArrowPos?: ?Pos,
    ): N.Expression {
      if (!this.match(tt.question)) return expr;
      // only do the expensive clone if there is a question mark
      // and if we come from inside parens
      if (refNeedsArrowPos) {
        const state = this.state.clone();
        try {
          return super.parseConditional(expr, noIn, startPos, startLoc);
        } catch (err) {
          if (err instanceof SyntaxError) {
            this.state = state;
            refNeedsArrowPos.start = err.pos || this.state.start;
            return expr;
          } else {
            // istanbul ignore next: no such error is expected
            throw err;
          }
        }
      }
      this.expect(tt.question);
      const state = this.state.clone();
      const originalNoArrowAt = this.state.noArrowAt;
      const node = this.startNodeAt(startPos, startLoc);
      let { consequent, failed } = this.tryParseConditionalConsequent();
      let [valid, invalid] = this.getArrowLikeExpressions(consequent);
      if (failed || invalid.length > 0) {
        const noArrowAt = [...originalNoArrowAt];
        if (invalid.length > 0) {
          this.state = state;
          this.state.noArrowAt = noArrowAt;
          for (let i = 0; i < invalid.length; i++) {
            noArrowAt.push(invalid[i].start);
          }
          ({ consequent, failed } = this.tryParseConditionalConsequent());
          [valid, invalid] = this.getArrowLikeExpressions(consequent);
        }
        if (failed && valid.length > 1) {
          // if there are two or more possible correct ways of parsing, throw an
          // error.
          // e.g.   Source: a ? (b): c => (d): e => f
          //      Result 1: a ? b : (c => ((d): e => f))
          //      Result 2: a ? ((b): c => d) : (e => f)
          this.raise(
            state.start,
            "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
          );
        }
        if (failed && valid.length === 1) {
          this.state = state;
          this.state.noArrowAt = noArrowAt.concat(valid[0].start);
          ({ consequent, failed } = this.tryParseConditionalConsequent());
        }
        this.getArrowLikeExpressions(consequent, true);
      }
      this.state.noArrowAt = originalNoArrowAt;
      this.expect(tt.colon);
      node.test = expr;
      node.consequent = consequent;
      node.alternate = this.forwardNoArrowParamsConversionAt(node, () =>
        this.parseMaybeAssign(noIn, undefined, undefined, undefined),
      );
      return this.finishNode(node, "ConditionalExpression");
    }
    tryParseConditionalConsequent(): {
      consequent: N.Expression,
      failed: boolean,
    } {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      const consequent = this.parseMaybeAssign();
      const failed = !this.match(tt.colon);
      this.state.noArrowParamsConversionAt.pop();
      return { consequent, failed };
    }
    // Given an expression, walks through out its arrow functions whose body is
    // an expression and through out conditional expressions. It returns every
    // function which has been parsed with a return type but could have been
    // parenthesized expressions.
    // These functions are separated into two arrays: one containing the ones
    // whose parameters can be converted to assignable lists, one containing the
    // others.
    getArrowLikeExpressions(
      node: N.Expression,
      disallowInvalid?: boolean,
    ): [N.ArrowFunctionExpression[], N.ArrowFunctionExpression[]] {
      const stack = [node];
      const arrows: N.ArrowFunctionExpression[] = [];
      while (stack.length !== 0) {
        const node = stack.pop();
        if (node.type === "ArrowFunctionExpression") {
          if (node.typeParameters || !node.returnType) {
            // This is an arrow expression without ambiguity, so check its parameters
            this.toAssignableList(
              // node.params is Expression[] instead of $ReadOnlyArray<Pattern> because it
              // has not been converted yet.
              ((node.params: any): N.Expression[]),
              true,
              "arrow function parameters",
            );
            // Use super's method to force the parameters to be checked
            super.checkFunctionNameAndParams(node, true);
          } else {
            arrows.push(node);
          }
          stack.push(node.body);
        } else if (node.type === "ConditionalExpression") {
          stack.push(node.consequent);
          stack.push(node.alternate);
        }
      }
      if (disallowInvalid) {
        for (let i = 0; i < arrows.length; i++) {
          this.toAssignableList(
            ((node.params: any): N.Expression[]),
            true,
            "arrow function parameters",
          );
        }
        return [arrows, []];
      }
      return partition(arrows, node => {
        try {
          this.toAssignableList(
            ((node.params: any): N.Expression[]),
            true,
            "arrow function parameters",
          );
          return true;
        } catch (err) {
          return false;
        }
      });
    }
    forwardNoArrowParamsConversionAt<T>(node: N.Node, parse: () => T): T {
      let result: T;
      if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
        this.state.noArrowParamsConversionAt.push(this.state.start);
        result = parse();
        this.state.noArrowParamsConversionAt.pop();
      } else {
        result = parse();
      }
      return result;
    }
    parseParenItem(
      node: N.Expression,
      startPos: number,
      startLoc: Position,
    ): N.Expression {
      node = super.parseParenItem(node, startPos, startLoc);
      if (this.eat(tt.question)) {
        node.optional = true;
      }
      if (this.match(tt.colon)) {
        const typeCastNode = this.startNodeAt(startPos, startLoc);
        typeCastNode.expression = node;
        typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
        return this.finishNode(typeCastNode, "TypeCastExpression");
      }
      return node;
    }
    assertModuleNodeAllowed(node: N.Node) {
      if (
        (node.type === "ImportDeclaration" &&
          (node.importKind === "type" || node.importKind === "typeof")) ||
        (node.type === "ExportNamedDeclaration" &&
          node.exportKind === "type") ||
        (node.type === "ExportAllDeclaration" && node.exportKind === "type")
      ) {
        // Allow Flowtype imports and exports in all conditions because
        // Flow itself does not care about 'sourceType'.
        return;
      }
      super.assertModuleNodeAllowed(node);
    }
    parseExport(node: N.ExportNamedDeclaration): N.ExportNamedDeclaration {
      node = super.parseExport(node);
      if (
        node.type === "ExportNamedDeclaration" ||
        node.type === "ExportAllDeclaration"
      ) {
        node.exportKind = node.exportKind || "value";
      }
      return node;
    }
    parseExportDeclaration(node: N.ExportNamedDeclaration): ?N.Declaration {
      if (this.isContextual("type")) {
        node.exportKind = "type";
        const declarationNode = this.startNode();
        this.next();
        if (this.match(tt.braceL)) {
          // export type { foo, bar };
          node.specifiers = this.parseExportSpecifiers();
          this.parseExportFrom(node);
          return null;
        } else {
          // export type Foo = Bar;
          return this.flowParseTypeAlias(declarationNode);
        }
      } else if (this.isContextual("opaque")) {
        node.exportKind = "type";
        const declarationNode = this.startNode();
        this.next();
        // export opaque type Foo = Bar;
        return this.flowParseOpaqueType(declarationNode, false);
      } else if (this.isContextual("interface")) {
        node.exportKind = "type";
        const declarationNode = this.startNode();
        this.next();
        return this.flowParseInterface(declarationNode);
      } else {
        return super.parseExportDeclaration(node);
      }
    }
    shouldParseExportStar(): boolean {
      return (
        super.shouldParseExportStar() ||
        (this.isContextual("type") && this.lookahead().type === tt.star)
      );
    }
    parseExportStar(node: N.ExportNamedDeclaration): void {
      if (this.eatContextual("type")) {
        node.exportKind = "type";
      }
      return super.parseExportStar(node);
    }
    parseExportNamespace(node: N.ExportNamedDeclaration) {
      if (node.exportKind === "type") {
        this.unexpected();
      }
      return super.parseExportNamespace(node);
    }
    parseClassId(node: N.Class, isStatement: boolean, optionalId: ?boolean) {
      super.parseClassId(node, isStatement, optionalId);
      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      }
    }
    // don't consider `void` to be a keyword as then it'll use the void token type
    // and set startExpr
    isKeyword(name: string): boolean {
      if (this.state.inType && name === "void") {
        return false;
      } else {
        return super.isKeyword(name);
      }
    }
    // ensure that inside flow types, we bypass the jsx parser plugin
    readToken(code: number): void {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (
        this.state.inType &&
        (code === charCodes.greaterThan || code === charCodes.lessThan)
      ) {
        return this.finishOp(tt.relational, 1);
      } else if (isIteratorStart(code, next)) {
        this.state.isIterator = true;
        return super.readWord();
      } else {
        return super.readToken(code);
      }
    }
    toAssignable(
      node: N.Node,
      isBinding: ?boolean,
      contextDescription: string,
    ): N.Node {
      if (node.type === "TypeCastExpression") {
        return super.toAssignable(
          this.typeCastToParameter(node),
          isBinding,
          contextDescription,
        );
      } else {
        return super.toAssignable(node, isBinding, contextDescription);
      }
    }
    // turn type casts that we found in function parameter head into type annotated params
    toAssignableList(
      exprList: N.Expression[],
      isBinding: ?boolean,
      contextDescription: string,
    ): $ReadOnlyArray<N.Pattern> {
      for (let i = 0; i < exprList.length; i++) {
        const expr = exprList[i];
        if (expr && expr.type === "TypeCastExpression") {
          exprList[i] = this.typeCastToParameter(expr);
        }
      }
      return super.toAssignableList(exprList, isBinding, contextDescription);
    }
    // this is a list of nodes, from something like a call expression, we need to filter the
    // type casts that we've found that are illegal in this context
    toReferencedList(
      exprList: $ReadOnlyArray<?N.Expression>,
    ): $ReadOnlyArray<?N.Expression> {
      for (let i = 0; i < exprList.length; i++) {
        const expr = exprList[i];
        if (expr && expr._exprListItem && expr.type === "TypeCastExpression") {
          this.raise(expr.start, "Unexpected type cast");
        }
      }
      return exprList;
    }
    // parse an item inside a expression list eg. `(NODE, NODE)` where NODE represents
    // the position where this function is called
    parseExprListItem(
      allowEmpty: ?boolean,
      refShorthandDefaultPos: ?Pos,
      refNeedsArrowPos: ?Pos,
    ): ?N.Expression {
      const container = this.startNode();
      const node = super.parseExprListItem(
        allowEmpty,
        refShorthandDefaultPos,
        refNeedsArrowPos,
      );
      if (this.match(tt.colon)) {
        container._exprListItem = true;
        container.expression = node;
        container.typeAnnotation = this.flowParseTypeAnnotation();
        return this.finishNode(container, "TypeCastExpression");
      } else {
        return node;
      }
    }
    checkLVal(
      expr: N.Expression,
      isBinding: ?boolean,
      checkClashes: ?{ [key: string]: boolean },
      contextDescription: string,
    ): void {
      if (expr.type !== "TypeCastExpression") {
        return super.checkLVal(
          expr,
          isBinding,
          checkClashes,
          contextDescription,
        );
      }
    }
    // parse class property type annotations
    parseClassProperty(node: N.ClassProperty): N.ClassProperty {
      if (this.match(tt.colon)) {
        node.typeAnnotation = this.flowParseTypeAnnotation();
      }
      return super.parseClassProperty(node);
    }
    parseClassPrivateProperty(
      node: N.ClassPrivateProperty,
    ): N.ClassPrivateProperty {
      if (this.match(tt.colon)) {
        node.typeAnnotation = this.flowParseTypeAnnotation();
      }
      return super.parseClassPrivateProperty(node);
    }
    // determine whether or not we're currently in the position where a class method would appear
    isClassMethod(): boolean {
      return this.isRelational("<") || super.isClassMethod();
    }
    // determine whether or not we're currently in the position where a class property would appear
    isClassProperty(): boolean {
      return this.match(tt.colon) || super.isClassProperty();
    }
    isNonstaticConstructor(method: N.ClassMethod | N.ClassProperty): boolean {
      return !this.match(tt.colon) && super.isNonstaticConstructor(method);
    }
    // parse type parameters for class methods
    pushClassMethod(
      classBody: N.ClassBody,
      method: N.ClassMethod,
      isGenerator: boolean,
      isAsync: boolean,
      isConstructor: boolean,
    ): void {
      if ((method: $FlowFixMe).variance) {
        this.unexpected((method: $FlowFixMe).variance.start);
      }
      delete (method: $FlowFixMe).variance;
      if (this.isRelational("<")) {
        method.typeParameters = this.flowParseTypeParameterDeclaration(
          /* allowDefault */ false,
        );
      }
      super.pushClassMethod(
        classBody,
        method,
        isGenerator,
        isAsync,
        isConstructor,
      );
    }
    pushClassPrivateMethod(
      classBody: N.ClassBody,
      method: N.ClassPrivateMethod,
      isGenerator: boolean,
      isAsync: boolean,
    ): void {
      if ((method: $FlowFixMe).variance) {
        this.unexpected((method: $FlowFixMe).variance.start);
      }
      delete (method: $FlowFixMe).variance;
      if (this.isRelational("<")) {
        method.typeParameters = this.flowParseTypeParameterDeclaration();
      }
      super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
    }
    // parse a the super class type parameters and implements
    parseClassSuper(node: N.Class): void {
      super.parseClassSuper(node);
      if (node.superClass && this.isRelational("<")) {
        node.superTypeParameters = this.flowParseTypeParameterInstantiation();
      }
      if (this.isContextual("implements")) {
        this.next();
        const implemented: N.FlowClassImplements[] = (node.implements = []);
        do {
          const node = this.startNode();
          node.id = this.flowParseRestrictedIdentifier(/*liberal*/ true);
          if (this.isRelational("<")) {
            node.typeParameters = this.flowParseTypeParameterInstantiation();
          } else {
            node.typeParameters = null;
          }
          implemented.push(this.finishNode(node, "ClassImplements"));
        } while (this.eat(tt.comma));
      }
    }
    parsePropertyName(
      node: N.ObjectOrClassMember | N.ClassMember | N.TsNamedTypeElementBase,
    ): N.Identifier {
      const variance = this.flowParseVariance();
      const key = super.parsePropertyName(node);
      // $FlowIgnore ("variance" not defined on TsNamedTypeElementBase)
      node.variance = variance;
      return key;
    }
    // parse type parameters for object method shorthand
    parseObjPropValue(
      prop: N.ObjectMember,
      startPos: ?number,
      startLoc: ?Position,
      isGenerator: boolean,
      isAsync: boolean,
      isPattern: boolean,
      refShorthandDefaultPos: ?Pos,
      containsEsc: boolean,
    ): void {
      if ((prop: $FlowFixMe).variance) {
        this.unexpected((prop: $FlowFixMe).variance.start);
      }
      delete (prop: $FlowFixMe).variance;
      let typeParameters;
      // method shorthand
      if (this.isRelational("<")) {
        typeParameters = this.flowParseTypeParameterDeclaration(
          /* allowDefault */ false,
        );
        if (!this.match(tt.parenL)) this.unexpected();
      }
      super.parseObjPropValue(
        prop,
        startPos,
        startLoc,
        isGenerator,
        isAsync,
        isPattern,
        refShorthandDefaultPos,
        containsEsc,
      );
      // add typeParameters if we found them
      if (typeParameters) {
        (prop.value || prop).typeParameters = typeParameters;
      }
    }
    parseAssignableListItemTypes(param: N.Pattern): N.Pattern {
      if (this.eat(tt.question)) {
        if (param.type !== "Identifier") {
          throw this.raise(
            param.start,
            "A binding pattern parameter cannot be optional in an implementation signature.",
          );
        }
        param.optional = true;
      }
      if (this.match(tt.colon)) {
        param.typeAnnotation = this.flowParseTypeAnnotation();
      }
      this.finishNode(param, param.type);
      return param;
    }
    parseMaybeDefault(
      startPos?: ?number,
      startLoc?: ?Position,
      left?: ?N.Pattern,
    ): N.Pattern {
      const node = super.parseMaybeDefault(startPos, startLoc, left);
      if (
        node.type === "AssignmentPattern" &&
        node.typeAnnotation &&
        node.right.start < node.typeAnnotation.start
      ) {
        this.raise(
          node.typeAnnotation.start,
          "Type annotations must come before default assignments, " +
            "e.g. instead of `age = 25: number` use `age: number = 25`",
        );
      }
      return node;
    }
    shouldParseDefaultImport(node: N.ImportDeclaration): boolean {
      if (!hasTypeImportKind(node)) {
        return super.shouldParseDefaultImport(node);
      }
      return isMaybeDefaultImport(this.state);
    }
    parseImportSpecifierLocal(
      node: N.ImportDeclaration,
      specifier: N.Node,
      type: string,
      contextDescription: string,
    ): void {
      specifier.local = hasTypeImportKind(node)
        ? this.flowParseRestrictedIdentifier(true)
        : this.parseIdentifier();
      this.checkLVal(specifier.local, true, undefined, contextDescription);
      node.specifiers.push(this.finishNode(specifier, type));
    }
    // parse typeof and type imports
    parseImportSpecifiers(node: N.ImportDeclaration): void {
      node.importKind = "value";
      let kind = null;
      if (this.match(tt._typeof)) {
        kind = "typeof";
      } else if (this.isContextual("type")) {
        kind = "type";
      }
      if (kind) {
        const lh = this.lookahead();
        // import type * is not allowed
        if (kind === "type" && lh.type === tt.star) {
          this.unexpected(lh.start);
        }
        if (
          isMaybeDefaultImport(lh) ||
          lh.type === tt.braceL ||
          lh.type === tt.star
        ) {
          this.next();
          node.importKind = kind;
        }
      }
      super.parseImportSpecifiers(node);
    }
    // parse import-type/typeof shorthand
    parseImportSpecifier(node: N.ImportDeclaration): void {
      const specifier = this.startNode();
      const firstIdentLoc = this.state.start;
      const firstIdent = this.parseIdentifier(true);
      let specifierTypeKind = null;
      if (firstIdent.name === "type") {
        specifierTypeKind = "type";
      } else if (firstIdent.name === "typeof") {
        specifierTypeKind = "typeof";
      }
      let isBinding = false;
      if (this.isContextual("as") && !this.isLookaheadContextual("as")) {
        const as_ident = this.parseIdentifier(true);
        if (
          specifierTypeKind !== null &&
          !this.match(tt.name) &&
          !this.state.type.keyword
        ) {
          // `import {type as ,` or `import {type as }`
          specifier.imported = as_ident;
          specifier.importKind = specifierTypeKind;
          specifier.local = as_ident.__clone();
        } else {
          // `import {type as foo`
          specifier.imported = firstIdent;
          specifier.importKind = null;
          specifier.local = this.parseIdentifier();
        }
      } else if (
        specifierTypeKind !== null &&
        (this.match(tt.name) || this.state.type.keyword)
      ) {
        // `import {type foo`
        specifier.imported = this.parseIdentifier(true);
        specifier.importKind = specifierTypeKind;
        if (this.eatContextual("as")) {
          specifier.local = this.parseIdentifier();
        } else {
          isBinding = true;
          specifier.local = specifier.imported.__clone();
        }
      } else {
        isBinding = true;
        specifier.imported = firstIdent;
        specifier.importKind = null;
        specifier.local = specifier.imported.__clone();
      }
      const nodeIsTypeImport = hasTypeImportKind(node);
      const specifierIsTypeImport = hasTypeImportKind(specifier);
      if (nodeIsTypeImport && specifierIsTypeImport) {
        this.raise(
          firstIdentLoc,
          "The `type` and `typeof` keywords on named imports can only be used on regular " +
            "`import` statements. It cannot be used with `import type` or `import typeof` statements",
        );
      }
      if (nodeIsTypeImport || specifierIsTypeImport) {
        this.checkReservedType(specifier.local.name, specifier.local.start);
      }
      if (isBinding && !nodeIsTypeImport && !specifierIsTypeImport) {
        this.checkReservedWord(
          specifier.local.name,
          specifier.start,
          true,
          true,
        );
      }
      this.checkLVal(specifier.local, true, undefined, "import specifier");
      node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
    }
    // parse function type parameters - function foo<T>() {}
    parseFunctionParams(node: N.Function): void {
      // $FlowFixMe
      const kind = node.kind;
      if (kind !== "get" && kind !== "set" && this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterDeclaration(
          /* allowDefault */ false,
        );
      }
      super.parseFunctionParams(node);
    }
    // parse flow type annotations on variable declarator heads - let foo: string = bar
    parseVarHead(decl: N.VariableDeclarator): void {
      super.parseVarHead(decl);
      if (this.match(tt.colon)) {
        decl.id.typeAnnotation = this.flowParseTypeAnnotation();
        this.finishNode(decl.id, decl.id.type);
      }
    }
    // parse the return type of an async arrow function - let foo = (async (): number => {});
    parseAsyncArrowFromCallExpression(
      node: N.ArrowFunctionExpression,
      call: N.CallExpression,
    ): N.ArrowFunctionExpression {
      if (this.match(tt.colon)) {
        const oldNoAnonFunctionType = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = true;
        node.returnType = this.flowParseTypeAnnotation();
        this.state.noAnonFunctionType = oldNoAnonFunctionType;
      }
      return super.parseAsyncArrowFromCallExpression(node, call);
    }
    // todo description
    shouldParseAsyncArrow(): boolean {
      return this.match(tt.colon) || super.shouldParseAsyncArrow();
    }
    // We need to support type parameter declarations for arrow functions. This
    // is tricky. There are three situations we need to handle
    //
    // 1. This is either JSX or an arrow function. We'll try JSX first. If that
    //    fails, we'll try an arrow function. If that fails, we'll throw the JSX
    //    error.
    // 2. This is an arrow function. We'll parse the type parameter declaration,
    //    parse the rest, make sure the rest is an arrow function, and go from
    //    there
    // 3. This is neither. Just call the super method
    parseMaybeAssign(
      noIn?: ?boolean,
      refShorthandDefaultPos?: ?Pos,
      afterLeftParse?: Function,
      refNeedsArrowPos?: ?Pos,
    ): N.Expression {
      let jsxError = null;
      if (tt.jsxTagStart && this.match(tt.jsxTagStart)) {
        const state = this.state.clone();
        try {
          return super.parseMaybeAssign(
            noIn,
            refShorthandDefaultPos,
            afterLeftParse,
            refNeedsArrowPos,
          );
        } catch (err) {
          if (err instanceof SyntaxError) {
            this.state = state;
            // Remove `tc.j_expr` and `tc.j_oTag` from context added
            // by parsing `jsxTagStart` to stop the JSX plugin from
            // messing with the tokens
            this.state.context.length -= 2;
            jsxError = err;
          } else {
            // istanbul ignore next: no such error is expected
            throw err;
          }
        }
      }
      if (jsxError != null || this.isRelational("<")) {
        let arrowExpression;
        let typeParameters;
        try {
          typeParameters = this.flowParseTypeParameterDeclaration();
          arrowExpression = this.forwardNoArrowParamsConversionAt(
            typeParameters,
            () =>
              super.parseMaybeAssign(
                noIn,
                refShorthandDefaultPos,
                afterLeftParse,
                refNeedsArrowPos,
              ),
          );
          arrowExpression.typeParameters = typeParameters;
          this.resetStartLocationFromNode(arrowExpression, typeParameters);
        } catch (err) {
          throw jsxError || err;
        }
        if (arrowExpression.type === "ArrowFunctionExpression") {
          return arrowExpression;
        } else if (jsxError != null) {
          throw jsxError;
        } else {
          this.raise(
            typeParameters.start,
            "Expected an arrow function after this type parameter declaration",
          );
        }
      }
      return super.parseMaybeAssign(
        noIn,
        refShorthandDefaultPos,
        afterLeftParse,
        refNeedsArrowPos,
      );
    }
    // handle return types for arrow functions
    parseArrow(node: N.ArrowFunctionExpression): ?N.ArrowFunctionExpression {
      if (this.match(tt.colon)) {
        const state = this.state.clone();
        try {
          const oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = true;
          const typeNode = this.startNode();
          [
            // $FlowFixMe (destructuring not supported yet)
            typeNode.typeAnnotation,
            // $FlowFixMe (destructuring not supported yet)
            node.predicate,
          ] = this.flowParseTypeAndPredicateInitialiser();
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
          if (this.canInsertSemicolon()) this.unexpected();
          if (!this.match(tt.arrow)) this.unexpected();
          // assign after it is clear it is an arrow
          node.returnType = typeNode.typeAnnotation
            ? this.finishNode(typeNode, "TypeAnnotation")
            : null;
        } catch (err) {
          if (err instanceof SyntaxError) {
            this.state = state;
          } else {
            // istanbul ignore next: no such error is expected
            throw err;
          }
        }
      }
      return super.parseArrow(node);
    }
    shouldParseArrow(): boolean {
      return this.match(tt.colon) || super.shouldParseArrow();
    }
    setArrowFunctionParameters(
      node: N.ArrowFunctionExpression,
      params: N.Expression[],
    ): void {
      if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
        node.params = params;
      } else {
        super.setArrowFunctionParameters(node, params);
      }
    }
    checkFunctionNameAndParams(
      node: N.Function,
      isArrowFunction: ?boolean,
    ): void {
      if (
        isArrowFunction &&
        this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1
      ) {
        return;
      }
      return super.checkFunctionNameAndParams(node, isArrowFunction);
    }
    parseParenAndDistinguishExpression(canBeArrow: boolean): N.Expression {
      return super.parseParenAndDistinguishExpression(
        canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1,
      );
    }
    parseSubscripts(
      base: N.Expression,
      startPos: number,
      startLoc: Position,
      noCalls?: ?boolean,
    ): N.Expression {
      if (
        base.type === "Identifier" &&
        base.name === "async" &&
        this.state.noArrowAt.indexOf(startPos) !== -1
      ) {
        this.next();
        const node = this.startNodeAt(startPos, startLoc);
        node.callee = base;
        node.arguments = this.parseCallExpressionArguments(tt.parenR, false);
        base = this.finishNode(node, "CallExpression");
      } else if (
        base.type === "Identifier" &&
        base.name === "async" &&
        this.isRelational("<")
      ) {
        const state = this.state.clone();
        let error;
        try {
          const node = this.parseAsyncArrowWithTypeParameters(
            startPos,
            startLoc,
          );
          if (node) return node;
        } catch (e) {
          error = e;
        }
        this.state = state;
        try {
          return super.parseSubscripts(base, startPos, startLoc, noCalls);
        } catch (e) {
          throw error || e;
        }
      }
      return super.parseSubscripts(base, startPos, startLoc, noCalls);
    }
    parseSubscript(
      base: N.Expression,
      startPos: number,
      startLoc: Position,
      noCalls: ?boolean,
      subscriptState: N.ParseSubscriptState,
    ): N.Expression {
      if (this.match(tt.questionDot) && this.isLookaheadRelational("<")) {
        this.expectPlugin("optionalChaining");
        subscriptState.optionalChainMember = true;
        if (noCalls) {
          subscriptState.stop = true;
          return base;
        }
        this.next();
        const node: N.OptionalCallExpression = this.startNodeAt(
          startPos,
          startLoc,
        );
        node.callee = base;
        node.typeArguments = this.flowParseTypeParameterInstantiation();
        this.expect(tt.parenL);
        // $FlowFixMe
        node.arguments = this.parseCallExpressionArguments(tt.parenR, false);
        node.optional = true;
        return this.finishNode(node, "OptionalCallExpression");
      } else if (
        !noCalls &&
        this.shouldParseTypes() &&
        this.isRelational("<")
      ) {
        const node = this.startNodeAt(startPos, startLoc);
        node.callee = base;
        const state = this.state.clone();
        try {
          node.typeArguments = this.flowParseTypeParameterInstantiation();
          this.expect(tt.parenL);
          node.arguments = this.parseCallExpressionArguments(tt.parenR, false);
          if (subscriptState.optionalChainMember) {
            node.optional = false;
            return this.finishNode(node, "OptionalCallExpression");
          }
          return this.finishNode(node, "CallExpression");
        } catch (e) {
          if (e instanceof SyntaxError) {
            this.state = state;
          } else {
            throw e;
          }
        }
      }
      return super.parseSubscript(
        base,
        startPos,
        startLoc,
        noCalls,
        subscriptState,
      );
    }
    parseNewArguments(node: N.NewExpression): void {
      let targs = null;
      if (this.shouldParseTypes() && this.isRelational("<")) {
        const state = this.state.clone();
        try {
          targs = this.flowParseTypeParameterInstantiation();
        } catch (e) {
          if (e instanceof SyntaxError) {
            this.state = state;
          } else {
            throw e;
          }
        }
      }
      node.typeArguments = targs;
      super.parseNewArguments(node);
    }
    parseAsyncArrowWithTypeParameters(
      startPos: number,
      startLoc: Position,
    ): ?N.ArrowFunctionExpression {
      const node = this.startNodeAt(startPos, startLoc);
      this.parseFunctionParams(node);
      if (!this.parseArrow(node)) return;
      return this.parseArrowExpression(
        node,
        /* params */ undefined,
        /* isAsync */ true,
      );
    }
    readToken_mult_modulo(code: number): void {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (
        code === charCodes.asterisk &&
        next === charCodes.slash &&
        this.state.hasFlowComment
      ) {
        this.state.hasFlowComment = false;
        this.state.pos += 2;
        this.nextToken();
        return;
      }
      super.readToken_mult_modulo(code);
    }
    skipBlockComment(): void {
      if (
        this.hasPlugin("flow") &&
        this.hasPlugin("flowComments") &&
        this.skipFlowComment()
      ) {
        this.hasFlowCommentCompletion();
        this.state.pos += this.skipFlowComment();
        this.state.hasFlowComment = true;
        return;
      }
      let end;
      if (this.hasPlugin("flow") && this.state.hasFlowComment) {
        end = this.input.indexOf("*-/", (this.state.pos += 2));
        if (end === -1) this.raise(this.state.pos - 2, "Unterminated comment");
        this.state.pos = end + 3;
        return;
      }
      super.skipBlockComment();
    }
    skipFlowComment(): number | boolean {
      const ch2 = this.input.charCodeAt(this.state.pos + 2);
      const ch3 = this.input.charCodeAt(this.state.pos + 3);
      if (ch2 === charCodes.colon && ch3 === charCodes.colon) {
        return 4; // check for /*::
      }
      if (this.input.slice(this.state.pos + 2, 14) === "flow-include") {
        return 14; // check for /*flow-include
      }
      if (ch2 === charCodes.colon && ch3 !== charCodes.colon) {
        return 2; // check for /*:, advance only 2 steps
      }
      return false;
    }
    hasFlowCommentCompletion(): void {
      const end = this.input.indexOf("*/", this.state.pos);
      if (end === -1) {
        this.raise(this.state.pos, "Unterminated comment");
      }
    }
  };

// </from> /home/qfox/apps/babel/packages/babel-parser/src/plugins/flow.js

// <from> /home/qfox/apps/babel/packages/babel-parser/src/plugins/jsx/index.js

// @flow
import * as charCodes from "charcodes";
import XHTMLEntities from "./xhtml";
import { TokenType, types as tt } from "../../tokenizer/types";
import { TokContext, types as tc } from "../../tokenizer/context";
import * as N from "../../types";
import { isIdentifierChar, isIdentifierStart } from "../../util/identifier";
import { isNewLine } from "../../util/whitespace";
const HEX_NUMBER = /^[\da-fA-F]+$/;
const DECIMAL_NUMBER = /^\d+$/;
tc.j_oTag = new TokContext("<tag", false);
tc.j_cTag = new TokContext("</tag", false);
tc.j_expr = new TokContext("<tag>...</tag>", true, true);
tt.jsxName = new TokenType("jsxName");
tt.jsxText = new TokenType("jsxText", { beforeExpr: true });
tt.jsxTagStart = new TokenType("jsxTagStart", { startsExpr: true });
tt.jsxTagEnd = new TokenType("jsxTagEnd");
tt.jsxTagStart.updateContext = function() {
  this.state.context.push(tc.j_expr); // treat as beginning of JSX expression
  this.state.context.push(tc.j_oTag); // start opening tag context
  this.state.exprAllowed = false;
};
tt.jsxTagEnd.updateContext = function(prevType) {
  const out = this.state.context.pop();
  if ((out === tc.j_oTag && prevType === tt.slash) || out === tc.j_cTag) {
    this.state.context.pop();
    this.state.exprAllowed = this.curContext() === tc.j_expr;
  } else {
    this.state.exprAllowed = true;
  }
};
function isFragment(object: ?N.JSXElement): boolean {
  return object
    ? object.type === "JSXOpeningFragment" ||
        object.type === "JSXClosingFragment"
    : false;
}
// Transforms JSX element name to string.
function getQualifiedJSXName(
  object: N.JSXIdentifier | N.JSXNamespacedName | N.JSXMemberExpression,
): string {
  if (object.type === "JSXIdentifier") {
    return object.name;
  }
  if (object.type === "JSXNamespacedName") {
    return object.namespace.name + ":" + object.name.name;
  }
  if (object.type === "JSXMemberExpression") {
    return (
      getQualifiedJSXName(object.object) +
      "." +
      getQualifiedJSXName(object.property)
    );
  }
  // istanbul ignore next
  throw new Error("Node had unexpected type: " + object.type);
}
export default (superClass: Class<Parser>): Class<Parser> =>
  class extends superClass {
    // Reads inline JSX contents token.
    jsxReadToken(): void {
      let out = "";
      let chunkStart = this.state.pos;
      for (;;) {
        if (this.state.pos >= this.input.length) {
          this.raise(this.state.start, "Unterminated JSX contents");
        }
        const ch = this.input.charCodeAt(this.state.pos);
        switch (ch) {
          case charCodes.lessThan:
          case charCodes.leftCurlyBrace:
            if (this.state.pos === this.state.start) {
              if (ch === charCodes.lessThan && this.state.exprAllowed) {
                ++this.state.pos;
                return this.finishToken(tt.jsxTagStart);
              }
              return this.getTokenFromCode(ch);
            }
            out += this.input.slice(chunkStart, this.state.pos);
            return this.finishToken(tt.jsxText, out);
          case charCodes.ampersand:
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadEntity();
            chunkStart = this.state.pos;
            break;
          default:
            if (isNewLine(ch)) {
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadNewLine(true);
              chunkStart = this.state.pos;
            } else {
              ++this.state.pos;
            }
        }
      }
    }
    jsxReadNewLine(normalizeCRLF: boolean): string {
      const ch = this.input.charCodeAt(this.state.pos);
      let out;
      ++this.state.pos;
      if (
        ch === charCodes.carriageReturn &&
        this.input.charCodeAt(this.state.pos) === charCodes.lineFeed
      ) {
        ++this.state.pos;
        out = normalizeCRLF ? "\n" : "\r\n";
      } else {
        out = String.fromCharCode(ch);
      }
      ++this.state.curLine;
      this.state.lineStart = this.state.pos;
      return out;
    }
    jsxReadString(quote: number): void {
      let out = "";
      let chunkStart = ++this.state.pos;
      for (;;) {
        if (this.state.pos >= this.input.length) {
          this.raise(this.state.start, "Unterminated string constant");
        }
        const ch = this.input.charCodeAt(this.state.pos);
        if (ch === quote) break;
        if (ch === charCodes.ampersand) {
          out += this.input.slice(chunkStart, this.state.pos);
          out += this.jsxReadEntity();
          chunkStart = this.state.pos;
        } else if (isNewLine(ch)) {
          out += this.input.slice(chunkStart, this.state.pos);
          out += this.jsxReadNewLine(false);
          chunkStart = this.state.pos;
        } else {
          ++this.state.pos;
        }
      }
      out += this.input.slice(chunkStart, this.state.pos++);
      return this.finishToken(tt.string, out);
    }
    jsxReadEntity(): string {
      let str = "";
      let count = 0;
      let entity;
      let ch = this.input[this.state.pos];
      const startPos = ++this.state.pos;
      while (this.state.pos < this.input.length && count++ < 10) {
        ch = this.input[this.state.pos++];
        if (ch === ";") {
          if (str[0] === "#") {
            if (str[1] === "x") {
              str = str.substr(2);
              if (HEX_NUMBER.test(str)) {
                entity = String.fromCodePoint(parseInt(str, 16));
              }
            } else {
              str = str.substr(1);
              if (DECIMAL_NUMBER.test(str)) {
                entity = String.fromCodePoint(parseInt(str, 10));
              }
            }
          } else {
            entity = XHTMLEntities[str];
          }
          break;
        }
        str += ch;
      }
      if (!entity) {
        this.state.pos = startPos;
        return "&";
      }
      return entity;
    }
    // Read a JSX identifier (valid tag or attribute name).
    //
    // Optimized version since JSX identifiers can"t contain
    // escape characters and so can be read as single slice.
    // Also assumes that first character was already checked
    // by isIdentifierStart in readToken.
    jsxReadWord(): void {
      let ch;
      const start = this.state.pos;
      do {
        ch = this.input.charCodeAt(++this.state.pos);
      } while (isIdentifierChar(ch) || ch === charCodes.dash);
      return this.finishToken(
        tt.jsxName,
        this.input.slice(start, this.state.pos),
      );
    }
    // Parse next token as JSX identifier
    jsxParseIdentifier(): N.JSXIdentifier {
      const node = this.startNode();
      if (this.match(tt.jsxName)) {
        node.name = this.state.value;
      } else if (this.state.type.keyword) {
        node.name = this.state.type.keyword;
      } else {
        this.unexpected();
      }
      this.next();
      return this.finishNode(node, "JSXIdentifier");
    }
    // Parse namespaced identifier.
    jsxParseNamespacedName(): N.JSXNamespacedName {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      const name = this.jsxParseIdentifier();
      if (!this.eat(tt.colon)) return name;
      const node = this.startNodeAt(startPos, startLoc);
      node.namespace = name;
      node.name = this.jsxParseIdentifier();
      return this.finishNode(node, "JSXNamespacedName");
    }
    // Parses element name in any form - namespaced, member
    // or single identifier.
    jsxParseElementName(): N.JSXNamespacedName | N.JSXMemberExpression {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      let node = this.jsxParseNamespacedName();
      while (this.eat(tt.dot)) {
        const newNode = this.startNodeAt(startPos, startLoc);
        newNode.object = node;
        newNode.property = this.jsxParseIdentifier();
        node = this.finishNode(newNode, "JSXMemberExpression");
      }
      return node;
    }
    // Parses any type of JSX attribute value.
    jsxParseAttributeValue(): N.Expression {
      let node;
      switch (this.state.type) {
        case tt.braceL:
          node = this.jsxParseExpressionContainer();
          if (node.expression.type === "JSXEmptyExpression") {
            throw this.raise(
              node.start,
              "JSX attributes must only be assigned a non-empty expression",
            );
          } else {
            return node;
          }
        case tt.jsxTagStart:
        case tt.string:
          return this.parseExprAtom();
        default:
          throw this.raise(
            this.state.start,
            "JSX value should be either an expression or a quoted JSX text",
          );
      }
    }
    // JSXEmptyExpression is unique type since it doesn't actually parse anything,
    // and so it should start at the end of last read token (left brace) and finish
    // at the beginning of the next one (right brace).
    jsxParseEmptyExpression(): N.JSXEmptyExpression {
      const node = this.startNodeAt(
        this.state.lastTokEnd,
        this.state.lastTokEndLoc,
      );
      return this.finishNodeAt(
        node,
        "JSXEmptyExpression",
        this.state.start,
        this.state.startLoc,
      );
    }
    // Parse JSX spread child
    jsxParseSpreadChild(): N.JSXSpreadChild {
      const node = this.startNode();
      this.expect(tt.braceL);
      this.expect(tt.ellipsis);
      node.expression = this.parseExpression();
      this.expect(tt.braceR);
      return this.finishNode(node, "JSXSpreadChild");
    }
    // Parses JSX expression enclosed into curly brackets.
    jsxParseExpressionContainer(): N.JSXExpressionContainer {
      const node = this.startNode();
      this.next();
      if (this.match(tt.braceR)) {
        node.expression = this.jsxParseEmptyExpression();
      } else {
        node.expression = this.parseExpression();
      }
      this.expect(tt.braceR);
      return this.finishNode(node, "JSXExpressionContainer");
    }
    // Parses following JSX attribute name-value pair.
    jsxParseAttribute(): N.JSXAttribute {
      const node = this.startNode();
      if (this.eat(tt.braceL)) {
        this.expect(tt.ellipsis);
        node.argument = this.parseMaybeAssign();
        this.expect(tt.braceR);
        return this.finishNode(node, "JSXSpreadAttribute");
      }
      node.name = this.jsxParseNamespacedName();
      node.value = this.eat(tt.eq) ? this.jsxParseAttributeValue() : null;
      return this.finishNode(node, "JSXAttribute");
    }
    // Parses JSX opening tag starting after "<".
    jsxParseOpeningElementAt(
      startPos: number,
      startLoc: Position,
    ): N.JSXOpeningElement {
      const node = this.startNodeAt(startPos, startLoc);
      if (this.match(tt.jsxTagEnd)) {
        this.expect(tt.jsxTagEnd);
        return this.finishNode(node, "JSXOpeningFragment");
      }
      node.name = this.jsxParseElementName();
      return this.jsxParseOpeningElementAfterName(node);
    }
    jsxParseOpeningElementAfterName(
      node: N.JSXOpeningElement,
    ): N.JSXOpeningElement {
      const attributes: N.JSXAttribute[] = [];
      while (!this.match(tt.slash) && !this.match(tt.jsxTagEnd)) {
        attributes.push(this.jsxParseAttribute());
      }
      node.attributes = attributes;
      node.selfClosing = this.eat(tt.slash);
      this.expect(tt.jsxTagEnd);
      return this.finishNode(node, "JSXOpeningElement");
    }
    // Parses JSX closing tag starting after "</".
    jsxParseClosingElementAt(
      startPos: number,
      startLoc: Position,
    ): N.JSXClosingElement {
      const node = this.startNodeAt(startPos, startLoc);
      if (this.match(tt.jsxTagEnd)) {
        this.expect(tt.jsxTagEnd);
        return this.finishNode(node, "JSXClosingFragment");
      }
      node.name = this.jsxParseElementName();
      this.expect(tt.jsxTagEnd);
      return this.finishNode(node, "JSXClosingElement");
    }
    // Parses entire JSX element, including it"s opening tag
    // (starting after "<"), attributes, contents and closing tag.
    jsxParseElementAt(startPos: number, startLoc: Position): N.JSXElement {
      const node = this.startNodeAt(startPos, startLoc);
      const children = [];
      const openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);
      let closingElement = null;
      if (!openingElement.selfClosing) {
        contents: for (;;) {
          switch (this.state.type) {
            case tt.jsxTagStart:
              startPos = this.state.start;
              startLoc = this.state.startLoc;
              this.next();
              if (this.eat(tt.slash)) {
                closingElement = this.jsxParseClosingElementAt(
                  startPos,
                  startLoc,
                );
                break contents;
              }
              children.push(this.jsxParseElementAt(startPos, startLoc));
              break;
            case tt.jsxText:
              children.push(this.parseExprAtom());
              break;
            case tt.braceL:
              if (this.lookahead().type === tt.ellipsis) {
                children.push(this.jsxParseSpreadChild());
              } else {
                children.push(this.jsxParseExpressionContainer());
              }
              break;
            // istanbul ignore next - should never happen
            default:
              throw this.unexpected();
          }
        }
        if (isFragment(openingElement) && !isFragment(closingElement)) {
          this.raise(
            // $FlowIgnore
            closingElement.start,
            "Expected corresponding JSX closing tag for <>",
          );
        } else if (!isFragment(openingElement) && isFragment(closingElement)) {
          this.raise(
            // $FlowIgnore
            closingElement.start,
            "Expected corresponding JSX closing tag for <" +
              getQualifiedJSXName(openingElement.name) +
              ">",
          );
        } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
          if (
            // $FlowIgnore
            getQualifiedJSXName(closingElement.name) !==
            getQualifiedJSXName(openingElement.name)
          ) {
            this.raise(
              // $FlowIgnore
              closingElement.start,
              "Expected corresponding JSX closing tag for <" +
                getQualifiedJSXName(openingElement.name) +
                ">",
            );
          }
        }
      }
      if (isFragment(openingElement)) {
        node.openingFragment = openingElement;
        node.closingFragment = closingElement;
      } else {
        node.openingElement = openingElement;
        node.closingElement = closingElement;
      }
      node.children = children;
      if (this.match(tt.relational) && this.state.value === "<") {
        this.raise(
          this.state.start,
          "Adjacent JSX elements must be wrapped in an enclosing tag. " +
            "Did you want a JSX fragment <>...</>?",
        );
      }
      return isFragment(openingElement)
        ? this.finishNode(node, "JSXFragment")
        : this.finishNode(node, "JSXElement");
    }
    // Parses entire JSX element from current position.
    jsxParseElement(): N.JSXElement {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      this.next();
      return this.jsxParseElementAt(startPos, startLoc);
    }
    // ==================================
    // Overrides
    // ==================================
    parseExprAtom(refShortHandDefaultPos: ?Pos): N.Expression {
      if (this.match(tt.jsxText)) {
        return this.parseLiteral(this.state.value, "JSXText");
      } else if (this.match(tt.jsxTagStart)) {
        return this.jsxParseElement();
      } else {
        return super.parseExprAtom(refShortHandDefaultPos);
      }
    }
    readToken(code: number): void {
      if (this.state.inPropertyName) return super.readToken(code);
      const context = this.curContext();
      if (context === tc.j_expr) {
        return this.jsxReadToken();
      }
      if (context === tc.j_oTag || context === tc.j_cTag) {
        if (isIdentifierStart(code)) {
          return this.jsxReadWord();
        }
        if (code === charCodes.greaterThan) {
          ++this.state.pos;
          return this.finishToken(tt.jsxTagEnd);
        }
        if (
          (code === charCodes.quotationMark || code === charCodes.apostrophe) &&
          context === tc.j_oTag
        ) {
          return this.jsxReadString(code);
        }
      }
      if (code === charCodes.lessThan && this.state.exprAllowed) {
        ++this.state.pos;
        return this.finishToken(tt.jsxTagStart);
      }
      return super.readToken(code);
    }
    updateContext(prevType: TokenType): void {
      if (this.match(tt.braceL)) {
        const curContext = this.curContext();
        if (curContext === tc.j_oTag) {
          this.state.context.push(tc.braceExpression);
        } else if (curContext === tc.j_expr) {
          this.state.context.push(tc.templateQuasi);
        } else {
          super.updateContext(prevType);
        }
        this.state.exprAllowed = true;
      } else if (this.match(tt.slash) && prevType === tt.jsxTagStart) {
        this.state.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore
        this.state.context.push(tc.j_cTag); // reconsider as closing tag context
        this.state.exprAllowed = false;
      } else {
        return super.updateContext(prevType);
      }
    }
  };

// </from> /home/qfox/apps/babel/packages/babel-parser/src/plugins/jsx/index.js

// <from> /home/qfox/apps/babel/packages/babel-parser/src/plugins/jsx/xhtml.js

// @flow
const entities: { [name: string]: string } = {
  quot: "\u0022",
  amp: "&",
  apos: "\u0027",
  lt: "<",
  gt: ">",
  nbsp: "\u00A0",
  iexcl: "\u00A1",
  cent: "\u00A2",
  pound: "\u00A3",
  curren: "\u00A4",
  yen: "\u00A5",
  brvbar: "\u00A6",
  sect: "\u00A7",
  uml: "\u00A8",
  copy: "\u00A9",
  ordf: "\u00AA",
  laquo: "\u00AB",
  not: "\u00AC",
  shy: "\u00AD",
  reg: "\u00AE",
  macr: "\u00AF",
  deg: "\u00B0",
  plusmn: "\u00B1",
  sup2: "\u00B2",
  sup3: "\u00B3",
  acute: "\u00B4",
  micro: "\u00B5",
  para: "\u00B6",
  middot: "\u00B7",
  cedil: "\u00B8",
  sup1: "\u00B9",
  ordm: "\u00BA",
  raquo: "\u00BB",
  frac14: "\u00BC",
  frac12: "\u00BD",
  frac34: "\u00BE",
  iquest: "\u00BF",
  Agrave: "\u00C0",
  Aacute: "\u00C1",
  Acirc: "\u00C2",
  Atilde: "\u00C3",
  Auml: "\u00C4",
  Aring: "\u00C5",
  AElig: "\u00C6",
  Ccedil: "\u00C7",
  Egrave: "\u00C8",
  Eacute: "\u00C9",
  Ecirc: "\u00CA",
  Euml: "\u00CB",
  Igrave: "\u00CC",
  Iacute: "\u00CD",
  Icirc: "\u00CE",
  Iuml: "\u00CF",
  ETH: "\u00D0",
  Ntilde: "\u00D1",
  Ograve: "\u00D2",
  Oacute: "\u00D3",
  Ocirc: "\u00D4",
  Otilde: "\u00D5",
  Ouml: "\u00D6",
  times: "\u00D7",
  Oslash: "\u00D8",
  Ugrave: "\u00D9",
  Uacute: "\u00DA",
  Ucirc: "\u00DB",
  Uuml: "\u00DC",
  Yacute: "\u00DD",
  THORN: "\u00DE",
  szlig: "\u00DF",
  agrave: "\u00E0",
  aacute: "\u00E1",
  acirc: "\u00E2",
  atilde: "\u00E3",
  auml: "\u00E4",
  aring: "\u00E5",
  aelig: "\u00E6",
  ccedil: "\u00E7",
  egrave: "\u00E8",
  eacute: "\u00E9",
  ecirc: "\u00EA",
  euml: "\u00EB",
  igrave: "\u00EC",
  iacute: "\u00ED",
  icirc: "\u00EE",
  iuml: "\u00EF",
  eth: "\u00F0",
  ntilde: "\u00F1",
  ograve: "\u00F2",
  oacute: "\u00F3",
  ocirc: "\u00F4",
  otilde: "\u00F5",
  ouml: "\u00F6",
  divide: "\u00F7",
  oslash: "\u00F8",
  ugrave: "\u00F9",
  uacute: "\u00FA",
  ucirc: "\u00FB",
  uuml: "\u00FC",
  yacute: "\u00FD",
  thorn: "\u00FE",
  yuml: "\u00FF",
  OElig: "\u0152",
  oelig: "\u0153",
  Scaron: "\u0160",
  scaron: "\u0161",
  Yuml: "\u0178",
  fnof: "\u0192",
  circ: "\u02C6",
  tilde: "\u02DC",
  Alpha: "\u0391",
  Beta: "\u0392",
  Gamma: "\u0393",
  Delta: "\u0394",
  Epsilon: "\u0395",
  Zeta: "\u0396",
  Eta: "\u0397",
  Theta: "\u0398",
  Iota: "\u0399",
  Kappa: "\u039A",
  Lambda: "\u039B",
  Mu: "\u039C",
  Nu: "\u039D",
  Xi: "\u039E",
  Omicron: "\u039F",
  Pi: "\u03A0",
  Rho: "\u03A1",
  Sigma: "\u03A3",
  Tau: "\u03A4",
  Upsilon: "\u03A5",
  Phi: "\u03A6",
  Chi: "\u03A7",
  Psi: "\u03A8",
  Omega: "\u03A9",
  alpha: "\u03B1",
  beta: "\u03B2",
  gamma: "\u03B3",
  delta: "\u03B4",
  epsilon: "\u03B5",
  zeta: "\u03B6",
  eta: "\u03B7",
  theta: "\u03B8",
  iota: "\u03B9",
  kappa: "\u03BA",
  lambda: "\u03BB",
  mu: "\u03BC",
  nu: "\u03BD",
  xi: "\u03BE",
  omicron: "\u03BF",
  pi: "\u03C0",
  rho: "\u03C1",
  sigmaf: "\u03C2",
  sigma: "\u03C3",
  tau: "\u03C4",
  upsilon: "\u03C5",
  phi: "\u03C6",
  chi: "\u03C7",
  psi: "\u03C8",
  omega: "\u03C9",
  thetasym: "\u03D1",
  upsih: "\u03D2",
  piv: "\u03D6",
  ensp: "\u2002",
  emsp: "\u2003",
  thinsp: "\u2009",
  zwnj: "\u200C",
  zwj: "\u200D",
  lrm: "\u200E",
  rlm: "\u200F",
  ndash: "\u2013",
  mdash: "\u2014",
  lsquo: "\u2018",
  rsquo: "\u2019",
  sbquo: "\u201A",
  ldquo: "\u201C",
  rdquo: "\u201D",
  bdquo: "\u201E",
  dagger: "\u2020",
  Dagger: "\u2021",
  bull: "\u2022",
  hellip: "\u2026",
  permil: "\u2030",
  prime: "\u2032",
  Prime: "\u2033",
  lsaquo: "\u2039",
  rsaquo: "\u203A",
  oline: "\u203E",
  frasl: "\u2044",
  euro: "\u20AC",
  image: "\u2111",
  weierp: "\u2118",
  real: "\u211C",
  trade: "\u2122",
  alefsym: "\u2135",
  larr: "\u2190",
  uarr: "\u2191",
  rarr: "\u2192",
  darr: "\u2193",
  harr: "\u2194",
  crarr: "\u21B5",
  lArr: "\u21D0",
  uArr: "\u21D1",
  rArr: "\u21D2",
  dArr: "\u21D3",
  hArr: "\u21D4",
  forall: "\u2200",
  part: "\u2202",
  exist: "\u2203",
  empty: "\u2205",
  nabla: "\u2207",
  isin: "\u2208",
  notin: "\u2209",
  ni: "\u220B",
  prod: "\u220F",
  sum: "\u2211",
  minus: "\u2212",
  lowast: "\u2217",
  radic: "\u221A",
  prop: "\u221D",
  infin: "\u221E",
  ang: "\u2220",
  and: "\u2227",
  or: "\u2228",
  cap: "\u2229",
  cup: "\u222A",
  int: "\u222B",
  there4: "\u2234",
  sim: "\u223C",
  cong: "\u2245",
  asymp: "\u2248",
  ne: "\u2260",
  equiv: "\u2261",
  le: "\u2264",
  ge: "\u2265",
  sub: "\u2282",
  sup: "\u2283",
  nsub: "\u2284",
  sube: "\u2286",
  supe: "\u2287",
  oplus: "\u2295",
  otimes: "\u2297",
  perp: "\u22A5",
  sdot: "\u22C5",
  lceil: "\u2308",
  rceil: "\u2309",
  lfloor: "\u230A",
  rfloor: "\u230B",
  lang: "\u2329",
  rang: "\u232A",
  loz: "\u25CA",
  spades: "\u2660",
  clubs: "\u2663",
  hearts: "\u2665",
  diams: "\u2666",
};
export default entities;

// </from> /home/qfox/apps/babel/packages/babel-parser/src/plugins/jsx/xhtml.js

// <from> /home/qfox/apps/babel/packages/babel-parser/src/plugins/typescript.js

// @flow
import { types as tt } from "../tokenizer/types";
import { types as ct } from "../tokenizer/context";
import * as N from "../types";
import Parser from "../parser";
type TsModifier =
  | "readonly"
  | "abstract"
  | "static"
  | "public"
  | "private"
  | "protected";
function nonNull<T>(x: ?T): T {
  if (x == null) {
    // $FlowIgnore
    throw new Error(`Unexpected ${x} value.`);
  }
  return x;
}
function assert(x: boolean): void {
  if (!x) {
    throw new Error("Assert fail");
  }
}
type ParsingContext =
  | "EnumMembers"
  | "HeritageClauseElement"
  | "TupleElementTypes"
  | "TypeMembers"
  | "TypeParametersOrArguments";
// Doesn't handle "void" or "null" because those are keywords, not identifiers.
function keywordTypeFromName(
  value: string,
): N.TsKeywordTypeType | typeof undefined {
  switch (value) {
    case "any":
      return "TSAnyKeyword";
    case "boolean":
      return "TSBooleanKeyword";
    case "never":
      return "TSNeverKeyword";
    case "number":
      return "TSNumberKeyword";
    case "object":
      return "TSObjectKeyword";
    case "string":
      return "TSStringKeyword";
    case "symbol":
      return "TSSymbolKeyword";
    case "undefined":
      return "TSUndefinedKeyword";
    case "unknown":
      return "TSUnknownKeyword";
    default:
      return undefined;
  }
}
export default (superClass: Class<Parser>): Class<Parser> =>
  class extends superClass {
    tsIsIdentifier(): boolean {
      // TODO: actually a bit more complex in TypeScript, but shouldn't matter.
      // See https://github.com/Microsoft/TypeScript/issues/15008
      return this.match(tt.name);
    }
    tsNextTokenCanFollowModifier() {
      // Note: TypeScript's implementation is much more complicated because
      // more things are considered modifiers there.
      // This implementation only handles modifiers not handled by @babel/parser itself. And "static".
      // TODO: Would be nice to avoid lookahead. Want a hasLineBreakUpNext() method...
      this.next();
      return (
        !this.hasPrecedingLineBreak() &&
        !this.match(tt.parenL) &&
        !this.match(tt.parenR) &&
        !this.match(tt.colon) &&
        !this.match(tt.eq) &&
        !this.match(tt.question)
      );
    }
    /** Parses a modifier matching one the given modifier names. */
    tsParseModifier<T: TsModifier>(allowedModifiers: T[]): ?T {
      if (!this.match(tt.name)) {
        return undefined;
      }
      const modifier = this.state.value;
      if (
        allowedModifiers.indexOf(modifier) !== -1 &&
        this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))
      ) {
        return modifier;
      }
      return undefined;
    }
    tsIsListTerminator(kind: ParsingContext): boolean {
      switch (kind) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(tt.braceR);
        case "HeritageClauseElement":
          return this.match(tt.braceL);
        case "TupleElementTypes":
          return this.match(tt.bracketR);
        case "TypeParametersOrArguments":
          return this.isRelational(">");
      }
      throw new Error("Unreachable");
    }
    tsParseList<T: N.Node>(kind: ParsingContext, parseElement: () => T): T[] {
      const result: T[] = [];
      while (!this.tsIsListTerminator(kind)) {
        // Skipping "parseListElement" from the TS source since that's just for error handling.
        result.push(parseElement());
      }
      return result;
    }
    tsParseDelimitedList<T: N.Node>(
      kind: ParsingContext,
      parseElement: () => T,
    ): T[] {
      return nonNull(
        this.tsParseDelimitedListWorker(
          kind,
          parseElement,
          /* expectSuccess */ true,
        ),
      );
    }
    tsTryParseDelimitedList<T: N.Node>(
      kind: ParsingContext,
      parseElement: () => ?T,
    ): ?(T[]) {
      return this.tsParseDelimitedListWorker(
        kind,
        parseElement,
        /* expectSuccess */ false,
      );
    }
    /**
     * If !expectSuccess, returns undefined instead of failing to parse.
     * If expectSuccess, parseElement should always return a defined value.
     */
    tsParseDelimitedListWorker<T: N.Node>(
      kind: ParsingContext,
      parseElement: () => ?T,
      expectSuccess: boolean,
    ): ?(T[]) {
      const result = [];
      while (true) {
        if (this.tsIsListTerminator(kind)) {
          break;
        }
        const element = parseElement();
        if (element == null) {
          return undefined;
        }
        result.push(element);
        if (this.eat(tt.comma)) {
          continue;
        }
        if (this.tsIsListTerminator(kind)) {
          break;
        }
        if (expectSuccess) {
          // This will fail with an error about a missing comma
          this.expect(tt.comma);
        }
        return undefined;
      }
      return result;
    }
    tsParseBracketedList<T: N.Node>(
      kind: ParsingContext,
      parseElement: () => T,
      bracket: boolean,
      skipFirstToken: boolean,
    ): T[] {
      if (!skipFirstToken) {
        if (bracket) {
          this.expect(tt.bracketL);
        } else {
          this.expectRelational("<");
        }
      }
      const result = this.tsParseDelimitedList(kind, parseElement);
      if (bracket) {
        this.expect(tt.bracketR);
      } else {
        this.expectRelational(">");
      }
      return result;
    }
    tsParseEntityName(allowReservedWords: boolean): N.TsEntityName {
      let entity: N.TsEntityName = this.parseIdentifier();
      while (this.eat(tt.dot)) {
        const node: N.TsQualifiedName = this.startNodeAtNode(entity);
        node.left = entity;
        node.right = this.parseIdentifier(allowReservedWords);
        entity = this.finishNode(node, "TSQualifiedName");
      }
      return entity;
    }
    tsParseTypeReference(): N.TsTypeReference {
      const node: N.TsTypeReference = this.startNode();
      node.typeName = this.tsParseEntityName(/* allowReservedWords */ false);
      if (!this.hasPrecedingLineBreak() && this.isRelational("<")) {
        node.typeParameters = this.tsParseTypeArguments();
      }
      return this.finishNode(node, "TSTypeReference");
    }
    tsParseThisTypePredicate(lhs: N.TsThisType): N.TsTypePredicate {
      this.next();
      const node: N.TsTypePredicate = this.startNode();
      node.parameterName = lhs;
      node.typeAnnotation = this.tsParseTypeAnnotation(/* eatColon */ false);
      return this.finishNode(node, "TSTypePredicate");
    }
    tsParseThisTypeNode(): N.TsThisType {
      const node: N.TsThisType = this.startNode();
      this.next();
      return this.finishNode(node, "TSThisType");
    }
    tsParseTypeQuery(): N.TsTypeQuery {
      const node: N.TsTypeQuery = this.startNode();
      this.expect(tt._typeof);
      node.exprName = this.tsParseEntityName(/* allowReservedWords */ true);
      return this.finishNode(node, "TSTypeQuery");
    }
    tsParseTypeParameter(): N.TsTypeParameter {
      const node: N.TsTypeParameter = this.startNode();
      node.name = this.parseIdentifierName(node.start);
      node.constraint = this.tsEatThenParseType(tt._extends);
      node.default = this.tsEatThenParseType(tt.eq);
      return this.finishNode(node, "TSTypeParameter");
    }
    tsTryParseTypeParameters(): ?N.TsTypeParameterDeclaration {
      if (this.isRelational("<")) {
        return this.tsParseTypeParameters();
      }
    }
    tsParseTypeParameters() {
      const node: N.TsTypeParameterDeclaration = this.startNode();
      if (this.isRelational("<") || this.match(tt.jsxTagStart)) {
        this.next();
      } else {
        this.unexpected();
      }
      node.params = this.tsParseBracketedList(
        "TypeParametersOrArguments",
        this.tsParseTypeParameter.bind(this),
        /* bracket */ false,
        /* skipFirstToken */ true,
      );
      return this.finishNode(node, "TSTypeParameterDeclaration");
    }
    // Note: In TypeScript implementation we must provide `yieldContext` and `awaitContext`,
    // but here it's always false, because this is only used for types.
    tsFillSignature(
      returnToken: TokenType,
      signature: N.TsSignatureDeclaration,
    ): void {
      // Arrow fns *must* have return token (`=>`). Normal functions can omit it.
      const returnTokenRequired = returnToken === tt.arrow;
      signature.typeParameters = this.tsTryParseTypeParameters();
      this.expect(tt.parenL);
      signature.parameters = this.tsParseBindingListForSignature();
      if (returnTokenRequired) {
        signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(
          returnToken,
        );
      } else if (this.match(returnToken)) {
        signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(
          returnToken,
        );
      }
    }
    tsParseBindingListForSignature(): $ReadOnlyArray<
      N.Identifier | N.RestElement,
    > {
      return this.parseBindingList(tt.parenR).map(pattern => {
        if (pattern.type !== "Identifier" && pattern.type !== "RestElement") {
          throw this.unexpected(
            pattern.start,
            "Name in a signature must be an Identifier.",
          );
        }
        return pattern;
      });
    }
    tsParseTypeMemberSemicolon(): void {
      if (!this.eat(tt.comma)) {
        this.semicolon();
      }
    }
    tsParseSignatureMember(
      kind: "TSCallSignatureDeclaration" | "TSConstructSignatureDeclaration",
    ): N.TsCallSignatureDeclaration | N.TsConstructSignatureDeclaration {
      const node:
        | N.TsCallSignatureDeclaration
        | N.TsConstructSignatureDeclaration = this.startNode();
      if (kind === "TSConstructSignatureDeclaration") {
        this.expect(tt._new);
      }
      this.tsFillSignature(tt.colon, node);
      this.tsParseTypeMemberSemicolon();
      return this.finishNode(node, kind);
    }
    tsIsUnambiguouslyIndexSignature() {
      this.next(); // Skip '{'
      return this.eat(tt.name) && this.match(tt.colon);
    }
    tsTryParseIndexSignature(node: N.TsIndexSignature): ?N.TsIndexSignature {
      if (
        !(
          this.match(tt.bracketL) &&
          this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))
        )
      ) {
        return undefined;
      }
      this.expect(tt.bracketL);
      const id = this.parseIdentifier();
      this.expect(tt.colon);
      id.typeAnnotation = this.tsParseTypeAnnotation(/* eatColon */ false);
      this.expect(tt.bracketR);
      node.parameters = [id];
      const type = this.tsTryParseTypeAnnotation();
      if (type) node.typeAnnotation = type;
      this.tsParseTypeMemberSemicolon();
      return this.finishNode(node, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(
      node: N.TsPropertySignature | N.TsMethodSignature,
      readonly: boolean,
    ): N.TsPropertySignature | N.TsMethodSignature {
      this.parsePropertyName(node);
      if (this.eat(tt.question)) node.optional = true;
      const nodeAny: any = node;
      if (!readonly && (this.match(tt.parenL) || this.isRelational("<"))) {
        const method: N.TsMethodSignature = nodeAny;
        this.tsFillSignature(tt.colon, method);
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(method, "TSMethodSignature");
      } else {
        const property: N.TsPropertySignature = nodeAny;
        if (readonly) property.readonly = true;
        const type = this.tsTryParseTypeAnnotation();
        if (type) property.typeAnnotation = type;
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(property, "TSPropertySignature");
      }
    }
    tsParseTypeMember(): N.TsTypeElement {
      if (this.match(tt.parenL) || this.isRelational("<")) {
        return this.tsParseSignatureMember("TSCallSignatureDeclaration");
      }
      if (
        this.match(tt._new) &&
        this.tsLookAhead(this.tsIsStartOfConstructSignature.bind(this))
      ) {
        return this.tsParseSignatureMember("TSConstructSignatureDeclaration");
      }
      // Instead of fullStart, we create a node here.
      const node: any = this.startNode();
      const readonly = !!this.tsParseModifier(["readonly"]);
      const idx = this.tsTryParseIndexSignature(node);
      if (idx) {
        if (readonly) node.readonly = true;
        return idx;
      }
      return this.tsParsePropertyOrMethodSignature(node, readonly);
    }
    tsIsStartOfConstructSignature() {
      this.next();
      return this.match(tt.parenL) || this.isRelational("<");
    }
    tsParseTypeLiteral(): N.TsTypeLiteral {
      const node: N.TsTypeLiteral = this.startNode();
      node.members = this.tsParseObjectTypeMembers();
      return this.finishNode(node, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers(): $ReadOnlyArray<N.TsTypeElement> {
      this.expect(tt.braceL);
      const members = this.tsParseList(
        "TypeMembers",
        this.tsParseTypeMember.bind(this),
      );
      this.expect(tt.braceR);
      return members;
    }
    tsIsStartOfMappedType(): boolean {
      this.next();
      if (this.eat(tt.plusMin)) {
        return this.isContextual("readonly");
      }
      if (this.isContextual("readonly")) {
        this.next();
      }
      if (!this.match(tt.bracketL)) {
        return false;
      }
      this.next();
      if (!this.tsIsIdentifier()) {
        return false;
      }
      this.next();
      return this.match(tt._in);
    }
    tsParseMappedTypeParameter(): N.TsTypeParameter {
      const node: N.TsTypeParameter = this.startNode();
      node.name = this.parseIdentifierName(node.start);
      node.constraint = this.tsExpectThenParseType(tt._in);
      return this.finishNode(node, "TSTypeParameter");
    }
    tsParseMappedType(): N.TsMappedType {
      const node: N.TsMappedType = this.startNode();
      this.expect(tt.braceL);
      if (this.match(tt.plusMin)) {
        node.readonly = this.state.value;
        this.next();
        this.expectContextual("readonly");
      } else if (this.eatContextual("readonly")) {
        node.readonly = true;
      }
      this.expect(tt.bracketL);
      node.typeParameter = this.tsParseMappedTypeParameter();
      this.expect(tt.bracketR);
      if (this.match(tt.plusMin)) {
        node.optional = this.state.value;
        this.next();
        this.expect(tt.question);
      } else if (this.eat(tt.question)) {
        node.optional = true;
      }
      node.typeAnnotation = this.tsTryParseType();
      this.semicolon();
      this.expect(tt.braceR);
      return this.finishNode(node, "TSMappedType");
    }
    tsParseTupleType(): N.TsTupleType {
      const node: N.TsTupleType = this.startNode();
      node.elementTypes = this.tsParseBracketedList(
        "TupleElementTypes",
        this.tsParseTupleElementType.bind(this),
        /* bracket */ true,
        /* skipFirstToken */ false,
      );
      return this.finishNode(node, "TSTupleType");
    }
    tsParseTupleElementType(): N.TsType {
      const type = this.tsParseType();
      if (this.eat(tt.question)) {
        const optionalTypeNode: N.TsOptionalType = this.startNodeAtNode(type);
        optionalTypeNode.typeAnnotation = type;
        return this.finishNode(optionalTypeNode, "TSOptionalType");
      }
      return type;
    }
    tsParseParenthesizedType(): N.TsParenthesizedType {
      const node = this.startNode();
      this.expect(tt.parenL);
      node.typeAnnotation = this.tsParseType();
      this.expect(tt.parenR);
      return this.finishNode(node, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(
      type: "TSFunctionType" | "TSConstructorType",
    ): N.TsFunctionOrConstructorType {
      const node: N.TsFunctionOrConstructorType = this.startNode();
      if (type === "TSConstructorType") {
        this.expect(tt._new);
      }
      this.tsFillSignature(tt.arrow, node);
      return this.finishNode(node, type);
    }
    tsParseLiteralTypeNode(): N.TsLiteralType {
      const node: N.TsLiteralType = this.startNode();
      node.literal = (() => {
        switch (this.state.type) {
          case tt.num:
            return this.parseLiteral(this.state.value, "NumericLiteral");
          case tt.string:
            return this.parseLiteral(this.state.value, "StringLiteral");
          case tt._true:
          case tt._false:
            return this.parseBooleanLiteral();
          default:
            throw this.unexpected();
        }
      })();
      return this.finishNode(node, "TSLiteralType");
    }
    tsParseNonArrayType(): N.TsType {
      switch (this.state.type) {
        case tt.name:
        case tt._void:
        case tt._null: {
          const type = this.match(tt._void)
            ? "TSVoidKeyword"
            : this.match(tt._null)
              ? "TSNullKeyword"
              : keywordTypeFromName(this.state.value);
          if (type !== undefined && this.lookahead().type !== tt.dot) {
            const node: N.TsKeywordType = this.startNode();
            this.next();
            return this.finishNode(node, type);
          }
          return this.tsParseTypeReference();
        }
        case tt.string:
        case tt.num:
        case tt._true:
        case tt._false:
          return this.tsParseLiteralTypeNode();
        case tt.plusMin:
          if (this.state.value === "-") {
            const node: N.TsLiteralType = this.startNode();
            this.next();
            if (!this.match(tt.num)) {
              throw this.unexpected();
            }
            node.literal = this.parseLiteral(
              -this.state.value,
              "NumericLiteral",
              node.start,
              node.loc.start,
            );
            return this.finishNode(node, "TSLiteralType");
          }
          break;
        case tt._this: {
          const thisKeyword = this.tsParseThisTypeNode();
          if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
            return this.tsParseThisTypePredicate(thisKeyword);
          } else {
            return thisKeyword;
          }
        }
        case tt._typeof:
          return this.tsParseTypeQuery();
        case tt.braceL:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this))
            ? this.tsParseMappedType()
            : this.tsParseTypeLiteral();
        case tt.bracketL:
          return this.tsParseTupleType();
        case tt.parenL:
          return this.tsParseParenthesizedType();
      }
      throw this.unexpected();
    }
    tsParseArrayTypeOrHigher(): N.TsType {
      let type = this.tsParseNonArrayType();
      while (!this.hasPrecedingLineBreak() && this.eat(tt.bracketL)) {
        if (this.match(tt.bracketR)) {
          const node: N.TsArrayType = this.startNodeAtNode(type);
          node.elementType = type;
          this.expect(tt.bracketR);
          type = this.finishNode(node, "TSArrayType");
        } else {
          const node: N.TsIndexedAccessType = this.startNodeAtNode(type);
          node.objectType = type;
          node.indexType = this.tsParseType();
          this.expect(tt.bracketR);
          type = this.finishNode(node, "TSIndexedAccessType");
        }
      }
      return type;
    }
    tsParseTypeOperator(operator: "keyof" | "unique"): N.TsTypeOperator {
      const node: N.TsTypeOperator = this.startNode();
      this.expectContextual(operator);
      node.operator = operator;
      node.typeAnnotation = this.tsParseTypeOperatorOrHigher();
      return this.finishNode(node, "TSTypeOperator");
    }
    tsParseInferType(): N.TsInferType {
      const node = this.startNode();
      this.expectContextual("infer");
      const typeParameter = this.startNode();
      typeParameter.name = this.parseIdentifierName(typeParameter.start);
      node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
      return this.finishNode(node, "TSInferType");
    }
    tsParseTypeOperatorOrHigher(): N.TsType {
      const operator = ["keyof", "unique"].find(kw => this.isContextual(kw));
      return operator
        ? this.tsParseTypeOperator(operator)
        : this.isContextual("infer")
          ? this.tsParseInferType()
          : this.tsParseArrayTypeOrHigher();
    }
    tsParseUnionOrIntersectionType(
      kind: "TSUnionType" | "TSIntersectionType",
      parseConstituentType: () => N.TsType,
      operator: TokenType,
    ): N.TsType {
      this.eat(operator);
      let type = parseConstituentType();
      if (this.match(operator)) {
        const types = [type];
        while (this.eat(operator)) {
          types.push(parseConstituentType());
        }
        const node: N.TsUnionType | N.TsIntersectionType = this.startNodeAtNode(
          type,
        );
        node.types = types;
        type = this.finishNode(node, kind);
      }
      return type;
    }
    tsParseIntersectionTypeOrHigher(): N.TsType {
      return this.tsParseUnionOrIntersectionType(
        "TSIntersectionType",
        this.tsParseTypeOperatorOrHigher.bind(this),
        tt.bitwiseAND,
      );
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType(
        "TSUnionType",
        this.tsParseIntersectionTypeOrHigher.bind(this),
        tt.bitwiseOR,
      );
    }
    tsIsStartOfFunctionType() {
      if (this.isRelational("<")) {
        return true;
      }
      return (
        this.match(tt.parenL) &&
        this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this))
      );
    }
    tsSkipParameterStart(): boolean {
      if (this.match(tt.name) || this.match(tt._this)) {
        this.next();
        return true;
      }
      return false;
    }
    tsIsUnambiguouslyStartOfFunctionType(): boolean {
      this.next();
      if (this.match(tt.parenR) || this.match(tt.ellipsis)) {
        // ( )
        // ( ...
        return true;
      }
      if (this.tsSkipParameterStart()) {
        if (
          this.match(tt.colon) ||
          this.match(tt.comma) ||
          this.match(tt.question) ||
          this.match(tt.eq)
        ) {
          // ( xxx :
          // ( xxx ,
          // ( xxx ?
          // ( xxx =
          return true;
        }
        if (this.match(tt.parenR)) {
          this.next();
          if (this.match(tt.arrow)) {
            // ( xxx ) =>
            return true;
          }
        }
      }
      return false;
    }
    tsParseTypeOrTypePredicateAnnotation(
      returnToken: TokenType,
    ): N.TsTypeAnnotation {
      return this.tsInType(() => {
        const t: N.TsTypeAnnotation = this.startNode();
        this.expect(returnToken);
        const typePredicateVariable =
          this.tsIsIdentifier() &&
          this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!typePredicateVariable) {
          return this.tsParseTypeAnnotation(/* eatColon */ false, t);
        }
        const type = this.tsParseTypeAnnotation(/* eatColon */ false);
        const node: N.TsTypePredicate = this.startNodeAtNode(
          typePredicateVariable,
        );
        node.parameterName = typePredicateVariable;
        node.typeAnnotation = type;
        t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
        return this.finishNode(t, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation(): ?N.TsTypeAnnotation {
      return this.match(tt.colon)
        ? this.tsParseTypeOrTypePredicateAnnotation(tt.colon)
        : undefined;
    }
    tsTryParseTypeAnnotation(): ?N.TsTypeAnnotation {
      return this.match(tt.colon) ? this.tsParseTypeAnnotation() : undefined;
    }
    tsTryParseType(): ?N.TsType {
      return this.tsEatThenParseType(tt.colon);
    }
    tsParseTypePredicatePrefix(): ?N.Identifier {
      const id = this.parseIdentifier();
      if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
        this.next();
        return id;
      }
    }
    tsParseTypeAnnotation(
      eatColon = true,
      t: N.TsTypeAnnotation = this.startNode(),
    ): N.TsTypeAnnotation {
      this.tsInType(() => {
        if (eatColon) this.expect(tt.colon);
        t.typeAnnotation = this.tsParseType();
      });
      return this.finishNode(t, "TSTypeAnnotation");
    }
    /** Be sure to be in a type context before calling this, using `tsInType`. */
    tsParseType(): N.TsType {
      // Need to set `state.inType` so that we don't parse JSX in a type context.
      assert(this.state.inType);
      const type = this.tsParseNonConditionalType();
      if (this.hasPrecedingLineBreak() || !this.eat(tt._extends)) {
        return type;
      }
      const node: N.TsConditionalType = this.startNodeAtNode(type);
      node.checkType = type;
      node.extendsType = this.tsParseNonConditionalType();
      this.expect(tt.question);
      node.trueType = this.tsParseType();
      this.expect(tt.colon);
      node.falseType = this.tsParseType();
      return this.finishNode(node, "TSConditionalType");
    }
    tsParseNonConditionalType(): N.TsType {
      if (this.tsIsStartOfFunctionType()) {
        return this.tsParseFunctionOrConstructorType("TSFunctionType");
      }
      if (this.match(tt._new)) {
        // As in `new () => Date`
        return this.tsParseFunctionOrConstructorType("TSConstructorType");
      }
      return this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion(): N.TsTypeAssertion {
      const node: N.TsTypeAssertion = this.startNode();
      // Not actually necessary to set state.inType because we never reach here if JSX plugin is enabled,
      // but need `tsInType` to satisfy the assertion in `tsParseType`.
      node.typeAnnotation = this.tsInType(() => this.tsParseType());
      this.expectRelational(">");
      node.expression = this.parseMaybeUnary();
      return this.finishNode(node, "TSTypeAssertion");
    }
    tsParseHeritageClause(): $ReadOnlyArray<N.TsExpressionWithTypeArguments> {
      return this.tsParseDelimitedList(
        "HeritageClauseElement",
        this.tsParseExpressionWithTypeArguments.bind(this),
      );
    }
    tsParseExpressionWithTypeArguments(): N.TsExpressionWithTypeArguments {
      const node: N.TsExpressionWithTypeArguments = this.startNode();
      // Note: TS uses parseLeftHandSideExpressionOrHigher,
      // then has grammar errors later if it's not an EntityName.
      node.expression = this.tsParseEntityName(/* allowReservedWords */ false);
      if (this.isRelational("<")) {
        node.typeParameters = this.tsParseTypeArguments();
      }
      return this.finishNode(node, "TSExpressionWithTypeArguments");
    }
    tsParseInterfaceDeclaration(
      node: N.TsInterfaceDeclaration,
    ): N.TsInterfaceDeclaration {
      node.id = this.parseIdentifier();
      node.typeParameters = this.tsTryParseTypeParameters();
      if (this.eat(tt._extends)) {
        node.extends = this.tsParseHeritageClause();
      }
      const body: N.TSInterfaceBody = this.startNode();
      body.body = this.tsParseObjectTypeMembers();
      node.body = this.finishNode(body, "TSInterfaceBody");
      return this.finishNode(node, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(
      node: N.TsTypeAliasDeclaration,
    ): N.TsTypeAliasDeclaration {
      node.id = this.parseIdentifier();
      node.typeParameters = this.tsTryParseTypeParameters();
      node.typeAnnotation = this.tsExpectThenParseType(tt.eq);
      this.semicolon();
      return this.finishNode(node, "TSTypeAliasDeclaration");
    }
    tsInNoContext<T>(cb: () => T): T {
      const oldContext = this.state.context;
      this.state.context = [oldContext[0]];
      try {
        return cb();
      } finally {
        this.state.context = oldContext;
      }
    }
    /**
     * Runs `cb` in a type context.
     * This should be called one token *before* the first type token,
     * so that the call to `next()` is run in type context.
     */
    tsInType<T>(cb: () => T): T {
      const oldInType = this.state.inType;
      this.state.inType = true;
      try {
        return cb();
      } finally {
        this.state.inType = oldInType;
      }
    }
    tsEatThenParseType(token: TokenType): N.TsType | typeof undefined {
      return !this.match(token) ? undefined : this.tsNextThenParseType();
    }
    tsExpectThenParseType(token: TokenType): N.TsType {
      return this.tsDoThenParseType(() => this.expect(token));
    }
    tsNextThenParseType(): N.TsType {
      return this.tsDoThenParseType(() => this.next());
    }
    tsDoThenParseType(cb: () => void): N.TsType {
      return this.tsInType(() => {
        cb();
        return this.tsParseType();
      });
    }
    tsParseEnumMember(): N.TsEnumMember {
      const node: N.TsEnumMember = this.startNode();
      // Computed property names are grammar errors in an enum, so accept just string literal or identifier.
      node.id = this.match(tt.string)
        ? this.parseLiteral(this.state.value, "StringLiteral")
        : this.parseIdentifier(/* liberal */ true);
      if (this.eat(tt.eq)) {
        node.initializer = this.parseMaybeAssign();
      }
      return this.finishNode(node, "TSEnumMember");
    }
    tsParseEnumDeclaration(
      node: N.TsEnumDeclaration,
      isConst: boolean,
    ): N.TsEnumDeclaration {
      if (isConst) node.const = true;
      node.id = this.parseIdentifier();
      this.expect(tt.braceL);
      node.members = this.tsParseDelimitedList(
        "EnumMembers",
        this.tsParseEnumMember.bind(this),
      );
      this.expect(tt.braceR);
      return this.finishNode(node, "TSEnumDeclaration");
    }
    tsParseModuleBlock(): N.TsModuleBlock {
      const node: N.TsModuleBlock = this.startNode();
      this.expect(tt.braceL);
      // Inside of a module block is considered "top-level", meaning it can have imports and exports.
      this.parseBlockOrModuleBlockBody(
        (node.body = []),
        /* directives */ undefined,
        /* topLevel */ true,
        /* end */ tt.braceR,
      );
      return this.finishNode(node, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(
      node: N.TsModuleDeclaration,
    ): N.TsModuleDeclaration {
      node.id = this.parseIdentifier();
      if (this.eat(tt.dot)) {
        const inner = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(inner);
        node.body = inner;
      } else {
        node.body = this.tsParseModuleBlock();
      }
      return this.finishNode(node, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(
      node: N.TsModuleDeclaration,
    ): N.TsModuleDeclaration {
      if (this.isContextual("global")) {
        node.global = true;
        node.id = this.parseIdentifier();
      } else if (this.match(tt.string)) {
        node.id = this.parseExprAtom();
      } else {
        this.unexpected();
      }
      if (this.match(tt.braceL)) {
        node.body = this.tsParseModuleBlock();
      } else {
        this.semicolon();
      }
      return this.finishNode(node, "TSModuleDeclaration");
    }
    tsParseImportEqualsDeclaration(
      node: N.TsImportEqualsDeclaration,
      isExport?: boolean,
    ): N.TsImportEqualsDeclaration {
      node.isExport = isExport || false;
      node.id = this.parseIdentifier();
      this.expect(tt.eq);
      node.moduleReference = this.tsParseModuleReference();
      this.semicolon();
      return this.finishNode(node, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference(): boolean {
      return (
        this.isContextual("require") && this.lookahead().type === tt.parenL
      );
    }
    tsParseModuleReference(): N.TsModuleReference {
      return this.tsIsExternalModuleReference()
        ? this.tsParseExternalModuleReference()
        : this.tsParseEntityName(/* allowReservedWords */ false);
    }
    tsParseExternalModuleReference(): N.TsExternalModuleReference {
      const node: N.TsExternalModuleReference = this.startNode();
      this.expectContextual("require");
      this.expect(tt.parenL);
      if (!this.match(tt.string)) {
        throw this.unexpected();
      }
      node.expression = this.parseLiteral(this.state.value, "StringLiteral");
      this.expect(tt.parenR);
      return this.finishNode(node, "TSExternalModuleReference");
    }
    // Utilities
    tsLookAhead<T>(f: () => T): T {
      const state = this.state.clone();
      const res = f();
      this.state = state;
      return res;
    }
    tsTryParseAndCatch<T>(f: () => T): ?T {
      const state = this.state.clone();
      try {
        return f();
      } catch (e) {
        if (e instanceof SyntaxError) {
          this.state = state;
          return undefined;
        }
        throw e;
      }
    }
    tsTryParse<T>(f: () => ?T): ?T {
      const state = this.state.clone();
      const result = f();
      if (result !== undefined && result !== false) {
        return result;
      } else {
        this.state = state;
        return undefined;
      }
    }
    nodeWithSamePosition<T: N.Node>(original: N.Node, type: string): T {
      const node = this.startNodeAtNode(original);
      node.type = type;
      node.end = original.end;
      node.loc.end = original.loc.end;
      if (original.leadingComments) {
        node.leadingComments = original.leadingComments;
      }
      if (original.trailingComments) {
        node.trailingComments = original.trailingComments;
      }
      if (original.innerComments) node.innerComments = original.innerComments;
      return node;
    }
    tsTryParseDeclare(nany: any): ?N.Declaration {
      switch (this.state.type) {
        case tt._function:
          this.next();
          return this.parseFunction(nany, /* isStatement */ true);
        case tt._class:
          return this.parseClass(
            nany,
            /* isStatement */ true,
            /* optionalId */ false,
          );
        case tt._const:
          if (this.match(tt._const) && this.isLookaheadContextual("enum")) {
            // `const enum = 0;` not allowed because "enum" is a strict mode reserved word.
            this.expect(tt._const);
            this.expectContextual("enum");
            return this.tsParseEnumDeclaration(nany, /* isConst */ true);
          }
        // falls through
        case tt._var:
        case tt._let:
          return this.parseVarStatement(nany, this.state.type);
        case tt.name: {
          const value = this.state.value;
          if (value === "global") {
            return this.tsParseAmbientExternalModuleDeclaration(nany);
          } else {
            return this.tsParseDeclaration(nany, value, /* next */ true);
          }
        }
      }
    }
    // Note: this won't be called unless the keyword is allowed in `shouldParseExportDeclaration`.
    tsTryParseExportDeclaration(): ?N.Declaration {
      return this.tsParseDeclaration(
        this.startNode(),
        this.state.value,
        /* next */ true,
      );
    }
    tsParseExpressionStatement(node: any, expr: N.Identifier): ?N.Declaration {
      switch (expr.name) {
        case "declare": {
          const declaration = this.tsTryParseDeclare(node);
          if (declaration) {
            declaration.declare = true;
            return declaration;
          }
          break;
        }
        case "global":
          // `global { }` (with no `declare`) may appear inside an ambient module declaration.
          // Would like to use tsParseAmbientExternalModuleDeclaration here, but already ran past "global".
          if (this.match(tt.braceL)) {
            const mod: N.TsModuleDeclaration = node;
            mod.global = true;
            mod.id = expr;
            mod.body = this.tsParseModuleBlock();
            return this.finishNode(mod, "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(node, expr.name, /* next */ false);
      }
    }
    // Common to tsTryParseDeclare, tsTryParseExportDeclaration, and tsParseExpressionStatement.
    tsParseDeclaration(
      node: any,
      value: string,
      next: boolean,
    ): ?N.Declaration {
      switch (value) {
        case "abstract":
          if (next || this.match(tt._class)) {
            const cls: N.ClassDeclaration = node;
            cls.abstract = true;
            if (next) this.next();
            return this.parseClass(
              cls,
              /* isStatement */ true,
              /* optionalId */ false,
            );
          }
          break;
        case "enum":
          if (next || this.match(tt.name)) {
            if (next) this.next();
            return this.tsParseEnumDeclaration(node, /* isConst */ false);
          }
          break;
        case "interface":
          if (next || this.match(tt.name)) {
            if (next) this.next();
            return this.tsParseInterfaceDeclaration(node);
          }
          break;
        case "module":
          if (next) this.next();
          if (this.match(tt.string)) {
            return this.tsParseAmbientExternalModuleDeclaration(node);
          } else if (next || this.match(tt.name)) {
            return this.tsParseModuleOrNamespaceDeclaration(node);
          }
          break;
        case "namespace":
          if (next || this.match(tt.name)) {
            if (next) this.next();
            return this.tsParseModuleOrNamespaceDeclaration(node);
          }
          break;
        case "type":
          if (next || this.match(tt.name)) {
            if (next) this.next();
            return this.tsParseTypeAliasDeclaration(node);
          }
          break;
      }
    }
    tsTryParseGenericAsyncArrowFunction(
      startPos: number,
      startLoc: Position,
    ): ?N.ArrowFunctionExpression {
      const res: ?N.ArrowFunctionExpression = this.tsTryParseAndCatch(() => {
        const node: N.ArrowFunctionExpression = this.startNodeAt(
          startPos,
          startLoc,
        );
        node.typeParameters = this.tsParseTypeParameters();
        // Don't use overloaded parseFunctionParams which would look for "<" again.
        super.parseFunctionParams(node);
        node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
        this.expect(tt.arrow);
        return node;
      });
      if (!res) {
        return undefined;
      }
      res.id = null;
      res.generator = false;
      res.expression = true; // May be set again by parseFunctionBody.
      res.async = true;
      this.parseFunctionBody(res, true);
      return this.finishNode(res, "ArrowFunctionExpression");
    }
    tsParseTypeArguments(): N.TsTypeParameterInstantiation {
      const node = this.startNode();
      node.params = this.tsInType(() =>
        // Temporarily remove a JSX parsing context, which makes us scan different tokens.
        this.tsInNoContext(() => {
          this.expectRelational("<");
          return this.tsParseDelimitedList(
            "TypeParametersOrArguments",
            this.tsParseType.bind(this),
          );
        }),
      );
      // This reads the next token after the `>` too, so do this in the enclosing context.
      // But be sure not to parse a regex in the jsx expression `<C<number> />`, so set exprAllowed = false
      this.state.exprAllowed = false;
      this.expectRelational(">");
      return this.finishNode(node, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart(): boolean {
      if (this.match(tt.name)) {
        switch (this.state.value) {
          case "abstract":
          case "declare":
          case "enum":
          case "interface":
          case "module":
          case "namespace":
          case "type":
            return true;
        }
      }
      return false;
    }
    // ======================================================
    // OVERRIDES
    // ======================================================
    isExportDefaultSpecifier(): boolean {
      if (this.tsIsDeclarationStart()) return false;
      return super.isExportDefaultSpecifier();
    }
    parseAssignableListItem(
      allowModifiers: ?boolean,
      decorators: N.Decorator[],
    ): N.Pattern | N.TSParameterProperty {
      let accessibility: ?N.Accessibility;
      let readonly = false;
      if (allowModifiers) {
        accessibility = this.parseAccessModifier();
        readonly = !!this.tsParseModifier(["readonly"]);
      }
      const left = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(left);
      const elt = this.parseMaybeDefault(left.start, left.loc.start, left);
      if (accessibility || readonly) {
        const pp: N.TSParameterProperty = this.startNodeAtNode(elt);
        if (decorators.length) {
          pp.decorators = decorators;
        }
        if (accessibility) pp.accessibility = accessibility;
        if (readonly) pp.readonly = readonly;
        if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
          throw this.raise(
            pp.start,
            "A parameter property may not be declared using a binding pattern.",
          );
        }
        pp.parameter = elt;
        return this.finishNode(pp, "TSParameterProperty");
      } else {
        if (decorators.length) {
          left.decorators = decorators;
        }
        return elt;
      }
    }
    parseFunctionBodyAndFinish(
      node: N.BodilessFunctionOrMethodBase,
      type: string,
      allowExpressionBody?: boolean,
    ): void {
      // For arrow functions, `parseArrow` handles the return type itself.
      if (!allowExpressionBody && this.match(tt.colon)) {
        node.returnType = this.tsParseTypeOrTypePredicateAnnotation(tt.colon);
      }
      const bodilessType =
        type === "FunctionDeclaration"
          ? "TSDeclareFunction"
          : type === "ClassMethod"
            ? "TSDeclareMethod"
            : undefined;
      if (bodilessType && !this.match(tt.braceL) && this.isLineTerminator()) {
        this.finishNode(node, bodilessType);
        return;
      }
      super.parseFunctionBodyAndFinish(node, type, allowExpressionBody);
    }
    parseSubscript(
      base: N.Expression,
      startPos: number,
      startLoc: Position,
      noCalls: ?boolean,
      state: N.ParseSubscriptState,
    ): N.Expression {
      if (!this.hasPrecedingLineBreak() && this.match(tt.bang)) {
        this.state.exprAllowed = false;
        this.next();
        const nonNullExpression: N.TsNonNullExpression = this.startNodeAt(
          startPos,
          startLoc,
        );
        nonNullExpression.expression = base;
        return this.finishNode(nonNullExpression, "TSNonNullExpression");
      }
      if (this.isRelational("<")) {
        // tsTryParseAndCatch is expensive, so avoid if not necessary.
        // There are number of things we are going to "maybe" parse, like type arguments on
        // tagged template expressions. If any of them fail, walk it back and continue.
        const result = this.tsTryParseAndCatch(() => {
          if (!noCalls && this.atPossibleAsync(base)) {
            // Almost certainly this is a generic async function `async <T>() => ...
            // But it might be a call with a type argument `async<T>();`
            const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(
              startPos,
              startLoc,
            );
            if (asyncArrowFn) {
              return asyncArrowFn;
            }
          }
          const node: N.CallExpression = this.startNodeAt(startPos, startLoc);
          node.callee = base;
          const typeArguments = this.tsParseTypeArguments();
          if (typeArguments) {
            if (!noCalls && this.eat(tt.parenL)) {
              // possibleAsync always false here, because we would have handled it above.
              // $FlowIgnore (won't be any undefined arguments)
              node.arguments = this.parseCallExpressionArguments(
                tt.parenR,
                /* possibleAsync */ false,
              );
              node.typeParameters = typeArguments;
              return this.finishCallExpression(node);
            } else if (this.match(tt.backQuote)) {
              return this.parseTaggedTemplateExpression(
                startPos,
                startLoc,
                base,
                state,
                typeArguments,
              );
            }
          }
          this.unexpected();
        });
        if (result) return result;
      }
      return super.parseSubscript(base, startPos, startLoc, noCalls, state);
    }
    parseNewArguments(node: N.NewExpression): void {
      if (this.isRelational("<")) {
        // tsTryParseAndCatch is expensive, so avoid if not necessary.
        // 99% certain this is `new C<T>();`. But may be `new C < T;`, which is also legal.
        const typeParameters = this.tsTryParseAndCatch(() => {
          const args = this.tsParseTypeArguments();
          if (!this.match(tt.parenL)) this.unexpected();
          return args;
        });
        if (typeParameters) {
          node.typeParameters = typeParameters;
        }
      }
      super.parseNewArguments(node);
    }
    parseExprOp(
      left: N.Expression,
      leftStartPos: number,
      leftStartLoc: Position,
      minPrec: number,
      noIn: ?boolean,
    ) {
      if (
        nonNull(tt._in.binop) > minPrec &&
        !this.hasPrecedingLineBreak() &&
        this.isContextual("as")
      ) {
        const node: N.TsAsExpression = this.startNodeAt(
          leftStartPos,
          leftStartLoc,
        );
        node.expression = left;
        node.typeAnnotation = this.tsNextThenParseType();
        this.finishNode(node, "TSAsExpression");
        return this.parseExprOp(
          node,
          leftStartPos,
          leftStartLoc,
          minPrec,
          noIn,
        );
      }
      return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec, noIn);
    }
    checkReservedWord(
      word: string, // eslint-disable-line no-unused-vars
      startLoc: number, // eslint-disable-line no-unused-vars
      checkKeywords: boolean, // eslint-disable-line no-unused-vars
      // eslint-disable-next-line no-unused-vars
      isBinding: boolean,
    ): void {
      // Don't bother checking for TypeScript code.
      // Strict mode words may be allowed as in `declare namespace N { const static: number; }`.
      // And we have a type checker anyway, so don't bother having the parser do it.
    }
    /*
    Don't bother doing this check in TypeScript code because:
    1. We may have a nested export statement with the same name:
      export const x = 0;
      export namespace N {
        export const x = 1;
      }
    2. We have a type checker to warn us about this sort of thing.
    */
    checkDuplicateExports() {}
    parseImport(
      node: N.Node,
    ): N.ImportDeclaration | N.TsImportEqualsDeclaration {
      if (this.match(tt.name) && this.lookahead().type === tt.eq) {
        return this.tsParseImportEqualsDeclaration(node);
      }
      return super.parseImport(node);
    }
    parseExport(node: N.Node): N.Node {
      if (this.match(tt._import)) {
        // `export import A = B;`
        this.expect(tt._import);
        return this.tsParseImportEqualsDeclaration(node, /* isExport */ true);
      } else if (this.eat(tt.eq)) {
        // `export = x;`
        const assign: N.TsExportAssignment = node;
        assign.expression = this.parseExpression();
        this.semicolon();
        return this.finishNode(assign, "TSExportAssignment");
      } else if (this.eatContextual("as")) {
        // `export as namespace A;`
        const decl: N.TsNamespaceExportDeclaration = node;
        // See `parseNamespaceExportDeclaration` in TypeScript's own parser
        this.expectContextual("namespace");
        decl.id = this.parseIdentifier();
        this.semicolon();
        return this.finishNode(decl, "TSNamespaceExportDeclaration");
      } else {
        return super.parseExport(node);
      }
    }
    isAbstractClass(): boolean {
      return (
        this.isContextual("abstract") && this.lookahead().type === tt._class
      );
    }
    parseExportDefaultExpression(): N.Expression | N.Declaration {
      if (this.isAbstractClass()) {
        const cls = this.startNode();
        this.next(); // Skip "abstract"
        this.parseClass(cls, true, true);
        cls.abstract = true;
        return cls;
      }
      // export default interface allowed in:
      // https://github.com/Microsoft/TypeScript/pull/16040
      if (this.state.value === "interface") {
        const result = this.tsParseDeclaration(
          this.startNode(),
          this.state.value,
          true,
        );
        if (result) return result;
      }
      return super.parseExportDefaultExpression();
    }
    parseStatementContent(
      declaration: boolean,
      topLevel: ?boolean,
    ): N.Statement {
      if (this.state.type === tt._const) {
        const ahead = this.lookahead();
        if (ahead.type === tt.name && ahead.value === "enum") {
          const node: N.TsEnumDeclaration = this.startNode();
          this.expect(tt._const);
          this.expectContextual("enum");
          return this.tsParseEnumDeclaration(node, /* isConst */ true);
        }
      }
      return super.parseStatementContent(declaration, topLevel);
    }
    parseAccessModifier(): ?N.Accessibility {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    parseClassMember(
      classBody: N.ClassBody,
      member: any,
      state: { hadConstructor: boolean },
    ): void {
      const accessibility = this.parseAccessModifier();
      if (accessibility) member.accessibility = accessibility;
      super.parseClassMember(classBody, member, state);
    }
    parseClassMemberWithIsStatic(
      classBody: N.ClassBody,
      member: any,
      state: { hadConstructor: boolean },
      isStatic: boolean,
    ): void {
      const methodOrProp: N.ClassMethod | N.ClassProperty = member;
      const prop: N.ClassProperty = member;
      const propOrIdx: N.ClassProperty | N.TsIndexSignature = member;
      let abstract = false,
        readonly = false;
      const mod = this.tsParseModifier(["abstract", "readonly"]);
      switch (mod) {
        case "readonly":
          readonly = true;
          abstract = !!this.tsParseModifier(["abstract"]);
          break;
        case "abstract":
          abstract = true;
          readonly = !!this.tsParseModifier(["readonly"]);
          break;
      }
      if (abstract) methodOrProp.abstract = true;
      if (readonly) propOrIdx.readonly = true;
      if (!abstract && !isStatic && !methodOrProp.accessibility) {
        const idx = this.tsTryParseIndexSignature(member);
        if (idx) {
          classBody.body.push(idx);
          return;
        }
      }
      if (readonly) {
        // Must be a property (if not an index signature).
        methodOrProp.static = isStatic;
        this.parseClassPropertyName(prop);
        this.parsePostMemberNameModifiers(methodOrProp);
        this.pushClassProperty(classBody, prop);
        return;
      }
      super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
    }
    parsePostMemberNameModifiers(
      methodOrProp: N.ClassMethod | N.ClassProperty,
    ): void {
      const optional = this.eat(tt.question);
      if (optional) methodOrProp.optional = true;
    }
    // Note: The reason we do this in `parseExpressionStatement` and not `parseStatement`
    // is that e.g. `type()` is valid JS, so we must try parsing that first.
    // If it's really a type, we will parse `type` as the statement, and can correct it here
    // by parsing the rest.
    parseExpressionStatement(
      node: N.ExpressionStatement,
      expr: N.Expression,
    ): N.Statement {
      const decl =
        expr.type === "Identifier"
          ? this.tsParseExpressionStatement(node, expr)
          : undefined;
      return decl || super.parseExpressionStatement(node, expr);
    }
    // export type
    // Should be true for anything parsed by `tsTryParseExportDeclaration`.
    shouldParseExportDeclaration(): boolean {
      if (this.tsIsDeclarationStart()) return true;
      return super.shouldParseExportDeclaration();
    }
    // An apparent conditional expression could actually be an optional parameter in an arrow function.
    parseConditional(
      expr: N.Expression,
      noIn: ?boolean,
      startPos: number,
      startLoc: Position,
      refNeedsArrowPos?: ?Pos,
    ): N.Expression {
      // only do the expensive clone if there is a question mark
      // and if we come from inside parens
      if (!refNeedsArrowPos || !this.match(tt.question)) {
        return super.parseConditional(
          expr,
          noIn,
          startPos,
          startLoc,
          refNeedsArrowPos,
        );
      }
      const state = this.state.clone();
      try {
        return super.parseConditional(expr, noIn, startPos, startLoc);
      } catch (err) {
        if (!(err instanceof SyntaxError)) {
          // istanbul ignore next: no such error is expected
          throw err;
        }
        this.state = state;
        refNeedsArrowPos.start = err.pos || this.state.start;
        return expr;
      }
    }
    // Note: These "type casts" are *not* valid TS expressions.
    // But we parse them here and change them when completing the arrow function.
    parseParenItem(
      node: N.Expression,
      startPos: number,
      startLoc: Position,
    ): N.Expression {
      node = super.parseParenItem(node, startPos, startLoc);
      if (this.eat(tt.question)) {
        node.optional = true;
      }
      if (this.match(tt.colon)) {
        const typeCastNode: N.TsTypeCastExpression = this.startNodeAt(
          startPos,
          startLoc,
        );
        typeCastNode.expression = node;
        typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
        return this.finishNode(typeCastNode, "TSTypeCastExpression");
      }
      return node;
    }
    parseExportDeclaration(node: N.ExportNamedDeclaration): ?N.Declaration {
      // "export declare" is equivalent to just "export".
      const isDeclare = this.eatContextual("declare");
      let declaration: ?N.Declaration;
      if (this.match(tt.name)) {
        declaration = this.tsTryParseExportDeclaration();
      }
      if (!declaration) {
        declaration = super.parseExportDeclaration(node);
      }
      if (declaration && isDeclare) {
        declaration.declare = true;
      }
      return declaration;
    }
    parseClassId(
      node: N.Class,
      isStatement: boolean,
      optionalId: ?boolean,
    ): void {
      if ((!isStatement || optionalId) && this.isContextual("implements")) {
        return;
      }
      super.parseClassId(...arguments);
      const typeParameters = this.tsTryParseTypeParameters();
      if (typeParameters) node.typeParameters = typeParameters;
    }
    parseClassProperty(node: N.ClassProperty): N.ClassProperty {
      if (!node.optional && this.eat(tt.bang)) {
        node.definite = true;
      }
      const type = this.tsTryParseTypeAnnotation();
      if (type) node.typeAnnotation = type;
      return super.parseClassProperty(node);
    }
    pushClassMethod(
      classBody: N.ClassBody,
      method: N.ClassMethod,
      isGenerator: boolean,
      isAsync: boolean,
      isConstructor: boolean,
    ): void {
      const typeParameters = this.tsTryParseTypeParameters();
      if (typeParameters) method.typeParameters = typeParameters;
      super.pushClassMethod(
        classBody,
        method,
        isGenerator,
        isAsync,
        isConstructor,
      );
    }
    pushClassPrivateMethod(
      classBody: N.ClassBody,
      method: N.ClassPrivateMethod,
      isGenerator: boolean,
      isAsync: boolean,
    ): void {
      const typeParameters = this.tsTryParseTypeParameters();
      if (typeParameters) method.typeParameters = typeParameters;
      super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
    }
    parseClassSuper(node: N.Class): void {
      super.parseClassSuper(node);
      if (node.superClass && this.isRelational("<")) {
        node.superTypeParameters = this.tsParseTypeArguments();
      }
      if (this.eatContextual("implements")) {
        node.implements = this.tsParseHeritageClause();
      }
    }
    parseObjPropValue(prop: N.ObjectMember, ...args): void {
      const typeParameters = this.tsTryParseTypeParameters();
      if (typeParameters) prop.typeParameters = typeParameters;
      super.parseObjPropValue(prop, ...args);
    }
    parseFunctionParams(node: N.Function, allowModifiers?: boolean): void {
      const typeParameters = this.tsTryParseTypeParameters();
      if (typeParameters) node.typeParameters = typeParameters;
      super.parseFunctionParams(node, allowModifiers);
    }
    // `let x: number;`
    parseVarHead(decl: N.VariableDeclarator): void {
      super.parseVarHead(decl);
      if (decl.id.type === "Identifier" && this.eat(tt.bang)) {
        decl.definite = true;
      }
      const type = this.tsTryParseTypeAnnotation();
      if (type) {
        decl.id.typeAnnotation = type;
        this.finishNode(decl.id, decl.id.type); // set end position to end of type
      }
    }
    // parse the return type of an async arrow function - let foo = (async (): number => {});
    parseAsyncArrowFromCallExpression(
      node: N.ArrowFunctionExpression,
      call: N.CallExpression,
    ): N.ArrowFunctionExpression {
      if (this.match(tt.colon)) {
        node.returnType = this.tsParseTypeAnnotation();
      }
      return super.parseAsyncArrowFromCallExpression(node, call);
    }
    parseMaybeAssign(...args): N.Expression {
      // Note: When the JSX plugin is on, type assertions (`<T> x`) aren't valid syntax.
      let jsxError: ?SyntaxError;
      if (this.match(tt.jsxTagStart)) {
        const context = this.curContext();
        assert(context === ct.j_oTag);
        // Only time j_oTag is pushed is right after j_expr.
        assert(this.state.context[this.state.context.length - 2] === ct.j_expr);
        // Prefer to parse JSX if possible. But may be an arrow fn.
        const state = this.state.clone();
        try {
          return super.parseMaybeAssign(...args);
        } catch (err) {
          if (!(err instanceof SyntaxError)) {
            // istanbul ignore next: no such error is expected
            throw err;
          }
          this.state = state;
          // Pop the context added by the jsxTagStart.
          assert(this.curContext() === ct.j_oTag);
          this.state.context.pop();
          assert(this.curContext() === ct.j_expr);
          this.state.context.pop();
          jsxError = err;
        }
      }
      if (jsxError === undefined && !this.isRelational("<")) {
        return super.parseMaybeAssign(...args);
      }
      // Either way, we're looking at a '<': tt.jsxTagStart or relational.
      let arrowExpression;
      let typeParameters: N.TsTypeParameterDeclaration;
      const state = this.state.clone();
      try {
        // This is similar to TypeScript's `tryParseParenthesizedArrowFunctionExpression`.
        typeParameters = this.tsParseTypeParameters();
        arrowExpression = super.parseMaybeAssign(...args);
        if (arrowExpression.type !== "ArrowFunctionExpression") {
          this.unexpected(); // Go to the catch block (needs a SyntaxError).
        }
      } catch (err) {
        if (!(err instanceof SyntaxError)) {
          // istanbul ignore next: no such error is expected
          throw err;
        }
        if (jsxError) {
          throw jsxError;
        }
        // Try parsing a type cast instead of an arrow function.
        // This will never happen outside of JSX.
        // (Because in JSX the '<' should be a jsxTagStart and not a relational.
        assert(!this.hasPlugin("jsx"));
        // Parsing an arrow function failed, so try a type cast.
        this.state = state;
        // This will start with a type assertion (via parseMaybeUnary).
        // But don't directly call `this.tsParseTypeAssertion` because we want to handle any binary after it.
        return super.parseMaybeAssign(...args);
      }
      // Correct TypeScript code should have at least 1 type parameter, but don't crash on bad code.
      if (typeParameters && typeParameters.params.length !== 0) {
        this.resetStartLocationFromNode(
          arrowExpression,
          typeParameters.params[0],
        );
      }
      arrowExpression.typeParameters = typeParameters;
      return arrowExpression;
    }
    // Handle type assertions
    parseMaybeUnary(refShorthandDefaultPos?: ?Pos): N.Expression {
      if (!this.hasPlugin("jsx") && this.eatRelational("<")) {
        return this.tsParseTypeAssertion();
      } else {
        return super.parseMaybeUnary(refShorthandDefaultPos);
      }
    }
    parseArrow(node: N.ArrowFunctionExpression): ?N.ArrowFunctionExpression {
      if (this.match(tt.colon)) {
        // This is different from how the TS parser does it.
        // TS uses lookahead. The Babel Parser parses it as a parenthesized expression and converts.
        const state = this.state.clone();
        try {
          const returnType = this.tsParseTypeOrTypePredicateAnnotation(
            tt.colon,
          );
          if (this.canInsertSemicolon()) this.unexpected();
          if (!this.match(tt.arrow)) this.unexpected();
          node.returnType = returnType;
        } catch (err) {
          if (err instanceof SyntaxError) {
            this.state = state;
          } else {
            // istanbul ignore next: no such error is expected
            throw err;
          }
        }
      }
      return super.parseArrow(node);
    }
    // Allow type annotations inside of a parameter list.
    parseAssignableListItemTypes(param: N.Pattern) {
      if (this.eat(tt.question)) {
        if (param.type !== "Identifier") {
          throw this.raise(
            param.start,
            "A binding pattern parameter cannot be optional in an implementation signature.",
          );
        }
        param.optional = true;
      }
      const type = this.tsTryParseTypeAnnotation();
      if (type) param.typeAnnotation = type;
      return this.finishNode(param, param.type);
    }
    toAssignable(
      node: N.Node,
      isBinding: ?boolean,
      contextDescription: string,
    ): N.Node {
      switch (node.type) {
        case "TSTypeCastExpression":
          return super.toAssignable(
            this.typeCastToParameter(node),
            isBinding,
            contextDescription,
          );
        case "TSParameterProperty":
          return super.toAssignable(node, isBinding, contextDescription);
        case "TSAsExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          node.expression = this.toAssignable(
            node.expression,
            isBinding,
            contextDescription,
          );
          return node;
        default:
          return super.toAssignable(node, isBinding, contextDescription);
      }
    }
    checkLVal(
      expr: N.Expression,
      isBinding: ?boolean,
      checkClashes: ?{ [key: string]: boolean },
      contextDescription: string,
    ): void {
      switch (expr.type) {
        case "TSTypeCastExpression":
          // Allow "typecasts" to appear on the left of assignment expressions,
          // because it may be in an arrow function.
          // e.g. `const f = (foo: number = 0) => foo;`
          return;
        case "TSParameterProperty":
          this.checkLVal(
            expr.parameter,
            isBinding,
            checkClashes,
            "parameter property",
          );
          return;
        case "TSAsExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          this.checkLVal(
            expr.expression,
            isBinding,
            checkClashes,
            contextDescription,
          );
          return;
        default:
          super.checkLVal(expr, isBinding, checkClashes, contextDescription);
          return;
      }
    }
    parseBindingAtom(): N.Pattern {
      switch (this.state.type) {
        case tt._this:
          // "this" may be the name of a parameter, so allow it.
          return this.parseIdentifier(/* liberal */ true);
        default:
          return super.parseBindingAtom();
      }
    }
    parseMaybeDecoratorArguments(expr: N.Expression): N.Expression {
      if (this.isRelational("<")) {
        const typeArguments = this.tsParseTypeArguments();
        if (this.match(tt.parenL)) {
          const call = super.parseMaybeDecoratorArguments(expr);
          call.typeParameters = typeArguments;
          return call;
        }
        this.unexpected(this.state.start, tt.parenL);
      }
      return super.parseMaybeDecoratorArguments(expr);
    }
    // === === === === === === === === === === === === === === === ===
    // Note: All below methods are duplicates of something in flow.js.
    // Not sure what the best way to combine these is.
    // === === === === === === === === === === === === === === === ===
    isClassMethod(): boolean {
      return this.isRelational("<") || super.isClassMethod();
    }
    isClassProperty(): boolean {
      return (
        this.match(tt.bang) || this.match(tt.colon) || super.isClassProperty()
      );
    }
    parseMaybeDefault(...args): N.Pattern {
      const node = super.parseMaybeDefault(...args);
      if (
        node.type === "AssignmentPattern" &&
        node.typeAnnotation &&
        node.right.start < node.typeAnnotation.start
      ) {
        this.raise(
          node.typeAnnotation.start,
          "Type annotations must come before default assignments, " +
            "e.g. instead of `age = 25: number` use `age: number = 25`",
        );
      }
      return node;
    }
    // ensure that inside types, we bypass the jsx parser plugin
    readToken(code: number): void {
      if (this.state.inType && (code === 62 || code === 60)) {
        return this.finishOp(tt.relational, 1);
      } else {
        return super.readToken(code);
      }
    }
    toAssignableList(
      exprList: N.Expression[],
      isBinding: ?boolean,
      contextDescription: string,
    ): $ReadOnlyArray<N.Pattern> {
      for (let i = 0; i < exprList.length; i++) {
        const expr = exprList[i];
        if (expr && expr.type === "TSTypeCastExpression") {
          exprList[i] = this.typeCastToParameter(expr);
        }
      }
      return super.toAssignableList(exprList, isBinding, contextDescription);
    }
    typeCastToParameter(node: N.TsTypeCastExpression): N.Node {
      node.expression.typeAnnotation = node.typeAnnotation;
      return this.finishNodeAt(
        node.expression,
        node.expression.type,
        node.typeAnnotation.end,
        node.typeAnnotation.loc.end,
      );
    }
    toReferencedList(
      exprList: $ReadOnlyArray<?N.Expression>,
    ): $ReadOnlyArray<?N.Expression> {
      for (let i = 0; i < exprList.length; i++) {
        const expr = exprList[i];
        if (
          expr &&
          expr._exprListItem &&
          expr.type === "TsTypeCastExpression"
        ) {
          this.raise(expr.start, "Did not expect a type annotation here.");
        }
      }
      return exprList;
    }
    shouldParseArrow() {
      return this.match(tt.colon) || super.shouldParseArrow();
    }
    shouldParseAsyncArrow(): boolean {
      return this.match(tt.colon) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      // Avoid unnecessary lookahead in checking for abstract class unless needed!
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(
      node: N.JSXOpeningElement,
    ): N.JSXOpeningElement {
      const typeArguments = this.tsTryParseAndCatch(() =>
        this.tsParseTypeArguments(),
      );
      if (typeArguments) node.typeParameters = typeArguments;
      return super.jsxParseOpeningElementAfterName(node);
    }
  };

// </from> /home/qfox/apps/babel/packages/babel-parser/src/plugins/typescript.js

// <from> /home/qfox/apps/babel/packages/babel-parser/src/plugins/estree.js

// @flow
import { types as tt, TokenType } from "../tokenizer/types";
import * as N from "../types";
function isSimpleProperty(node: N.Node): boolean {
  return (
    node != null &&
    node.type === "Property" &&
    node.kind === "init" &&
    node.method === false
  );
}
export default (superClass: Class<Parser>): Class<Parser> =>
  class extends superClass {
    estreeParseRegExpLiteral({ pattern, flags }: N.RegExpLiteral): N.Node {
      let regex = null;
      try {
        regex = new RegExp(pattern, flags);
      } catch (e) {
        // In environments that don't support these flags value will
        // be null as the regex can't be represented natively.
      }
      const node = this.estreeParseLiteral(regex);
      node.regex = { pattern, flags };
      return node;
    }
    estreeParseLiteral(value: any): N.Node {
      return this.parseLiteral(value, "Literal");
    }
    directiveToStmt(directive: N.Directive): N.ExpressionStatement {
      const directiveLiteral = directive.value;
      const stmt = this.startNodeAt(directive.start, directive.loc.start);
      const expression = this.startNodeAt(
        directiveLiteral.start,
        directiveLiteral.loc.start,
      );
      expression.value = directiveLiteral.value;
      expression.raw = directiveLiteral.extra.raw;
      stmt.expression = this.finishNodeAt(
        expression,
        "Literal",
        directiveLiteral.end,
        directiveLiteral.loc.end,
      );
      stmt.directive = directiveLiteral.extra.raw.slice(1, -1);
      return this.finishNodeAt(
        stmt,
        "ExpressionStatement",
        directive.end,
        directive.loc.end,
      );
    }
    // ==================================
    // Overrides
    // ==================================
    initFunction(
      node: N.BodilessFunctionOrMethodBase,
      isAsync: ?boolean,
    ): void {
      super.initFunction(node, isAsync);
      node.expression = false;
    }
    checkDeclaration(node: N.Pattern | N.ObjectProperty): void {
      if (isSimpleProperty(node)) {
        this.checkDeclaration(((node: any): N.EstreeProperty).value);
      } else {
        super.checkDeclaration(node);
      }
    }
    checkGetterSetterParams(method: N.ObjectMethod | N.ClassMethod): void {
      const prop = ((method: any): N.EstreeProperty | N.EstreeMethodDefinition);
      const paramCount = prop.kind === "get" ? 0 : 1;
      const start = prop.start;
      if (prop.value.params.length !== paramCount) {
        if (prop.kind === "get") {
          this.raise(start, "getter must not have any formal parameters");
        } else {
          this.raise(start, "setter must have exactly one formal parameter");
        }
      }
      if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
        this.raise(
          start,
          "setter function argument must not be a rest parameter",
        );
      }
    }
    checkLVal(
      expr: N.Expression,
      isBinding: ?boolean,
      checkClashes: ?{ [key: string]: boolean },
      contextDescription: string,
    ): void {
      switch (expr.type) {
        case "ObjectPattern":
          expr.properties.forEach(prop => {
            this.checkLVal(
              prop.type === "Property" ? prop.value : prop,
              isBinding,
              checkClashes,
              "object destructuring pattern",
            );
          });
          break;
        default:
          super.checkLVal(expr, isBinding, checkClashes, contextDescription);
      }
    }
    checkPropClash(
      prop: N.ObjectMember,
      propHash: { [key: string]: boolean },
    ): void {
      if (prop.computed || !isSimpleProperty(prop)) return;
      const key = prop.key;
      // It is either an Identifier or a String/NumericLiteral
      const name = key.type === "Identifier" ? key.name : String(key.value);
      if (name === "__proto__") {
        if (propHash.proto) {
          this.raise(key.start, "Redefinition of __proto__ property");
        }
        propHash.proto = true;
      }
    }
    isStrictBody(node: { body: N.BlockStatement }): boolean {
      const isBlockStatement = node.body.type === "BlockStatement";
      if (isBlockStatement && node.body.body.length > 0) {
        for (const directive of node.body.body) {
          if (
            directive.type === "ExpressionStatement" &&
            directive.expression.type === "Literal"
          ) {
            if (directive.expression.value === "use strict") return true;
          } else {
            // Break for the first non literal expression
            break;
          }
        }
      }
      return false;
    }
    isValidDirective(stmt: N.Statement): boolean {
      return (
        stmt.type === "ExpressionStatement" &&
        stmt.expression.type === "Literal" &&
        typeof stmt.expression.value === "string" &&
        (!stmt.expression.extra || !stmt.expression.extra.parenthesized)
      );
    }
    stmtToDirective(stmt: N.Statement): N.Directive {
      const directive = super.stmtToDirective(stmt);
      const value = stmt.expression.value;
      // Reset value to the actual value as in estree mode we want
      // the stmt to have the real value and not the raw value
      directive.value.value = value;
      return directive;
    }
    parseBlockBody(
      node: N.BlockStatementLike,
      allowDirectives: ?boolean,
      topLevel: boolean,
      end: TokenType,
    ): void {
      super.parseBlockBody(node, allowDirectives, topLevel, end);
      const directiveStatements = node.directives.map(d =>
        this.directiveToStmt(d),
      );
      node.body = directiveStatements.concat(node.body);
      delete node.directives;
    }
    pushClassMethod(
      classBody: N.ClassBody,
      method: N.ClassMethod,
      isGenerator: boolean,
      isAsync: boolean,
      isConstructor: boolean,
    ): void {
      this.parseMethod(
        method,
        isGenerator,
        isAsync,
        isConstructor,
        "MethodDefinition",
      );
      if (method.typeParameters) {
        // $FlowIgnore
        method.value.typeParameters = method.typeParameters;
        delete method.typeParameters;
      }
      classBody.body.push(method);
    }
    parseExprAtom(refShorthandDefaultPos?: ?Pos): N.Expression {
      switch (this.state.type) {
        case tt.regexp:
          return this.estreeParseRegExpLiteral(this.state.value);
        case tt.num:
        case tt.string:
          return this.estreeParseLiteral(this.state.value);
        case tt._null:
          return this.estreeParseLiteral(null);
        case tt._true:
          return this.estreeParseLiteral(true);
        case tt._false:
          return this.estreeParseLiteral(false);
        default:
          return super.parseExprAtom(refShorthandDefaultPos);
      }
    }
    parseLiteral<T: N.Literal>(
      value: any,
      type: /*T["kind"]*/ string,
      startPos?: number,
      startLoc?: Position,
    ): T {
      const node = super.parseLiteral(value, type, startPos, startLoc);
      node.raw = node.extra.raw;
      delete node.extra;
      return node;
    }
    parseFunctionBody(node: N.Function, allowExpression: ?boolean): void {
      super.parseFunctionBody(node, allowExpression);
      node.expression = node.body.type !== "BlockStatement";
    }
    parseMethod<T: N.MethodLike>(
      node: T,
      isGenerator: boolean,
      isAsync: boolean,
      isConstructor: boolean,
      type: string,
    ): T {
      let funcNode = this.startNode();
      funcNode.kind = node.kind; // provide kind, so super method correctly sets state
      funcNode = super.parseMethod(
        funcNode,
        isGenerator,
        isAsync,
        isConstructor,
        "FunctionExpression",
      );
      delete funcNode.kind;
      // $FlowIgnore
      node.value = funcNode;
      return this.finishNode(node, type);
    }
    parseObjectMethod(
      prop: N.ObjectMethod,
      isGenerator: boolean,
      isAsync: boolean,
      isPattern: boolean,
      containsEsc: boolean,
    ): ?N.ObjectMethod {
      const node: N.EstreeProperty = (super.parseObjectMethod(
        prop,
        isGenerator,
        isAsync,
        isPattern,
        containsEsc,
      ): any);
      if (node) {
        node.type = "Property";
        if (node.kind === "method") node.kind = "init";
        node.shorthand = false;
      }
      return (node: any);
    }
    parseObjectProperty(
      prop: N.ObjectProperty,
      startPos: ?number,
      startLoc: ?Position,
      isPattern: boolean,
      refShorthandDefaultPos: ?Pos,
    ): ?N.ObjectProperty {
      const node: N.EstreeProperty = (super.parseObjectProperty(
        prop,
        startPos,
        startLoc,
        isPattern,
        refShorthandDefaultPos,
      ): any);
      if (node) {
        node.kind = "init";
        node.type = "Property";
      }
      return (node: any);
    }
    toAssignable(
      node: N.Node,
      isBinding: ?boolean,
      contextDescription: string,
    ): N.Node {
      if (isSimpleProperty(node)) {
        this.toAssignable(node.value, isBinding, contextDescription);
        return node;
      }
      return super.toAssignable(node, isBinding, contextDescription);
    }
    toAssignableObjectExpressionProp(
      prop: N.Node,
      isBinding: ?boolean,
      isLast: boolean,
    ) {
      if (prop.kind === "get" || prop.kind === "set") {
        this.raise(
          prop.key.start,
          "Object pattern can't contain getter or setter",
        );
      } else if (prop.method) {
        this.raise(prop.key.start, "Object pattern can't contain methods");
      } else {
        super.toAssignableObjectExpressionProp(prop, isBinding, isLast);
      }
    }
  };

// </from> /home/qfox/apps/babel/packages/babel-parser/src/plugins/estree.js

// <from> /home/qfox/apps/babel/packages/babel-parser/src/parser/index.js

// @flow
import { getOptions } from "../options";
import StatementParser from "./statement";
export type PluginsMap = {
  [key: string]: { [option: string]: any },
};
export default class Parser extends StatementParser {
  // Forward-declaration so typescript plugin can override jsx plugin
  +jsxParseOpeningElementAfterName: (
    node: JSXOpeningElement,
  ) => JSXOpeningElement;
  constructor(options: ?Options, input: string) {
    options = getOptions(options);
    super(options, input);
    this.options = options;
    this.inModule = this.options.sourceType === "module";
    this.input = input;
    this.plugins = pluginsMap(this.options.plugins);
    this.filename = options.sourceFilename;
  }
  parse(): File {
    const file = this.startNode();
    const program = this.startNode();
    this.nextToken();
    return this.parseTopLevel(file, program);
  }
}
function pluginsMap(plugins: PluginList): PluginsMap {
  const pluginMap: PluginsMap = (Object.create(null): Object);
  for (const plugin of plugins) {
    const [name, options = {}] = Array.isArray(plugin) ? plugin : [plugin, {}];
    if (!pluginMap[name]) pluginMap[name] = options || {};
  }
  return pluginMap;
}

// </from> /home/qfox/apps/babel/packages/babel-parser/src/parser/index.js

// <from> /home/qfox/apps/babel/packages/babel-parser/src/parser/statement.js

// @flow
import * as N from "../types";
import { types as tt, type TokenType } from "../tokenizer/types";
import ExpressionParser from "./expression";
import { isIdentifierChar } from "../util/identifier";
import { lineBreak, skipWhiteSpace } from "../util/whitespace";
// Reused empty array added for node fields that are always empty.
const empty = [];
const loopLabel = { kind: "loop" },
  switchLabel = { kind: "switch" };
export default class StatementParser extends ExpressionParser {
  // ### Statement parsing
  // Parse a program. Initializes the parser, reads any number of
  // statements, and wraps them in a Program node.  Optionally takes a
  // `program` argument.  If present, the statements will be appended
  // to its body instead of creating a new node.
  parseTopLevel(file: N.File, program: N.Program): N.File {
    program.sourceType = this.options.sourceType;
    program.interpreter = this.parseInterpreterDirective();
    this.parseBlockBody(program, true, true, tt.eof);
    file.program = this.finishNode(program, "Program");
    file.comments = this.state.comments;
    if (this.options.tokens) file.tokens = this.state.tokens;
    return this.finishNode(file, "File");
  }
  // TODO
  stmtToDirective(stmt: N.Statement): N.Directive {
    const expr = stmt.expression;
    const directiveLiteral = this.startNodeAt(expr.start, expr.loc.start);
    const directive = this.startNodeAt(stmt.start, stmt.loc.start);
    const raw = this.input.slice(expr.start, expr.end);
    const val = (directiveLiteral.value = raw.slice(1, -1)); // remove quotes
    this.addExtra(directiveLiteral, "raw", raw);
    this.addExtra(directiveLiteral, "rawValue", val);
    directive.value = this.finishNodeAt(
      directiveLiteral,
      "DirectiveLiteral",
      expr.end,
      expr.loc.end,
    );
    return this.finishNodeAt(directive, "Directive", stmt.end, stmt.loc.end);
  }
  parseInterpreterDirective(): N.InterpreterDirective | null {
    if (!this.match(tt.interpreterDirective)) {
      return null;
    }
    const node = this.startNode();
    node.value = this.state.value;
    this.next();
    return this.finishNode(node, "InterpreterDirective");
  }
  // Parse a single statement.
  //
  // If expecting a statement and finding a slash operator, parse a
  // regular expression literal. This is to handle cases like
  // `if (foo) /blah/.exec(foo)`, where looking at the previous token
  // does not help.
  parseStatement(declaration: boolean, topLevel?: boolean): N.Statement {
    if (this.match(tt.at)) {
      this.parseDecorators(true);
    }
    return this.parseStatementContent(declaration, topLevel);
  }
  parseStatementContent(declaration: boolean, topLevel: ?boolean): N.Statement {
    const starttype = this.state.type;
    const node = this.startNode();
    // Most types of statements are recognized by the keyword they
    // start with. Many are trivial to parse, some require a bit of
    // complexity.
    switch (starttype) {
      case tt._break:
      case tt._continue:
        // $FlowFixMe
        return this.parseBreakContinueStatement(node, starttype.keyword);
      case tt._debugger:
        return this.parseDebuggerStatement(node);
      case tt._do:
        return this.parseDoStatement(node);
      case tt._for:
        return this.parseForStatement(node);
      case tt._function:
        if (this.lookahead().type === tt.dot) break;
        if (!declaration) this.unexpected();
        return this.parseFunctionStatement(node);
      case tt._class:
        if (!declaration) this.unexpected();
        return this.parseClass(node, true);
      case tt._if:
        return this.parseIfStatement(node);
      case tt._return:
        return this.parseReturnStatement(node);
      case tt._switch:
        return this.parseSwitchStatement(node);
      case tt._throw:
        return this.parseThrowStatement(node);
      case tt._try:
        return this.parseTryStatement(node);
      case tt._let:
      case tt._const:
        if (!declaration) this.unexpected(); // NOTE: falls through to _var
      case tt._var:
        return this.parseVarStatement(node, starttype);
      case tt._while:
        return this.parseWhileStatement(node);
      case tt._with:
        return this.parseWithStatement(node);
      case tt.braceL:
        return this.parseBlock();
      case tt.semi:
        return this.parseEmptyStatement(node);
      case tt._export:
      case tt._import: {
        const nextToken = this.lookahead();
        if (nextToken.type === tt.parenL || nextToken.type === tt.dot) {
          break;
        }
        if (!this.options.allowImportExportEverywhere && !topLevel) {
          this.raise(
            this.state.start,
            "'import' and 'export' may only appear at the top level",
          );
        }
        this.next();
        let result;
        if (starttype == tt._import) {
          result = this.parseImport(node);
          if (
            result.type === "ImportDeclaration" &&
            (!result.importKind || result.importKind === "value")
          ) {
            this.sawUnambiguousESM = true;
          }
        } else {
          result = this.parseExport(node);
          if (
            (result.type === "ExportNamedDeclaration" &&
              (!result.exportKind || result.exportKind === "value")) ||
            (result.type === "ExportAllDeclaration" &&
              (!result.exportKind || result.exportKind === "value")) ||
            result.type === "ExportDefaultDeclaration"
          ) {
            this.sawUnambiguousESM = true;
          }
        }
        this.assertModuleNodeAllowed(node);
        return result;
      }
      case tt.name:
        if (this.isContextual("async")) {
          // peek ahead and see if next token is a function
          const state = this.state.clone();
          this.next();
          if (this.match(tt._function) && !this.canInsertSemicolon()) {
            this.expect(tt._function);
            return this.parseFunction(node, true, false, true);
          } else {
            this.state = state;
          }
        }
    }
    // If the statement does not start with a statement keyword or a
    // brace, it's an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.
    const maybeName = this.state.value;
    const expr = this.parseExpression();
    if (
      starttype === tt.name &&
      expr.type === "Identifier" &&
      this.eat(tt.colon)
    ) {
      return this.parseLabeledStatement(node, maybeName, expr);
    } else {
      return this.parseExpressionStatement(node, expr);
    }
  }
  assertModuleNodeAllowed(node: N.Node): void {
    if (!this.options.allowImportExportEverywhere && !this.inModule) {
      this.raise(
        node.start,
        `'import' and 'export' may appear only with 'sourceType: "module"'`,
        {
          code: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED",
        },
      );
    }
  }
  takeDecorators(node: N.HasDecorators): void {
    const decorators = this.state.decoratorStack[
      this.state.decoratorStack.length - 1
    ];
    if (decorators.length) {
      node.decorators = decorators;
      this.resetStartLocationFromNode(node, decorators[0]);
      this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];
    }
  }
  canHaveLeadingDecorator(): boolean {
    return this.match(tt._class);
  }
  parseDecorators(allowExport?: boolean): void {
    const currentContextDecorators = this.state.decoratorStack[
      this.state.decoratorStack.length - 1
    ];
    while (this.match(tt.at)) {
      const decorator = this.parseDecorator();
      currentContextDecorators.push(decorator);
    }
    if (this.match(tt._export)) {
      if (!allowExport) {
        this.unexpected();
      }
      if (
        this.hasPlugin("decorators") &&
        !this.getPluginOption("decorators", "decoratorsBeforeExport")
      ) {
        this.raise(
          this.state.start,
          "Using the export keyword between a decorator and a class is not allowed. " +
            "Please use `export @dec class` instead.",
        );
      }
    } else if (!this.canHaveLeadingDecorator()) {
      this.raise(
        this.state.start,
        "Leading decorators must be attached to a class declaration",
      );
    }
  }
  parseDecorator(): N.Decorator {
    this.expectOnePlugin(["decorators-legacy", "decorators"]);
    const node = this.startNode();
    this.next();
    if (this.hasPlugin("decorators")) {
      // Every time a decorator class expression is evaluated, a new empty array is pushed onto the stack
      // So that the decorators of any nested class expressions will be dealt with separately
      this.state.decoratorStack.push([]);
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      let expr: N.Expression;
      if (this.eat(tt.parenL)) {
        expr = this.parseExpression();
        this.expect(tt.parenR);
      } else {
        expr = this.parseIdentifier(false);
        while (this.eat(tt.dot)) {
          const node = this.startNodeAt(startPos, startLoc);
          node.object = expr;
          node.property = this.parseIdentifier(true);
          node.computed = false;
          expr = this.finishNode(node, "MemberExpression");
        }
      }
      node.expression = this.parseMaybeDecoratorArguments(expr);
      this.state.decoratorStack.pop();
    } else {
      node.expression = this.parseMaybeAssign();
    }
    return this.finishNode(node, "Decorator");
  }
  parseMaybeDecoratorArguments(expr: N.Expression): N.Expression {
    if (this.eat(tt.parenL)) {
      const node = this.startNodeAtNode(expr);
      node.callee = expr;
      node.arguments = this.parseCallExpressionArguments(tt.parenR, false);
      this.toReferencedList(node.arguments);
      return this.finishNode(node, "CallExpression");
    }
    return expr;
  }
  parseBreakContinueStatement(
    node: N.BreakStatement | N.ContinueStatement,
    keyword: string,
  ): N.BreakStatement | N.ContinueStatement {
    const isBreak = keyword === "break";
    this.next();
    if (this.isLineTerminator()) {
      node.label = null;
    } else if (!this.match(tt.name)) {
      this.unexpected();
    } else {
      node.label = this.parseIdentifier();
      this.semicolon();
    }
    // Verify that there is an actual destination to break or
    // continue to.
    let i;
    for (i = 0; i < this.state.labels.length; ++i) {
      const lab = this.state.labels[i];
      if (node.label == null || lab.name === node.label.name) {
        if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
        if (node.label && isBreak) break;
      }
    }
    if (i === this.state.labels.length) {
      this.raise(node.start, "Unsyntactic " + keyword);
    }
    return this.finishNode(
      node,
      isBreak ? "BreakStatement" : "ContinueStatement",
    );
  }
  parseDebuggerStatement(node: N.DebuggerStatement): N.DebuggerStatement {
    this.next();
    this.semicolon();
    return this.finishNode(node, "DebuggerStatement");
  }
  parseDoStatement(node: N.DoWhileStatement): N.DoWhileStatement {
    this.next();
    this.state.labels.push(loopLabel);
    node.body = this.parseStatement(false);
    this.state.labels.pop();
    this.expect(tt._while);
    node.test = this.parseParenExpression();
    this.eat(tt.semi);
    return this.finishNode(node, "DoWhileStatement");
  }
  // Disambiguating between a `for` and a `for`/`in` or `for`/`of`
  // loop is non-trivial. Basically, we have to parse the init `var`
  // statement or expression, disallowing the `in` operator (see
  // the second parameter to `parseExpression`), and then check
  // whether the next token is `in` or `of`. When there is no init
  // part (semicolon immediately after the opening parenthesis), it
  // is a regular `for` loop.
  parseForStatement(node: N.Node): N.ForLike {
    this.next();
    this.state.labels.push(loopLabel);
    let forAwait = false;
    if (this.state.inAsync && this.isContextual("await")) {
      this.expectPlugin("asyncGenerators");
      forAwait = true;
      this.next();
    }
    this.expect(tt.parenL);
    if (this.match(tt.semi)) {
      if (forAwait) {
        this.unexpected();
      }
      return this.parseFor(node, null);
    }
    if (this.match(tt._var) || this.match(tt._let) || this.match(tt._const)) {
      const init = this.startNode();
      const varKind = this.state.type;
      this.next();
      this.parseVar(init, true, varKind);
      this.finishNode(init, "VariableDeclaration");
      if (this.match(tt._in) || this.isContextual("of")) {
        if (init.declarations.length === 1) {
          const declaration = init.declarations[0];
          const isForInInitializer =
            varKind === tt._var &&
            declaration.init &&
            declaration.id.type != "ObjectPattern" &&
            declaration.id.type != "ArrayPattern" &&
            !this.isContextual("of");
          if (this.state.strict && isForInInitializer) {
            this.raise(this.state.start, "for-in initializer in strict mode");
          } else if (isForInInitializer || !declaration.init) {
            return this.parseForIn(node, init, forAwait);
          }
        }
      }
      if (forAwait) {
        this.unexpected();
      }
      return this.parseFor(node, init);
    }
    const refShorthandDefaultPos = { start: 0 };
    const init = this.parseExpression(true, refShorthandDefaultPos);
    if (this.match(tt._in) || this.isContextual("of")) {
      const description = this.isContextual("of")
        ? "for-of statement"
        : "for-in statement";
      this.toAssignable(init, undefined, description);
      this.checkLVal(init, undefined, undefined, description);
      return this.parseForIn(node, init, forAwait);
    } else if (refShorthandDefaultPos.start) {
      this.unexpected(refShorthandDefaultPos.start);
    }
    if (forAwait) {
      this.unexpected();
    }
    return this.parseFor(node, init);
  }
  parseFunctionStatement(node: N.FunctionDeclaration): N.FunctionDeclaration {
    this.next();
    return this.parseFunction(node, true);
  }
  parseIfStatement(node: N.IfStatement): N.IfStatement {
    this.next();
    node.test = this.parseParenExpression();
    node.consequent = this.parseStatement(false);
    node.alternate = this.eat(tt._else) ? this.parseStatement(false) : null;
    return this.finishNode(node, "IfStatement");
  }
  parseReturnStatement(node: N.ReturnStatement): N.ReturnStatement {
    if (!this.state.inFunction && !this.options.allowReturnOutsideFunction) {
      this.raise(this.state.start, "'return' outside of function");
    }
    this.next();
    // In `return` (and `break`/`continue`), the keywords with
    // optional arguments, we eagerly look for a semicolon or the
    // possibility to insert one.
    if (this.isLineTerminator()) {
      node.argument = null;
    } else {
      node.argument = this.parseExpression();
      this.semicolon();
    }
    return this.finishNode(node, "ReturnStatement");
  }
  parseSwitchStatement(node: N.SwitchStatement): N.SwitchStatement {
    this.next();
    node.discriminant = this.parseParenExpression();
    const cases = (node.cases = []);
    this.expect(tt.braceL);
    this.state.labels.push(switchLabel);
    // Statements under must be grouped (by label) in SwitchCase
    // nodes. `cur` is used to keep the node that we are currently
    // adding statements to.
    let cur;
    for (let sawDefault; !this.match(tt.braceR); ) {
      if (this.match(tt._case) || this.match(tt._default)) {
        const isCase = this.match(tt._case);
        if (cur) this.finishNode(cur, "SwitchCase");
        cases.push((cur = this.startNode()));
        cur.consequent = [];
        this.next();
        if (isCase) {
          cur.test = this.parseExpression();
        } else {
          if (sawDefault) {
            this.raise(this.state.lastTokStart, "Multiple default clauses");
          }
          sawDefault = true;
          cur.test = null;
        }
        this.expect(tt.colon);
      } else {
        if (cur) {
          cur.consequent.push(this.parseStatement(true));
        } else {
          this.unexpected();
        }
      }
    }
    if (cur) this.finishNode(cur, "SwitchCase");
    this.next(); // Closing brace
    this.state.labels.pop();
    return this.finishNode(node, "SwitchStatement");
  }
  parseThrowStatement(node: N.ThrowStatement): N.ThrowStatement {
    this.next();
    if (
      lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start))
    ) {
      this.raise(this.state.lastTokEnd, "Illegal newline after throw");
    }
    node.argument = this.parseExpression();
    this.semicolon();
    return this.finishNode(node, "ThrowStatement");
  }
  parseTryStatement(node: N.TryStatement): N.TryStatement {
    this.next();
    node.block = this.parseBlock();
    node.handler = null;
    if (this.match(tt._catch)) {
      const clause = this.startNode();
      this.next();
      if (this.match(tt.parenL)) {
        this.expect(tt.parenL);
        clause.param = this.parseBindingAtom();
        const clashes: any = Object.create(null);
        this.checkLVal(clause.param, true, clashes, "catch clause");
        this.expect(tt.parenR);
      } else {
        this.expectPlugin("optionalCatchBinding");
        clause.param = null;
      }
      clause.body = this.parseBlock();
      node.handler = this.finishNode(clause, "CatchClause");
    }
    node.guardedHandlers = empty;
    node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null;
    if (!node.handler && !node.finalizer) {
      this.raise(node.start, "Missing catch or finally clause");
    }
    return this.finishNode(node, "TryStatement");
  }
  parseVarStatement(
    node: N.VariableDeclaration,
    kind: TokenType,
  ): N.VariableDeclaration {
    this.next();
    this.parseVar(node, false, kind);
    this.semicolon();
    return this.finishNode(node, "VariableDeclaration");
  }
  parseWhileStatement(node: N.WhileStatement): N.WhileStatement {
    this.next();
    node.test = this.parseParenExpression();
    this.state.labels.push(loopLabel);
    node.body = this.parseStatement(false);
    this.state.labels.pop();
    return this.finishNode(node, "WhileStatement");
  }
  parseWithStatement(node: N.WithStatement): N.WithStatement {
    if (this.state.strict) {
      this.raise(this.state.start, "'with' in strict mode");
    }
    this.next();
    node.object = this.parseParenExpression();
    node.body = this.parseStatement(false);
    return this.finishNode(node, "WithStatement");
  }
  parseEmptyStatement(node: N.EmptyStatement): N.EmptyStatement {
    this.next();
    return this.finishNode(node, "EmptyStatement");
  }
  parseLabeledStatement(
    node: N.LabeledStatement,
    maybeName: string,
    expr: N.Identifier,
  ): N.LabeledStatement {
    for (const label of this.state.labels) {
      if (label.name === maybeName) {
        this.raise(expr.start, `Label '${maybeName}' is already declared`);
      }
    }
    const kind = this.state.type.isLoop
      ? "loop"
      : this.match(tt._switch)
        ? "switch"
        : null;
    for (let i = this.state.labels.length - 1; i >= 0; i--) {
      const label = this.state.labels[i];
      if (label.statementStart === node.start) {
        label.statementStart = this.state.start;
        label.kind = kind;
      } else {
        break;
      }
    }
    this.state.labels.push({
      name: maybeName,
      kind: kind,
      statementStart: this.state.start,
    });
    node.body = this.parseStatement(true);
    if (
      node.body.type == "ClassDeclaration" ||
      (node.body.type == "VariableDeclaration" && node.body.kind !== "var") ||
      (node.body.type == "FunctionDeclaration" &&
        (this.state.strict || node.body.generator || node.body.async))
    ) {
      this.raise(node.body.start, "Invalid labeled declaration");
    }
    this.state.labels.pop();
    node.label = expr;
    return this.finishNode(node, "LabeledStatement");
  }
  parseExpressionStatement(
    node: N.ExpressionStatement,
    expr: N.Expression,
  ): N.ExpressionStatement {
    node.expression = expr;
    this.semicolon();
    return this.finishNode(node, "ExpressionStatement");
  }
  // Parse a semicolon-enclosed block of statements, handling `"use
  // strict"` declarations when `allowStrict` is true (used for
  // function bodies).
  parseBlock(allowDirectives?: boolean): N.BlockStatement {
    const node = this.startNode();
    this.expect(tt.braceL);
    this.parseBlockBody(node, allowDirectives, false, tt.braceR);
    return this.finishNode(node, "BlockStatement");
  }
  isValidDirective(stmt: N.Statement): boolean {
    return (
      stmt.type === "ExpressionStatement" &&
      stmt.expression.type === "StringLiteral" &&
      !stmt.expression.extra.parenthesized
    );
  }
  parseBlockBody(
    node: N.BlockStatementLike,
    allowDirectives: ?boolean,
    topLevel: boolean,
    end: TokenType,
  ): void {
    const body = (node.body = []);
    const directives = (node.directives = []);
    this.parseBlockOrModuleBlockBody(
      body,
      allowDirectives ? directives : undefined,
      topLevel,
      end,
    );
  }
  // Undefined directives means that directives are not allowed.
  parseBlockOrModuleBlockBody(
    body: N.Statement[],
    directives: ?(N.Directive[]),
    topLevel: boolean,
    end: TokenType,
  ): void {
    let parsedNonDirective = false;
    let oldStrict;
    let octalPosition;
    while (!this.eat(end)) {
      if (!parsedNonDirective && this.state.containsOctal && !octalPosition) {
        octalPosition = this.state.octalPosition;
      }
      const stmt = this.parseStatement(true, topLevel);
      if (directives && !parsedNonDirective && this.isValidDirective(stmt)) {
        const directive = this.stmtToDirective(stmt);
        directives.push(directive);
        if (oldStrict === undefined && directive.value.value === "use strict") {
          oldStrict = this.state.strict;
          this.setStrict(true);
          if (octalPosition) {
            this.raise(octalPosition, "Octal literal in strict mode");
          }
        }
        continue;
      }
      parsedNonDirective = true;
      body.push(stmt);
    }
    if (oldStrict === false) {
      this.setStrict(false);
    }
  }
  // Parse a regular `for` loop. The disambiguation code in
  // `parseStatement` will already have parsed the init statement or
  // expression.
  parseFor(
    node: N.ForStatement,
    init: ?(N.VariableDeclaration | N.Expression),
  ): N.ForStatement {
    node.init = init;
    this.expect(tt.semi);
    node.test = this.match(tt.semi) ? null : this.parseExpression();
    this.expect(tt.semi);
    node.update = this.match(tt.parenR) ? null : this.parseExpression();
    this.expect(tt.parenR);
    node.body = this.parseStatement(false);
    this.state.labels.pop();
    return this.finishNode(node, "ForStatement");
  }
  // Parse a `for`/`in` and `for`/`of` loop, which are almost
  // same from parser's perspective.
  parseForIn(
    node: N.ForInOf,
    init: N.VariableDeclaration,
    forAwait: boolean,
  ): N.ForInOf {
    const type = this.match(tt._in) ? "ForInStatement" : "ForOfStatement";
    if (forAwait) {
      this.eatContextual("of");
    } else {
      this.next();
    }
    if (type === "ForOfStatement") {
      node.await = !!forAwait;
    }
    node.left = init;
    node.right = this.parseExpression();
    this.expect(tt.parenR);
    node.body = this.parseStatement(false);
    this.state.labels.pop();
    return this.finishNode(node, type);
  }
  // Parse a list of variable declarations.
  parseVar(
    node: N.VariableDeclaration,
    isFor: boolean,
    kind: TokenType,
  ): N.VariableDeclaration {
    const declarations = (node.declarations = []);
    // $FlowFixMe
    node.kind = kind.keyword;
    for (;;) {
      const decl = this.startNode();
      this.parseVarHead(decl);
      if (this.eat(tt.eq)) {
        decl.init = this.parseMaybeAssign(isFor);
      } else {
        if (
          kind === tt._const &&
          !(this.match(tt._in) || this.isContextual("of"))
        ) {
          // `const` with no initializer is allowed in TypeScript.
          // It could be a declaration like `const x: number;`.
          if (!this.hasPlugin("typescript")) {
            this.unexpected();
          }
        } else if (
          decl.id.type !== "Identifier" &&
          !(isFor && (this.match(tt._in) || this.isContextual("of")))
        ) {
          this.raise(
            this.state.lastTokEnd,
            "Complex binding patterns require an initialization value",
          );
        }
        decl.init = null;
      }
      declarations.push(this.finishNode(decl, "VariableDeclarator"));
      if (!this.eat(tt.comma)) break;
    }
    return node;
  }
  parseVarHead(decl: N.VariableDeclarator): void {
    decl.id = this.parseBindingAtom();
    this.checkLVal(decl.id, true, undefined, "variable declaration");
  }
  // Parse a function declaration or literal (depending on the
  // `isStatement` parameter).
  parseFunction<T: N.NormalFunction>(
    node: T,
    isStatement: boolean,
    allowExpressionBody?: boolean,
    isAsync?: boolean,
    optionalId?: boolean,
  ): T {
    const oldInFunc = this.state.inFunction;
    const oldInMethod = this.state.inMethod;
    const oldInGenerator = this.state.inGenerator;
    const oldInClassProperty = this.state.inClassProperty;
    this.state.inFunction = true;
    this.state.inMethod = false;
    this.state.inClassProperty = false;
    this.initFunction(node, isAsync);
    if (this.match(tt.star)) {
      if (node.async) {
        this.expectPlugin("asyncGenerators");
      }
      node.generator = true;
      this.next();
    }
    if (
      isStatement &&
      !optionalId &&
      !this.match(tt.name) &&
      !this.match(tt._yield)
    ) {
      this.unexpected();
    }
    // When parsing function expression, the binding identifier is parsed
    // according to the rules inside the function.
    // e.g. (function* yield() {}) is invalid because "yield" is disallowed in
    // generators.
    // This isn't the case with function declarations: function* yield() {} is
    // valid because yield is parsed as if it was outside the generator.
    // Therefore, this.state.inGenerator is set before or after parsing the
    // function id according to the "isStatement" parameter.
    if (!isStatement) this.state.inGenerator = node.generator;
    if (this.match(tt.name) || this.match(tt._yield)) {
      node.id = this.parseBindingIdentifier();
    }
    if (isStatement) this.state.inGenerator = node.generator;
    this.parseFunctionParams(node);
    this.parseFunctionBodyAndFinish(
      node,
      isStatement ? "FunctionDeclaration" : "FunctionExpression",
      allowExpressionBody,
    );
    this.state.inFunction = oldInFunc;
    this.state.inMethod = oldInMethod;
    this.state.inGenerator = oldInGenerator;
    this.state.inClassProperty = oldInClassProperty;
    return node;
  }
  parseFunctionParams(node: N.Function, allowModifiers?: boolean): void {
    const oldInParameters = this.state.inParameters;
    this.state.inParameters = true;
    this.expect(tt.parenL);
    node.params = this.parseBindingList(
      tt.parenR,
      /* allowEmpty */ false,
      allowModifiers,
    );
    this.state.inParameters = oldInParameters;
  }
  // Parse a class declaration or literal (depending on the
  // `isStatement` parameter).
  parseClass<T: N.Class>(
    node: T,
    isStatement: /* T === ClassDeclaration */ boolean,
    optionalId?: boolean,
  ): T {
    this.next();
    this.takeDecorators(node);
    this.parseClassId(node, isStatement, optionalId);
    this.parseClassSuper(node);
    this.parseClassBody(node);
    return this.finishNode(
      node,
      isStatement ? "ClassDeclaration" : "ClassExpression",
    );
  }
  isClassProperty(): boolean {
    return this.match(tt.eq) || this.match(tt.semi) || this.match(tt.braceR);
  }
  isClassMethod(): boolean {
    return this.match(tt.parenL);
  }
  isNonstaticConstructor(method: N.ClassMethod | N.ClassProperty): boolean {
    return (
      !method.computed &&
      !method.static &&
      (method.key.name === "constructor" || // Identifier
        method.key.value === "constructor") // String literal
    );
  }
  parseClassBody(node: N.Class): void {
    // class bodies are implicitly strict
    const oldStrict = this.state.strict;
    this.state.strict = true;
    this.state.classLevel++;
    const state = { hadConstructor: false };
    let decorators: N.Decorator[] = [];
    const classBody: N.ClassBody = this.startNode();
    classBody.body = [];
    this.expect(tt.braceL);
    while (!this.eat(tt.braceR)) {
      if (this.eat(tt.semi)) {
        if (decorators.length > 0) {
          this.raise(
            this.state.lastTokEnd,
            "Decorators must not be followed by a semicolon",
          );
        }
        continue;
      }
      if (this.match(tt.at)) {
        decorators.push(this.parseDecorator());
        continue;
      }
      const member = this.startNode();
      // steal the decorators if there are any
      if (decorators.length) {
        member.decorators = decorators;
        this.resetStartLocationFromNode(member, decorators[0]);
        decorators = [];
      }
      this.parseClassMember(classBody, member, state);
      if (
        member.kind === "constructor" &&
        member.decorators &&
        member.decorators.length > 0
      ) {
        this.raise(
          member.start,
          "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
        );
      }
    }
    if (decorators.length) {
      this.raise(
        this.state.start,
        "You have trailing decorators with no method",
      );
    }
    node.body = this.finishNode(classBody, "ClassBody");
    this.state.classLevel--;
    this.state.strict = oldStrict;
  }
  parseClassMember(
    classBody: N.ClassBody,
    member: N.ClassMember,
    state: { hadConstructor: boolean },
  ): void {
    let isStatic = false;
    const containsEsc = this.state.containsEsc;
    if (this.match(tt.name) && this.state.value === "static") {
      const key = this.parseIdentifier(true); // eats 'static'
      if (this.isClassMethod()) {
        const method: N.ClassMethod = (member: any);
        // a method named 'static'
        method.kind = "method";
        method.computed = false;
        method.key = key;
        method.static = false;
        this.pushClassMethod(
          classBody,
          method,
          false,
          false,
          /* isConstructor */ false,
        );
        return;
      } else if (this.isClassProperty()) {
        const prop: N.ClassProperty = (member: any);
        // a property named 'static'
        prop.computed = false;
        prop.key = key;
        prop.static = false;
        classBody.body.push(this.parseClassProperty(prop));
        return;
      } else if (containsEsc) {
        throw this.unexpected();
      }
      // otherwise something static
      isStatic = true;
    }
    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
  }
  parseClassMemberWithIsStatic(
    classBody: N.ClassBody,
    member: N.ClassMember,
    state: { hadConstructor: boolean },
    isStatic: boolean,
  ) {
    const publicMethod: $FlowSubtype<N.ClassMethod> = member;
    const privateMethod: $FlowSubtype<N.ClassPrivateMethod> = member;
    const publicProp: $FlowSubtype<N.ClassMethod> = member;
    const privateProp: $FlowSubtype<N.ClassPrivateMethod> = member;
    const method: typeof publicMethod | typeof privateMethod = publicMethod;
    const publicMember: typeof publicMethod | typeof publicProp = publicMethod;
    member.static = isStatic;
    if (this.eat(tt.star)) {
      // a generator
      method.kind = "method";
      this.parseClassPropertyName(method);
      if (method.key.type === "PrivateName") {
        // Private generator method
        this.pushClassPrivateMethod(classBody, privateMethod, true, false);
        return;
      }
      if (this.isNonstaticConstructor(publicMethod)) {
        this.raise(publicMethod.key.start, "Constructor can't be a generator");
      }
      this.pushClassMethod(
        classBody,
        publicMethod,
        true,
        false,
        /* isConstructor */ false,
      );
      return;
    }
    const key = this.parseClassPropertyName(member);
    const isPrivate = key.type === "PrivateName";
    // Check the key is not a computed expression or string literal.
    const isSimple = key.type === "Identifier";
    this.parsePostMemberNameModifiers(publicMember);
    if (this.isClassMethod()) {
      method.kind = "method";
      if (isPrivate) {
        this.pushClassPrivateMethod(classBody, privateMethod, false, false);
        return;
      }
      // a normal method
      const isConstructor = this.isNonstaticConstructor(publicMethod);
      if (isConstructor) {
        publicMethod.kind = "constructor";
        if (publicMethod.decorators) {
          this.raise(
            publicMethod.start,
            "You can't attach decorators to a class constructor",
          );
        }
        // TypeScript allows multiple overloaded constructor declarations.
        if (state.hadConstructor && !this.hasPlugin("typescript")) {
          this.raise(key.start, "Duplicate constructor in the same class");
        }
        state.hadConstructor = true;
      }
      this.pushClassMethod(
        classBody,
        publicMethod,
        false,
        false,
        isConstructor,
      );
    } else if (this.isClassProperty()) {
      if (isPrivate) {
        this.pushClassPrivateProperty(classBody, privateProp);
      } else {
        this.pushClassProperty(classBody, publicProp);
      }
    } else if (isSimple && key.name === "async" && !this.isLineTerminator()) {
      // an async method
      const isGenerator = this.match(tt.star);
      if (isGenerator) {
        this.expectPlugin("asyncGenerators");
        this.next();
      }
      method.kind = "method";
      // The so-called parsed name would have been "async": get the real name.
      this.parseClassPropertyName(method);
      if (method.key.type === "PrivateName") {
        // private async method
        this.pushClassPrivateMethod(
          classBody,
          privateMethod,
          isGenerator,
          true,
        );
      } else {
        if (this.isNonstaticConstructor(publicMethod)) {
          this.raise(
            publicMethod.key.start,
            "Constructor can't be an async function",
          );
        }
        this.pushClassMethod(
          classBody,
          publicMethod,
          isGenerator,
          true,
          /* isConstructor */ false,
        );
      }
    } else if (
      isSimple &&
      (key.name === "get" || key.name === "set") &&
      !(this.isLineTerminator() && this.match(tt.star))
    ) {
      // `get\n*` is an uninitialized property named 'get' followed by a generator.
      // a getter or setter
      method.kind = key.name;
      // The so-called parsed name would have been "get/set": get the real name.
      this.parseClassPropertyName(publicMethod);
      if (method.key.type === "PrivateName") {
        // private getter/setter
        this.pushClassPrivateMethod(classBody, privateMethod, false, false);
      } else {
        if (this.isNonstaticConstructor(publicMethod)) {
          this.raise(
            publicMethod.key.start,
            "Constructor can't have get/set modifier",
          );
        }
        this.pushClassMethod(
          classBody,
          publicMethod,
          false,
          false,
          /* isConstructor */ false,
        );
      }
      this.checkGetterSetterParams(publicMethod);
    } else if (this.isLineTerminator()) {
      // an uninitialized class property (due to ASI, since we don't otherwise recognize the next token)
      if (isPrivate) {
        this.pushClassPrivateProperty(classBody, privateProp);
      } else {
        this.pushClassProperty(classBody, publicProp);
      }
    } else {
      this.unexpected();
    }
  }
  parseClassPropertyName(member: N.ClassMember): N.Expression | N.Identifier {
    const key = this.parsePropertyName(member);
    if (
      !member.computed &&
      member.static &&
      ((key: $FlowSubtype<N.Identifier>).name === "prototype" ||
        (key: $FlowSubtype<N.StringLiteral>).value === "prototype")
    ) {
      this.raise(
        key.start,
        "Classes may not have static property named prototype",
      );
    }
    if (key.type === "PrivateName" && key.id.name === "constructor") {
      this.raise(
        key.start,
        "Classes may not have a private field named '#constructor'",
      );
    }
    return key;
  }
  pushClassProperty(classBody: N.ClassBody, prop: N.ClassProperty) {
    // This only affects properties, not methods.
    if (this.isNonstaticConstructor(prop)) {
      this.raise(
        prop.key.start,
        "Classes may not have a non-static field named 'constructor'",
      );
    }
    classBody.body.push(this.parseClassProperty(prop));
  }
  pushClassPrivateProperty(
    classBody: N.ClassBody,
    prop: N.ClassPrivateProperty,
  ) {
    this.expectPlugin("classPrivateProperties", prop.key.start);
    classBody.body.push(this.parseClassPrivateProperty(prop));
  }
  pushClassMethod(
    classBody: N.ClassBody,
    method: N.ClassMethod,
    isGenerator: boolean,
    isAsync: boolean,
    isConstructor: boolean,
  ): void {
    classBody.body.push(
      this.parseMethod(
        method,
        isGenerator,
        isAsync,
        isConstructor,
        "ClassMethod",
      ),
    );
  }
  pushClassPrivateMethod(
    classBody: N.ClassBody,
    method: N.ClassPrivateMethod,
    isGenerator: boolean,
    isAsync: boolean,
  ): void {
    this.expectPlugin("classPrivateMethods", method.key.start);
    classBody.body.push(
      this.parseMethod(
        method,
        isGenerator,
        isAsync,
        /* isConstructor */ false,
        "ClassPrivateMethod",
      ),
    );
  }
  // Overridden in typescript.js
  parsePostMemberNameModifiers(
    // eslint-disable-next-line no-unused-vars
    methodOrProp: N.ClassMethod | N.ClassProperty,
  ): void {}
  // Overridden in typescript.js
  parseAccessModifier(): ?N.Accessibility {
    return undefined;
  }
  parseClassPrivateProperty(
    node: N.ClassPrivateProperty,
  ): N.ClassPrivateProperty {
    const oldInMethod = this.state.inMethod;
    this.state.inMethod = false;
    this.state.inClassProperty = true;
    node.value = this.eat(tt.eq) ? this.parseMaybeAssign() : null;
    this.semicolon();
    this.state.inClassProperty = false;
    this.state.inMethod = oldInMethod;
    return this.finishNode(node, "ClassPrivateProperty");
  }
  parseClassProperty(node: N.ClassProperty): N.ClassProperty {
    if (!node.typeAnnotation) {
      this.expectPlugin("classProperties");
    }
    const oldInMethod = this.state.inMethod;
    this.state.inMethod = false;
    this.state.inClassProperty = true;
    if (this.match(tt.eq)) {
      this.expectPlugin("classProperties");
      this.next();
      node.value = this.parseMaybeAssign();
    } else {
      node.value = null;
    }
    this.semicolon();
    this.state.inClassProperty = false;
    this.state.inMethod = oldInMethod;
    return this.finishNode(node, "ClassProperty");
  }
  parseClassId(
    node: N.Class,
    isStatement: boolean,
    optionalId: ?boolean,
  ): void {
    if (this.match(tt.name)) {
      node.id = this.parseIdentifier();
    } else {
      if (optionalId || !isStatement) {
        node.id = null;
      } else {
        this.unexpected(null, "A class name is required");
      }
    }
  }
  parseClassSuper(node: N.Class): void {
    node.superClass = this.eat(tt._extends) ? this.parseExprSubscripts() : null;
  }
  // Parses module export declaration.
  // TODO: better type. Node is an N.AnyExport.
  parseExport(node: N.Node): N.Node {
    // export * from '...'
    if (this.shouldParseExportStar()) {
      this.parseExportStar(node);
      if (node.type === "ExportAllDeclaration") return node;
    } else if (this.isExportDefaultSpecifier()) {
      this.expectPlugin("exportDefaultFrom");
      const specifier = this.startNode();
      specifier.exported = this.parseIdentifier(true);
      const specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
      node.specifiers = specifiers;
      if (this.match(tt.comma) && this.lookahead().type === tt.star) {
        this.expect(tt.comma);
        const specifier = this.startNode();
        this.expect(tt.star);
        this.expectContextual("as");
        specifier.exported = this.parseIdentifier();
        specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
      } else {
        this.parseExportSpecifiersMaybe(node);
      }
      this.parseExportFrom(node, true);
    } else if (this.eat(tt._default)) {
      // export default ...
      node.declaration = this.parseExportDefaultExpression();
      this.checkExport(node, true, true);
      return this.finishNode(node, "ExportDefaultDeclaration");
    } else if (this.shouldParseExportDeclaration()) {
      if (this.isContextual("async")) {
        const next = this.lookahead();
        // export async;
        if (next.type !== tt._function) {
          this.unexpected(next.start, `Unexpected token, expected "function"`);
        }
      }
      node.specifiers = [];
      node.source = null;
      node.declaration = this.parseExportDeclaration(node);
    } else {
      // export { x, y as z } [from '...']
      node.declaration = null;
      node.specifiers = this.parseExportSpecifiers();
      this.parseExportFrom(node);
    }
    this.checkExport(node, true);
    return this.finishNode(node, "ExportNamedDeclaration");
  }
  isAsyncFunction() {
    if (!this.isContextual("async")) return false;
    const { input, pos } = this.state;
    skipWhiteSpace.lastIndex = pos;
    const skip = skipWhiteSpace.exec(input);
    if (!skip || !skip.length) return false;
    const next = pos + skip[0].length;
    return (
      !lineBreak.test(input.slice(pos, next)) &&
      input.slice(next, next + 8) === "function" &&
      (next + 8 === input.length || !isIdentifierChar(input.charAt(next + 8)))
    );
  }
  parseExportDefaultExpression(): N.Expression | N.Declaration {
    const expr = this.startNode();
    const isAsync = this.isAsyncFunction();
    if (this.eat(tt._function) || isAsync) {
      if (isAsync) {
        this.eatContextual("async");
        this.expect(tt._function);
      }
      return this.parseFunction(expr, true, false, isAsync, true);
    } else if (this.match(tt._class)) {
      return this.parseClass(expr, true, true);
    } else if (this.match(tt.at)) {
      if (
        this.hasPlugin("decorators") &&
        this.getPluginOption("decorators", "decoratorsBeforeExport")
      ) {
        this.unexpected(
          this.state.start,
          "Decorators must be placed *before* the 'export' keyword." +
            " You can set the 'decoratorsBeforeExport' option to false to use" +
            " the 'export @decorator class {}' syntax",
        );
      }
      this.parseDecorators(false);
      return this.parseClass(expr, true, true);
    } else if (
      this.match(tt._let) ||
      this.match(tt._const) ||
      this.match(tt._var)
    ) {
      return this.raise(
        this.state.start,
        "Only expressions, functions or classes are allowed as the `default` export.",
      );
    } else {
      const res = this.parseMaybeAssign();
      this.semicolon();
      return res;
    }
  }
  // eslint-disable-next-line no-unused-vars
  parseExportDeclaration(node: N.ExportNamedDeclaration): ?N.Declaration {
    return this.parseStatement(true);
  }
  isExportDefaultSpecifier(): boolean {
    if (this.match(tt.name)) {
      return this.state.value !== "async";
    }
    if (!this.match(tt._default)) {
      return false;
    }
    const lookahead = this.lookahead();
    return (
      lookahead.type === tt.comma ||
      (lookahead.type === tt.name && lookahead.value === "from")
    );
  }
  parseExportSpecifiersMaybe(node: N.ExportNamedDeclaration): void {
    if (this.eat(tt.comma)) {
      node.specifiers = node.specifiers.concat(this.parseExportSpecifiers());
    }
  }
  parseExportFrom(node: N.ExportNamedDeclaration, expect?: boolean): void {
    if (this.eatContextual("from")) {
      node.source = this.match(tt.string)
        ? this.parseExprAtom()
        : this.unexpected();
      this.checkExport(node);
    } else {
      if (expect) {
        this.unexpected();
      } else {
        node.source = null;
      }
    }
    this.semicolon();
  }
  shouldParseExportStar(): boolean {
    return this.match(tt.star);
  }
  parseExportStar(node: N.ExportNamedDeclaration): void {
    this.expect(tt.star);
    if (this.isContextual("as")) {
      this.parseExportNamespace(node);
    } else {
      this.parseExportFrom(node, true);
      this.finishNode(node, "ExportAllDeclaration");
    }
  }
  parseExportNamespace(node: N.ExportNamedDeclaration): void {
    this.expectPlugin("exportNamespaceFrom");
    const specifier = this.startNodeAt(
      this.state.lastTokStart,
      this.state.lastTokStartLoc,
    );
    this.next();
    specifier.exported = this.parseIdentifier(true);
    node.specifiers = [this.finishNode(specifier, "ExportNamespaceSpecifier")];
    this.parseExportSpecifiersMaybe(node);
    this.parseExportFrom(node, true);
  }
  shouldParseExportDeclaration(): boolean {
    if (this.match(tt.at)) {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      if (this.hasPlugin("decorators")) {
        if (this.getPluginOption("decorators", "decoratorsBeforeExport")) {
          this.unexpected(
            this.state.start,
            "Decorators must be placed *before* the 'export' keyword." +
              " You can set the 'decoratorsBeforeExport' option to false to use" +
              " the 'export @decorator class {}' syntax",
          );
        } else {
          return true;
        }
      }
    }
    return (
      this.state.type.keyword === "var" ||
      this.state.type.keyword === "const" ||
      this.state.type.keyword === "let" ||
      this.state.type.keyword === "function" ||
      this.state.type.keyword === "class" ||
      this.isAsyncFunction()
    );
  }
  checkExport(
    node: N.ExportNamedDeclaration,
    checkNames: ?boolean,
    isDefault?: boolean,
  ): void {
    if (checkNames) {
      // Check for duplicate exports
      if (isDefault) {
        // Default exports
        this.checkDuplicateExports(node, "default");
      } else if (node.specifiers && node.specifiers.length) {
        // Named exports
        for (const specifier of node.specifiers) {
          this.checkDuplicateExports(specifier, specifier.exported.name);
        }
      } else if (node.declaration) {
        // Exported declarations
        if (
          node.declaration.type === "FunctionDeclaration" ||
          node.declaration.type === "ClassDeclaration"
        ) {
          const id = node.declaration.id;
          if (!id) throw new Error("Assertion failure");
          this.checkDuplicateExports(node, id.name);
        } else if (node.declaration.type === "VariableDeclaration") {
          for (const declaration of node.declaration.declarations) {
            this.checkDeclaration(declaration.id);
          }
        }
      }
    }
    const currentContextDecorators = this.state.decoratorStack[
      this.state.decoratorStack.length - 1
    ];
    if (currentContextDecorators.length) {
      const isClass =
        node.declaration &&
        (node.declaration.type === "ClassDeclaration" ||
          node.declaration.type === "ClassExpression");
      if (!node.declaration || !isClass) {
        throw this.raise(
          node.start,
          "You can only use decorators on an export when exporting a class",
        );
      }
      this.takeDecorators(node.declaration);
    }
  }
  checkDeclaration(node: N.Pattern | N.ObjectProperty): void {
    if (node.type === "ObjectPattern") {
      for (const prop of node.properties) {
        this.checkDeclaration(prop);
      }
    } else if (node.type === "ArrayPattern") {
      for (const elem of node.elements) {
        if (elem) {
          this.checkDeclaration(elem);
        }
      }
    } else if (node.type === "ObjectProperty") {
      this.checkDeclaration(node.value);
    } else if (node.type === "RestElement") {
      this.checkDeclaration(node.argument);
    } else if (node.type === "Identifier") {
      this.checkDuplicateExports(node, node.name);
    }
  }
  checkDuplicateExports(
    node: N.Identifier | N.ExportNamedDeclaration | N.ExportSpecifier,
    name: string,
  ): void {
    if (this.state.exportedIdentifiers.indexOf(name) > -1) {
      this.raiseDuplicateExportError(node, name);
    }
    this.state.exportedIdentifiers.push(name);
  }
  raiseDuplicateExportError(
    node: N.Identifier | N.ExportNamedDeclaration | N.ExportSpecifier,
    name: string,
  ): empty {
    throw this.raise(
      node.start,
      name === "default"
        ? "Only one default export allowed per module."
        : `\`${name}\` has already been exported. Exported identifiers must be unique.`,
    );
  }
  // Parses a comma-separated list of module exports.
  parseExportSpecifiers(): Array<N.ExportSpecifier> {
    const nodes = [];
    let first = true;
    let needsFrom;
    // export { x, y as z } [from '...']
    this.expect(tt.braceL);
    while (!this.eat(tt.braceR)) {
      if (first) {
        first = false;
      } else {
        this.expect(tt.comma);
        if (this.eat(tt.braceR)) break;
      }
      const isDefault = this.match(tt._default);
      if (isDefault && !needsFrom) needsFrom = true;
      const node = this.startNode();
      node.local = this.parseIdentifier(isDefault);
      node.exported = this.eatContextual("as")
        ? this.parseIdentifier(true)
        : node.local.__clone();
      nodes.push(this.finishNode(node, "ExportSpecifier"));
    }
    // https://github.com/ember-cli/ember-cli/pull/3739
    if (needsFrom && !this.isContextual("from")) {
      this.unexpected();
    }
    return nodes;
  }
  // Parses import declaration.
  parseImport(node: N.Node): N.ImportDeclaration | N.TsImportEqualsDeclaration {
    // import '...'
    if (this.match(tt.string)) {
      node.specifiers = [];
      node.source = this.parseExprAtom();
    } else {
      node.specifiers = [];
      this.parseImportSpecifiers(node);
      this.expectContextual("from");
      node.source = this.match(tt.string)
        ? this.parseExprAtom()
        : this.unexpected();
    }
    this.semicolon();
    return this.finishNode(node, "ImportDeclaration");
  }
  // eslint-disable-next-line no-unused-vars
  shouldParseDefaultImport(node: N.ImportDeclaration): boolean {
    return this.match(tt.name);
  }
  parseImportSpecifierLocal(
    node: N.ImportDeclaration,
    specifier: N.Node,
    type: string,
    contextDescription: string,
  ): void {
    specifier.local = this.parseIdentifier();
    this.checkLVal(specifier.local, true, undefined, contextDescription);
    node.specifiers.push(this.finishNode(specifier, type));
  }
  // Parses a comma-separated list of module imports.
  parseImportSpecifiers(node: N.ImportDeclaration): void {
    let first = true;
    if (this.shouldParseDefaultImport(node)) {
      // import defaultObj, { x, y as z } from '...'
      this.parseImportSpecifierLocal(
        node,
        this.startNode(),
        "ImportDefaultSpecifier",
        "default import specifier",
      );
      if (!this.eat(tt.comma)) return;
    }
    if (this.match(tt.star)) {
      const specifier = this.startNode();
      this.next();
      this.expectContextual("as");
      this.parseImportSpecifierLocal(
        node,
        specifier,
        "ImportNamespaceSpecifier",
        "import namespace specifier",
      );
      return;
    }
    this.expect(tt.braceL);
    while (!this.eat(tt.braceR)) {
      if (first) {
        first = false;
      } else {
        // Detect an attempt to deep destructure
        if (this.eat(tt.colon)) {
          this.unexpected(
            null,
            "ES2015 named imports do not destructure. " +
              "Use another statement for destructuring after the import.",
          );
        }
        this.expect(tt.comma);
        if (this.eat(tt.braceR)) break;
      }
      this.parseImportSpecifier(node);
    }
  }
  parseImportSpecifier(node: N.ImportDeclaration): void {
    const specifier = this.startNode();
    specifier.imported = this.parseIdentifier(true);
    if (this.eatContextual("as")) {
      specifier.local = this.parseIdentifier();
    } else {
      this.checkReservedWord(
        specifier.imported.name,
        specifier.start,
        true,
        true,
      );
      specifier.local = specifier.imported.__clone();
    }
    this.checkLVal(specifier.local, true, undefined, "import specifier");
    node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
  }
}

// </from> /home/qfox/apps/babel/packages/babel-parser/src/parser/statement.js

// <from> /home/qfox/apps/babel/packages/babel-parser/src/parser/location.js

// @flow
import { getLineInfo, type Position } from "../util/location";
import CommentsParser from "./comments";
// This function is used to raise exceptions on parse errors. It
// takes an offset integer (into the current `input`) to indicate
// the location of the error, attaches the position to the end
// of the error message, and then raises a `SyntaxError` with that
// message.
export default class LocationParser extends CommentsParser {
  raise(
    pos: number,
    message: string,
    {
      missingPluginNames,
      code,
    }: {
      missingPluginNames?: Array<string>,
      code?: string,
    } = {},
  ): empty {
    const loc = getLineInfo(this.input, pos);
    message += ` (${loc.line}:${loc.column})`;
    // $FlowIgnore
    const err: SyntaxError & { pos: number, loc: Position } = new SyntaxError(
      message,
    );
    err.pos = pos;
    err.loc = loc;
    if (missingPluginNames) {
      err.missingPlugin = missingPluginNames;
    }
    if (code !== undefined) {
      err.code = code;
    }
    throw err;
  }
}

// </from> /home/qfox/apps/babel/packages/babel-parser/src/parser/location.js

// <from> /home/qfox/apps/babel/packages/babel-parser/src/parser/lval.js

// @flow
import { types as tt, type TokenType } from "../tokenizer/types";
  TSParameterProperty,
  Decorator,
  Expression,
  Identifier,
  Node,
  ObjectExpression,
  ObjectPattern,
  Pattern,
  RestElement,
  SpreadElement,
} from "../types";
import { NodeUtils } from "./node";
export default class LValParser extends NodeUtils {
  // Forward-declaration: defined in expression.js
  +checkReservedWord: (
    word: string,
    startLoc: number,
    checkKeywords: boolean,
    isBinding: boolean,
  ) => void;
  +parseIdentifier: (liberal?: boolean) => Identifier;
  +parseMaybeAssign: (
    noIn?: ?boolean,
    refShorthandDefaultPos?: ?Pos,
    afterLeftParse?: Function,
    refNeedsArrowPos?: ?Pos,
  ) => Expression;
  +parseObj: <T: ObjectPattern | ObjectExpression>(
    isPattern: boolean,
    refShorthandDefaultPos?: ?Pos,
  ) => T;
  // Forward-declaration: defined in statement.js
  +parseDecorator: () => Decorator;
  // Convert existing expression atom to assignable pattern
  // if possible.
  toAssignable(
    node: Node,
    isBinding: ?boolean,
    contextDescription: string,
  ): Node {
    if (node) {
      switch (node.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
          break;
        case "ObjectExpression":
          node.type = "ObjectPattern";
          for (let index = 0; index < node.properties.length; index++) {
            const prop = node.properties[index];
            const isLast = index === node.properties.length - 1;
            this.toAssignableObjectExpressionProp(prop, isBinding, isLast);
          }
          break;
        case "ObjectProperty":
          this.toAssignable(node.value, isBinding, contextDescription);
          break;
        case "SpreadElement": {
          this.checkToRestConversion(node);
          node.type = "RestElement";
          const arg = node.argument;
          this.toAssignable(arg, isBinding, contextDescription);
          break;
        }
        case "ArrayExpression":
          node.type = "ArrayPattern";
          this.toAssignableList(node.elements, isBinding, contextDescription);
          break;
        case "AssignmentExpression":
          if (node.operator === "=") {
            node.type = "AssignmentPattern";
            delete node.operator;
          } else {
            this.raise(
              node.left.end,
              "Only '=' operator can be used for specifying default value.",
            );
          }
          break;
        case "MemberExpression":
          if (!isBinding) break;
        default: {
          const message =
            "Invalid left-hand side" +
            (contextDescription
              ? " in " + contextDescription
              : /* istanbul ignore next */ "expression");
          this.raise(node.start, message);
        }
      }
    }
    return node;
  }
  toAssignableObjectExpressionProp(
    prop: Node,
    isBinding: ?boolean,
    isLast: boolean,
  ) {
    if (prop.type === "ObjectMethod") {
      const error =
        prop.kind === "get" || prop.kind === "set"
          ? "Object pattern can't contain getter or setter"
          : "Object pattern can't contain methods";
      this.raise(prop.key.start, error);
    } else if (prop.type === "SpreadElement" && !isLast) {
      this.raise(
        prop.start,
        "The rest element has to be the last element when destructuring",
      );
    } else {
      this.toAssignable(prop, isBinding, "object destructuring pattern");
    }
  }
  // Convert list of expression atoms to binding list.
  toAssignableList(
    exprList: Expression[],
    isBinding: ?boolean,
    contextDescription: string,
  ): $ReadOnlyArray<Pattern> {
    let end = exprList.length;
    if (end) {
      const last = exprList[end - 1];
      if (last && last.type === "RestElement") {
        --end;
      } else if (last && last.type === "SpreadElement") {
        last.type = "RestElement";
        const arg = last.argument;
        this.toAssignable(arg, isBinding, contextDescription);
        if (
          [
            "Identifier",
            "MemberExpression",
            "ArrayPattern",
            "ObjectPattern",
          ].indexOf(arg.type) === -1
        ) {
          this.unexpected(arg.start);
        }
        --end;
      }
    }
    for (let i = 0; i < end; i++) {
      const elt = exprList[i];
      if (elt && elt.type === "SpreadElement") {
        this.raise(
          elt.start,
          "The rest element has to be the last element when destructuring",
        );
      }
      if (elt) this.toAssignable(elt, isBinding, contextDescription);
    }
    return exprList;
  }
  // Convert list of expression atoms to a list of
  toReferencedList(
    exprList: $ReadOnlyArray<?Expression>,
  ): $ReadOnlyArray<?Expression> {
    return exprList;
  }
  // Parses spread element.
  parseSpread<T: RestElement | SpreadElement>(
    refShorthandDefaultPos: ?Pos,
    refNeedsArrowPos?: ?Pos,
  ): T {
    const node = this.startNode();
    this.next();
    node.argument = this.parseMaybeAssign(
      false,
      refShorthandDefaultPos,
      undefined,
      refNeedsArrowPos,
    );
    return this.finishNode(node, "SpreadElement");
  }
  parseRest(): RestElement {
    const node = this.startNode();
    this.next();
    node.argument = this.parseBindingAtom();
    return this.finishNode(node, "RestElement");
  }
  shouldAllowYieldIdentifier(): boolean {
    return (
      this.match(tt._yield) && !this.state.strict && !this.state.inGenerator
    );
  }
  parseBindingIdentifier(): Identifier {
    return this.parseIdentifier(this.shouldAllowYieldIdentifier());
  }
  // Parses lvalue (assignable) atom.
  parseBindingAtom(): Pattern {
    switch (this.state.type) {
      case tt._yield:
      case tt.name:
        return this.parseBindingIdentifier();
      case tt.bracketL: {
        const node = this.startNode();
        this.next();
        node.elements = this.parseBindingList(tt.bracketR, true);
        return this.finishNode(node, "ArrayPattern");
      }
      case tt.braceL:
        return this.parseObj(true);
      default:
        throw this.unexpected();
    }
  }
  parseBindingList(
    close: TokenType,
    allowEmpty?: boolean,
    allowModifiers?: boolean,
  ): $ReadOnlyArray<Pattern | TSParameterProperty> {
    const elts: Array<Pattern | TSParameterProperty> = [];
    let first = true;
    while (!this.eat(close)) {
      if (first) {
        first = false;
      } else {
        this.expect(tt.comma);
      }
      if (allowEmpty && this.match(tt.comma)) {
        // $FlowFixMe This method returns `$ReadOnlyArray<?Pattern>` if `allowEmpty` is set.
        elts.push(null);
      } else if (this.eat(close)) {
        break;
      } else if (this.match(tt.ellipsis)) {
        elts.push(this.parseAssignableListItemTypes(this.parseRest()));
        this.expect(close);
        break;
      } else {
        const decorators = [];
        if (this.match(tt.at) && this.hasPlugin("decorators")) {
          this.raise(
            this.state.start,
            "Stage 2 decorators cannot be used to decorate parameters",
          );
        }
        while (this.match(tt.at)) {
          decorators.push(this.parseDecorator());
        }
        elts.push(this.parseAssignableListItem(allowModifiers, decorators));
      }
    }
    return elts;
  }
  parseAssignableListItem(
    allowModifiers: ?boolean,
    decorators: Decorator[],
  ): Pattern | TSParameterProperty {
    const left = this.parseMaybeDefault();
    this.parseAssignableListItemTypes(left);
    const elt = this.parseMaybeDefault(left.start, left.loc.start, left);
    if (decorators.length) {
      left.decorators = decorators;
    }
    return elt;
  }
  parseAssignableListItemTypes(param: Pattern): Pattern {
    return param;
  }
  // Parses assignment pattern around given atom if possible.
  parseMaybeDefault(
    startPos?: ?number,
    startLoc?: ?Position,
    left?: ?Pattern,
  ): Pattern {
    startLoc = startLoc || this.state.startLoc;
    startPos = startPos || this.state.start;
    left = left || this.parseBindingAtom();
    if (!this.eat(tt.eq)) return left;
    const node = this.startNodeAt(startPos, startLoc);
    node.left = left;
    node.right = this.parseMaybeAssign();
    return this.finishNode(node, "AssignmentPattern");
  }
  // Verify that a node is an lval  something that can be assigned
  // to.
  checkLVal(
    expr: Expression,
    isBinding: ?boolean,
    checkClashes: ?{ [key: string]: boolean },
    contextDescription: string,
  ): void {
    switch (expr.type) {
      case "Identifier":
        this.checkReservedWord(expr.name, expr.start, false, true);
        if (checkClashes) {
          // we need to prefix this with an underscore for the cases where we have a key of
          // `__proto__`. there's a bug in old V8 where the following wouldn't work:
          //
          //   > var obj = Object.create(null);
          //   undefined
          //   > obj.__proto__
          //   null
          //   > obj.__proto__ = true;
          //   true
          //   > obj.__proto__
          //   null
          const key = `_${expr.name}`;
          if (checkClashes[key]) {
            this.raise(expr.start, "Argument name clash in strict mode");
          } else {
            checkClashes[key] = true;
          }
        }
        break;
      case "MemberExpression":
        if (isBinding) this.raise(expr.start, "Binding member expression");
        break;
      case "ObjectPattern":
        for (let prop of expr.properties) {
          if (prop.type === "ObjectProperty") prop = prop.value;
          this.checkLVal(
            prop,
            isBinding,
            checkClashes,
            "object destructuring pattern",
          );
        }
        break;
      case "ArrayPattern":
        for (const elem of expr.elements) {
          if (elem) {
            this.checkLVal(
              elem,
              isBinding,
              checkClashes,
              "array destructuring pattern",
            );
          }
        }
        break;
      case "AssignmentPattern":
        this.checkLVal(
          expr.left,
          isBinding,
          checkClashes,
          "assignment pattern",
        );
        break;
      case "RestElement":
        this.checkLVal(expr.argument, isBinding, checkClashes, "rest element");
        break;
      default: {
        const message =
          (isBinding
            ? /* istanbul ignore next */ "Binding invalid"
            : "Invalid") +
          " left-hand side" +
          (contextDescription
            ? " in " + contextDescription
            : /* istanbul ignore next */ "expression");
        this.raise(expr.start, message);
      }
    }
  }
  checkToRestConversion(node: SpreadElement): void {
    const validArgumentTypes = ["Identifier", "MemberExpression"];
    if (validArgumentTypes.indexOf(node.argument.type) !== -1) {
      return;
    }
    this.raise(node.argument.start, "Invalid rest operator's argument");
  }
}

// </from> /home/qfox/apps/babel/packages/babel-parser/src/parser/lval.js

// <from> /home/qfox/apps/babel/packages/babel-parser/src/parser/util.js

// @flow
import { types as tt, type TokenType } from "../tokenizer/types";
import Tokenizer from "../tokenizer";
import { lineBreak } from "../util/whitespace";
// ## Parser utilities
export default class UtilParser extends Tokenizer {
  // TODO
  addExtra(node: Node, key: string, val: any): void {
    if (!node) return;
    const extra = (node.extra = node.extra || {});
    extra[key] = val;
  }
  // TODO
  isRelational(op: "<" | ">"): boolean {
    return this.match(tt.relational) && this.state.value === op;
  }
  isLookaheadRelational(op: "<" | ">"): boolean {
    const l = this.lookahead();
    return l.type == tt.relational && l.value == op;
  }
  // TODO
  expectRelational(op: "<" | ">"): void {
    if (this.isRelational(op)) {
      this.next();
    } else {
      this.unexpected(null, tt.relational);
    }
  }
  // eat() for relational operators.
  eatRelational(op: "<" | ">"): boolean {
    if (this.isRelational(op)) {
      this.next();
      return true;
    }
    return false;
  }
  // Tests whether parsed token is a contextual keyword.
  isContextual(name: string): boolean {
    return (
      this.match(tt.name) &&
      this.state.value === name &&
      !this.state.containsEsc
    );
  }
  isLookaheadContextual(name: string): boolean {
    const l = this.lookahead();
    return l.type === tt.name && l.value === name;
  }
  // Consumes contextual keyword if possible.
  eatContextual(name: string): boolean {
    return this.isContextual(name) && this.eat(tt.name);
  }
  // Asserts that following token is given contextual keyword.
  expectContextual(name: string, message?: string): void {
    if (!this.eatContextual(name)) this.unexpected(null, message);
  }
  // Test whether a semicolon can be inserted at the current position.
  canInsertSemicolon(): boolean {
    return (
      this.match(tt.eof) ||
      this.match(tt.braceR) ||
      this.hasPrecedingLineBreak()
    );
  }
  hasPrecedingLineBreak(): boolean {
    return lineBreak.test(
      this.input.slice(this.state.lastTokEnd, this.state.start),
    );
  }
  // TODO
  isLineTerminator(): boolean {
    return this.eat(tt.semi) || this.canInsertSemicolon();
  }
  // Consume a semicolon, or, failing that, see if we are allowed to
  // pretend that there is a semicolon at this position.
  semicolon(): void {
    if (!this.isLineTerminator()) this.unexpected(null, tt.semi);
  }
  // Expect a token of a given type. If found, consume it, otherwise,
  // raise an unexpected token error at given pos.
  expect(type: TokenType, pos?: ?number): void {
    this.eat(type) || this.unexpected(pos, type);
  }
  // Raise an unexpected token error. Can take the expected token type
  // instead of a message string.
  unexpected(
    pos: ?number,
    messageOrType: string | TokenType = "Unexpected token",
  ): empty {
    if (typeof messageOrType !== "string") {
      messageOrType = `Unexpected token, expected "${messageOrType.label}"`;
    }
    throw this.raise(pos != null ? pos : this.state.start, messageOrType);
  }
  expectPlugin(name: string, pos?: ?number): true {
    if (!this.hasPlugin(name)) {
      throw this.raise(
        pos != null ? pos : this.state.start,
        `This experimental syntax requires enabling the parser plugin: '${name}'`,
        { missingPluginNames: [name] },
      );
    }
    return true;
  }
  expectOnePlugin(names: Array<string>, pos?: ?number): void {
    if (!names.some(n => this.hasPlugin(n))) {
      throw this.raise(
        pos != null ? pos : this.state.start,
        `This experimental syntax requires enabling one of the following parser plugin(s): '${names.join(
          ", ",
        )}'`,
        { missingPluginNames: names },
      );
    }
  }
}

// </from> /home/qfox/apps/babel/packages/babel-parser/src/parser/util.js

// <from> /home/qfox/apps/babel/packages/babel-parser/src/parser/comments.js

// @flow
/**
 * Based on the comment attachment algorithm used in espree and estraverse.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
import BaseParser from "./base";
function last<T>(stack: $ReadOnlyArray<T>): T {
  return stack[stack.length - 1];
}
export default class CommentsParser extends BaseParser {
  addComment(comment: Comment): void {
    if (this.filename) comment.loc.filename = this.filename;
    this.state.trailingComments.push(comment);
    this.state.leadingComments.push(comment);
  }
  processComment(node: Node): void {
    if (node.type === "Program" && node.body.length > 0) return;
    const stack = this.state.commentStack;
    let firstChild, lastChild, trailingComments, i, j;
    if (this.state.trailingComments.length > 0) {
      // If the first comment in trailingComments comes after the
      // current node, then we're good - all comments in the array will
      // come after the node and so it's safe to add them as official
      // trailingComments.
      if (this.state.trailingComments[0].start >= node.end) {
        trailingComments = this.state.trailingComments;
        this.state.trailingComments = [];
      } else {
        // Otherwise, if the first comment doesn't come after the
        // current node, that means we have a mix of leading and trailing
        // comments in the array and that leadingComments contains the
        // same items as trailingComments. Reset trailingComments to
        // zero items and we'll handle this by evaluating leadingComments
        // later.
        this.state.trailingComments.length = 0;
      }
    } else if (stack.length > 0) {
      const lastInStack = last(stack);
      if (
        lastInStack.trailingComments &&
        lastInStack.trailingComments[0].start >= node.end
      ) {
        trailingComments = lastInStack.trailingComments;
        delete lastInStack.trailingComments;
      }
    }
    // Eating the stack.
    if (stack.length > 0 && last(stack).start >= node.start) {
      firstChild = stack.pop();
    }
    while (stack.length > 0 && last(stack).start >= node.start) {
      lastChild = stack.pop();
    }
    if (!lastChild && firstChild) lastChild = firstChild;
    // Attach comments that follow a trailing comma on the last
    // property in an object literal or a trailing comma in function arguments
    // as trailing comments
    if (firstChild && this.state.leadingComments.length > 0) {
      const lastComment = last(this.state.leadingComments);
      if (firstChild.type === "ObjectProperty") {
        if (lastComment.start >= node.start) {
          if (this.state.commentPreviousNode) {
            for (j = 0; j < this.state.leadingComments.length; j++) {
              if (
                this.state.leadingComments[j].end <
                this.state.commentPreviousNode.end
              ) {
                this.state.leadingComments.splice(j, 1);
                j--;
              }
            }
            if (this.state.leadingComments.length > 0) {
              firstChild.trailingComments = this.state.leadingComments;
              this.state.leadingComments = [];
            }
          }
        }
      } else if (
        node.type === "CallExpression" &&
        node.arguments &&
        node.arguments.length
      ) {
        const lastArg = last(node.arguments);
        if (
          lastArg &&
          lastComment.start >= lastArg.start &&
          lastComment.end <= node.end
        ) {
          if (this.state.commentPreviousNode) {
            for (j = 0; j < this.state.leadingComments.length; j++) {
              if (
                this.state.leadingComments[j].end <
                this.state.commentPreviousNode.end
              ) {
                this.state.leadingComments.splice(j, 1);
                j--;
              }
            }
            if (this.state.leadingComments.length > 0) {
              lastArg.trailingComments = this.state.leadingComments;
              this.state.leadingComments = [];
            }
          }
        }
      }
    }
    if (lastChild) {
      if (lastChild.leadingComments) {
        if (
          lastChild !== node &&
          lastChild.leadingComments.length > 0 &&
          last(lastChild.leadingComments).end <= node.start
        ) {
          node.leadingComments = lastChild.leadingComments;
          delete lastChild.leadingComments;
        } else {
          // A leading comment for an anonymous class had been stolen by its first ClassMethod,
          // so this takes back the leading comment.
          // See also: https://github.com/eslint/espree/issues/158
          for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {
            if (lastChild.leadingComments[i].end <= node.start) {
              node.leadingComments = lastChild.leadingComments.splice(0, i + 1);
              break;
            }
          }
        }
      }
    } else if (this.state.leadingComments.length > 0) {
      if (last(this.state.leadingComments).end <= node.start) {
        if (this.state.commentPreviousNode) {
          for (j = 0; j < this.state.leadingComments.length; j++) {
            if (
              this.state.leadingComments[j].end <
              this.state.commentPreviousNode.end
            ) {
              this.state.leadingComments.splice(j, 1);
              j--;
            }
          }
        }
        if (this.state.leadingComments.length > 0) {
          node.leadingComments = this.state.leadingComments;
          this.state.leadingComments = [];
        }
      } else {
        // https://github.com/eslint/espree/issues/2
        //
        // In special cases, such as return (without a value) and
        // debugger, all comments will end up as leadingComments and
        // will otherwise be eliminated. This step runs when the
        // commentStack is empty and there are comments left
        // in leadingComments.
        //
        // This loop figures out the stopping point between the actual
        // leading and trailing comments by finding the location of the
        // first comment that comes after the given node.
        for (i = 0; i < this.state.leadingComments.length; i++) {
          if (this.state.leadingComments[i].end > node.start) {
            break;
          }
        }
        // Split the array based on the location of the first comment
        // that comes after the node. Keep in mind that this could
        // result in an empty array, and if so, the array must be
        // deleted.
        const leadingComments = this.state.leadingComments.slice(0, i);
        if (leadingComments.length) {
          node.leadingComments = leadingComments;
        }
        // Similarly, trailing comments are attached later. The variable
        // must be reset to null if there are no trailing comments.
        trailingComments = this.state.leadingComments.slice(i);
        if (trailingComments.length === 0) {
          trailingComments = null;
        }
      }
    }
    this.state.commentPreviousNode = node;
    if (trailingComments) {
      if (
        trailingComments.length &&
        trailingComments[0].start >= node.start &&
        last(trailingComments).end <= node.end
      ) {
        node.innerComments = trailingComments;
      } else {
        node.trailingComments = trailingComments;
      }
    }
    stack.push(node);
  }
}

// </from> /home/qfox/apps/babel/packages/babel-parser/src/parser/comments.js

// <from> /home/qfox/apps/babel/packages/babel-parser/src/parser/expression.js

// @flow
// A recursive descent parser operates by defining functions for all
// syntactic elements, and recursively calling those, each function
// advancing the input stream and returning an AST node. Precedence
// of constructs (for example, the fact that `!x[1]` means `!(x[1])`
// instead of `(!x)[1]` is handled by the fact that the parser
// function that parses unary prefix operators is called first, and
// in turn calls the function that parses `[]` subscripts  that
// way, it'll receive the node for `x[1]` already parsed, and wraps
// *that* in the unary operator node.
//
// Acorn uses an [operator precedence parser][opp] to handle binary
// operator precedence, because it is much more compact than using
// the technique outlined above, which uses different, nesting
// functions to specify precedence, for all of the ten binary
// precedence levels that JavaScript defines.
//
// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser
import { types as tt, type TokenType } from "../tokenizer/types";
import * as N from "../types";
import LValParser from "./lval";
import { reservedWords } from "../util/identifier";
export default class ExpressionParser extends LValParser {
  // Forward-declaration: defined in statement.js
  +parseBlock: (allowDirectives?: boolean) => N.BlockStatement;
  +parseClass: (
    node: N.Class,
    isStatement: boolean,
    optionalId?: boolean,
  ) => N.Class;
  +parseDecorators: (allowExport?: boolean) => void;
  +parseFunction: <T: N.NormalFunction>(
    node: T,
    isStatement: boolean,
    allowExpressionBody?: boolean,
    isAsync?: boolean,
    optionalId?: boolean,
  ) => T;
  +parseFunctionParams: (node: N.Function, allowModifiers?: boolean) => void;
  +takeDecorators: (node: N.HasDecorators) => void;
  // Check if property name clashes with already added.
  // Object/class getters and setters are not allowed to clash 
  // either with each other or with an init property  and in
  // strict mode, init properties are also not allowed to be repeated.
  checkPropClash(
    prop: N.ObjectMember,
    propHash: { [key: string]: boolean },
  ): void {
    if (prop.computed || prop.kind) return;
    const key = prop.key;
    // It is either an Identifier or a String/NumericLiteral
    const name = key.type === "Identifier" ? key.name : String(key.value);
    if (name === "__proto__") {
      if (propHash.proto) {
        this.raise(key.start, "Redefinition of __proto__ property");
      }
      propHash.proto = true;
    }
  }
  // Convenience method to parse an Expression only
  getExpression(): N.Expression {
    this.nextToken();
    const expr = this.parseExpression();
    if (!this.match(tt.eof)) {
      this.unexpected();
    }
    expr.comments = this.state.comments;
    return expr;
  }
  // ### Expression parsing
  // These nest, from the most general expression type at the top to
  // 'atomic', nondivisible expression types at the bottom. Most of
  // the functions will simply let the function (s) below them parse,
  // and, *if* the syntactic construct they handle is present, wrap
  // the AST node that the inner parser gave them in another node.
  // Parse a full expression. The optional arguments are used to
  // forbid the `in` operator (in for loops initialization expressions)
  // and provide reference for storing '=' operator inside shorthand
  // property assignment in contexts where both object expression
  // and object pattern might appear (so it's possible to raise
  // delayed syntax error at correct position).
  parseExpression(noIn?: boolean, refShorthandDefaultPos?: Pos): N.Expression {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    const expr = this.parseMaybeAssign(noIn, refShorthandDefaultPos);
    if (this.match(tt.comma)) {
      const node = this.startNodeAt(startPos, startLoc);
      node.expressions = [expr];
      while (this.eat(tt.comma)) {
        node.expressions.push(
          this.parseMaybeAssign(noIn, refShorthandDefaultPos),
        );
      }
      this.toReferencedList(node.expressions);
      return this.finishNode(node, "SequenceExpression");
    }
    return expr;
  }
  // Parse an assignment expression. This includes applications of
  // operators like `+=`.
  parseMaybeAssign(
    noIn?: ?boolean,
    refShorthandDefaultPos?: ?Pos,
    afterLeftParse?: Function,
    refNeedsArrowPos?: ?Pos,
  ): N.Expression {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    if (this.match(tt._yield) && this.state.inGenerator) {
      let left = this.parseYield();
      if (afterLeftParse) {
        left = afterLeftParse.call(this, left, startPos, startLoc);
      }
      return left;
    }
    let failOnShorthandAssign;
    if (refShorthandDefaultPos) {
      failOnShorthandAssign = false;
    } else {
      refShorthandDefaultPos = { start: 0 };
      failOnShorthandAssign = true;
    }
    if (this.match(tt.parenL) || this.match(tt.name) || this.match(tt._yield)) {
      this.state.potentialArrowAt = this.state.start;
    }
    let left = this.parseMaybeConditional(
      noIn,
      refShorthandDefaultPos,
      refNeedsArrowPos,
    );
    if (afterLeftParse) {
      left = afterLeftParse.call(this, left, startPos, startLoc);
    }
    if (this.state.type.isAssign) {
      const node = this.startNodeAt(startPos, startLoc);
      const operator = this.state.value;
      node.operator = operator;
      if (operator === "??=") {
        this.expectPlugin("nullishCoalescingOperator");
        this.expectPlugin("logicalAssignment");
      }
      if (operator === "||=" || operator === "&&=") {
        this.expectPlugin("logicalAssignment");
      }
      node.left = this.match(tt.eq)
        ? this.toAssignable(left, undefined, "assignment expression")
        : left;
      refShorthandDefaultPos.start = 0; // reset because shorthand default was used correctly
      this.checkLVal(left, undefined, undefined, "assignment expression");
      if (left.extra && left.extra.parenthesized) {
        let errorMsg;
        if (left.type === "ObjectPattern") {
          errorMsg = "`({a}) = 0` use `({a} = 0)`";
        } else if (left.type === "ArrayPattern") {
          errorMsg = "`([a]) = 0` use `([a] = 0)`";
        }
        if (errorMsg) {
          this.raise(
            left.start,
            `You're trying to assign to a parenthesized expression, eg. instead of ${errorMsg}`,
          );
        }
      }
      this.next();
      node.right = this.parseMaybeAssign(noIn);
      return this.finishNode(node, "AssignmentExpression");
    } else if (failOnShorthandAssign && refShorthandDefaultPos.start) {
      this.unexpected(refShorthandDefaultPos.start);
    }
    return left;
  }
  // Parse a ternary conditional (`?:`) operator.
  parseMaybeConditional(
    noIn: ?boolean,
    refShorthandDefaultPos: Pos,
    refNeedsArrowPos?: ?Pos,
  ): N.Expression {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    const potentialArrowAt = this.state.potentialArrowAt;
    const expr = this.parseExprOps(noIn, refShorthandDefaultPos);
    if (
      expr.type === "ArrowFunctionExpression" &&
      expr.start === potentialArrowAt
    ) {
      return expr;
    }
    if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
    return this.parseConditional(
      expr,
      noIn,
      startPos,
      startLoc,
      refNeedsArrowPos,
    );
  }
  parseConditional(
    expr: N.Expression,
    noIn: ?boolean,
    startPos: number,
    startLoc: Position,
    // FIXME: Disabling this for now since can't seem to get it to play nicely
    // eslint-disable-next-line no-unused-vars
    refNeedsArrowPos?: ?Pos,
  ): N.Expression {
    if (this.eat(tt.question)) {
      const node = this.startNodeAt(startPos, startLoc);
      node.test = expr;
      node.consequent = this.parseMaybeAssign();
      this.expect(tt.colon);
      node.alternate = this.parseMaybeAssign(noIn);
      return this.finishNode(node, "ConditionalExpression");
    }
    return expr;
  }
  // Start the precedence parser.
  parseExprOps(noIn: ?boolean, refShorthandDefaultPos: Pos): N.Expression {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    const potentialArrowAt = this.state.potentialArrowAt;
    const expr = this.parseMaybeUnary(refShorthandDefaultPos);
    if (
      expr.type === "ArrowFunctionExpression" &&
      expr.start === potentialArrowAt
    ) {
      return expr;
    }
    if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
      return expr;
    }
    return this.parseExprOp(expr, startPos, startLoc, -1, noIn);
  }
  // Parse binary operators with the operator precedence parsing
  // algorithm. `left` is the left-hand side of the operator.
  // `minPrec` provides context that allows the function to stop and
  // defer further parser to one of its callers when it encounters an
  // operator that has a lower precedence than the set it is parsing.
  parseExprOp(
    left: N.Expression,
    leftStartPos: number,
    leftStartLoc: Position,
    minPrec: number,
    noIn: ?boolean,
  ): N.Expression {
    const prec = this.state.type.binop;
    if (prec != null && (!noIn || !this.match(tt._in))) {
      if (prec > minPrec) {
        const node = this.startNodeAt(leftStartPos, leftStartLoc);
        const operator = this.state.value;
        node.left = left;
        node.operator = operator;
        if (
          operator === "**" &&
          left.type === "UnaryExpression" &&
          !(left.extra && left.extra.parenthesized)
        ) {
          this.raise(
            left.argument.start,
            "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
          );
        }
        const op = this.state.type;
        if (op === tt.nullishCoalescing) {
          this.expectPlugin("nullishCoalescingOperator");
        } else if (op === tt.pipeline) {
          this.expectPlugin("pipelineOperator");
        }
        this.next();
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        if (op === tt.pipeline) {
          if (
            this.match(tt.name) &&
            this.state.value === "await" &&
            this.state.inAsync
          ) {
            throw this.raise(
              this.state.start,
              `Unexpected "await" after pipeline body; await must have parentheses in minimal proposal`,
            );
          }
        }
        node.right = this.parseExprOp(
          this.parseMaybeUnary(),
          startPos,
          startLoc,
          op.rightAssociative ? prec - 1 : prec,
          noIn,
        );
        this.finishNode(
          node,
          op === tt.logicalOR ||
          op === tt.logicalAND ||
          op === tt.nullishCoalescing
            ? "LogicalExpression"
            : "BinaryExpression",
        );
        return this.parseExprOp(
          node,
          leftStartPos,
          leftStartLoc,
          minPrec,
          noIn,
        );
      }
    }
    return left;
  }
  // Parse unary operators, both prefix and postfix.
  parseMaybeUnary(refShorthandDefaultPos: ?Pos): N.Expression {
    if (this.state.type.prefix) {
      const node = this.startNode();
      const update = this.match(tt.incDec);
      node.operator = this.state.value;
      node.prefix = true;
      if (node.operator === "throw") {
        this.expectPlugin("throwExpressions");
      }
      this.next();
      node.argument = this.parseMaybeUnary();
      if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
        this.unexpected(refShorthandDefaultPos.start);
      }
      if (update) {
        this.checkLVal(node.argument, undefined, undefined, "prefix operation");
      } else if (this.state.strict && node.operator === "delete") {
        const arg = node.argument;
        if (arg.type === "Identifier") {
          this.raise(node.start, "Deleting local variable in strict mode");
        } else if (
          arg.type === "MemberExpression" &&
          arg.property.type === "PrivateName"
        ) {
          this.raise(node.start, "Deleting a private field is not allowed");
        }
      }
      return this.finishNode(
        node,
        update ? "UpdateExpression" : "UnaryExpression",
      );
    }
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    let expr = this.parseExprSubscripts(refShorthandDefaultPos);
    if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
    while (this.state.type.postfix && !this.canInsertSemicolon()) {
      const node = this.startNodeAt(startPos, startLoc);
      node.operator = this.state.value;
      node.prefix = false;
      node.argument = expr;
      this.checkLVal(expr, undefined, undefined, "postfix operation");
      this.next();
      expr = this.finishNode(node, "UpdateExpression");
    }
    return expr;
  }
  // Parse call, dot, and `[]`-subscript expressions.
  parseExprSubscripts(refShorthandDefaultPos: ?Pos): N.Expression {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    const potentialArrowAt = this.state.potentialArrowAt;
    const expr = this.parseExprAtom(refShorthandDefaultPos);
    if (
      expr.type === "ArrowFunctionExpression" &&
      expr.start === potentialArrowAt
    ) {
      return expr;
    }
    if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
      return expr;
    }
    return this.parseSubscripts(expr, startPos, startLoc);
  }
  parseSubscripts(
    base: N.Expression,
    startPos: number,
    startLoc: Position,
    noCalls?: ?boolean,
  ): N.Expression {
    const state = {
      optionalChainMember: false,
      stop: false,
    };
    do {
      base = this.parseSubscript(base, startPos, startLoc, noCalls, state);
    } while (!state.stop);
    return base;
  }
  /**
   * @param state Set 'state.stop = true' to indicate that we should stop parsing subscripts.
   *   state.optionalChainMember to indicate that the member is currently in OptionalChain
   */
  parseSubscript(
    base: N.Expression,
    startPos: number,
    startLoc: Position,
    noCalls: ?boolean,
    state: N.ParseSubscriptState,
  ): N.Expression {
    if (!noCalls && this.eat(tt.doubleColon)) {
      const node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.callee = this.parseNoCallExpr();
      state.stop = true;
      return this.parseSubscripts(
        this.finishNode(node, "BindExpression"),
        startPos,
        startLoc,
        noCalls,
      );
    } else if (this.match(tt.questionDot)) {
      this.expectPlugin("optionalChaining");
      state.optionalChainMember = true;
      if (noCalls && this.lookahead().type == tt.parenL) {
        state.stop = true;
        return base;
      }
      this.next();
      const node = this.startNodeAt(startPos, startLoc);
      if (this.eat(tt.bracketL)) {
        node.object = base;
        node.property = this.parseExpression();
        node.computed = true;
        node.optional = true;
        this.expect(tt.bracketR);
        return this.finishNode(node, "OptionalMemberExpression");
      } else if (this.eat(tt.parenL)) {
        const possibleAsync = this.atPossibleAsync(base);
        node.callee = base;
        node.arguments = this.parseCallExpressionArguments(
          tt.parenR,
          possibleAsync,
        );
        node.optional = true;
        return this.finishNode(node, "OptionalCallExpression");
      } else {
        node.object = base;
        node.property = this.parseIdentifier(true);
        node.computed = false;
        node.optional = true;
        return this.finishNode(node, "OptionalMemberExpression");
      }
    } else if (this.eat(tt.dot)) {
      const node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.property = this.parseMaybePrivateName();
      node.computed = false;
      if (state.optionalChainMember) {
        node.optional = false;
        return this.finishNode(node, "OptionalMemberExpression");
      }
      return this.finishNode(node, "MemberExpression");
    } else if (this.eat(tt.bracketL)) {
      const node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.property = this.parseExpression();
      node.computed = true;
      this.expect(tt.bracketR);
      if (state.optionalChainMember) {
        node.optional = false;
        return this.finishNode(node, "OptionalMemberExpression");
      }
      return this.finishNode(node, "MemberExpression");
    } else if (!noCalls && this.match(tt.parenL)) {
      const possibleAsync = this.atPossibleAsync(base);
      this.next();
      const node = this.startNodeAt(startPos, startLoc);
      node.callee = base;
      // TODO: Clean up/merge this into `this.state` or a class like acorn's
      // `DestructuringErrors` alongside refShorthandDefaultPos and
      // refNeedsArrowPos.
      const refTrailingCommaPos: Pos = { start: -1 };
      node.arguments = this.parseCallExpressionArguments(
        tt.parenR,
        possibleAsync,
        refTrailingCommaPos,
      );
      if (!state.optionalChainMember) {
        this.finishCallExpression(node);
      } else {
        this.finishOptionalCallExpression(node);
      }
      if (possibleAsync && this.shouldParseAsyncArrow()) {
        state.stop = true;
        if (refTrailingCommaPos.start > -1) {
          this.raise(
            refTrailingCommaPos.start,
            "A trailing comma is not permitted after the rest element",
          );
        }
        return this.parseAsyncArrowFromCallExpression(
          this.startNodeAt(startPos, startLoc),
          node,
        );
      } else {
        this.toReferencedList(node.arguments);
      }
      return node;
    } else if (this.match(tt.backQuote)) {
      return this.parseTaggedTemplateExpression(
        startPos,
        startLoc,
        base,
        state,
      );
    } else {
      state.stop = true;
      return base;
    }
  }
  parseTaggedTemplateExpression(
    startPos: number,
    startLoc: Position,
    base: N.Expression,
    state: N.ParseSubscriptState,
    typeArguments?: ?N.TsTypeParameterInstantiation,
  ): N.TaggedTemplateExpression {
    const node: N.TaggedTemplateExpression = this.startNodeAt(
      startPos,
      startLoc,
    );
    node.tag = base;
    node.quasi = this.parseTemplate(true);
    if (typeArguments) node.typeParameters = typeArguments;
    if (state.optionalChainMember) {
      this.raise(
        startPos,
        "Tagged Template Literals are not allowed in optionalChain",
      );
    }
    return this.finishNode(node, "TaggedTemplateExpression");
  }
  atPossibleAsync(base: N.Expression): boolean {
    return (
      !this.state.containsEsc &&
      this.state.potentialArrowAt === base.start &&
      base.type === "Identifier" &&
      base.name === "async" &&
      !this.canInsertSemicolon()
    );
  }
  finishCallExpression(node: N.CallExpression): N.CallExpression {
    if (node.callee.type === "Import") {
      if (node.arguments.length !== 1) {
        this.raise(node.start, "import() requires exactly one argument");
      }
      const importArg = node.arguments[0];
      if (importArg && importArg.type === "SpreadElement") {
        this.raise(importArg.start, "... is not allowed in import()");
      }
    }
    return this.finishNode(node, "CallExpression");
  }
  finishOptionalCallExpression(node: N.CallExpression): N.CallExpression {
    if (node.callee.type === "Import") {
      if (node.arguments.length !== 1) {
        this.raise(node.start, "import() requires exactly one argument");
      }
      const importArg = node.arguments[0];
      if (importArg && importArg.type === "SpreadElement") {
        this.raise(importArg.start, "... is not allowed in import()");
      }
    }
    return this.finishNode(node, "OptionalCallExpression");
  }
  parseCallExpressionArguments(
    close: TokenType,
    possibleAsyncArrow: boolean,
    refTrailingCommaPos?: Pos,
  ): $ReadOnlyArray<?N.Expression> {
    const elts = [];
    let innerParenStart;
    let first = true;
    while (!this.eat(close)) {
      if (first) {
        first = false;
      } else {
        this.expect(tt.comma);
        if (this.eat(close)) break;
      }
      // we need to make sure that if this is an async arrow functions,
      // that we don't allow inner parens inside the params
      if (this.match(tt.parenL) && !innerParenStart) {
        innerParenStart = this.state.start;
      }
      elts.push(
        this.parseExprListItem(
          false,
          possibleAsyncArrow ? { start: 0 } : undefined,
          possibleAsyncArrow ? { start: 0 } : undefined,
          possibleAsyncArrow ? refTrailingCommaPos : undefined,
        ),
      );
    }
    // we found an async arrow function so let's not allow any inner parens
    if (possibleAsyncArrow && innerParenStart && this.shouldParseAsyncArrow()) {
      this.unexpected();
    }
    return elts;
  }
  shouldParseAsyncArrow(): boolean {
    return this.match(tt.arrow);
  }
  parseAsyncArrowFromCallExpression(
    node: N.ArrowFunctionExpression,
    call: N.CallExpression,
  ): N.ArrowFunctionExpression {
    const oldYield = this.state.yieldInPossibleArrowParameters;
    this.state.yieldInPossibleArrowParameters = null;
    this.expect(tt.arrow);
    this.parseArrowExpression(node, call.arguments, true);
    this.state.yieldInPossibleArrowParameters = oldYield;
    return node;
  }
  // Parse a no-call expression (like argument of `new` or `::` operators).
  parseNoCallExpr(): N.Expression {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
  }
  // Parse an atomic expression  either a single token that is an
  // expression, an expression started by a keyword like `function` or
  // `new`, or an expression wrapped in punctuation like `()`, `[]`,
  // or `{}`.
  parseExprAtom(refShorthandDefaultPos?: ?Pos): N.Expression {
    const canBeArrow = this.state.potentialArrowAt === this.state.start;
    let node;
    switch (this.state.type) {
      case tt._super:
        if (
          !this.state.inMethod &&
          !this.state.inClassProperty &&
          !this.options.allowSuperOutsideMethod
        ) {
          this.raise(
            this.state.start,
            "super is only allowed in object methods and classes",
          );
        }
        node = this.startNode();
        this.next();
        if (
          !this.match(tt.parenL) &&
          !this.match(tt.bracketL) &&
          !this.match(tt.dot)
        ) {
          this.unexpected();
        }
        if (
          this.match(tt.parenL) &&
          this.state.inMethod !== "constructor" &&
          !this.options.allowSuperOutsideMethod
        ) {
          this.raise(
            node.start,
            "super() is only valid inside a class constructor. " +
              "Make sure the method name is spelled exactly as 'constructor'.",
          );
        }
        return this.finishNode(node, "Super");
      case tt._import:
        if (this.lookahead().type === tt.dot) {
          return this.parseImportMetaProperty();
        }
        this.expectPlugin("dynamicImport");
        node = this.startNode();
        this.next();
        if (!this.match(tt.parenL)) {
          this.unexpected(null, tt.parenL);
        }
        return this.finishNode(node, "Import");
      case tt._this:
        node = this.startNode();
        this.next();
        return this.finishNode(node, "ThisExpression");
      case tt._yield:
        if (this.state.inGenerator) this.unexpected();
      case tt.name: {
        node = this.startNode();
        const allowAwait =
          this.state.value === "await" &&
          (this.state.inAsync ||
            (!this.state.inFunction && this.options.allowAwaitOutsideFunction));
        const containsEsc = this.state.containsEsc;
        const allowYield = this.shouldAllowYieldIdentifier();
        const id = this.parseIdentifier(allowAwait || allowYield);
        if (id.name === "await") {
          if (
            this.state.inAsync ||
            this.inModule ||
            (!this.state.inFunction && this.options.allowAwaitOutsideFunction)
          ) {
            return this.parseAwait(node);
          }
        } else if (
          !containsEsc &&
          id.name === "async" &&
          this.match(tt._function) &&
          !this.canInsertSemicolon()
        ) {
          this.next();
          return this.parseFunction(node, false, false, true);
        } else if (canBeArrow && id.name === "async" && this.match(tt.name)) {
          const oldYield = this.state.yieldInPossibleArrowParameters;
          this.state.yieldInPossibleArrowParameters = null;
          const params = [this.parseIdentifier()];
          this.expect(tt.arrow);
          // let foo = bar => {};
          this.parseArrowExpression(node, params, true);
          this.state.yieldInPossibleArrowParameters = oldYield;
          return node;
        }
        if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow)) {
          const oldYield = this.state.yieldInPossibleArrowParameters;
          this.state.yieldInPossibleArrowParameters = null;
          this.parseArrowExpression(node, [id]);
          this.state.yieldInPossibleArrowParameters = oldYield;
          return node;
        }
        return id;
      }
      case tt._do: {
        this.expectPlugin("doExpressions");
        const node = this.startNode();
        this.next();
        const oldInFunction = this.state.inFunction;
        const oldLabels = this.state.labels;
        this.state.labels = [];
        this.state.inFunction = false;
        node.body = this.parseBlock(false);
        this.state.inFunction = oldInFunction;
        this.state.labels = oldLabels;
        return this.finishNode(node, "DoExpression");
      }
      case tt.regexp: {
        const value = this.state.value;
        node = this.parseLiteral(value.value, "RegExpLiteral");
        node.pattern = value.pattern;
        node.flags = value.flags;
        return node;
      }
      case tt.num:
        return this.parseLiteral(this.state.value, "NumericLiteral");
      case tt.bigint:
        return this.parseLiteral(this.state.value, "BigIntLiteral");
      case tt.string:
        return this.parseLiteral(this.state.value, "StringLiteral");
      case tt._null:
        node = this.startNode();
        this.next();
        return this.finishNode(node, "NullLiteral");
      case tt._true:
      case tt._false:
        return this.parseBooleanLiteral();
      case tt.parenL:
        return this.parseParenAndDistinguishExpression(canBeArrow);
      case tt.bracketL:
        node = this.startNode();
        this.next();
        node.elements = this.parseExprList(
          tt.bracketR,
          true,
          refShorthandDefaultPos,
        );
        this.toReferencedList(node.elements);
        return this.finishNode(node, "ArrayExpression");
      case tt.braceL:
        return this.parseObj(false, refShorthandDefaultPos);
      case tt._function:
        return this.parseFunctionExpression();
      case tt.at:
        this.parseDecorators();
      case tt._class:
        node = this.startNode();
        this.takeDecorators(node);
        return this.parseClass(node, false);
      case tt._new:
        return this.parseNew();
      case tt.backQuote:
        return this.parseTemplate(false);
      case tt.doubleColon: {
        node = this.startNode();
        this.next();
        node.object = null;
        const callee = (node.callee = this.parseNoCallExpr());
        if (callee.type === "MemberExpression") {
          return this.finishNode(node, "BindExpression");
        } else {
          throw this.raise(
            callee.start,
            "Binding should be performed on object property.",
          );
        }
      }
      default:
        throw this.unexpected();
    }
  }
  parseBooleanLiteral(): N.BooleanLiteral {
    const node = this.startNode();
    node.value = this.match(tt._true);
    this.next();
    return this.finishNode(node, "BooleanLiteral");
  }
  parseMaybePrivateName(): N.PrivateName | N.Identifier {
    const isPrivate = this.match(tt.hash);
    if (isPrivate) {
      this.expectOnePlugin(["classPrivateProperties", "classPrivateMethods"]);
      const node = this.startNode();
      const columnHashEnd = this.state.end;
      this.next();
      const columnIdentifierStart = this.state.start;
      const spacesBetweenHashAndIdentifier =
        columnIdentifierStart - columnHashEnd;
      if (spacesBetweenHashAndIdentifier != 0) {
        this.raise(
          columnIdentifierStart,
          "Unexpected space between # and identifier",
        );
      }
      node.id = this.parseIdentifier(true);
      return this.finishNode(node, "PrivateName");
    } else {
      return this.parseIdentifier(true);
    }
  }
  parseFunctionExpression(): N.FunctionExpression | N.MetaProperty {
    const node = this.startNode();
    const meta = this.parseIdentifier(true);
    if (this.state.inGenerator && this.eat(tt.dot)) {
      return this.parseMetaProperty(node, meta, "sent");
    }
    return this.parseFunction(node, false);
  }
  parseMetaProperty(
    node: N.MetaProperty,
    meta: N.Identifier,
    propertyName: string,
  ): N.MetaProperty {
    node.meta = meta;
    if (meta.name === "function" && propertyName === "sent") {
      if (this.isContextual(propertyName)) {
        this.expectPlugin("functionSent");
      } else if (!this.hasPlugin("functionSent")) {
        // The code wasn't `function.sent` but just `function.`, so a simple error is less confusing.
        this.unexpected();
      }
    }
    const containsEsc = this.state.containsEsc;
    node.property = this.parseIdentifier(true);
    if (node.property.name !== propertyName || containsEsc) {
      this.raise(
        node.property.start,
        `The only valid meta property for ${meta.name} is ${
          meta.name
        }.${propertyName}`,
      );
    }
    return this.finishNode(node, "MetaProperty");
  }
  parseImportMetaProperty(): N.MetaProperty {
    const node = this.startNode();
    const id = this.parseIdentifier(true);
    this.expect(tt.dot);
    if (id.name === "import") {
      if (this.isContextual("meta")) {
        this.expectPlugin("importMeta");
      } else if (!this.hasPlugin("importMeta")) {
        this.raise(
          id.start,
          `Dynamic imports require a parameter: import('a.js')`,
        );
      }
    }
    if (!this.inModule) {
      this.raise(
        id.start,
        `import.meta may appear only with 'sourceType: "module"'`,
        { code: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED" },
      );
    }
    this.sawUnambiguousESM = true;
    return this.parseMetaProperty(node, id, "meta");
  }
  parseLiteral<T: N.Literal>(
    value: any,
    type: /*T["kind"]*/ string,
    startPos?: number,
    startLoc?: Position,
  ): T {
    startPos = startPos || this.state.start;
    startLoc = startLoc || this.state.startLoc;
    const node = this.startNodeAt(startPos, startLoc);
    this.addExtra(node, "rawValue", value);
    this.addExtra(node, "raw", this.input.slice(startPos, this.state.end));
    node.value = value;
    this.next();
    return this.finishNode(node, type);
  }
  parseParenExpression(): N.Expression {
    this.expect(tt.parenL);
    const val = this.parseExpression();
    this.expect(tt.parenR);
    return val;
  }
  parseParenAndDistinguishExpression(canBeArrow: boolean): N.Expression {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    let val;
    this.expect(tt.parenL);
    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
    const oldYield = this.state.yieldInPossibleArrowParameters;
    this.state.maybeInArrowParameters = true;
    this.state.yieldInPossibleArrowParameters = null;
    const innerStartPos = this.state.start;
    const innerStartLoc = this.state.startLoc;
    const exprList = [];
    const refShorthandDefaultPos = { start: 0 };
    const refNeedsArrowPos = { start: 0 };
    let first = true;
    let spreadStart;
    let optionalCommaStart;
    while (!this.match(tt.parenR)) {
      if (first) {
        first = false;
      } else {
        this.expect(tt.comma, refNeedsArrowPos.start || null);
        if (this.match(tt.parenR)) {
          optionalCommaStart = this.state.start;
          break;
        }
      }
      if (this.match(tt.ellipsis)) {
        const spreadNodeStartPos = this.state.start;
        const spreadNodeStartLoc = this.state.startLoc;
        spreadStart = this.state.start;
        exprList.push(
          this.parseParenItem(
            this.parseRest(),
            spreadNodeStartPos,
            spreadNodeStartLoc,
          ),
        );
        if (this.match(tt.comma) && this.lookahead().type === tt.parenR) {
          this.raise(
            this.state.start,
            "A trailing comma is not permitted after the rest element",
          );
        }
        break;
      } else {
        exprList.push(
          this.parseMaybeAssign(
            false,
            refShorthandDefaultPos,
            this.parseParenItem,
            refNeedsArrowPos,
          ),
        );
      }
    }
    const innerEndPos = this.state.start;
    const innerEndLoc = this.state.startLoc;
    this.expect(tt.parenR);
    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
    let arrowNode = this.startNodeAt(startPos, startLoc);
    if (
      canBeArrow &&
      this.shouldParseArrow() &&
      (arrowNode = this.parseArrow(arrowNode))
    ) {
      for (const param of exprList) {
        if (param.extra && param.extra.parenthesized) {
          this.unexpected(param.extra.parenStart);
        }
      }
      this.parseArrowExpression(arrowNode, exprList);
      this.state.yieldInPossibleArrowParameters = oldYield;
      return arrowNode;
    }
    this.state.yieldInPossibleArrowParameters = oldYield;
    if (!exprList.length) {
      this.unexpected(this.state.lastTokStart);
    }
    if (optionalCommaStart) this.unexpected(optionalCommaStart);
    if (spreadStart) this.unexpected(spreadStart);
    if (refShorthandDefaultPos.start) {
      this.unexpected(refShorthandDefaultPos.start);
    }
    if (refNeedsArrowPos.start) this.unexpected(refNeedsArrowPos.start);
    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.toReferencedList(val.expressions);
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
    this.addExtra(val, "parenthesized", true);
    this.addExtra(val, "parenStart", startPos);
    return val;
  }
  shouldParseArrow(): boolean {
    return !this.canInsertSemicolon();
  }
  parseArrow(node: N.ArrowFunctionExpression): ?N.ArrowFunctionExpression {
    if (this.eat(tt.arrow)) {
      return node;
    }
  }
  parseParenItem(
    node: N.Expression,
    startPos: number, // eslint-disable-line no-unused-vars
    startLoc: Position, // eslint-disable-line no-unused-vars
  ): N.Expression {
    return node;
  }
  // New's precedence is slightly tricky. It must allow its argument to
  // be a `[]` or dot subscript expression, but not a call  at least,
  // not without wrapping it in parentheses. Thus, it uses the noCalls
  // argument to parseSubscripts to prevent it from consuming the
  // argument list.
  parseNew(): N.NewExpression | N.MetaProperty {
    const node = this.startNode();
    const meta = this.parseIdentifier(true);
    if (this.eat(tt.dot)) {
      const metaProp = this.parseMetaProperty(node, meta, "target");
      if (!this.state.inFunction && !this.state.inClassProperty) {
        let error = "new.target can only be used in functions";
        if (this.hasPlugin("classProperties")) {
          error += " or class properties";
        }
        this.raise(metaProp.start, error);
      }
      return metaProp;
    }
    node.callee = this.parseNoCallExpr();
    if (
      node.callee.type === "OptionalMemberExpression" ||
      node.callee.type === "OptionalCallExpression"
    ) {
      this.raise(
        this.state.lastTokEnd,
        "constructors in/after an Optional Chain are not allowed",
      );
    }
    if (this.eat(tt.questionDot)) {
      this.raise(
        this.state.start,
        "constructors in/after an Optional Chain are not allowed",
      );
    }
    this.parseNewArguments(node);
    return this.finishNode(node, "NewExpression");
  }
  parseNewArguments(node: N.NewExpression): void {
    if (this.eat(tt.parenL)) {
      const args = this.parseExprList(tt.parenR);
      this.toReferencedList(args);
      // $FlowFixMe (parseExprList should be all non-null in this case)
      node.arguments = args;
    } else {
      node.arguments = [];
    }
  }
  // Parse template expression.
  parseTemplateElement(isTagged: boolean): N.TemplateElement {
    const elem = this.startNode();
    if (this.state.value === null) {
      if (!isTagged) {
        // TODO: fix this
        this.raise(
          this.state.invalidTemplateEscapePosition || 0,
          "Invalid escape sequence in template",
        );
      } else {
        this.state.invalidTemplateEscapePosition = null;
      }
    }
    elem.value = {
      raw: this.input
        .slice(this.state.start, this.state.end)
        .replace(/\r\n?/g, "\n"),
      cooked: this.state.value,
    };
    this.next();
    elem.tail = this.match(tt.backQuote);
    return this.finishNode(elem, "TemplateElement");
  }
  parseTemplate(isTagged: boolean): N.TemplateLiteral {
    const node = this.startNode();
    this.next();
    node.expressions = [];
    let curElt = this.parseTemplateElement(isTagged);
    node.quasis = [curElt];
    while (!curElt.tail) {
      this.expect(tt.dollarBraceL);
      node.expressions.push(this.parseExpression());
      this.expect(tt.braceR);
      node.quasis.push((curElt = this.parseTemplateElement(isTagged)));
    }
    this.next();
    return this.finishNode(node, "TemplateLiteral");
  }
  // Parse an object literal or binding pattern.
  parseObj<T: N.ObjectPattern | N.ObjectExpression>(
    isPattern: boolean,
    refShorthandDefaultPos?: ?Pos,
  ): T {
    let decorators = [];
    const propHash: any = Object.create(null);
    let first = true;
    const node = this.startNode();
    node.properties = [];
    this.next();
    let firstRestLocation = null;
    while (!this.eat(tt.braceR)) {
      if (first) {
        first = false;
      } else {
        this.expect(tt.comma);
        if (this.eat(tt.braceR)) break;
      }
      if (this.match(tt.at)) {
        if (this.hasPlugin("decorators")) {
          this.raise(
            this.state.start,
            "Stage 2 decorators disallow object literal property decorators",
          );
        } else {
          // we needn't check if decorators (stage 0) plugin is enabled since it's checked by
          // the call to this.parseDecorator
          while (this.match(tt.at)) {
            decorators.push(this.parseDecorator());
          }
        }
      }
      let prop = this.startNode(),
        isGenerator = false,
        isAsync = false,
        startPos,
        startLoc;
      if (decorators.length) {
        prop.decorators = decorators;
        decorators = [];
      }
      if (this.match(tt.ellipsis)) {
        this.expectPlugin("objectRestSpread");
        prop = this.parseSpread(isPattern ? { start: 0 } : undefined);
        if (isPattern) {
          this.toAssignable(prop, true, "object pattern");
        }
        node.properties.push(prop);
        if (isPattern) {
          const position = this.state.start;
          if (firstRestLocation !== null) {
            this.unexpected(
              firstRestLocation,
              "Cannot have multiple rest elements when destructuring",
            );
          } else if (this.eat(tt.braceR)) {
            break;
          } else if (
            this.match(tt.comma) &&
            this.lookahead().type === tt.braceR
          ) {
            this.unexpected(
              position,
              "A trailing comma is not permitted after the rest element",
            );
          } else {
            firstRestLocation = position;
            continue;
          }
        } else {
          continue;
        }
      }
      prop.method = false;
      if (isPattern || refShorthandDefaultPos) {
        startPos = this.state.start;
        startLoc = this.state.startLoc;
      }
      if (!isPattern) {
        isGenerator = this.eat(tt.star);
      }
      const containsEsc = this.state.containsEsc;
      if (!isPattern && this.isContextual("async")) {
        if (isGenerator) this.unexpected();
        const asyncId = this.parseIdentifier();
        if (
          this.match(tt.colon) ||
          this.match(tt.parenL) ||
          this.match(tt.braceR) ||
          this.match(tt.eq) ||
          this.match(tt.comma)
        ) {
          prop.key = asyncId;
          prop.computed = false;
        } else {
          isAsync = true;
          if (this.match(tt.star)) {
            this.expectPlugin("asyncGenerators");
            this.next();
            isGenerator = true;
          }
          this.parsePropertyName(prop);
        }
      } else {
        this.parsePropertyName(prop);
      }
      this.parseObjPropValue(
        prop,
        startPos,
        startLoc,
        isGenerator,
        isAsync,
        isPattern,
        refShorthandDefaultPos,
        containsEsc,
      );
      this.checkPropClash(prop, propHash);
      if (prop.shorthand) {
        this.addExtra(prop, "shorthand", true);
      }
      node.properties.push(prop);
    }
    if (firstRestLocation !== null) {
      this.unexpected(
        firstRestLocation,
        "The rest element has to be the last element when destructuring",
      );
    }
    if (decorators.length) {
      this.raise(
        this.state.start,
        "You have trailing decorators with no property",
      );
    }
    return this.finishNode(
      node,
      isPattern ? "ObjectPattern" : "ObjectExpression",
    );
  }
  isGetterOrSetterMethod(prop: N.ObjectMethod, isPattern: boolean): boolean {
    return (
      !isPattern &&
      !prop.computed &&
      prop.key.type === "Identifier" &&
      (prop.key.name === "get" || prop.key.name === "set") &&
      (this.match(tt.string) || // get "string"() {}
      this.match(tt.num) || // get 1() {}
      this.match(tt.bracketL) || // get ["string"]() {}
      this.match(tt.name) || // get foo() {}
        !!this.state.type.keyword) // get debugger() {}
    );
  }
  // get methods aren't allowed to have any parameters
  // set methods must have exactly 1 parameter which is not a rest parameter
  checkGetterSetterParams(method: N.ObjectMethod | N.ClassMethod): void {
    const paramCount = method.kind === "get" ? 0 : 1;
    const start = method.start;
    if (method.params.length !== paramCount) {
      if (method.kind === "get") {
        this.raise(start, "getter must not have any formal parameters");
      } else {
        this.raise(start, "setter must have exactly one formal parameter");
      }
    }
    if (method.kind === "set" && method.params[0].type === "RestElement") {
      this.raise(
        start,
        "setter function argument must not be a rest parameter",
      );
    }
  }
  parseObjectMethod(
    prop: N.ObjectMethod,
    isGenerator: boolean,
    isAsync: boolean,
    isPattern: boolean,
    containsEsc: boolean,
  ): ?N.ObjectMethod {
    if (isAsync || isGenerator || this.match(tt.parenL)) {
      if (isPattern) this.unexpected();
      prop.kind = "method";
      prop.method = true;
      return this.parseMethod(
        prop,
        isGenerator,
        isAsync,
        /* isConstructor */ false,
        "ObjectMethod",
      );
    }
    if (!containsEsc && this.isGetterOrSetterMethod(prop, isPattern)) {
      if (isGenerator || isAsync) this.unexpected();
      prop.kind = prop.key.name;
      this.parsePropertyName(prop);
      this.parseMethod(
        prop,
        /* isGenerator */ false,
        /* isAsync */ false,
        /* isConstructor */ false,
        "ObjectMethod",
      );
      this.checkGetterSetterParams(prop);
      return prop;
    }
  }
  parseObjectProperty(
    prop: N.ObjectProperty,
    startPos: ?number,
    startLoc: ?Position,
    isPattern: boolean,
    refShorthandDefaultPos: ?Pos,
  ): ?N.ObjectProperty {
    prop.shorthand = false;
    if (this.eat(tt.colon)) {
      prop.value = isPattern
        ? this.parseMaybeDefault(this.state.start, this.state.startLoc)
        : this.parseMaybeAssign(false, refShorthandDefaultPos);
      return this.finishNode(prop, "ObjectProperty");
    }
    if (!prop.computed && prop.key.type === "Identifier") {
      this.checkReservedWord(prop.key.name, prop.key.start, true, true);
      if (isPattern) {
        prop.value = this.parseMaybeDefault(
          startPos,
          startLoc,
          prop.key.__clone(),
        );
      } else if (this.match(tt.eq) && refShorthandDefaultPos) {
        if (!refShorthandDefaultPos.start) {
          refShorthandDefaultPos.start = this.state.start;
        }
        prop.value = this.parseMaybeDefault(
          startPos,
          startLoc,
          prop.key.__clone(),
        );
      } else {
        prop.value = prop.key.__clone();
      }
      prop.shorthand = true;
      return this.finishNode(prop, "ObjectProperty");
    }
  }
  parseObjPropValue(
    prop: any,
    startPos: ?number,
    startLoc: ?Position,
    isGenerator: boolean,
    isAsync: boolean,
    isPattern: boolean,
    refShorthandDefaultPos: ?Pos,
    containsEsc: boolean,
  ): void {
    const node =
      this.parseObjectMethod(
        prop,
        isGenerator,
        isAsync,
        isPattern,
        containsEsc,
      ) ||
      this.parseObjectProperty(
        prop,
        startPos,
        startLoc,
        isPattern,
        refShorthandDefaultPos,
      );
    if (!node) this.unexpected();
    // $FlowFixMe
    return node;
  }
  parsePropertyName(
    prop: N.ObjectOrClassMember | N.ClassMember | N.TsNamedTypeElementBase,
  ): N.Expression | N.Identifier {
    if (this.eat(tt.bracketL)) {
      (prop: $FlowSubtype<N.ObjectOrClassMember>).computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(tt.bracketR);
    } else {
      const oldInPropertyName = this.state.inPropertyName;
      this.state.inPropertyName = true;
      // We check if it's valid for it to be a private name when we push it.
      (prop: $FlowFixMe).key =
        this.match(tt.num) || this.match(tt.string)
          ? this.parseExprAtom()
          : this.parseMaybePrivateName();
      if (prop.key.type !== "PrivateName") {
        // ClassPrivateProperty is never computed, so we don't assign in that case.
        prop.computed = false;
      }
      this.state.inPropertyName = oldInPropertyName;
    }
    return prop.key;
  }
  // Initialize empty function node.
  initFunction(node: N.BodilessFunctionOrMethodBase, isAsync: ?boolean): void {
    node.id = null;
    node.generator = false;
    node.async = !!isAsync;
  }
  // Parse object or class method.
  parseMethod<T: N.MethodLike>(
    node: T,
    isGenerator: boolean,
    isAsync: boolean,
    isConstructor: boolean,
    type: string,
  ): T {
    const oldInFunc = this.state.inFunction;
    const oldInMethod = this.state.inMethod;
    const oldInGenerator = this.state.inGenerator;
    this.state.inFunction = true;
    this.state.inMethod = node.kind || true;
    this.state.inGenerator = isGenerator;
    this.initFunction(node, isAsync);
    node.generator = !!isGenerator;
    const allowModifiers = isConstructor; // For TypeScript parameter properties
    this.parseFunctionParams((node: any), allowModifiers);
    this.parseFunctionBodyAndFinish(node, type);
    this.state.inFunction = oldInFunc;
    this.state.inMethod = oldInMethod;
    this.state.inGenerator = oldInGenerator;
    return node;
  }
  // Parse arrow function expression.
  // If the parameters are provided, they will be converted to an
  // assignable list.
  parseArrowExpression(
    node: N.ArrowFunctionExpression,
    params?: ?(N.Expression[]),
    isAsync?: boolean,
  ): N.ArrowFunctionExpression {
    // if we got there, it's no more "yield in possible arrow parameters";
    // it's just "yield in arrow parameters"
    if (this.state.yieldInPossibleArrowParameters) {
      this.raise(
        this.state.yieldInPossibleArrowParameters.start,
        "yield is not allowed in the parameters of an arrow function" +
          " inside a generator",
      );
    }
    const oldInFunc = this.state.inFunction;
    this.state.inFunction = true;
    this.initFunction(node, isAsync);
    if (params) this.setArrowFunctionParameters(node, params);
    const oldInGenerator = this.state.inGenerator;
    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
    this.state.inGenerator = false;
    this.state.maybeInArrowParameters = false;
    this.parseFunctionBody(node, true);
    this.state.inGenerator = oldInGenerator;
    this.state.inFunction = oldInFunc;
    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
    return this.finishNode(node, "ArrowFunctionExpression");
  }
  setArrowFunctionParameters(
    node: N.ArrowFunctionExpression,
    params: N.Expression[],
  ): void {
    node.params = this.toAssignableList(
      params,
      true,
      "arrow function parameters",
    );
  }
  isStrictBody(node: { body: N.BlockStatement }): boolean {
    const isBlockStatement = node.body.type === "BlockStatement";
    if (isBlockStatement && node.body.directives.length) {
      for (const directive of node.body.directives) {
        if (directive.value.value === "use strict") {
          return true;
        }
      }
    }
    return false;
  }
  parseFunctionBodyAndFinish(
    node: N.BodilessFunctionOrMethodBase,
    type: string,
    allowExpressionBody?: boolean,
  ): void {
    // $FlowIgnore (node is not bodiless if we get here)
    this.parseFunctionBody(node, allowExpressionBody);
    this.finishNode(node, type);
  }
  // Parse function body and check parameters.
  parseFunctionBody(node: N.Function, allowExpression: ?boolean): void {
    const isExpression = allowExpression && !this.match(tt.braceL);
    const oldInParameters = this.state.inParameters;
    const oldInAsync = this.state.inAsync;
    this.state.inParameters = false;
    this.state.inAsync = node.async;
    if (isExpression) {
      node.body = this.parseMaybeAssign();
    } else {
      // Start a new scope with regard to labels and the `inGenerator`
      // flag (restore them to their old value afterwards).
      const oldInGen = this.state.inGenerator;
      const oldInFunc = this.state.inFunction;
      const oldLabels = this.state.labels;
      this.state.inGenerator = node.generator;
      this.state.inFunction = true;
      this.state.labels = [];
      node.body = this.parseBlock(true);
      this.state.inFunction = oldInFunc;
      this.state.inGenerator = oldInGen;
      this.state.labels = oldLabels;
    }
    this.state.inAsync = oldInAsync;
    this.checkFunctionNameAndParams(node, allowExpression);
    this.state.inParameters = oldInParameters;
  }
  checkFunctionNameAndParams(
    node: N.Function,
    isArrowFunction: ?boolean,
  ): void {
    // If this is a strict mode function, verify that argument names
    // are not repeated, and it does not try to bind the words `eval`
    // or `arguments`.
    const isStrict = this.isStrictBody(node);
    // Also check for arrow functions
    const checkLVal = this.state.strict || isStrict || isArrowFunction;
    const oldStrict = this.state.strict;
    if (isStrict) this.state.strict = isStrict;
    if (checkLVal) {
      const nameHash: any = Object.create(null);
      if (node.id) {
        this.checkLVal(node.id, true, undefined, "function name");
      }
      for (const param of node.params) {
        if (isStrict && param.type !== "Identifier") {
          this.raise(param.start, "Non-simple parameter in strict mode");
        }
        this.checkLVal(param, true, nameHash, "function parameter list");
      }
    }
    this.state.strict = oldStrict;
  }
  // Parses a comma-separated list of expressions, and returns them as
  // an array. `close` is the token type that ends the list, and
  // `allowEmpty` can be turned on to allow subsequent commas with
  // nothing in between them to be parsed as `null` (which is needed
  // for array literals).
  parseExprList(
    close: TokenType,
    allowEmpty?: boolean,
    refShorthandDefaultPos?: ?Pos,
  ): $ReadOnlyArray<?N.Expression> {
    const elts = [];
    let first = true;
    while (!this.eat(close)) {
      if (first) {
        first = false;
      } else {
        this.expect(tt.comma);
        if (this.eat(close)) break;
      }
      elts.push(this.parseExprListItem(allowEmpty, refShorthandDefaultPos));
    }
    return elts;
  }
  parseExprListItem(
    allowEmpty: ?boolean,
    refShorthandDefaultPos: ?Pos,
    refNeedsArrowPos: ?Pos,
    refTrailingCommaPos?: Pos,
  ): ?N.Expression {
    let elt;
    if (allowEmpty && this.match(tt.comma)) {
      elt = null;
    } else if (this.match(tt.ellipsis)) {
      const spreadNodeStartPos = this.state.start;
      const spreadNodeStartLoc = this.state.startLoc;
      elt = this.parseParenItem(
        this.parseSpread(refShorthandDefaultPos, refNeedsArrowPos),
        spreadNodeStartPos,
        spreadNodeStartLoc,
      );
      if (refTrailingCommaPos && this.match(tt.comma)) {
        refTrailingCommaPos.start = this.state.start;
      }
    } else {
      elt = this.parseMaybeAssign(
        false,
        refShorthandDefaultPos,
        this.parseParenItem,
        refNeedsArrowPos,
      );
    }
    return elt;
  }
  // Parse the next token as an identifier. If `liberal` is true (used
  // when parsing properties), it will also convert keywords into
  // identifiers.
  parseIdentifier(liberal?: boolean): N.Identifier {
    const node = this.startNode();
    const name = this.parseIdentifierName(node.start, liberal);
    node.name = name;
    node.loc.identifierName = name;
    return this.finishNode(node, "Identifier");
  }
  parseIdentifierName(pos: number, liberal?: boolean): string {
    if (!liberal) {
      this.checkReservedWord(
        this.state.value,
        this.state.start,
        !!this.state.type.keyword,
        false,
      );
    }
    let name: string;
    if (this.match(tt.name)) {
      name = this.state.value;
    } else if (this.state.type.keyword) {
      name = this.state.type.keyword;
    } else {
      throw this.unexpected();
    }
    if (!liberal && name === "await" && this.state.inAsync) {
      this.raise(pos, "invalid use of await inside of an async function");
    }
    this.next();
    return name;
  }
  checkReservedWord(
    word: string,
    startLoc: number,
    checkKeywords: boolean,
    isBinding: boolean,
  ): void {
    if (
      this.state.strict &&
      (reservedWords.strict(word) ||
        (isBinding && reservedWords.strictBind(word)))
    ) {
      this.raise(startLoc, word + " is a reserved word in strict mode");
    }
    if (this.state.inGenerator && word === "yield") {
      this.raise(
        startLoc,
        "yield is a reserved word inside generator functions",
      );
    }
    if (this.state.inClassProperty && word === "arguments") {
      this.raise(
        startLoc,
        "'arguments' is not allowed in class field initializer",
      );
    }
    if (this.isReservedWord(word) || (checkKeywords && this.isKeyword(word))) {
      this.raise(startLoc, word + " is a reserved word");
    }
  }
  // Parses await expression inside async function.
  parseAwait(node: N.AwaitExpression): N.AwaitExpression {
    // istanbul ignore next: this condition is checked at the call site so won't be hit here
    if (
      !this.state.inAsync &&
      (this.state.inFunction || !this.options.allowAwaitOutsideFunction)
    ) {
      this.unexpected();
    }
    if (this.match(tt.star)) {
      this.raise(
        node.start,
        "await* has been removed from the async functions proposal. Use Promise.all() instead.",
      );
    }
    node.argument = this.parseMaybeUnary();
    return this.finishNode(node, "AwaitExpression");
  }
  // Parses yield expression inside generator.
  parseYield(): N.YieldExpression {
    const node = this.startNode();
    if (this.state.inParameters) {
      this.raise(node.start, "yield is not allowed in generator parameters");
    }
    if (
      this.state.maybeInArrowParameters &&
      // We only set yieldInPossibleArrowParameters if we haven't already
      // found a possible invalid YieldExpression.
      !this.state.yieldInPossibleArrowParameters
    ) {
      this.state.yieldInPossibleArrowParameters = node;
    }
    this.next();
    if (
      this.match(tt.semi) ||
      this.canInsertSemicolon() ||
      (!this.match(tt.star) && !this.state.type.startsExpr)
    ) {
      node.delegate = false;
      node.argument = null;
    } else {
      node.delegate = this.eat(tt.star);
      node.argument = this.parseMaybeAssign();
    }
    return this.finishNode(node, "YieldExpression");
  }
}

// </from> /home/qfox/apps/babel/packages/babel-parser/src/parser/expression.js

// <from> /home/qfox/apps/babel/packages/babel-parser/src/parser/node.js

// @flow
import UtilParser from "./util";
import { SourceLocation, type Position } from "../util/location";
// Start an AST node, attaching a start offset.
const commentKeys = ["leadingComments", "trailingComments", "innerComments"];
class Node implements NodeBase {
  constructor(parser: Parser, pos: number, loc: Position) {
    this.type = "";
    this.start = pos;
    this.end = 0;
    this.loc = new SourceLocation(loc);
    if (parser && parser.options.ranges) this.range = [pos, 0];
    if (parser && parser.filename) this.loc.filename = parser.filename;
  }
  type: string;
  start: number;
  end: number;
  loc: SourceLocation;
  range: [number, number];
  leadingComments: Array<Comment>;
  trailingComments: Array<Comment>;
  innerComments: Array<Comment>;
  extra: { [key: string]: any };
  __clone(): this {
    // $FlowIgnore
    const node2: any = new Node();
    Object.keys(this).forEach(key => {
      // Do not clone comments that are already attached to the node
      if (commentKeys.indexOf(key) < 0) {
        // $FlowIgnore
        node2[key] = this[key];
      }
    });
    return node2;
  }
}
export class NodeUtils extends UtilParser {
  startNode<T: NodeType>(): T {
    // $FlowIgnore
    return new Node(this, this.state.start, this.state.startLoc);
  }
  startNodeAt<T: NodeType>(pos: number, loc: Position): T {
    // $FlowIgnore
    return new Node(this, pos, loc);
  }
  /** Start a new node with a previous node's location. */
  startNodeAtNode<T: NodeType>(type: NodeType): T {
    return this.startNodeAt(type.start, type.loc.start);
  }
  // Finish an AST node, adding `type` and `end` properties.
  finishNode<T: NodeType>(node: T, type: string): T {
    return this.finishNodeAt(
      node,
      type,
      this.state.lastTokEnd,
      this.state.lastTokEndLoc,
    );
  }
  // Finish node at given position
  finishNodeAt<T: NodeType>(
    node: T,
    type: string,
    pos: number,
    loc: Position,
  ): T {
    node.type = type;
    node.end = pos;
    node.loc.end = loc;
    if (this.options.ranges) node.range[1] = pos;
    this.processComment(node);
    return node;
  }
  /**
   * Reset the start location of node to the start location of locationNode
   */
  resetStartLocationFromNode(node: NodeBase, locationNode: NodeBase): void {
    node.start = locationNode.start;
    node.loc.start = locationNode.loc.start;
    if (this.options.ranges) node.range[0] = locationNode.range[0];
  }
}

// </from> /home/qfox/apps/babel/packages/babel-parser/src/parser/node.js

// <from> /home/qfox/apps/babel/packages/babel-parser/src/parser/base.js

// @flow
import { reservedWords } from "../util/identifier";
export default class BaseParser {
  // Properties set by constructor in index.js
  options: Options;
  inModule: boolean;
  plugins: PluginsMap;
  filename: ?string;
  sawUnambiguousESM: boolean = false;
  // Initialized by Tokenizer
  state: State;
  input: string;
  isReservedWord(word: string): boolean {
    if (word === "await") {
      return this.inModule;
    } else {
      return reservedWords[6](word);
    }
  }
  hasPlugin(name: string): boolean {
    return Object.hasOwnProperty.call(this.plugins, name);
  }
  getPluginOption(plugin: string, name: string) {
    if (this.hasPlugin(plugin)) return this.plugins[plugin][name];
  }
}

// </from> /home/qfox/apps/babel/packages/babel-parser/src/parser/base.js

// <from> /home/qfox/apps/babel/packages/babel-parser/src/plugin-utils.js

// @flow
export type Plugin = string | [string, Object];
export type PluginList = $ReadOnlyArray<Plugin>;
export type MixinPlugin = (superClass: Class<Parser>) => Class<Parser>;
export function hasPlugin(plugins: PluginList, name: string): boolean {
  return plugins.some(plugin => {
    if (Array.isArray(plugin)) {
      return plugin[0] === name;
    } else {
      return plugin === name;
    }
  });
}
export function getPluginOption(
  plugins: PluginList,
  name: string,
  option: string,
) {
  const plugin = plugins.find(plugin => {
    if (Array.isArray(plugin)) {
      return plugin[0] === name;
    } else {
      return plugin === name;
    }
  });
  if (plugin && Array.isArray(plugin)) {
    return plugin[1][option];
  }
  return null;
}
const PIPELINE_PROPOSALS = ["minimal"];
export function validatePlugins(plugins: PluginList) {
  if (hasPlugin(plugins, "decorators")) {
    if (hasPlugin(plugins, "decorators-legacy")) {
      throw new Error(
        "Cannot use the decorators and decorators-legacy plugin together",
      );
    }
    const decoratorsBeforeExport = getPluginOption(
      plugins,
      "decorators",
      "decoratorsBeforeExport",
    );
    if (decoratorsBeforeExport == null) {
      throw new Error(
        "The 'decorators' plugin requires a 'decoratorsBeforeExport' option," +
          " whose value must be a boolean. If you are migrating from" +
          " Babylon/Babel 6 or want to use the old decorators proposal, you" +
          " should use the 'decorators-legacy' plugin instead of 'decorators'.",
      );
    } else if (typeof decoratorsBeforeExport !== "boolean") {
      throw new Error("'decoratorsBeforeExport' must be a boolean.");
    }
  }
  if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript")) {
    throw new Error("Cannot combine flow and typescript plugins.");
  }
  if (
    hasPlugin(plugins, "pipelineOperator") &&
    !PIPELINE_PROPOSALS.includes(
      getPluginOption(plugins, "pipelineOperator", "proposal"),
    )
  ) {
    throw new Error(
      "'pipelineOperator' requires 'proposal' option whose value should be one of: " +
        PIPELINE_PROPOSALS.join(", "),
    );
  }
}
// These plugins are defined using a mixin which extends the parser class.
import estree from "./plugins/estree";
import flow from "./plugins/flow";
import jsx from "./plugins/jsx";
import typescript from "./plugins/typescript";
// NOTE: estree must load first; flow and typescript must load last.
export const mixinPluginNames = ["estree", "jsx", "flow", "typescript"];
export const mixinPlugins: { [name: string]: MixinPlugin } = {
  estree,
  jsx,
  flow,
  typescript,
};

// </from> /home/qfox/apps/babel/packages/babel-parser/src/plugin-utils.js

// <from> /home/qfox/apps/babel/packages/babel-parser/src/util/location.js

// @flow
import { lineBreakG } from "./whitespace";
export type Pos = {
  start: number,
};
// These are used when `options.locations` is on, for the
// `startLoc` and `endLoc` properties.
export class Position {
  line: number;
  column: number;
  constructor(line: number, col: number) {
    this.line = line;
    this.column = col;
  }
}
export class SourceLocation {
  start: Position;
  end: Position;
  filename: string;
  identifierName: ?string;
  constructor(start: Position, end?: Position) {
    this.start = start;
    // $FlowIgnore (may start as null, but initialized later)
    this.end = end;
  }
}
// The `getLineInfo` function is mostly useful when the
// `locations` option is off (for performance reasons) and you
// want to find the line/column position for a given character
// offset. `input` should be the code string that the offset refers
// into.
export function getLineInfo(input: string, offset: number): Position {
  let line = 1;
  let lineStart = 0;
  let match;
  lineBreakG.lastIndex = 0;
  while ((match = lineBreakG.exec(input)) && match.index < offset) {
    line++;
    lineStart = lineBreakG.lastIndex;
  }
  return new Position(line, offset - lineStart);
}

// </from> /home/qfox/apps/babel/packages/babel-parser/src/util/location.js

// <from> /home/qfox/apps/babel/packages/babel-parser/src/util/whitespace.js

// @flow
import * as charCodes from "charcodes";
// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.
export const lineBreak = /\r\n?|\n|\u2028|\u2029/;
export const lineBreakG = new RegExp(lineBreak.source, "g");
// https://tc39.github.io/ecma262/#sec-line-terminators
export function isNewLine(code: number): boolean {
  switch (code) {
    case charCodes.lineFeed:
    case charCodes.carriageReturn:
    case charCodes.lineSeparator:
    case charCodes.paragraphSeparator:
      return true;
    default:
      return false;
  }
}
export const skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
// https://tc39.github.io/ecma262/#sec-white-space
export function isWhitespace(code: number): boolean {
  switch (code) {
    case 0x0009: // CHARACTER TABULATION
    case 0x000b: // LINE TABULATION
    case 0x000c: // FORM FEED
    case charCodes.space:
    case charCodes.nonBreakingSpace:
    case charCodes.oghamSpaceMark:
    case 0x2000: // EN QUAD
    case 0x2001: // EM QUAD
    case 0x2002: // EN SPACE
    case 0x2003: // EM SPACE
    case 0x2004: // THREE-PER-EM SPACE
    case 0x2005: // FOUR-PER-EM SPACE
    case 0x2006: // SIX-PER-EM SPACE
    case 0x2007: // FIGURE SPACE
    case 0x2008: // PUNCTUATION SPACE
    case 0x2009: // THIN SPACE
    case 0x200a: // HAIR SPACE
    case 0x202f: // NARROW NO-BREAK SPACE
    case 0x205f: // MEDIUM MATHEMATICAL SPACE
    case 0x3000: // IDEOGRAPHIC SPACE
    case 0xfeff: // ZERO WIDTH NO-BREAK SPACE
      return true;
    default:
      return false;
  }
}

// </from> /home/qfox/apps/babel/packages/babel-parser/src/util/whitespace.js

// <from> /home/qfox/apps/babel/packages/babel-parser/src/util/identifier.js

/* eslint max-len: 0 */
// @flow
import * as charCodes from "charcodes";
function makePredicate(words: string): (str: string) => boolean {
  const wordsArr = words.split(" ");
  return function(str) {
    return wordsArr.indexOf(str) >= 0;
  };
}
// Reserved word lists for various dialects of the language
export const reservedWords = {
  "6": makePredicate("enum await"),
  strict: makePredicate(
    "implements interface let package private protected public static yield",
  ),
  strictBind: makePredicate("eval arguments"),
};
// And the keywords
export const isKeyword = makePredicate(
  "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this let const class extends export import yield super",
);
// ## Character categories
// Big ugly regular expressions that matches characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 0x80.
// Generated by `scripts/generate-identifier-regex.js`.
/* prettier-ignore */
let nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7b9\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab65\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
/* prettier-ignore */
let nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
const nonASCIIidentifierStart = new RegExp(
  "[" + nonASCIIidentifierStartChars + "]",
);
const nonASCIIidentifier = new RegExp(
  "[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]",
);
nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
// These are a run-length and offset-encoded representation of the
// >0xffff code points that are a valid part of identifiers. The
// offset starts at 0x10000, and each pair of numbers represents an
// offset to the next range, and then a size of the range. They were
// generated by `scripts/generate-identifier-regex.js`.
/* prettier-ignore */
const astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,190,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,54,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,86,26,230,43,117,63,32,0,257,0,11,39,8,0,22,0,12,39,3,3,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,68,12,0,67,12,65,1,31,6129,15,754,9486,286,82,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,4149,196,60,67,1213,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541];
/* prettier-ignore */
const astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,280,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1016,45,17,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,2214,6,110,6,6,9,792487,239];
// This has a complexity linear to the value of the code. The
// assumption is that looking up astral identifier characters is
// rare.
function isInAstralSet(code: number, set: $ReadOnlyArray<number>): boolean {
  let pos = 0x10000;
  for (let i = 0; i < set.length; i += 2) {
    pos += set[i];
    if (pos > code) return false;
    pos += set[i + 1];
    if (pos >= code) return true;
  }
  return false;
}
// Test whether a given character code starts an identifier.
export function isIdentifierStart(code: number): boolean {
  if (code < charCodes.uppercaseA) return code === charCodes.dollarSign;
  if (code <= charCodes.uppercaseZ) return true;
  if (code < charCodes.lowercaseA) return code === charCodes.underscore;
  if (code <= charCodes.lowercaseZ) return true;
  if (code <= 0xffff) {
    return (
      code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code))
    );
  }
  return isInAstralSet(code, astralIdentifierStartCodes);
}
// Test whether a current state character code and next character code is @
export function isIteratorStart(current: number, next: number): boolean {
  return current === charCodes.atSign && next === charCodes.atSign;
}
// Test whether a given character is part of an identifier.
export function isIdentifierChar(code: number): boolean {
  if (code < charCodes.digit0) return code === charCodes.dollarSign;
  if (code < charCodes.colon) return true;
  if (code < charCodes.uppercaseA) return false;
  if (code <= charCodes.uppercaseZ) return true;
  if (code < charCodes.lowercaseA) return code === charCodes.underscore;
  if (code <= charCodes.lowercaseZ) return true;
  if (code <= 0xffff) {
    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
  }
  return (
    isInAstralSet(code, astralIdentifierStartCodes) ||
    isInAstralSet(code, astralIdentifierCodes)
  );
}

// </from> /home/qfox/apps/babel/packages/babel-parser/src/util/identifier.js

// <from> /home/qfox/apps/babel/packages/babel-parser/src/types.js

// @flow
/*
 * If making any changes to the AST, update:
 * - This repository:
 *   - This file
 *   - `ast` directory
 * - Babel repository:
 *   - packages/babel-types/src/definitions
 *   - packages/babel-generators/src/generators
 */
export type Comment = {
  type: "CommentBlock" | "CommentLine",
  value: string,
  start: number,
  end: number,
  loc: SourceLocation,
};
export interface NodeBase {
  start: number;
  end: number;
  loc: SourceLocation;
  range: [number, number];
  leadingComments?: Array<Comment>;
  trailingComments?: Array<Comment>;
  innerComments?: Array<Comment>;
  extra: { [key: string]: any };
}
// Using a union type for `Node` makes type-checking too slow.
// Instead, add an index signature to allow a Node to be treated as anything.
export type Node = NodeBase & { [key: string]: any };
export type Expression = Node;
export type Statement = Node;
export type Pattern =
  | Identifier
  | ObjectPattern
  | ArrayPattern
  | RestElement
  | AssignmentPattern;
export type Declaration =
  | VariableDeclaration
  | ClassDeclaration
  | FunctionDeclaration
  | TsInterfaceDeclaration
  | TsTypeAliasDeclaration
  | TsEnumDeclaration
  | TsModuleDeclaration;
export type DeclarationBase = NodeBase & {
  // TypeScript allows declarations to be prefixed by `declare`.
  //TODO: a FunctionDeclaration is never "declare", because it's a TSDeclareFunction instead.
  declare?: true,
};
// TODO: Not in spec
export type HasDecorators = NodeBase & {
  decorators?: $ReadOnlyArray<Decorator>,
};
export type InterpreterDirective = NodeBase & {
  type: "InterpreterDirective",
  value: string,
};
export type Identifier = PatternBase & {
  type: "Identifier",
  name: string,
  __clone(): Identifier,
  // TypeScript only. Used in case of an optional parameter.
  optional?: ?true,
};
export type PrivateName = NodeBase & {
  type: "PrivateName",
  id: Identifier,
};
// Literals
export type Literal =
  | RegExpLiteral
  | NullLiteral
  | StringLiteral
  | BooleanLiteral
  | NumericLiteral;
export type RegExpLiteral = NodeBase & {
  type: "RegExpLiteral",
  pattern: string,
  flags: RegExp$flags,
};
export type NullLiteral = NodeBase & {
  type: "NullLiteral",
};
export type StringLiteral = NodeBase & {
  type: "StringLiteral",
  value: string,
};
export type BooleanLiteral = NodeBase & {
  type: "BooleanLiteral",
  value: boolean,
};
export type NumericLiteral = NodeBase & {
  type: "NumericLiteral",
  value: number,
};
export type BigIntLiteral = NodeBase & {
  type: "BigIntLiteral",
  value: number,
};
// Programs
export type BlockStatementLike = Program | BlockStatement;
export type File = NodeBase & {
  type: "File",
  program: Program,
  comments: $ReadOnlyArray<Comment>,
  tokens: $ReadOnlyArray<Token | Comment>,
};
export type Program = NodeBase & {
  type: "Program",
  sourceType: SourceType,
  body: Array<Statement | ModuleDeclaration>, // TODO: $ReadOnlyArray
  directives: $ReadOnlyArray<Directive>, // TODO: Not in spec
  interpreter: InterpreterDirective | null,
};
// Functions
export type Function =
  | NormalFunction
  | ArrowFunctionExpression
  | ObjectMethod
  | ClassMethod;
export type NormalFunction = FunctionDeclaration | FunctionExpression;
export type BodilessFunctionOrMethodBase = HasDecorators & {
  // TODO: Remove this. Should not assign "id" to methods.
  // https://github.com/babel/babylon/issues/535
  id: ?Identifier,
  params: $ReadOnlyArray<Pattern | TSParameterProperty>,
  body: BlockStatement,
  generator: boolean,
  async: boolean,
  // TODO: All not in spec
  expression: boolean,
  typeParameters?: ?TypeParameterDeclarationBase,
  returnType?: ?TypeAnnotationBase,
};
export type BodilessFunctionBase = BodilessFunctionOrMethodBase & {
  id: ?Identifier,
};
export type FunctionBase = BodilessFunctionBase & {
  body: BlockStatement,
};
// Statements
export type ExpressionStatement = NodeBase & {
  type: "ExpressionStatement",
  expression: Expression,
};
export type BlockStatement = NodeBase & {
  type: "BlockStatement",
  body: Array<Statement>, // TODO: $ReadOnlyArray
  directives: $ReadOnlyArray<Directive>,
};
export type EmptyStatement = NodeBase & {
  type: "EmptyStatement",
};
export type DebuggerStatement = NodeBase & {
  type: "DebuggerStatement",
};
export type WithStatement = NodeBase & {
  type: "WithStatement",
  object: Expression,
  body: Statement,
};
export type ReturnStatement = NodeBase & {
  type: "ReturnStatement",
  argument: ?Expression,
};
export type LabeledStatement = NodeBase & {
  type: "LabeledStatement",
  label: Identifier,
  body: Statement,
};
export type BreakStatement = NodeBase & {
  type: "BreakStatement",
  label: ?Identifier,
};
export type ContinueStatement = NodeBase & {
  type: "ContinueStatement",
  label: ?Identifier,
};
// Choice
export type IfStatement = NodeBase & {
  type: "IfStatement",
  test: Expression,
  consequent: Statement,
  alternate: ?Statement,
};
export type SwitchStatement = NodeBase & {
  type: "SwitchStatement",
  discriminant: Expression,
  cases: $ReadOnlyArray<SwitchCase>,
};
export type SwitchCase = NodeBase & {
  type: "SwitchCase",
  test: ?Expression,
  consequent: $ReadOnlyArray<Statement>,
};
// Exceptions
export type ThrowStatement = NodeBase & {
  type: "ThrowStatement",
  argument: Expression,
};
export type TryStatement = NodeBase & {
  type: "TryStatement",
  block: BlockStatement,
  handler: CatchClause | null,
  finalizer: BlockStatement | null,
  guardedHandlers: $ReadOnlyArray<empty>, // TODO: Not in spec
};
export type CatchClause = NodeBase & {
  type: "CatchClause",
  param: Pattern,
  body: BlockStatement,
};
// Loops
export type WhileStatement = NodeBase & {
  type: "WhileStatement",
  test: Expression,
  body: Statement,
};
export type DoWhileStatement = NodeBase & {
  type: "DoWhileStatement",
  body: Statement,
  test: Expression,
};
export type ForLike = ForStatement | ForInOf;
export type ForStatement = NodeBase & {
  type: "ForStatement",
  init: ?(VariableDeclaration | Expression),
  test: ?Expression,
  update: ?Expression,
  body: Statement,
};
export type ForInOf = ForInStatement | ForOfStatement;
export type ForInOfBase = NodeBase & {
  type: "ForInStatement",
  left: VariableDeclaration | Expression,
  right: Expression,
  body: Statement,
};
export type ForInStatement = ForInOfBase & {
  type: "ForInStatement",
  // TODO: Shouldn't be here, but have to declare it because it's assigned to a ForInOf unconditionally.
  await: boolean,
};
export type ForOfStatement = ForInOfBase & {
  type: "ForOfStatement",
  await: boolean,
};
// Declarations
export type OptFunctionDeclaration = FunctionBase &
  DeclarationBase & {
    type: "FunctionDeclaration",
  };
export type FunctionDeclaration = OptFunctionDeclaration & {
  id: Identifier,
};
export type VariableDeclaration = DeclarationBase &
  HasDecorators & {
    type: "VariableDeclaration",
    declarations: $ReadOnlyArray<VariableDeclarator>,
    kind: "var" | "let" | "const",
  };
export type VariableDeclarator = NodeBase & {
  type: "VariableDeclarator",
  id: Pattern,
  init: ?Expression,
  // TypeScript only:
  definite?: true,
};
// Misc
export type Decorator = NodeBase & {
  type: "Decorator",
  expression: Expression,
  arguments?: Array<Expression | SpreadElement>,
};
export type Directive = NodeBase & {
  type: "Directive",
  value: DirectiveLiteral,
};
export type DirectiveLiteral = StringLiteral & { type: "DirectiveLiteral" };
// Expressions
export type Super = NodeBase & { type: "Super" };
export type Import = NodeBase & { type: "Import" };
export type ThisExpression = NodeBase & { type: "ThisExpression" };
export type ArrowFunctionExpression = FunctionBase & {
  type: "ArrowFunctionExpression",
  body: BlockStatement | Expression,
};
export type YieldExpression = NodeBase & {
  type: "YieldExpression",
  argument: ?Expression,
  delegate: boolean,
};
export type AwaitExpression = NodeBase & {
  type: "AwaitExpression",
  argument: ?Expression,
};
export type ArrayExpression = NodeBase & {
  type: "ArrayExpression",
  elements: $ReadOnlyArray<?(Expression | SpreadElement)>,
};
export type ObjectExpression = NodeBase & {
  type: "ObjectExpression",
  properties: $ReadOnlyArray<ObjectProperty | ObjectMethod | SpreadElement>,
};
export type ObjectOrClassMember = ClassMethod | ClassProperty | ObjectMember;
export type ObjectMember = ObjectProperty | ObjectMethod;
export type ObjectMemberBase = NodeBase & {
  key: Expression,
  computed: boolean,
  value: Expression,
  decorators: $ReadOnlyArray<Decorator>,
  kind?: "get" | "set" | "method",
  method: boolean, // TODO: Not in spec
  variance?: ?FlowVariance, // TODO: Not in spec
};
export type ObjectProperty = ObjectMemberBase & {
  type: "ObjectProperty",
  shorthand: boolean,
};
export type ObjectMethod = ObjectMemberBase &
  MethodBase & {
    type: "ObjectMethod",
    kind: "get" | "set" | "method", // Never "constructor"
  };
export type FunctionExpression = MethodBase & {
  kind?: void, // never set
  type: "FunctionExpression",
};
// Unary operations
export type UnaryExpression = NodeBase & {
  type: "UnaryExpression",
  operator: UnaryOperator,
  prefix: boolean,
  argument: Expression,
};
export type UnaryOperator =
  | "-"
  | "+"
  | "!"
  | "~"
  | "typeof"
  | "void"
  | "delete"
  | "throw";
export type UpdateExpression = NodeBase & {
  type: "UpdateExpression",
  operator: UpdateOperator,
  argument: Expression,
  prefix: boolean,
};
export type UpdateOperator = "++" | "--";
// Binary operations
export type BinaryExpression = NodeBase & {
  type: "BinaryExpression",
  operator: BinaryOperator,
  left: Expression,
  right: Expression,
};
export type BinaryOperator =
  | "=="
  | "!="
  | "==="
  | "!=="
  | "<"
  | "<="
  | ">"
  | ">="
  | "<<"
  | ">>"
  | ">>>"
  | "+"
  | "-"
  | "*"
  | "/"
  | "%"
  | "|"
  | "^"
  | "&"
  | "in"
  | "instanceof";
export type AssignmentExpression = NodeBase & {
  type: "AssignmentExpression",
  operator: AssignmentOperator,
  left: Pattern | Expression,
  right: Expression,
};
export type AssignmentOperator =
  | "="
  | "+="
  | "-="
  | "*="
  | "/="
  | "%="
  | "<<="
  | ">>="
  | ">>>="
  | "|="
  | "^="
  | "&=";
export type LogicalExpression = NodeBase & {
  type: "LogicalExpression",
  operator: LogicalOperator,
  left: Expression,
  right: Expression,
};
export type LogicalOperator = "||" | "&&";
export type SpreadElement = NodeBase & {
  type: "SpreadElement",
  argument: Expression,
};
export type MemberExpression = NodeBase & {
  type: "MemberExpression",
  object: Expression | Super,
  property: Expression,
  computed: boolean,
};
export type OptionalMemberExpression = NodeBase & {
  type: "OptionalMemberExpression",
  object: Expression | Super,
  property: Expression,
  computed: boolean,
  optional: boolean,
};
export type OptionalCallExpression = CallOrNewBase & {
  type: "OptionalCallExpression",
  optional: boolean,
};
export type BindExpression = NodeBase & {
  type: "BindExpression",
  object: $ReadOnlyArray<?Expression>,
  callee: $ReadOnlyArray<Expression>,
};
export type ConditionalExpression = NodeBase & {
  type: "ConditionalExpression",
  test: Expression,
  alternate: Expression,
  consequent: Expression,
};
export type CallOrNewBase = NodeBase & {
  callee: Expression | Super | Import,
  arguments: Array<Expression | SpreadElement>, // TODO: $ReadOnlyArray
  typeArguments: ?TypeParameterInstantiationBase,
  typeParameters?: ?TypeParameterInstantiationBase, // TODO: Not in spec
};
export type CallExpression = CallOrNewBase & {
  type: "CallExpression",
};
export type NewExpression = CallOrNewBase & {
  type: "NewExpression",
  optional?: boolean, // TODO: Not in spec
};
export type SequenceExpression = NodeBase & {
  type: "SequenceExpression",
  expressions: $ReadOnlyArray<Expression>,
};
// Template Literals
export type TemplateLiteral = NodeBase & {
  type: "TemplateLiteral",
  quasis: $ReadOnlyArray<TemplateElement>,
  expressions: $ReadOnlyArray<Expression>,
};
export type TaggedTemplateExpression = NodeBase & {
  type: "TaggedTemplateExpression",
  tag: Expression,
  quasi: TemplateLiteral,
  typeParameters?: ?TypeParameterInstantiationBase, // TODO: Not in spec
};
export type TemplateElement = NodeBase & {
  type: "TemplateElement",
  tail: boolean,
  value: {
    cooked: string,
    raw: string,
  },
};
// Patterns
// TypeScript access modifiers
export type Accessibility = "public" | "protected" | "private";
export type PatternBase = HasDecorators & {
  // TODO: All not in spec
  // Flow/TypeScript only:
  typeAnnotation?: ?TypeAnnotationBase,
};
export type AssignmentProperty = ObjectProperty & {
  value: Pattern,
};
export type ObjectPattern = PatternBase & {
  type: "ObjectPattern",
  properties: $ReadOnlyArray<AssignmentProperty | RestElement>,
};
export type ArrayPattern = PatternBase & {
  type: "ArrayPattern",
  elements: $ReadOnlyArray<?Pattern>,
};
export type RestElement = PatternBase & {
  type: "RestElement",
  argument: Pattern,
};
export type AssignmentPattern = PatternBase & {
  type: "AssignmentPattern",
  left: Pattern,
  right: Expression,
};
// Classes
export type Class = ClassDeclaration | ClassExpression;
export type ClassBase = HasDecorators & {
  id: ?Identifier,
  superClass: ?Expression,
  body: ClassBody,
  decorators: $ReadOnlyArray<Decorator>,
  // TODO: All not in spec
  typeParameters?: ?TypeParameterDeclarationBase,
  superTypeParameters?: ?TypeParameterInstantiationBase,
  implements?:
    | ?$ReadOnlyArray<TsExpressionWithTypeArguments>
    | $ReadOnlyArray<FlowClassImplements>,
};
export type ClassBody = NodeBase & {
  type: "ClassBody",
  body: Array<ClassMember | TsIndexSignature>, // TODO: $ReadOnlyArray
};
export type ClassMemberBase = NodeBase &
  HasDecorators & {
    static: boolean,
    computed: boolean,
    // TypeScript only:
    accessibility?: ?Accessibility,
    abstract?: ?true,
    optional?: ?true,
  };
export type ClassMember =
  | ClassMethod
  | ClassPrivateMethod
  | ClassProperty
  | ClassPrivateProperty;
export type MethodLike =
  | ObjectMethod
  | FunctionExpression
  | ClassMethod
  | ClassPrivateMethod
  | TSDeclareMethod;
export type MethodBase = FunctionBase & {
  +kind: MethodKind,
};
export type MethodKind = "constructor" | "method" | "get" | "set";
export type ClassMethodOrDeclareMethodCommon = ClassMemberBase & {
  key: Expression,
  kind: MethodKind,
  static: boolean,
  decorators: $ReadOnlyArray<Decorator>,
};
export type ClassMethod = MethodBase &
  ClassMethodOrDeclareMethodCommon & {
    type: "ClassMethod",
    variance?: ?FlowVariance, // TODO: Not in spec
  };
export type ClassPrivateMethod = NodeBase &
  ClassMethodOrDeclareMethodCommon &
  MethodBase & {
    type: "ClassPrivateMethod",
    key: PrivateName,
    computed: false,
  };
export type ClassProperty = ClassMemberBase & {
  type: "ClassProperty",
  key: Expression,
  value: ?Expression, // TODO: Not in spec that this is nullable.
  typeAnnotation?: ?TypeAnnotationBase, // TODO: Not in spec
  variance?: ?FlowVariance, // TODO: Not in spec
  // TypeScript only: (TODO: Not in spec)
  readonly?: true,
  definite?: true,
};
export type ClassPrivateProperty = NodeBase & {
  type: "ClassPrivateProperty",
  key: PrivateName,
  value: ?Expression, // TODO: Not in spec that this is nullable.
  static: boolean,
  computed: false,
  typeAnnotation?: ?TypeAnnotation, // TODO: Not in spec
};
export type OptClassDeclaration = ClassBase &
  DeclarationBase &
  HasDecorators & {
    type: "ClassDeclaration",
    // TypeScript only
    abstract?: ?true,
  };
export type ClassDeclaration = OptClassDeclaration & {
  id: Identifier,
};
export type ClassExpression = ClassBase & { type: "ClassExpression" };
export type MetaProperty = NodeBase & {
  type: "MetaProperty",
  meta: Identifier,
  property: Identifier,
};
// Modules
export type ModuleDeclaration = AnyImport | AnyExport;
export type AnyImport = ImportDeclaration | TsImportEqualsDeclaration;
export type AnyExport =
  | ExportNamedDeclaration
  | ExportDefaultDeclaration
  | ExportAllDeclaration
  | TsExportAssignment;
export type ModuleSpecifier = NodeBase & {
  local: Identifier,
};
// Imports
export type ImportDeclaration = NodeBase & {
  type: "ImportDeclaration",
  // TODO: $ReadOnlyArray
  specifiers: Array<
    ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier,
  >,
  source: Literal,
  importKind?: "type" | "typeof" | "value", // TODO: Not in spec
};
export type ImportSpecifier = ModuleSpecifier & {
  type: "ImportSpecifier",
  imported: Identifier,
};
export type ImportDefaultSpecifier = ModuleSpecifier & {
  type: "ImportDefaultSpecifier",
};
export type ImportNamespaceSpecifier = ModuleSpecifier & {
  type: "ImportNamespaceSpecifier",
};
// Exports
export type ExportNamedDeclaration = NodeBase & {
  type: "ExportNamedDeclaration",
  declaration: ?Declaration,
  specifiers: $ReadOnlyArray<ExportSpecifier>,
  source: ?Literal,
  exportKind?: "type" | "value", // TODO: Not in spec
};
export type ExportSpecifier = NodeBase & {
  type: "ExportSpecifier",
  exported: Identifier,
};
export type ExportDefaultDeclaration = NodeBase & {
  type: "ExportDefaultDeclaration",
  declaration:
    | OptFunctionDeclaration
    | OptTSDeclareFunction
    | OptClassDeclaration
    | Expression,
};
export type ExportAllDeclaration = NodeBase & {
  type: "ExportAllDeclaration",
  source: Literal,
  exportKind?: "type" | "value", // TODO: Not in spec
};
// JSX (TODO: Not in spec)
export type JSXIdentifier = Node;
export type JSXNamespacedName = Node;
export type JSXMemberExpression = Node;
export type JSXEmptyExpression = Node;
export type JSXSpreadChild = Node;
export type JSXExpressionContainer = Node;
export type JSXAttribute = Node;
export type JSXOpeningElement = NodeBase & {
  type: "JSXOpeningElement",
  name: JSXNamespacedName | JSXMemberExpression,
  typeParameters?: ?TypeParameterInstantiationBase, // TODO: Not in spec
  attributes: $ReadOnlyArray<JSXAttribute>,
  selfClosing: boolean,
};
export type JSXClosingElement = Node;
export type JSXElement = Node;
export type JSXOpeningFragment = Node;
export type JSXClosingFragment = Node;
export type JSXFragment = Node;
// Flow/TypeScript common (TODO: Not in spec)
export type TypeAnnotationBase = NodeBase & {
  typeAnnotation: Node,
};
export type TypeAnnotation = NodeBase & {
  type: "TypeAnnotation",
  typeAnnotation: FlowTypeAnnotation,
};
export type TsTypeAnnotation = NodeBase & {
  type: "TSTypeAnnotation",
  typeAnnotation: TsType,
};
export type TypeParameterDeclarationBase = NodeBase & {
  params: $ReadOnlyArray<TypeParameterBase>,
};
export type TypeParameterDeclaration = TypeParameterDeclarationBase & {
  type: "TypeParameterDeclaration",
  params: $ReadOnlyArray<TypeParameter>,
};
export type TsTypeParameterDeclaration = TypeParameterDeclarationBase & {
  type: "TsTypeParameterDeclaration",
  params: $ReadOnlyArray<TsTypeParameter>,
};
export type TypeParameterBase = NodeBase & {
  name: string,
};
export type TypeParameter = TypeParameterBase & {
  type: "TypeParameter",
  default?: TypeAnnotation,
};
export type TsTypeParameter = TypeParameterBase & {
  type: "TSTypeParameter",
  constraint?: TsType,
  default?: TsType,
};
export type TypeParameterInstantiationBase = NodeBase & {
  params: $ReadOnlyArray<Node>,
};
export type TypeParameterInstantiation = TypeParameterInstantiationBase & {
  type: "TypeParameterInstantiation",
  params: $ReadOnlyArray<FlowType>,
};
export type TsTypeParameterInstantiation = TypeParameterInstantiationBase & {
  type: "TSTypeParameterInstantiation",
  params: $ReadOnlyArray<TsType>,
};
// Flow (TODO: Not in spec)
export type TypeCastExpressionBase = NodeBase & {
  expression: Expression,
  typeAnnotation: TypeAnnotationBase,
};
export type TypeCastExpression = NodeBase & {
  type: "TypeCastExpression",
  expression: Expression,
  typeAnnotation: TypeAnnotation,
};
export type TsTypeCastExpression = NodeBase & {
  type: "TSTypeCastExpression",
  expression: Expression,
  typeAnnotation: TsTypeAnnotation,
};
export type FlowType = Node;
export type FlowPredicate = Node;
export type FlowDeclare = Node;
export type FlowDeclareClass = Node;
export type FlowDeclareExportDeclaration = Node;
export type FlowDeclareFunction = Node;
export type FlowDeclareVariable = Node;
export type FlowDeclareModule = Node;
export type FlowDeclareModuleExports = Node;
export type FlowDeclareTypeAlias = Node;
export type FlowDeclareOpaqueType = Node;
export type FlowDeclareInterface = Node;
export type FlowInterface = Node;
export type FlowInterfaceExtends = Node;
export type FlowTypeAlias = Node;
export type FlowOpaqueType = Node;
export type FlowObjectTypeIndexer = Node;
export type FlowObjectTypeInternalSlot = Node;
export type FlowFunctionTypeAnnotation = Node;
export type FlowObjectTypeProperty = Node;
export type FlowObjectTypeSpreadProperty = Node;
export type FlowObjectTypeCallProperty = Node;
export type FlowObjectTypeAnnotation = Node;
export type FlowQualifiedTypeIdentifier = Node;
export type FlowGenericTypeAnnotation = Node;
export type FlowTypeofTypeAnnotation = Node;
export type FlowTupleTypeAnnotation = Node;
export type FlowFunctionTypeParam = Node;
export type FlowTypeAnnotation = Node;
export type FlowVariance = Node;
export type FlowClassImplements = Node;
export type FlowInterfaceType = NodeBase & {
  type: "FlowInterfaceType",
  extends: FlowInterfaceExtends,
  body: FlowObjectTypeAnnotation,
};
// estree
export type EstreeProperty = NodeBase & {
  type: "Property",
  shorthand: boolean,
  key: Expression,
  computed: boolean,
  value: Expression,
  decorators: $ReadOnlyArray<Decorator>,
  kind?: "get" | "set" | "init",
  variance?: ?FlowVariance,
};
export type EstreeMethodDefinition = NodeBase & {
  type: "MethodDefinition",
  static: boolean,
  key: Expression,
  computed: boolean,
  value: Expression,
  decorators: $ReadOnlyArray<Decorator>,
  kind?: "get" | "set" | "method",
  variance?: ?FlowVariance,
};
// === === === ===
// TypeScript
// === === === ===
// Note: A type named `TsFoo` is based on TypeScript's `FooNode` type,
// defined in https://github.com/Microsoft/TypeScript/blob/master/src/compiler/types.ts
// Differences:
// * Change `NodeArray<T>` to just `$ReadOnlyArray<T>`.
// * Don't give nodes a "modifiers" list; use boolean flags instead,
//   and only allow modifiers that are not considered errors.
// * A property named `type` must be renamed to `typeAnnotation` to avoid conflict with the node's type.
// * Sometimes TypeScript allows to parse something which will be a grammar error later;
//   in @babel/parser these cause exceptions, so the AST format is stricter.
// ================
// Misc
// ================
export type TSParameterProperty = HasDecorators & {
  // Note: This has decorators instead of its parameter.
  type: "TSParameterProperty",
  // At least one of `accessibility` or `readonly` must be set.
  accessibility?: ?Accessibility,
  readonly?: ?true,
  parameter: Identifier | AssignmentPattern,
};
export type OptTSDeclareFunction = BodilessFunctionBase &
  DeclarationBase & {
    type: "TSDeclareFunction",
  };
export type TSDeclareFunction = OptTSDeclareFunction & {
  id: Identifier,
};
export type TSDeclareMethod = BodilessFunctionOrMethodBase &
  ClassMethodOrDeclareMethodCommon & {
    type: "TSDeclareMethod",
    +kind: MethodKind,
  };
export type TsQualifiedName = NodeBase & {
  type: "TSQualifiedName",
  left: TsEntityName,
  right: Identifier,
};
export type TsEntityName = Identifier | TsQualifiedName;
export type TsSignatureDeclaration =
  | TsCallSignatureDeclaration
  | TsConstructSignatureDeclaration
  | TsMethodSignature
  | TsFunctionType
  | TsConstructorType;
export type TsSignatureDeclarationOrIndexSignatureBase = NodeBase & {
  // Not using TypeScript's "ParameterDeclaration" here, since it's inconsistent with regular functions.
  parameters: $ReadOnlyArray<Identifier | RestElement>,
  typeAnnotation: ?TsTypeAnnotation,
};
export type TsSignatureDeclarationBase = TsSignatureDeclarationOrIndexSignatureBase & {
  typeParameters: ?TsTypeParameterDeclaration,
};
// ================
// TypeScript type members (for type literal / interface / class)
// ================
export type TsTypeElement =
  | TsCallSignatureDeclaration
  | TsConstructSignatureDeclaration
  | TsPropertySignature
  | TsMethodSignature
  | TsIndexSignature;
export type TsCallSignatureDeclaration = TsSignatureDeclarationBase & {
  type: "TSCallSignatureDeclaration",
};
export type TsConstructSignatureDeclaration = TsSignatureDeclarationBase & {
  type: "TSConstructSignature",
};
export type TsNamedTypeElementBase = NodeBase & {
  // Not using TypeScript's `PropertyName` here since we don't have a `ComputedPropertyName` node type.
  // This is usually an Identifier but may be e.g. `Symbol.iterator` if `computed` is true.
  key: Expression,
  computed: boolean,
  optional?: true,
};
export type TsPropertySignature = TsNamedTypeElementBase & {
  type: "TSPropertySignature",
  readonly?: true,
  typeAnnotation?: TsTypeAnnotation,
  initializer?: Expression,
};
export type TsMethodSignature = TsSignatureDeclarationBase &
  TsNamedTypeElementBase & {
    type: "TSMethodSignature",
  };
// *Not* a ClassMemberBase: Can't have accessibility, can't be abstract, can't be optional.
export type TsIndexSignature = TsSignatureDeclarationOrIndexSignatureBase & {
  readonly?: true,
  type: "TSIndexSignature",
  // Note: parameters.length must be 1.
};
// ================
// TypeScript types
// ================
export type TsType =
  | TsKeywordType
  | TsThisType
  | TsFunctionOrConstructorType
  | TsTypeReference
  | TsTypeQuery
  | TsTypeLiteral
  | TsArrayType
  | TsTupleType
  | TsOptionalType
  | TsUnionOrIntersectionType
  | TsConditionalType
  | TsInferType
  | TsParenthesizedType
  | TsTypeOperator
  | TsIndexedAccessType
  | TsMappedType
  | TsLiteralType
  // TODO: This probably shouldn't be included here.
  | TsTypePredicate;
export type TsTypeBase = NodeBase;
export type TsKeywordTypeType =
  | "TSAnyKeyword"
  | "TSUnknownKeyword"
  | "TSNumberKeyword"
  | "TSObjectKeyword"
  | "TSBooleanKeyword"
  | "TSStringKeyword"
  | "TSSymbolKeyword"
  | "TSVoidKeyword"
  | "TSUndefinedKeyword"
  | "TSNullKeyword"
  | "TSNeverKeyword";
export type TsKeywordType = TsTypeBase & {
  type: TsKeywordTypeType,
};
export type TsThisType = TsTypeBase & {
  type: "TSThisType",
};
export type TsFunctionOrConstructorType = TsFunctionType | TsConstructorType;
export type TsFunctionType = TsTypeBase &
  TsSignatureDeclarationBase & {
    type: "TSFunctionType",
    typeAnnotation: TypeAnnotation, // not optional
  };
export type TsConstructorType = TsTypeBase &
  TsSignatureDeclarationBase & {
    type: "TSConstructorType",
    typeAnnotation: TsTypeAnnotation,
  };
export type TsTypeReference = TsTypeBase & {
  type: "TSTypeReference",
  typeName: TsEntityName,
  typeParameters?: TsTypeParameterInstantiation,
};
export type TsTypePredicate = TsTypeBase & {
  type: "TSTypePredicate",
  parameterName: Identifier | TsThisType,
  typeAnnotation: TsTypeAnnotation,
};
// `typeof` operator
export type TsTypeQuery = TsTypeBase & {
  type: "TSTypeQuery",
  exprName: TsEntityName,
};
export type TsTypeLiteral = TsTypeBase & {
  type: "TSTypeLiteral",
  members: $ReadOnlyArray<TsTypeElement>,
};
export type TsArrayType = TsTypeBase & {
  type: "TSArrayType",
  elementType: TsType,
};
export type TsTupleType = TsTypeBase & {
  type: "TSTupleType",
  elementTypes: $ReadOnlyArray<TsType>,
};
export type TsOptionalType = TsTypeBase & {
  type: "TSOptionalType",
  typeAnnotation: TsType,
};
export type TsUnionOrIntersectionType = TsUnionType | TsIntersectionType;
export type TsUnionOrIntersectionTypeBase = TsTypeBase & {
  types: $ReadOnlyArray<TsType>,
};
export type TsUnionType = TsUnionOrIntersectionTypeBase & {
  type: "TSUnionType",
};
export type TsIntersectionType = TsUnionOrIntersectionTypeBase & {
  type: "TSIntersectionType",
};
export type TsConditionalType = TsTypeBase & {
  type: "TSConditionalType",
  checkType: TsType,
  extendsType: TsType,
  trueType: TsType,
  falseType: TsType,
};
export type TsInferType = TsTypeBase & {
  type: "TSInferType",
  typeParameter: TypeParameter,
};
export type TsParenthesizedType = TsTypeBase & {
  type: "TSParenthesizedType",
  typeAnnotation: TsType,
};
export type TsTypeOperator = TsTypeBase & {
  type: "TSTypeOperator",
  operator: "keyof" | "unique",
  typeAnnotation: TsType,
};
export type TsIndexedAccessType = TsTypeBase & {
  type: "TSIndexedAccessType",
  objectType: TsType,
  indexType: TsType,
};
export type TsMappedType = TsTypeBase & {
  type: "TSMappedType",
  readonly?: true | "+" | "-",
  typeParameter: TsTypeParameter,
  optional?: true | "+" | "-",
  typeAnnotation: ?TsType,
};
export type TsLiteralType = TsTypeBase & {
  type: "TSLiteralType",
  literal: NumericLiteral | StringLiteral | BooleanLiteral,
};
// ================
// TypeScript declarations
// ================
export type TsInterfaceDeclaration = DeclarationBase & {
  type: "TSInterfaceDeclaration",
  id: Identifier,
  typeParameters: ?TsTypeParameterDeclaration,
  // TS uses "heritageClauses", but want this to resemble ClassBase.
  extends?: $ReadOnlyArray<TsExpressionWithTypeArguments>,
  body: TSInterfaceBody,
};
export type TSInterfaceBody = NodeBase & {
  type: "TSInterfaceBody",
  body: $ReadOnlyArray<TsTypeElement>,
};
export type TsExpressionWithTypeArguments = TsTypeBase & {
  type: "TSExpressionWithTypeArguments",
  expression: TsEntityName,
  typeParameters?: TsTypeParameterInstantiation,
};
export type TsTypeAliasDeclaration = DeclarationBase & {
  type: "TSTypeAliasDeclaration",
  id: Identifier,
  typeParameters: ?TsTypeParameterDeclaration,
  typeAnnotation: TsType,
};
export type TsEnumDeclaration = DeclarationBase & {
  type: "TSEnumDeclaration",
  const?: true,
  id: Identifier,
  members: $ReadOnlyArray<TsEnumMember>,
};
export type TsEnumMember = NodeBase & {
  type: "TSEnumMemodulmber",
  id: Identifier | StringLiteral,
  initializer?: Expression,
};
export type TsModuleDeclaration = DeclarationBase & {
  type: "TSModuleDeclaration",
  global?: true, // In TypeScript, this is only available through `node.flags`.
  id: TsModuleName,
  body: TsNamespaceBody,
};
// `namespace A.B { }` is a namespace named `A` with another TsNamespaceDeclaration as its body.
export type TsNamespaceBody = TsModuleBlock | TsNamespaceDeclaration;
export type TsModuleBlock = NodeBase & {
  type: "TSModuleBlock",
  body: $ReadOnlyArray<Statement>,
};
export type TsNamespaceDeclaration = TsModuleDeclaration & {
  id: Identifier,
  body: TsNamespaceBody,
};
export type TsModuleName = Identifier | StringLiteral;
export type TsImportEqualsDeclaration = NodeBase & {
  type: "TSImportEqualsDeclaration",
  isExport: boolean,
  id: Identifier,
  moduleReference: TsModuleReference,
};
export type TsModuleReference = TsEntityName | TsExternalModuleReference;
export type TsExternalModuleReference = NodeBase & {
  type: "TSExternalModuleReference",
  expression: StringLiteral,
};
// TypeScript's own parser uses ExportAssignment for both `export default` and `export =`.
// But for @babel/parser, `export default` is an ExportDefaultDeclaration,
// so a TsExportAssignment is always `export =`.
export type TsExportAssignment = NodeBase & {
  type: "TSExportAssignment",
  expression: Expression,
};
export type TsNamespaceExportDeclaration = NodeBase & {
  type: "TSNamespaceExportDeclaration",
  id: Identifier,
};
// ================
// TypeScript expressions
// ================
export type TsTypeAssertionLikeBase = NodeBase & {
  expression: Expression,
  typeAnnotation: TsType,
};
export type TsAsExpression = TsTypeAssertionLikeBase & {
  type: "TSAsExpression",
};
export type TsTypeAssertion = TsTypeAssertionLikeBase & {
  type: "TSTypeAssertion",
};
export type TsNonNullExpression = NodeBase & {
  type: "TSNonNullExpression",
  expression: Expression,
};
// ================
// Other
// ================
export type ParseSubscriptState = {
  optionalChainMember: boolean,
  stop: boolean,
};

// </from> /home/qfox/apps/babel/packages/babel-parser/src/types.js

// <from> /home/qfox/apps/babel/packages/babel-parser/src/tokenizer/index.js

// @flow
import * as charCodes from "charcodes";
import {
  isIdentifierStart,
  isIdentifierChar,
  isKeyword,
} from "../util/identifier";
import { types as tt, keywords as keywordTypes, type TokenType } from "./types";
import { type TokContext, types as ct } from "./context";
import LocationParser from "../parser/location";
import { SourceLocation } from "../util/location";
import {
  lineBreak,
  lineBreakG,
  isNewLine,
  isWhitespace,
} from "../util/whitespace";
import State from "./state";
const VALID_REGEX_FLAGS = "gmsiyu";
// The following character codes are forbidden from being
// an immediate sibling of NumericLiteralSeparator _
const forbiddenNumericSeparatorSiblings = {
  decBinOct: [
    charCodes.dot,
    charCodes.uppercaseB,
    charCodes.uppercaseE,
    charCodes.uppercaseO,
    charCodes.underscore, // multiple separators are not allowed
    charCodes.lowercaseB,
    charCodes.lowercaseE,
    charCodes.lowercaseO,
  ],
  hex: [
    charCodes.dot,
    charCodes.uppercaseX,
    charCodes.underscore, // multiple separators are not allowed
    charCodes.lowercaseX,
  ],
};
const allowedNumericSeparatorSiblings = {};
allowedNumericSeparatorSiblings.bin = [
  // 0 - 1
  charCodes.digit0,
  charCodes.digit1,
];
allowedNumericSeparatorSiblings.oct = [
  // 0 - 7
  ...allowedNumericSeparatorSiblings.bin,
  charCodes.digit2,
  charCodes.digit3,
  charCodes.digit4,
  charCodes.digit5,
  charCodes.digit6,
  charCodes.digit7,
];
allowedNumericSeparatorSiblings.dec = [
  // 0 - 9
  ...allowedNumericSeparatorSiblings.oct,
  charCodes.digit8,
  charCodes.digit9,
];
allowedNumericSeparatorSiblings.hex = [
  // 0 - 9, A - F, a - f,
  ...allowedNumericSeparatorSiblings.dec,
  charCodes.uppercaseA,
  charCodes.uppercaseB,
  charCodes.uppercaseC,
  charCodes.uppercaseD,
  charCodes.uppercaseE,
  charCodes.uppercaseF,
  charCodes.lowercaseA,
  charCodes.lowercaseB,
  charCodes.lowercaseC,
  charCodes.lowercaseD,
  charCodes.lowercaseE,
  charCodes.lowercaseF,
];
// Object type used to represent tokens. Note that normally, tokens
// simply exist as properties on the parser object. This is only
// used for the onToken callback and the external tokenizer.
export class Token {
  constructor(state: State) {
    this.type = state.type;
    this.value = state.value;
    this.start = state.start;
    this.end = state.end;
    this.loc = new SourceLocation(state.startLoc, state.endLoc);
  }
  type: TokenType;
  value: any;
  start: number;
  end: number;
  loc: SourceLocation;
}
// ## Tokenizer
export default class Tokenizer extends LocationParser {
  // Forward-declarations
  // parser/util.js
  +unexpected: (pos?: ?number, messageOrType?: string | TokenType) => empty;
  isLookahead: boolean;
  constructor(options: Options, input: string) {
    super();
    this.state = new State();
    this.state.init(options, input);
    this.isLookahead = false;
  }
  // Move to the next token
  next(): void {
    if (this.options.tokens && !this.isLookahead) {
      this.state.tokens.push(new Token(this.state));
    }
    this.state.lastTokEnd = this.state.end;
    this.state.lastTokStart = this.state.start;
    this.state.lastTokEndLoc = this.state.endLoc;
    this.state.lastTokStartLoc = this.state.startLoc;
    this.nextToken();
  }
  // TODO
  eat(type: TokenType): boolean {
    if (this.match(type)) {
      this.next();
      return true;
    } else {
      return false;
    }
  }
  // TODO
  match(type: TokenType): boolean {
    return this.state.type === type;
  }
  // TODO
  isKeyword(word: string): boolean {
    return isKeyword(word);
  }
  // TODO
  lookahead(): State {
    const old = this.state;
    this.state = old.clone(true);
    this.isLookahead = true;
    this.next();
    this.isLookahead = false;
    const curr = this.state;
    this.state = old;
    return curr;
  }
  // Toggle strict mode. Re-reads the next number or string to please
  // pedantic tests (`"use strict"; 010;` should fail).
  setStrict(strict: boolean): void {
    this.state.strict = strict;
    if (!this.match(tt.num) && !this.match(tt.string)) return;
    this.state.pos = this.state.start;
    while (this.state.pos < this.state.lineStart) {
      this.state.lineStart =
        this.input.lastIndexOf("\n", this.state.lineStart - 2) + 1;
      --this.state.curLine;
    }
    this.nextToken();
  }
  curContext(): TokContext {
    return this.state.context[this.state.context.length - 1];
  }
  // Read a single token, updating the parser object's token-related
  // properties.
  nextToken(): void {
    const curContext = this.curContext();
    if (!curContext || !curContext.preserveSpace) this.skipSpace();
    this.state.containsOctal = false;
    this.state.octalPosition = null;
    this.state.start = this.state.pos;
    this.state.startLoc = this.state.curPosition();
    if (this.state.pos >= this.input.length) {
      this.finishToken(tt.eof);
      return;
    }
    if (curContext.override) {
      curContext.override(this);
    } else {
      this.readToken(this.input.codePointAt(this.state.pos));
    }
  }
  readToken(code: number): void {
    // Identifier or keyword. '\uXXXX' sequences are allowed in
    // identifiers, so '\' also dispatches to that.
    if (isIdentifierStart(code) || code === charCodes.backslash) {
      this.readWord();
    } else {
      this.getTokenFromCode(code);
    }
  }
  pushComment(
    block: boolean,
    text: string,
    start: number,
    end: number,
    startLoc: Position,
    endLoc: Position,
  ): void {
    const comment = {
      type: block ? "CommentBlock" : "CommentLine",
      value: text,
      start: start,
      end: end,
      loc: new SourceLocation(startLoc, endLoc),
    };
    if (!this.isLookahead) {
      if (this.options.tokens) this.state.tokens.push(comment);
      this.state.comments.push(comment);
      this.addComment(comment);
    }
  }
  skipBlockComment(): void {
    const startLoc = this.state.curPosition();
    const start = this.state.pos;
    const end = this.input.indexOf("*/", (this.state.pos += 2));
    if (end === -1) this.raise(this.state.pos - 2, "Unterminated comment");
    this.state.pos = end + 2;
    lineBreakG.lastIndex = start;
    let match;
    while (
      (match = lineBreakG.exec(this.input)) &&
      match.index < this.state.pos
    ) {
      ++this.state.curLine;
      this.state.lineStart = match.index + match[0].length;
    }
    this.pushComment(
      true,
      this.input.slice(start + 2, end),
      start,
      this.state.pos,
      startLoc,
      this.state.curPosition(),
    );
  }
  skipLineComment(startSkip: number): void {
    const start = this.state.pos;
    const startLoc = this.state.curPosition();
    let ch = this.input.charCodeAt((this.state.pos += startSkip));
    if (this.state.pos < this.input.length) {
      while (
        ch !== charCodes.lineFeed &&
        ch !== charCodes.carriageReturn &&
        ch !== charCodes.lineSeparator &&
        ch !== charCodes.paragraphSeparator &&
        ++this.state.pos < this.input.length
      ) {
        ch = this.input.charCodeAt(this.state.pos);
      }
    }
    this.pushComment(
      false,
      this.input.slice(start + startSkip, this.state.pos),
      start,
      this.state.pos,
      startLoc,
      this.state.curPosition(),
    );
  }
  // Called at the start of the parse and after every token. Skips
  // whitespace and comments, and.
  skipSpace(): void {
    loop: while (this.state.pos < this.input.length) {
      const ch = this.input.charCodeAt(this.state.pos);
      switch (ch) {
        case charCodes.carriageReturn:
          if (
            this.input.charCodeAt(this.state.pos + 1) === charCodes.lineFeed
          ) {
            ++this.state.pos;
          }
        case charCodes.lineFeed:
        case charCodes.lineSeparator:
        case charCodes.paragraphSeparator:
          ++this.state.pos;
          ++this.state.curLine;
          this.state.lineStart = this.state.pos;
          break;
        case charCodes.slash:
          switch (this.input.charCodeAt(this.state.pos + 1)) {
            case charCodes.asterisk:
              this.skipBlockComment();
              break;
            case charCodes.slash:
              this.skipLineComment(2);
              break;
            default:
              break loop;
          }
          break;
        default:
          if (isWhitespace(ch)) {
            ++this.state.pos;
          } else {
            break loop;
          }
      }
    }
  }
  // Called at the end of every token. Sets `end`, `val`, and
  // maintains `context` and `exprAllowed`, and skips the space after
  // the token, so that the next one's `start` will point at the
  // right position.
  finishToken(type: TokenType, val: any): void {
    this.state.end = this.state.pos;
    this.state.endLoc = this.state.curPosition();
    const prevType = this.state.type;
    this.state.type = type;
    this.state.value = val;
    this.updateContext(prevType);
  }
  // ### Token reading
  // This is the function that is called to fetch the next token. It
  // is somewhat obscure, because it works in character codes rather
  // than characters, and because operator parsing has been inlined
  // into it.
  //
  // All in the name of speed.
  //
  readToken_dot(): void {
    const next = this.input.charCodeAt(this.state.pos + 1);
    if (next >= charCodes.digit0 && next <= charCodes.digit9) {
      this.readNumber(true);
      return;
    }
    const next2 = this.input.charCodeAt(this.state.pos + 2);
    if (next === charCodes.dot && next2 === charCodes.dot) {
      this.state.pos += 3;
      this.finishToken(tt.ellipsis);
    } else {
      ++this.state.pos;
      this.finishToken(tt.dot);
    }
  }
  readToken_slash(): void {
    // '/'
    if (this.state.exprAllowed && !this.state.inType) {
      ++this.state.pos;
      this.readRegexp();
      return;
    }
    const next = this.input.charCodeAt(this.state.pos + 1);
    if (next === charCodes.equalsTo) {
      this.finishOp(tt.assign, 2);
    } else {
      this.finishOp(tt.slash, 1);
    }
  }
  readToken_interpreter(): boolean {
    if (this.state.pos !== 0 || this.state.input.length < 2) return false;
    const start = this.state.pos;
    this.state.pos += 1;
    let ch = this.input.charCodeAt(this.state.pos);
    if (ch !== charCodes.exclamationMark) return false;
    while (
      ch !== charCodes.lineFeed &&
      ch !== charCodes.carriageReturn &&
      ch !== charCodes.lineSeparator &&
      ch !== charCodes.paragraphSeparator &&
      ++this.state.pos < this.input.length
    ) {
      ch = this.input.charCodeAt(this.state.pos);
    }
    const value = this.input.slice(start + 2, this.state.pos);
    this.finishToken(tt.interpreterDirective, value);
    return true;
  }
  readToken_mult_modulo(code: number): void {
    // '%*'
    let type = code === charCodes.asterisk ? tt.star : tt.modulo;
    let width = 1;
    let next = this.input.charCodeAt(this.state.pos + 1);
    const exprAllowed = this.state.exprAllowed;
    // Exponentiation operator **
    if (code === charCodes.asterisk && next === charCodes.asterisk) {
      width++;
      next = this.input.charCodeAt(this.state.pos + 2);
      type = tt.exponent;
    }
    if (next === charCodes.equalsTo && !exprAllowed) {
      width++;
      type = tt.assign;
    }
    this.finishOp(type, width);
  }
  readToken_pipe_amp(code: number): void {
    // '|&'
    const next = this.input.charCodeAt(this.state.pos + 1);
    if (next === code) {
      if (this.input.charCodeAt(this.state.pos + 2) === charCodes.equalsTo) {
        this.finishOp(tt.assign, 3);
      } else {
        this.finishOp(
          code === charCodes.verticalBar ? tt.logicalOR : tt.logicalAND,
          2,
        );
      }
      return;
    }
    if (code === charCodes.verticalBar) {
      // '|>'
      if (next === charCodes.greaterThan) {
        this.finishOp(tt.pipeline, 2);
        return;
      } else if (next === charCodes.rightCurlyBrace && this.hasPlugin("flow")) {
        // '|}'
        this.finishOp(tt.braceBarR, 2);
        return;
      }
    }
    if (next === charCodes.equalsTo) {
      this.finishOp(tt.assign, 2);
      return;
    }
    this.finishOp(
      code === charCodes.verticalBar ? tt.bitwiseOR : tt.bitwiseAND,
      1,
    );
  }
  readToken_caret(): void {
    // '^'
    const next = this.input.charCodeAt(this.state.pos + 1);
    if (next === charCodes.equalsTo) {
      this.finishOp(tt.assign, 2);
    } else {
      this.finishOp(tt.bitwiseXOR, 1);
    }
  }
  readToken_plus_min(code: number): void {
    // '+-'
    const next = this.input.charCodeAt(this.state.pos + 1);
    if (next === code) {
      if (
        next === charCodes.dash &&
        !this.inModule &&
        this.input.charCodeAt(this.state.pos + 2) === charCodes.greaterThan &&
        lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.pos))
      ) {
        // A `-->` line comment
        this.skipLineComment(3);
        this.skipSpace();
        this.nextToken();
        return;
      }
      this.finishOp(tt.incDec, 2);
      return;
    }
    if (next === charCodes.equalsTo) {
      this.finishOp(tt.assign, 2);
    } else {
      this.finishOp(tt.plusMin, 1);
    }
  }
  readToken_lt_gt(code: number): void {
    // '<>'
    const next = this.input.charCodeAt(this.state.pos + 1);
    let size = 1;
    if (next === code) {
      size =
        code === charCodes.greaterThan &&
        this.input.charCodeAt(this.state.pos + 2) === charCodes.greaterThan
          ? 3
          : 2;
      if (this.input.charCodeAt(this.state.pos + size) === charCodes.equalsTo) {
        this.finishOp(tt.assign, size + 1);
        return;
      }
      this.finishOp(tt.bitShift, size);
      return;
    }
    if (
      next === charCodes.exclamationMark &&
      code === charCodes.lessThan &&
      !this.inModule &&
      this.input.charCodeAt(this.state.pos + 2) === charCodes.dash &&
      this.input.charCodeAt(this.state.pos + 3) === charCodes.dash
    ) {
      // `<!--`, an XML-style comment that should be interpreted as a line comment
      this.skipLineComment(4);
      this.skipSpace();
      this.nextToken();
      return;
    }
    if (next === charCodes.equalsTo) {
      // <= | >=
      size = 2;
    }
    this.finishOp(tt.relational, size);
  }
  readToken_eq_excl(code: number): void {
    // '=!'
    const next = this.input.charCodeAt(this.state.pos + 1);
    if (next === charCodes.equalsTo) {
      this.finishOp(
        tt.equality,
        this.input.charCodeAt(this.state.pos + 2) === charCodes.equalsTo
          ? 3
          : 2,
      );
      return;
    }
    if (code === charCodes.equalsTo && next === charCodes.greaterThan) {
      // '=>'
      this.state.pos += 2;
      this.finishToken(tt.arrow);
      return;
    }
    this.finishOp(code === charCodes.equalsTo ? tt.eq : tt.bang, 1);
  }
  readToken_question(): void {
    // '?'
    const next = this.input.charCodeAt(this.state.pos + 1);
    const next2 = this.input.charCodeAt(this.state.pos + 2);
    if (next === charCodes.questionMark && !this.state.inType) {
      if (next2 === charCodes.equalsTo) {
        // '??='
        this.finishOp(tt.assign, 3);
      } else {
        // '??'
        this.finishOp(tt.nullishCoalescing, 2);
      }
    } else if (
      next === charCodes.dot &&
      !(next2 >= charCodes.digit0 && next2 <= charCodes.digit9)
    ) {
      // '.' not followed by a number
      this.state.pos += 2;
      this.finishToken(tt.questionDot);
    } else {
      ++this.state.pos;
      this.finishToken(tt.question);
    }
  }
  getTokenFromCode(code: number): void {
    switch (code) {
      case charCodes.numberSign:
        if (this.state.pos === 0 && this.readToken_interpreter()) {
          return;
        }
        if (
          (this.hasPlugin("classPrivateProperties") ||
            this.hasPlugin("classPrivateMethods")) &&
          this.state.classLevel > 0
        ) {
          ++this.state.pos;
          this.finishToken(tt.hash);
          return;
        } else {
          this.raise(
            this.state.pos,
            `Unexpected character '${String.fromCodePoint(code)}'`,
          );
        }
      // The interpretation of a dot depends on whether it is followed
      // by a digit or another two dots.
      case charCodes.dot:
        this.readToken_dot();
        return;
      // Punctuation tokens.
      case charCodes.leftParenthesis:
        ++this.state.pos;
        this.finishToken(tt.parenL);
        return;
      case charCodes.rightParenthesis:
        ++this.state.pos;
        this.finishToken(tt.parenR);
        return;
      case charCodes.semicolon:
        ++this.state.pos;
        this.finishToken(tt.semi);
        return;
      case charCodes.comma:
        ++this.state.pos;
        this.finishToken(tt.comma);
        return;
      case charCodes.leftSquareBracket:
        ++this.state.pos;
        this.finishToken(tt.bracketL);
        return;
      case charCodes.rightSquareBracket:
        ++this.state.pos;
        this.finishToken(tt.bracketR);
        return;
      case charCodes.leftCurlyBrace:
        if (
          this.hasPlugin("flow") &&
          this.input.charCodeAt(this.state.pos + 1) === charCodes.verticalBar
        ) {
          this.finishOp(tt.braceBarL, 2);
        } else {
          ++this.state.pos;
          this.finishToken(tt.braceL);
        }
        return;
      case charCodes.rightCurlyBrace:
        ++this.state.pos;
        this.finishToken(tt.braceR);
        return;
      case charCodes.colon:
        if (
          this.hasPlugin("functionBind") &&
          this.input.charCodeAt(this.state.pos + 1) === charCodes.colon
        ) {
          this.finishOp(tt.doubleColon, 2);
        } else {
          ++this.state.pos;
          this.finishToken(tt.colon);
        }
        return;
      case charCodes.questionMark:
        this.readToken_question();
        return;
      case charCodes.atSign:
        ++this.state.pos;
        this.finishToken(tt.at);
        return;
      case charCodes.graveAccent:
        ++this.state.pos;
        this.finishToken(tt.backQuote);
        return;
      case charCodes.digit0: {
        const next = this.input.charCodeAt(this.state.pos + 1);
        // '0x', '0X' - hex number
        if (next === charCodes.lowercaseX || next === charCodes.uppercaseX) {
          this.readRadixNumber(16);
          return;
        }
        // '0o', '0O' - octal number
        if (next === charCodes.lowercaseO || next === charCodes.uppercaseO) {
          this.readRadixNumber(8);
          return;
        }
        // '0b', '0B' - binary number
        if (next === charCodes.lowercaseB || next === charCodes.uppercaseB) {
          this.readRadixNumber(2);
          return;
        }
      }
      // Anything else beginning with a digit is an integer, octal
      // number, or float.
      case charCodes.digit1:
      case charCodes.digit2:
      case charCodes.digit3:
      case charCodes.digit4:
      case charCodes.digit5:
      case charCodes.digit6:
      case charCodes.digit7:
      case charCodes.digit8:
      case charCodes.digit9:
        this.readNumber(false);
        return;
      // Quotes produce strings.
      case charCodes.quotationMark:
      case charCodes.apostrophe:
        this.readString(code);
        return;
      // Operators are parsed inline in tiny state machines. '=' (charCodes.equalsTo) is
      // often referred to. `finishOp` simply skips the amount of
      // characters it is given as second argument, and returns a token
      // of the type given by its first argument.
      case charCodes.slash:
        this.readToken_slash();
        return;
      case charCodes.percentSign:
      case charCodes.asterisk:
        this.readToken_mult_modulo(code);
        return;
      case charCodes.verticalBar:
      case charCodes.ampersand:
        this.readToken_pipe_amp(code);
        return;
      case charCodes.caret:
        this.readToken_caret();
        return;
      case charCodes.plusSign:
      case charCodes.dash:
        this.readToken_plus_min(code);
        return;
      case charCodes.lessThan:
      case charCodes.greaterThan:
        this.readToken_lt_gt(code);
        return;
      case charCodes.equalsTo:
      case charCodes.exclamationMark:
        this.readToken_eq_excl(code);
        return;
      case charCodes.tilde:
        this.finishOp(tt.tilde, 1);
        return;
    }
    this.raise(
      this.state.pos,
      `Unexpected character '${String.fromCodePoint(code)}'`,
    );
  }
  finishOp(type: TokenType, size: number): void {
    const str = this.input.slice(this.state.pos, this.state.pos + size);
    this.state.pos += size;
    this.finishToken(type, str);
  }
  readRegexp(): void {
    const start = this.state.pos;
    let escaped, inClass;
    for (;;) {
      if (this.state.pos >= this.input.length) {
        this.raise(start, "Unterminated regular expression");
      }
      const ch = this.input.charAt(this.state.pos);
      if (lineBreak.test(ch)) {
        this.raise(start, "Unterminated regular expression");
      }
      if (escaped) {
        escaped = false;
      } else {
        if (ch === "[") {
          inClass = true;
        } else if (ch === "]" && inClass) {
          inClass = false;
        } else if (ch === "/" && !inClass) {
          break;
        }
        escaped = ch === "\\";
      }
      ++this.state.pos;
    }
    const content = this.input.slice(start, this.state.pos);
    ++this.state.pos;
    let mods = "";
    while (this.state.pos < this.input.length) {
      const char = this.input[this.state.pos];
      const charCode = this.input.codePointAt(this.state.pos);
      if (VALID_REGEX_FLAGS.indexOf(char) > -1) {
        if (mods.indexOf(char) > -1) {
          this.raise(this.state.pos + 1, "Duplicate regular expression flag");
        }
        ++this.state.pos;
        mods += char;
      } else if (
        isIdentifierChar(charCode) ||
        charCode === charCodes.backslash
      ) {
        this.raise(this.state.pos + 1, "Invalid regular expression flag");
      } else {
        break;
      }
    }
    this.finishToken(tt.regexp, {
      pattern: content,
      flags: mods,
    });
  }
  // Read an integer in the given radix. Return null if zero digits
  // were read, the integer value otherwise. When `len` is given, this
  // will return `null` unless the integer has exactly `len` digits.
  readInt(radix: number, len?: number): number | null {
    const start = this.state.pos;
    const forbiddenSiblings =
      radix === 16
        ? forbiddenNumericSeparatorSiblings.hex
        : forbiddenNumericSeparatorSiblings.decBinOct;
    const allowedSiblings =
      radix === 16
        ? allowedNumericSeparatorSiblings.hex
        : radix === 10
          ? allowedNumericSeparatorSiblings.dec
          : radix === 8
            ? allowedNumericSeparatorSiblings.oct
            : allowedNumericSeparatorSiblings.bin;
    let total = 0;
    for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
      const code = this.input.charCodeAt(this.state.pos);
      let val;
      if (this.hasPlugin("numericSeparator")) {
        const prev = this.input.charCodeAt(this.state.pos - 1);
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (code === charCodes.underscore) {
          if (allowedSiblings.indexOf(next) === -1) {
            this.raise(this.state.pos, "Invalid or unexpected token");
          }
          if (
            forbiddenSiblings.indexOf(prev) > -1 ||
            forbiddenSiblings.indexOf(next) > -1 ||
            Number.isNaN(next)
          ) {
            this.raise(this.state.pos, "Invalid or unexpected token");
          }
          // Ignore this _ character
          ++this.state.pos;
          continue;
        }
      }
      if (code >= charCodes.lowercaseA) {
        val = code - charCodes.lowercaseA + charCodes.lineFeed;
      } else if (code >= charCodes.uppercaseA) {
        val = code - charCodes.uppercaseA + charCodes.lineFeed;
      } else if (charCodes.isDigit(code)) {
        val = code - charCodes.digit0; // 0-9
      } else {
        val = Infinity;
      }
      if (val >= radix) break;
      ++this.state.pos;
      total = total * radix + val;
    }
    if (
      this.state.pos === start ||
      (len != null && this.state.pos - start !== len)
    ) {
      return null;
    }
    return total;
  }
  readRadixNumber(radix: number): void {
    const start = this.state.pos;
    let isBigInt = false;
    this.state.pos += 2; // 0x
    const val = this.readInt(radix);
    if (val == null) {
      this.raise(this.state.start + 2, "Expected number in radix " + radix);
    }
    if (this.hasPlugin("bigInt")) {
      if (this.input.charCodeAt(this.state.pos) === charCodes.lowercaseN) {
        ++this.state.pos;
        isBigInt = true;
      }
    }
    if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {
      this.raise(this.state.pos, "Identifier directly after number");
    }
    if (isBigInt) {
      const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");
      this.finishToken(tt.bigint, str);
      return;
    }
    this.finishToken(tt.num, val);
  }
  // Read an integer, octal integer, or floating-point number.
  readNumber(startsWithDot: boolean): void {
    const start = this.state.pos;
    let octal = this.input.charCodeAt(start) === charCodes.digit0;
    let isFloat = false;
    let isBigInt = false;
    if (!startsWithDot && this.readInt(10) === null) {
      this.raise(start, "Invalid number");
    }
    if (octal && this.state.pos == start + 1) octal = false; // number === 0
    let next = this.input.charCodeAt(this.state.pos);
    if (next === charCodes.dot && !octal) {
      ++this.state.pos;
      this.readInt(10);
      isFloat = true;
      next = this.input.charCodeAt(this.state.pos);
    }
    if (
      (next === charCodes.uppercaseE || next === charCodes.lowercaseE) &&
      !octal
    ) {
      next = this.input.charCodeAt(++this.state.pos);
      if (next === charCodes.plusSign || next === charCodes.dash) {
        ++this.state.pos;
      }
      if (this.readInt(10) === null) this.raise(start, "Invalid number");
      isFloat = true;
      next = this.input.charCodeAt(this.state.pos);
    }
    if (this.hasPlugin("bigInt")) {
      if (next === charCodes.lowercaseN) {
        // disallow floats and legacy octal syntax, new style octal ("0o") is handled in this.readRadixNumber
        if (isFloat || octal) this.raise(start, "Invalid BigIntLiteral");
        ++this.state.pos;
        isBigInt = true;
      }
    }
    if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {
      this.raise(this.state.pos, "Identifier directly after number");
    }
    // remove "_" for numeric literal separator, and "n" for BigInts
    const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");
    if (isBigInt) {
      this.finishToken(tt.bigint, str);
      return;
    }
    let val;
    if (isFloat) {
      val = parseFloat(str);
    } else if (!octal || str.length === 1) {
      val = parseInt(str, 10);
    } else if (this.state.strict) {
      this.raise(start, "Invalid number");
    } else if (/[89]/.test(str)) {
      val = parseInt(str, 10);
    } else {
      val = parseInt(str, 8);
    }
    this.finishToken(tt.num, val);
  }
  // Read a string value, interpreting backslash-escapes.
  readCodePoint(throwOnInvalid: boolean): number | null {
    const ch = this.input.charCodeAt(this.state.pos);
    let code;
    if (ch === charCodes.leftCurlyBrace) {
      const codePos = ++this.state.pos;
      code = this.readHexChar(
        this.input.indexOf("}", this.state.pos) - this.state.pos,
        throwOnInvalid,
      );
      ++this.state.pos;
      if (code === null) {
        // $FlowFixMe (is this always non-null?)
        --this.state.invalidTemplateEscapePosition; // to point to the '\'' instead of the 'u'
      } else if (code > 0x10ffff) {
        if (throwOnInvalid) {
          this.raise(codePos, "Code point out of bounds");
        } else {
          this.state.invalidTemplateEscapePosition = codePos - 2;
          return null;
        }
      }
    } else {
      code = this.readHexChar(4, throwOnInvalid);
    }
    return code;
  }
  readString(quote: number): void {
    let out = "",
      chunkStart = ++this.state.pos;
    const hasJsonStrings = this.hasPlugin("jsonStrings");
    for (;;) {
      if (this.state.pos >= this.input.length) {
        this.raise(this.state.start, "Unterminated string constant");
      }
      const ch = this.input.charCodeAt(this.state.pos);
      if (ch === quote) break;
      if (ch === charCodes.backslash) {
        out += this.input.slice(chunkStart, this.state.pos);
        // $FlowFixMe
        out += this.readEscapedChar(false);
        chunkStart = this.state.pos;
      } else if (
        hasJsonStrings &&
        (ch === charCodes.lineSeparator || ch === charCodes.paragraphSeparator)
      ) {
        ++this.state.pos;
      } else if (isNewLine(ch)) {
        this.raise(this.state.start, "Unterminated string constant");
      } else {
        ++this.state.pos;
      }
    }
    out += this.input.slice(chunkStart, this.state.pos++);
    this.finishToken(tt.string, out);
  }
  // Reads template string tokens.
  readTmplToken(): void {
    let out = "",
      chunkStart = this.state.pos,
      containsInvalid = false;
    for (;;) {
      if (this.state.pos >= this.input.length) {
        this.raise(this.state.start, "Unterminated template");
      }
      const ch = this.input.charCodeAt(this.state.pos);
      if (
        ch === charCodes.graveAccent ||
        (ch === charCodes.dollarSign &&
          this.input.charCodeAt(this.state.pos + 1) ===
            charCodes.leftCurlyBrace)
      ) {
        if (this.state.pos === this.state.start && this.match(tt.template)) {
          if (ch === charCodes.dollarSign) {
            this.state.pos += 2;
            this.finishToken(tt.dollarBraceL);
            return;
          } else {
            ++this.state.pos;
            this.finishToken(tt.backQuote);
            return;
          }
        }
        out += this.input.slice(chunkStart, this.state.pos);
        this.finishToken(tt.template, containsInvalid ? null : out);
        return;
      }
      if (ch === charCodes.backslash) {
        out += this.input.slice(chunkStart, this.state.pos);
        const escaped = this.readEscapedChar(true);
        if (escaped === null) {
          containsInvalid = true;
        } else {
          out += escaped;
        }
        chunkStart = this.state.pos;
      } else if (isNewLine(ch)) {
        out += this.input.slice(chunkStart, this.state.pos);
        ++this.state.pos;
        switch (ch) {
          case charCodes.carriageReturn:
            if (this.input.charCodeAt(this.state.pos) === charCodes.lineFeed) {
              ++this.state.pos;
            }
          case charCodes.lineFeed:
            out += "\n";
            break;
          default:
            out += String.fromCharCode(ch);
            break;
        }
        ++this.state.curLine;
        this.state.lineStart = this.state.pos;
        chunkStart = this.state.pos;
      } else {
        ++this.state.pos;
      }
    }
  }
  // Used to read escaped characters
  readEscapedChar(inTemplate: boolean): string | null {
    const throwOnInvalid = !inTemplate;
    const ch = this.input.charCodeAt(++this.state.pos);
    ++this.state.pos;
    switch (ch) {
      case charCodes.lowercaseN:
        return "\n";
      case charCodes.lowercaseR:
        return "\r";
      case charCodes.lowercaseX: {
        const code = this.readHexChar(2, throwOnInvalid);
        return code === null ? null : String.fromCharCode(code);
      }
      case charCodes.lowercaseU: {
        const code = this.readCodePoint(throwOnInvalid);
        return code === null ? null : String.fromCodePoint(code);
      }
      case charCodes.lowercaseT:
        return "\t";
      case charCodes.lowercaseB:
        return "\b";
      case charCodes.lowercaseV:
        return "\u000b";
      case charCodes.lowercaseF:
        return "\f";
      case charCodes.carriageReturn:
        if (this.input.charCodeAt(this.state.pos) === charCodes.lineFeed) {
          ++this.state.pos;
        }
      case charCodes.lineFeed:
        this.state.lineStart = this.state.pos;
        ++this.state.curLine;
        return "";
      default:
        if (ch >= charCodes.digit0 && ch <= charCodes.digit7) {
          const codePos = this.state.pos - 1;
          // $FlowFixMe
          let octalStr = this.input
            .substr(this.state.pos - 1, 3)
            .match(/^[0-7]+/)[0];
          let octal = parseInt(octalStr, 8);
          if (octal > 255) {
            octalStr = octalStr.slice(0, -1);
            octal = parseInt(octalStr, 8);
          }
          if (octal > 0) {
            if (inTemplate) {
              this.state.invalidTemplateEscapePosition = codePos;
              return null;
            } else if (this.state.strict) {
              this.raise(codePos, "Octal literal in strict mode");
            } else if (!this.state.containsOctal) {
              // These properties are only used to throw an error for an octal which occurs
              // in a directive which occurs prior to a "use strict" directive.
              this.state.containsOctal = true;
              this.state.octalPosition = codePos;
            }
          }
          this.state.pos += octalStr.length - 1;
          return String.fromCharCode(octal);
        }
        return String.fromCharCode(ch);
    }
  }
  // Used to read character escape sequences ('\x', '\u').
  readHexChar(len: number, throwOnInvalid: boolean): number | null {
    const codePos = this.state.pos;
    const n = this.readInt(16, len);
    if (n === null) {
      if (throwOnInvalid) {
        this.raise(codePos, "Bad character escape sequence");
      } else {
        this.state.pos = codePos - 1;
        this.state.invalidTemplateEscapePosition = codePos - 1;
      }
    }
    return n;
  }
  // Read an identifier, and return it as a string. Sets `this.state.containsEsc`
  // to whether the word contained a '\u' escape.
  //
  // Incrementally adds only escaped chars, adding other chunks as-is
  // as a micro-optimization.
  readWord1(): string {
    this.state.containsEsc = false;
    let word = "",
      first = true,
      chunkStart = this.state.pos;
    while (this.state.pos < this.input.length) {
      const ch = this.input.codePointAt(this.state.pos);
      if (isIdentifierChar(ch)) {
        this.state.pos += ch <= 0xffff ? 1 : 2;
      } else if (this.state.isIterator && ch === charCodes.atSign) {
        this.state.pos += 1;
      } else if (ch === charCodes.backslash) {
        this.state.containsEsc = true;
        word += this.input.slice(chunkStart, this.state.pos);
        const escStart = this.state.pos;
        if (this.input.charCodeAt(++this.state.pos) !== charCodes.lowercaseU) {
          this.raise(
            this.state.pos,
            "Expecting Unicode escape sequence \\uXXXX",
          );
        }
        ++this.state.pos;
        const esc = this.readCodePoint(true);
        // $FlowFixMe (thinks esc may be null, but throwOnInvalid is true)
        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, true)) {
          this.raise(escStart, "Invalid Unicode escape");
        }
        // $FlowFixMe
        word += String.fromCodePoint(esc);
        chunkStart = this.state.pos;
      } else {
        break;
      }
      first = false;
    }
    return word + this.input.slice(chunkStart, this.state.pos);
  }
  isIterator(word: string): boolean {
    return word === "@@iterator" || word === "@@asyncIterator";
  }
  // Read an identifier or keyword token. Will check for reserved
  // words when necessary.
  readWord(): void {
    const word = this.readWord1();
    let type = tt.name;
    if (this.isKeyword(word)) {
      if (this.state.containsEsc) {
        this.raise(this.state.pos, `Escape sequence in keyword ${word}`);
      }
      type = keywordTypes[word];
    }
    // Allow @@iterator and @@asyncIterator as a identifier only inside type
    if (
      this.state.isIterator &&
      (!this.isIterator(word) || !this.state.inType)
    ) {
      this.raise(this.state.pos, `Invalid identifier ${word}`);
    }
    this.finishToken(type, word);
  }
  braceIsBlock(prevType: TokenType): boolean {
    if (prevType === tt.colon) {
      const parent = this.curContext();
      if (parent === ct.braceStatement || parent === ct.braceExpression) {
        return !parent.isExpr;
      }
    }
    if (prevType === tt._return) {
      return lineBreak.test(
        this.input.slice(this.state.lastTokEnd, this.state.start),
      );
    }
    if (
      prevType === tt._else ||
      prevType === tt.semi ||
      prevType === tt.eof ||
      prevType === tt.parenR
    ) {
      return true;
    }
    if (prevType === tt.braceL) {
      return this.curContext() === ct.braceStatement;
    }
    if (prevType === tt.relational) {
      // `class C<T> { ... }`
      return true;
    }
    return !this.state.exprAllowed;
  }
  updateContext(prevType: TokenType): void {
    const type = this.state.type;
    let update;
    if (type.keyword && (prevType === tt.dot || prevType === tt.questionDot)) {
      this.state.exprAllowed = false;
    } else if ((update = type.updateContext)) {
      update.call(this, prevType);
    } else {
      this.state.exprAllowed = type.beforeExpr;
    }
  }
}

// </from> /home/qfox/apps/babel/packages/babel-parser/src/tokenizer/index.js

// <from> /home/qfox/apps/babel/packages/babel-parser/src/tokenizer/state.js

// @flow
import * as N from "../types";
import { Position } from "../util/location";
import { types as ct, type TokContext } from "./context";
import { types as tt, type TokenType } from "./types";
export default class State {
  init(options: Options, input: string): void {
    this.strict =
      options.strictMode === false ? false : options.sourceType === "module";
    this.input = input;
    this.potentialArrowAt = -1;
    this.noArrowAt = [];
    this.noArrowParamsConversionAt = [];
    this.inMethod = false;
    this.inFunction = false;
    this.inParameters = false;
    this.maybeInArrowParameters = false;
    this.inGenerator = false;
    this.inAsync = false;
    this.inPropertyName = false;
    this.inType = false;
    this.inClassProperty = false;
    this.noAnonFunctionType = false;
    this.hasFlowComment = false;
    this.isIterator = false;
    this.classLevel = 0;
    this.labels = [];
    this.decoratorStack = [[]];
    this.yieldInPossibleArrowParameters = null;
    this.tokens = [];
    this.comments = [];
    this.trailingComments = [];
    this.leadingComments = [];
    this.commentStack = [];
    // $FlowIgnore
    this.commentPreviousNode = null;
    this.pos = this.lineStart = 0;
    this.curLine = options.startLine;
    this.type = tt.eof;
    this.value = null;
    this.start = this.end = this.pos;
    this.startLoc = this.endLoc = this.curPosition();
    // $FlowIgnore
    this.lastTokEndLoc = this.lastTokStartLoc = null;
    this.lastTokStart = this.lastTokEnd = this.pos;
    this.context = [ct.braceStatement];
    this.exprAllowed = true;
    this.containsEsc = this.containsOctal = false;
    this.octalPosition = null;
    this.invalidTemplateEscapePosition = null;
    this.exportedIdentifiers = [];
  }
  // TODO
  strict: boolean;
  // TODO
  input: string;
  // Used to signify the start of a potential arrow function
  potentialArrowAt: number;
  // Used to signify the start of an expression which looks like a
  // typed arrow function, but it isn't
  // e.g. a ? (b) : c => d
  //          ^
  noArrowAt: number[];
  // Used to signify the start of an expression whose params, if it looks like
  // an arrow function, shouldn't be converted to assignable nodes.
  // This is used to defer the validation of typed arrow functions inside
  // conditional expressions.
  // e.g. a ? (b) : c => d
  //          ^
  noArrowParamsConversionAt: number[];
  // Flags to track whether we are in a function, a generator.
  inFunction: boolean;
  inParameters: boolean;
  maybeInArrowParameters: boolean;
  inGenerator: boolean;
  inMethod: boolean | N.MethodKind;
  inAsync: boolean;
  inType: boolean;
  noAnonFunctionType: boolean;
  inPropertyName: boolean;
  inClassProperty: boolean;
  hasFlowComment: boolean;
  isIterator: boolean;
  // Check whether we are in a (nested) class or not.
  classLevel: number;
  // Labels in scope.
  labels: Array<{
    kind: ?("loop" | "switch"),
    name?: ?string,
    statementStart?: number,
  }>;
  // Leading decorators. Last element of the stack represents the decorators in current context.
  // Supports nesting of decorators, e.g. @foo(@bar class inner {}) class outer {}
  // where @foo belongs to the outer class and @bar to the inner
  decoratorStack: Array<Array<N.Decorator>>;
  // The first yield expression inside parenthesized expressions and arrow
  // function parameters. It is used to disallow yield in arrow function
  // parameters.
  yieldInPossibleArrowParameters: ?N.YieldExpression;
  // Token store.
  tokens: Array<Token | N.Comment>;
  // Comment store.
  comments: Array<N.Comment>;
  // Comment attachment store
  trailingComments: Array<N.Comment>;
  leadingComments: Array<N.Comment>;
  commentStack: Array<{
    start: number,
    leadingComments: ?Array<N.Comment>,
    trailingComments: ?Array<N.Comment>,
    type: string,
  }>;
  commentPreviousNode: N.Node;
  // The current position of the tokenizer in the input.
  pos: number;
  lineStart: number;
  curLine: number;
  // Properties of the current token:
  // Its type
  type: TokenType;
  // For tokens that include more information than their type, the value
  value: any;
  // Its start and end offset
  start: number;
  end: number;
  // And, if locations are used, the {line, column} object
  // corresponding to those offsets
  startLoc: Position;
  endLoc: Position;
  // Position information for the previous token
  lastTokEndLoc: Position;
  lastTokStartLoc: Position;
  lastTokStart: number;
  lastTokEnd: number;
  // The context stack is used to superficially track syntactic
  // context to predict whether a regular expression is allowed in a
  // given position.
  context: Array<TokContext>;
  exprAllowed: boolean;
  // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.
  containsEsc: boolean;
  // TODO
  containsOctal: boolean;
  octalPosition: ?number;
  // Names of exports store. `default` is stored as a name for both
  // `export default foo;` and `export { foo as default };`.
  exportedIdentifiers: Array<string>;
  invalidTemplateEscapePosition: ?number;
  curPosition(): Position {
    return new Position(this.curLine, this.pos - this.lineStart);
  }
  clone(skipArrays?: boolean): State {
    const state = new State();
    Object.keys(this).forEach(key => {
      // $FlowIgnore
      let val = this[key];
      if ((!skipArrays || key === "context") && Array.isArray(val)) {
        val = val.slice();
      }
      // $FlowIgnore
      state[key] = val;
    });
    return state;
  }
}

// </from> /home/qfox/apps/babel/packages/babel-parser/src/tokenizer/state.js

// <from> /home/qfox/apps/babel/packages/babel-parser/src/tokenizer/context.js

// @flow
// The algorithm used to determine whether a regexp can appear at a
// given point in the program is loosely based on sweet.js' approach.
// See https://github.com/mozilla/sweet.js/wiki/design
import { types as tt } from "./types";
import { lineBreak } from "../util/whitespace";
export class TokContext {
  constructor(
    token: string,
    isExpr?: boolean,
    preserveSpace?: boolean,
    override?: Function, // Takes a Tokenizer as a this-parameter, and returns void.
  ) {
    this.token = token;
    this.isExpr = !!isExpr;
    this.preserveSpace = !!preserveSpace;
    this.override = override;
  }
  token: string;
  isExpr: boolean;
  preserveSpace: boolean;
  override: ?Function;
}
export const types: {
  [key: string]: TokContext,
} = {
  braceStatement: new TokContext("{", false),
  braceExpression: new TokContext("{", true),
  templateQuasi: new TokContext("${", true),
  parenStatement: new TokContext("(", false),
  parenExpression: new TokContext("(", true),
  template: new TokContext("`", true, true, p => p.readTmplToken()),
  functionExpression: new TokContext("function", true),
};
// Token-specific context update code
tt.parenR.updateContext = tt.braceR.updateContext = function() {
  if (this.state.context.length === 1) {
    this.state.exprAllowed = true;
    return;
  }
  const out = this.state.context.pop();
  if (
    out === types.braceStatement &&
    this.curContext() === types.functionExpression
  ) {
    this.state.context.pop();
    this.state.exprAllowed = false;
  } else if (out === types.templateQuasi) {
    this.state.exprAllowed = true;
  } else {
    this.state.exprAllowed = !out.isExpr;
  }
};
tt.name.updateContext = function(prevType) {
  if (this.state.value === "of" && this.curContext() === types.parenStatement) {
    this.state.exprAllowed = !prevType.beforeExpr;
    return;
  }
  this.state.exprAllowed = false;
  if (prevType === tt._let || prevType === tt._const || prevType === tt._var) {
    if (lineBreak.test(this.input.slice(this.state.end))) {
      this.state.exprAllowed = true;
    }
  }
  if (this.state.isIterator) {
    this.state.isIterator = false;
  }
};
tt.braceL.updateContext = function(prevType) {
  this.state.context.push(
    this.braceIsBlock(prevType) ? types.braceStatement : types.braceExpression,
  );
  this.state.exprAllowed = true;
};
tt.dollarBraceL.updateContext = function() {
  this.state.context.push(types.templateQuasi);
  this.state.exprAllowed = true;
};
tt.parenL.updateContext = function(prevType) {
  const statementParens =
    prevType === tt._if ||
    prevType === tt._for ||
    prevType === tt._with ||
    prevType === tt._while;
  this.state.context.push(
    statementParens ? types.parenStatement : types.parenExpression,
  );
  this.state.exprAllowed = true;
};
tt.incDec.updateContext = function() {
  // tokExprAllowed stays unchanged
};
tt._function.updateContext = tt._class.updateContext = function(prevType) {
  if (this.state.exprAllowed && !this.braceIsBlock(prevType)) {
    this.state.context.push(types.functionExpression);
  }
  this.state.exprAllowed = false;
};
tt.backQuote.updateContext = function() {
  if (this.curContext() === types.template) {
    this.state.context.pop();
  } else {
    this.state.context.push(types.template);
  }
  this.state.exprAllowed = false;
};

// </from> /home/qfox/apps/babel/packages/babel-parser/src/tokenizer/context.js

// <from> /home/qfox/apps/babel/packages/babel-parser/src/tokenizer/types.js

// @flow
// ## Token types
// The assignment of fine-grained, information-carrying type objects
// allows the tokenizer to store the information it has about a
// token in a way that is very cheap for the parser to look up.
// All token type variables start with an underscore, to make them
// easy to recognize.
// The `beforeExpr` property is used to disambiguate between regular
// expressions and divisions. It is set on all token types that can
// be followed by an expression (thus, a slash after them would be a
// regular expression).
//
// `isLoop` marks a keyword as starting a loop, which is important
// to know when parsing a label, in order to allow or disallow
// continue jumps to that label.
const beforeExpr = true;
const startsExpr = true;
const isLoop = true;
const isAssign = true;
const prefix = true;
const postfix = true;
type TokenOptions = {
  keyword?: string,
  beforeExpr?: boolean,
  startsExpr?: boolean,
  rightAssociative?: boolean,
  isLoop?: boolean,
  isAssign?: boolean,
  prefix?: boolean,
  postfix?: boolean,
  binop?: ?number,
};
export class TokenType {
  label: string;
  keyword: ?string;
  beforeExpr: boolean;
  startsExpr: boolean;
  rightAssociative: boolean;
  isLoop: boolean;
  isAssign: boolean;
  prefix: boolean;
  postfix: boolean;
  binop: ?number;
  updateContext: ?(prevType: TokenType) => void;
  constructor(label: string, conf: TokenOptions = {}) {
    this.label = label;
    this.keyword = conf.keyword;
    this.beforeExpr = !!conf.beforeExpr;
    this.startsExpr = !!conf.startsExpr;
    this.rightAssociative = !!conf.rightAssociative;
    this.isLoop = !!conf.isLoop;
    this.isAssign = !!conf.isAssign;
    this.prefix = !!conf.prefix;
    this.postfix = !!conf.postfix;
    this.binop = conf.binop === 0 ? 0 : conf.binop || null;
    this.updateContext = null;
  }
}
function KeywordTokenType(keyword: string, options: TokenOptions = {}) {
  return new TokenType(keyword, { ...options, keyword });
}
function BinopTokenType(name: string, binop: number) {
  return new TokenType(name, { beforeExpr, binop });
}
export const types: { [name: string]: TokenType } = {
  num: new TokenType("num", { startsExpr }),
  bigint: new TokenType("bigint", { startsExpr }),
  regexp: new TokenType("regexp", { startsExpr }),
  string: new TokenType("string", { startsExpr }),
  name: new TokenType("name", { startsExpr }),
  eof: new TokenType("eof"),
  // Punctuation token types.
  bracketL: new TokenType("[", { beforeExpr, startsExpr }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", { beforeExpr, startsExpr }),
  braceBarL: new TokenType("{|", { beforeExpr, startsExpr }),
  braceR: new TokenType("}"),
  braceBarR: new TokenType("|}"),
  parenL: new TokenType("(", { beforeExpr, startsExpr }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", { beforeExpr }),
  semi: new TokenType(";", { beforeExpr }),
  colon: new TokenType(":", { beforeExpr }),
  doubleColon: new TokenType("::", { beforeExpr }),
  dot: new TokenType("."),
  question: new TokenType("?", { beforeExpr }),
  questionDot: new TokenType("?."),
  arrow: new TokenType("=>", { beforeExpr }),
  template: new TokenType("template"),
  ellipsis: new TokenType("...", { beforeExpr }),
  backQuote: new TokenType("`", { startsExpr }),
  dollarBraceL: new TokenType("${", { beforeExpr, startsExpr }),
  at: new TokenType("@"),
  hash: new TokenType("#"),
  // Special hashbang token.
  interpreterDirective: new TokenType("#!..."),
  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.
  eq: new TokenType("=", { beforeExpr, isAssign }),
  assign: new TokenType("_=", { beforeExpr, isAssign }),
  incDec: new TokenType("++/--", { prefix, postfix, startsExpr }),
  bang: new TokenType("!", { beforeExpr, prefix, startsExpr }),
  tilde: new TokenType("~", { beforeExpr, prefix, startsExpr }),
  pipeline: new BinopTokenType("|>", 0),
  nullishCoalescing: new BinopTokenType("??", 1),
  logicalOR: new BinopTokenType("||", 1),
  logicalAND: new BinopTokenType("&&", 2),
  bitwiseOR: new BinopTokenType("|", 3),
  bitwiseXOR: new BinopTokenType("^", 4),
  bitwiseAND: new BinopTokenType("&", 5),
  equality: new BinopTokenType("==/!=", 6),
  relational: new BinopTokenType("</>", 7),
  bitShift: new BinopTokenType("<</>>", 8),
  plusMin: new TokenType("+/-", { beforeExpr, binop: 9, prefix, startsExpr }),
  modulo: new BinopTokenType("%", 10),
  star: new BinopTokenType("*", 10),
  slash: new BinopTokenType("/", 10),
  exponent: new TokenType("**", {
    beforeExpr,
    binop: 11,
    rightAssociative: true,
  }),
};
export const keywords = {
  break: new KeywordTokenType("break"),
  case: new KeywordTokenType("case", { beforeExpr }),
  catch: new KeywordTokenType("catch"),
  continue: new KeywordTokenType("continue"),
  debugger: new KeywordTokenType("debugger"),
  default: new KeywordTokenType("default", { beforeExpr }),
  do: new KeywordTokenType("do", { isLoop, beforeExpr }),
  else: new KeywordTokenType("else", { beforeExpr }),
  finally: new KeywordTokenType("finally"),
  for: new KeywordTokenType("for", { isLoop }),
  function: new KeywordTokenType("function", { startsExpr }),
  if: new KeywordTokenType("if"),
  return: new KeywordTokenType("return", { beforeExpr }),
  switch: new KeywordTokenType("switch"),
  throw: new KeywordTokenType("throw", { beforeExpr, prefix, startsExpr }),
  try: new KeywordTokenType("try"),
  var: new KeywordTokenType("var"),
  let: new KeywordTokenType("let"),
  const: new KeywordTokenType("const"),
  while: new KeywordTokenType("while", { isLoop }),
  with: new KeywordTokenType("with"),
  new: new KeywordTokenType("new", { beforeExpr, startsExpr }),
  this: new KeywordTokenType("this", { startsExpr }),
  super: new KeywordTokenType("super", { startsExpr }),
  class: new KeywordTokenType("class"),
  extends: new KeywordTokenType("extends", { beforeExpr }),
  export: new KeywordTokenType("export"),
  import: new KeywordTokenType("import", { startsExpr }),
  yield: new KeywordTokenType("yield", { beforeExpr, startsExpr }),
  null: new KeywordTokenType("null", { startsExpr }),
  true: new KeywordTokenType("true", { startsExpr }),
  false: new KeywordTokenType("false", { startsExpr }),
  in: new KeywordTokenType("in", { beforeExpr, binop: 7 }),
  instanceof: new KeywordTokenType("instanceof", { beforeExpr, binop: 7 }),
  typeof: new KeywordTokenType("typeof", { beforeExpr, prefix, startsExpr }),
  void: new KeywordTokenType("void", { beforeExpr, prefix, startsExpr }),
  delete: new KeywordTokenType("delete", { beforeExpr, prefix, startsExpr }),
};
// Map keyword names to token types.
Object.keys(keywords).forEach(name => {
  types["_" + name] = keywords[name];
});

// </from> /home/qfox/apps/babel/packages/babel-parser/src/tokenizer/types.js

// <from> /home/qfox/apps/babel/packages/babel-parser/src/options.js

// @flow
// A second optional argument can be given to further configure
// the parser process. These options are recognized:
export type SourceType = "script" | "module" | "unambiguous";
export type Options = {
  sourceType: SourceType,
  sourceFilename?: string,
  startLine: number,
  allowAwaitOutsideFunction: boolean,
  allowReturnOutsideFunction: boolean,
  allowImportExportEverywhere: boolean,
  allowSuperOutsideMethod: boolean,
  plugins: PluginList,
  strictMode: ?boolean,
  ranges: boolean,
  tokens: boolean,
};
export const defaultOptions: Options = {
  // Source type ("script" or "module") for different semantics
  sourceType: "script",
  // Source filename.
  sourceFilename: undefined,
  // Line from which to start counting source. Useful for
  // integration with other tools.
  startLine: 1,
  // When enabled, await at the top level is not considered an
  // error.
  allowAwaitOutsideFunction: false,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program.
  allowImportExportEverywhere: false,
  // TODO
  allowSuperOutsideMethod: false,
  // An array of plugins to enable
  plugins: [],
  // TODO
  strictMode: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // Adds all parsed tokens to a `tokens` property on the `File` node
  tokens: false,
};
// Interpret and default an options object
export function getOptions(opts: ?Options): Options {
  const options: any = {};
  for (const key in defaultOptions) {
    options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];
  }
  return options;
}

// </from> /home/qfox/apps/babel/packages/babel-parser/src/options.js

// <from> /home/qfox/apps/babel/packages/babel-parser/bin/babel-parser.js

#!/usr/bin/env node
/* eslint no-var: 0 */
var parser = require("..");
var fs = require("fs");
var filename = process.argv[2];
if (!filename) {
  console.error("no filename specified");
  process.exit(0);
}
var file = fs.readFileSync(filename, "utf8");
var ast = parser.parse(file);
console.log(JSON.stringify(ast, null, "  "));

// </from> /home/qfox/apps/babel/packages/babel-parser/bin/babel-parser.js

// <from> /home/qfox/apps/babel/packages/babel-parser/scripts/generate-identifier-regex.js

"use strict";
// Which Unicode version should be used?
const version = "11.0.0";
const start = require("unicode-" +
  version +
  "/Binary_Property/ID_Start/code-points.js").filter(function(ch) {
  return ch > 0x7f;
});
let last = -1;
const cont = [0x200c, 0x200d].concat(
  require("unicode-" +
    version +
    "/Binary_Property/ID_Continue/code-points.js").filter(function(ch) {
    return ch > 0x7f && search(start, ch, last + 1) == -1;
  })
);
function search(arr, ch, starting) {
  for (let i = starting; arr[i] <= ch && i < arr.length; last = i++) {
    if (arr[i] === ch) return i;
  }
  return -1;
}
function pad(str, width) {
  while (str.length < width) str = "0" + str;
  return str;
}
function esc(code) {
  const hex = code.toString(16);
  if (hex.length <= 2) return "\\x" + pad(hex, 2);
  else return "\\u" + pad(hex, 4);
}
function generate(chars) {
  const astral = [];
  let re = "";
  for (let i = 0, at = 0x10000; i < chars.length; i++) {
    const from = chars[i];
    let to = from;
    while (i < chars.length - 1 && chars[i + 1] == to + 1) {
      i++;
      to++;
    }
    if (to <= 0xffff) {
      if (from == to) re += esc(from);
      else if (from + 1 == to) re += esc(from) + esc(to);
      else re += esc(from) + "-" + esc(to);
    } else {
      astral.push(from - at, to - from);
      at = to;
    }
  }
  return { nonASCII: re, astral: astral };
}
const startData = generate(start);
const contData = generate(cont);
console.log('let nonASCIIidentifierStartChars = "' + startData.nonASCII + '";');
console.log('let nonASCIIidentifierChars = "' + contData.nonASCII + '";');
console.log(
  "const astralIdentifierStartCodes = " + JSON.stringify(startData.astral) + ";"
);
console.log(
  "const astralIdentifierCodes = " + JSON.stringify(contData.astral) + ";"
);

// </from> /home/qfox/apps/babel/packages/babel-parser/scripts/generate-identifier-regex.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-proposal-pipeline-operator/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import syntaxPipelineOperator from "@babel/plugin-syntax-pipeline-operator";
import { types as t } from "@babel/core";
export default declare(api => {
  api.assertVersion(7);
  return {
    inherits: syntaxPipelineOperator,
    visitor: {
      BinaryExpression(path) {
        const { scope } = path;
        const { node } = path;
        const { operator, left } = node;
        let { right } = node;
        if (operator !== "|>") return;
        let optimizeArrow =
          t.isArrowFunctionExpression(right) &&
          t.isExpression(right.body) &&
          !right.async &&
          !right.generator;
        let param;
        if (optimizeArrow) {
          const { params } = right;
          if (params.length === 1 && t.isIdentifier(params[0])) {
            param = params[0];
          } else if (params.length > 0) {
            optimizeArrow = false;
          }
        } else if (t.isIdentifier(right, { name: "eval" })) {
          right = t.sequenceExpression([t.numericLiteral(0), right]);
        }
        if (optimizeArrow && !param) {
          // Arrow function with 0 arguments
          path.replaceWith(t.sequenceExpression([left, right.body]));
          return;
        }
        const placeholder = scope.generateUidIdentifierBasedOnNode(
          param || left,
        );
        scope.push({ id: placeholder });
        if (param) {
          path.get("right").scope.rename(param.name, placeholder.name);
        }
        const call = optimizeArrow
          ? right.body
          : t.callExpression(right, [t.cloneNode(placeholder)]);
        path.replaceWith(
          t.sequenceExpression([
            t.assignmentExpression("=", t.cloneNode(placeholder), left),
            call,
          ]),
        );
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-proposal-pipeline-operator/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-helper-module-transforms/src/index.js

import assert from "assert";
import * as t from "@babel/types";
import template from "@babel/template";
import chunk from "lodash/chunk";
import { isModule } from "@babel/helper-module-imports";
import rewriteThis from "./rewrite-this";
import rewriteLiveReferences from "./rewrite-live-references";
import normalizeAndLoadModuleMetadata, {
  hasExports,
  isSideEffectImport,
} from "./normalize-and-load-metadata";
export { hasExports, isSideEffectImport, isModule };
/**
 * Perform all of the generic ES6 module rewriting needed to handle initial
 * module processing. This function will rewrite the majority of the given
 * program to reference the modules described by the returned metadata,
 * and returns a list of statements for use when initializing the module.
 */
export function rewriteModuleStatementsAndPrepareHeader(
  path: NodePath,
  {
    exportName,
    strict,
    allowTopLevelThis,
    strictMode,
    loose,
    noInterop,
    lazy,
    esNamespaceOnly,
  },
) {
  assert(isModule(path), "Cannot process module statements in a script");
  path.node.sourceType = "script";
  const meta = normalizeAndLoadModuleMetadata(path, exportName, {
    noInterop,
    loose,
    lazy,
    esNamespaceOnly,
  });
  if (!allowTopLevelThis) {
    rewriteThis(path);
  }
  rewriteLiveReferences(path, meta);
  if (strictMode !== false) {
    const hasStrict = path.node.directives.some(directive => {
      return directive.value.value === "use strict";
    });
    if (!hasStrict) {
      path.unshiftContainer(
        "directives",
        t.directive(t.directiveLiteral("use strict")),
      );
    }
  }
  const headers = [];
  if (hasExports(meta) && !strict) {
    headers.push(buildESModuleHeader(meta, loose /* enumerable */));
  }
  const nameList = buildExportNameListDeclaration(path, meta);
  if (nameList) {
    meta.exportNameListName = nameList.name;
    headers.push(nameList.statement);
  }
  // Create all of the statically known named exports.
  headers.push(...buildExportInitializationStatements(path, meta, loose));
  return { meta, headers };
}
/**
 * Flag a set of statements as hoisted above all else so that module init
 * statements all run before user code.
 */
export function ensureStatementsHoisted(statements) {
  // Force all of the header fields to be at the top of the file.
  statements.forEach(header => {
    header._blockHoist = 3;
  });
}
/**
 * Given an expression for a standard import object, like "require('foo')",
 * wrap it in a call to the interop helpers based on the type.
 */
export function wrapInterop(
  programPath: NodePath,
  expr: Node,
  type: InteropType,
): Node {
  if (type === "none") {
    return null;
  }
  let helper;
  if (type === "default") {
    helper = "interopRequireDefault";
  } else if (type === "namespace") {
    helper = "interopRequireWildcard";
  } else {
    throw new Error(`Unknown interop: ${type}`);
  }
  return t.callExpression(programPath.hub.addHelper(helper), [expr]);
}
/**
 * Create the runtime initialization statements for a given requested source.
 * These will initialize all of the runtime import/export logic that
 * can't be handled statically by the statements created by
 * buildExportInitializationStatements().
 */
export function buildNamespaceInitStatements(
  metadata: ModuleMetadata,
  sourceMetadata: SourceModuleMetadata,
  loose: boolean = false,
) {
  const statements = [];
  let srcNamespace = t.identifier(sourceMetadata.name);
  if (sourceMetadata.lazy) srcNamespace = t.callExpression(srcNamespace, []);
  for (const localName of sourceMetadata.importsNamespace) {
    if (localName === sourceMetadata.name) continue;
    // Create and assign binding to namespace object
    statements.push(
      template.statement`var NAME = SOURCE;`({
        NAME: localName,
        SOURCE: t.cloneNode(srcNamespace),
      }),
    );
  }
  if (loose) {
    statements.push(...buildReexportsFromMeta(metadata, sourceMetadata, loose));
  }
  for (const exportName of sourceMetadata.reexportNamespace) {
    // Assign export to namespace object.
    statements.push(
      (sourceMetadata.lazy
        ? template.statement`
            Object.defineProperty(EXPORTS, "NAME", {
              enumerable: true,
              get: function() {
                return NAMESPACE;
              }
            });
          `
        : template.statement`EXPORTS.NAME = NAMESPACE;`)({
        EXPORTS: metadata.exportName,
        NAME: exportName,
        NAMESPACE: t.cloneNode(srcNamespace),
      }),
    );
  }
  if (sourceMetadata.reexportAll) {
    const statement = buildNamespaceReexport(
      metadata,
      t.cloneNode(srcNamespace),
      loose,
    );
    statement.loc = sourceMetadata.reexportAll.loc;
    // Iterate props creating getter for each prop.
    statements.push(statement);
  }
  return statements;
}
const getTemplateForReexport = loose => {
  return loose
    ? template.statement`EXPORTS.EXPORT_NAME = NAMESPACE.IMPORT_NAME;`
    : template`
      Object.defineProperty(EXPORTS, "EXPORT_NAME", {
        enumerable: true,
        get: function() {
          return NAMESPACE.IMPORT_NAME;
        },
      });
    `;
};
const buildReexportsFromMeta = (meta, metadata, loose) => {
  const namespace = metadata.lazy
    ? t.callExpression(t.identifier(metadata.name), [])
    : t.identifier(metadata.name);
  const templateForCurrentMode = getTemplateForReexport(loose);
  return Array.from(metadata.reexports, ([exportName, importName]) =>
    templateForCurrentMode({
      EXPORTS: meta.exportName,
      EXPORT_NAME: exportName,
      NAMESPACE: t.cloneNode(namespace),
      IMPORT_NAME: importName,
    }),
  );
};
/**
 * Build an "__esModule" header statement setting the property on a given object.
 */
function buildESModuleHeader(
  metadata: ModuleMetadata,
  enumerable: boolean = false,
) {
  return (enumerable
    ? template.statement`
        EXPORTS.__esModule = true;
      `
    : template.statement`
        Object.defineProperty(EXPORTS, "__esModule", {
          value: true,
        });
      `)({ EXPORTS: metadata.exportName });
}
/**
 * Create a re-export initialization loop for a specific imported namespace.
 */
function buildNamespaceReexport(metadata, namespace, loose) {
  return (loose
    ? template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          EXPORTS[key] = NAMESPACE[key];
        });
      `
    : template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          Object.defineProperty(EXPORTS, key, {
            enumerable: true,
            get: function() {
              return NAMESPACE[key];
            },
          });
        });
    `)({
    NAMESPACE: namespace,
    EXPORTS: metadata.exportName,
    VERIFY_NAME_LIST: metadata.exportNameListName
      ? template`
            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;
          `({ EXPORTS_LIST: metadata.exportNameListName })
      : null,
  });
}
/**
 * Build a statement declaring a variable that contains all of the exported
 * variable names in an object so they can easily be referenced from an
 * export * from statement to check for conflicts.
 */
function buildExportNameListDeclaration(
  programPath: NodePath,
  metadata: ModuleMetadata,
) {
  const exportedVars = Object.create(null);
  for (const data of metadata.local.values()) {
    for (const name of data.names) {
      exportedVars[name] = true;
    }
  }
  let hasReexport = false;
  for (const data of metadata.source.values()) {
    for (const exportName of data.reexports.keys()) {
      exportedVars[exportName] = true;
    }
    for (const exportName of data.reexportNamespace) {
      exportedVars[exportName] = true;
    }
    hasReexport = hasReexport || data.reexportAll;
  }
  if (!hasReexport || Object.keys(exportedVars).length === 0) return null;
  const name = programPath.scope.generateUidIdentifier("exportNames");
  delete exportedVars.default;
  return {
    name: name.name,
    statement: t.variableDeclaration("var", [
      t.variableDeclarator(name, t.valueToNode(exportedVars)),
    ]),
  };
}
/**
 * Create a set of statements that will initialize all of the statically-known
 * export names with their expected values.
 */
function buildExportInitializationStatements(
  programPath: NodePath,
  metadata: ModuleMetadata,
  loose: boolean = false,
) {
  const initStatements = [];
  const exportNames = [];
  for (const [localName, data] of metadata.local) {
    if (data.kind === "import") {
      // No-open since these are explicitly set with the "reexports" block.
    } else if (data.kind === "hoisted") {
      initStatements.push(
        buildInitStatement(metadata, data.names, t.identifier(localName)),
      );
    } else {
      exportNames.push(...data.names);
    }
  }
  for (const data of metadata.source.values()) {
    if (!loose) {
      initStatements.push(...buildReexportsFromMeta(metadata, data, loose));
    }
    for (const exportName of data.reexportNamespace) {
      exportNames.push(exportName);
    }
  }
  initStatements.push(
    ...chunk(exportNames, 100).map(members => {
      return buildInitStatement(
        metadata,
        members,
        programPath.scope.buildUndefinedNode(),
      );
    }),
  );
  return initStatements;
}
/**
 * Given a set of export names, create a set of nested assignments to
 * initialize them all to a given expression.
 */
function buildInitStatement(metadata, exportNames, initExpr) {
  return t.expressionStatement(
    exportNames.reduce(
      (acc, exportName) =>
        template.expression`EXPORTS.NAME = VALUE`({
          EXPORTS: metadata.exportName,
          NAME: exportName,
          VALUE: acc,
        }),
      initExpr,
    ),
  );
}

// </from> /home/qfox/apps/babel/packages/babel-helper-module-transforms/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-helper-module-transforms/src/rewrite-this.js

export default function rewriteThis(programPath: NodePath) {
  // Rewrite "this" to be "undefined".
  programPath.traverse(rewriteThisVisitor);
}
/**
 * A visitor to walk the tree, rewriting all `this` references in the top-level scope to be
 * `undefined`.
 */
const rewriteThisVisitor = {
  ThisExpression(path) {
    path.replaceWith(path.scope.buildUndefinedNode());
  },
  Function(path) {
    if (!path.isArrowFunctionExpression()) path.skip();
  },
  ClassProperty(path) {
    path.skip();
  },
};

// </from> /home/qfox/apps/babel/packages/babel-helper-module-transforms/src/rewrite-this.js

// <from> /home/qfox/apps/babel/packages/babel-helper-module-transforms/src/rewrite-live-references.js

import assert from "assert";
import * as t from "@babel/types";
import template from "@babel/template";
import simplifyAccess from "@babel/helper-simple-access";
export default function rewriteLiveReferences(
  programPath: NodePath,
  metadata: ModuleMetadata,
) {
  const imported = new Map();
  const exported = new Map();
  const requeueInParent = path => {
    // Manualy re-queue `exports.default =` expressions so that the ES3
    // transform has an opportunity to convert them. Ideally this would
    // happen automatically from the replaceWith above. See #4140 for
    // more info.
    programPath.requeue(path);
  };
  for (const [source, data] of metadata.source) {
    for (const [localName, importName] of data.imports) {
      imported.set(localName, [source, importName, null]);
    }
    for (const localName of data.importsNamespace) {
      imported.set(localName, [source, null, localName]);
    }
  }
  for (const [local, data] of metadata.local) {
    let exportMeta = exported.get(local);
    if (!exportMeta) {
      exportMeta = [];
      exported.set(local, exportMeta);
    }
    exportMeta.push(...data.names);
  }
  // Rewrite initialization of bindings to update exports.
  programPath.traverse(rewriteBindingInitVisitor, {
    metadata,
    requeueInParent,
    scope: programPath.scope,
    exported, // local name => exported name list
  });
  simplifyAccess(
    programPath,
    // NOTE(logan): The 'Array.from' calls are to make this code with in loose mode.
    new Set([...Array.from(imported.keys()), ...Array.from(exported.keys())]),
  );
  // Rewrite reads/writes from imports and exports to have the correct behavior.
  programPath.traverse(rewriteReferencesVisitor, {
    seen: new WeakSet(),
    metadata,
    requeueInParent,
    scope: programPath.scope,
    imported, // local / import
    exported, // local name => exported name list
    buildImportReference: ([source, importName, localName], identNode) => {
      const meta = metadata.source.get(source);
      if (localName) {
        if (meta.lazy) identNode = t.callExpression(identNode, []);
        return identNode;
      }
      let namespace = t.identifier(meta.name);
      if (meta.lazy) namespace = t.callExpression(namespace, []);
      return t.memberExpression(namespace, t.identifier(importName));
    },
  });
}
/**
 * A visitor to inject export update statements during binding initialization.
 */
const rewriteBindingInitVisitor = {
  ClassProperty(path) {
    path.skip();
  },
  Function(path) {
    path.skip();
  },
  ClassDeclaration(path) {
    const { requeueInParent, exported, metadata } = this;
    const { id } = path.node;
    if (!id) throw new Error("Expected class to have a name");
    const localName = id.name;
    const exportNames = exported.get(localName) || [];
    if (exportNames.length > 0) {
      const statement = t.expressionStatement(
        buildBindingExportAssignmentExpression(
          metadata,
          exportNames,
          t.identifier(localName),
        ),
      );
      statement._blockHoist = path.node._blockHoist;
      requeueInParent(path.insertAfter(statement)[0]);
    }
  },
  VariableDeclaration(path) {
    const { requeueInParent, exported, metadata } = this;
    Object.keys(path.getOuterBindingIdentifiers()).forEach(localName => {
      const exportNames = exported.get(localName) || [];
      if (exportNames.length > 0) {
        const statement = t.expressionStatement(
          buildBindingExportAssignmentExpression(
            metadata,
            exportNames,
            t.identifier(localName),
          ),
        );
        statement._blockHoist = path.node._blockHoist;
        requeueInParent(path.insertAfter(statement)[0]);
      }
    });
  },
};
const buildBindingExportAssignmentExpression = (
  metadata,
  exportNames,
  localExpr,
) => {
  return (exportNames || []).reduce((expr, exportName) => {
    // class Foo {} export { Foo, Foo as Bar };
    // as
    // class Foo {} exports.Foo = exports.Bar = Foo;
    return t.assignmentExpression(
      "=",
      t.memberExpression(
        t.identifier(metadata.exportName),
        t.identifier(exportName),
      ),
      expr,
    );
  }, localExpr);
};
const buildImportThrow = localName => {
  return template.expression.ast`
    (function() {
      throw new Error('"' + '${localName}' + '" is read-only.');
    })()
  `;
};
const rewriteReferencesVisitor = {
  ReferencedIdentifier(path) {
    const {
      seen,
      buildImportReference,
      scope,
      imported,
      requeueInParent,
    } = this;
    if (seen.has(path.node)) return;
    seen.add(path.node);
    const localName = path.node.name;
    const localBinding = path.scope.getBinding(localName);
    const rootBinding = scope.getBinding(localName);
    // redeclared in this scope
    if (rootBinding !== localBinding) return;
    const importData = imported.get(localName);
    if (importData) {
      const ref = buildImportReference(importData, path.node);
      // Preserve the binding location so that sourcemaps are nicer.
      ref.loc = path.node.loc;
      if (
        path.parentPath.isCallExpression({ callee: path.node }) &&
        t.isMemberExpression(ref)
      ) {
        path.replaceWith(t.sequenceExpression([t.numericLiteral(0), ref]));
      } else if (path.isJSXIdentifier() && t.isMemberExpression(ref)) {
        const { object, property } = ref;
        path.replaceWith(
          t.JSXMemberExpression(
            t.JSXIdentifier(object.name),
            t.JSXIdentifier(property.name),
          ),
        );
      } else {
        path.replaceWith(ref);
      }
      requeueInParent(path);
      // The path could have been replaced with an identifier that would
      // otherwise be re-visited, so we skip processing its children.
      path.skip();
    }
  },
  AssignmentExpression: {
    exit(path) {
      const {
        scope,
        seen,
        imported,
        exported,
        requeueInParent,
        buildImportReference,
      } = this;
      if (seen.has(path.node)) return;
      seen.add(path.node);
      const left = path.get("left");
      if (left.isIdentifier()) {
        // Simple update-assign foo += 1; export { foo };
        // =>   exports.foo =  (foo += 1);
        const localName = left.node.name;
        // redeclared in this scope
        if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {
          return;
        }
        const exportedNames = exported.get(localName) || [];
        const importData = imported.get(localName);
        if (exportedNames.length > 0 || importData) {
          assert(path.node.operator === "=", "Path was not simplified");
          const assignment = path.node;
          if (importData) {
            assignment.left = buildImportReference(importData, assignment.left);
            assignment.right = t.sequenceExpression([
              assignment.right,
              buildImportThrow(localName),
            ]);
          }
          path.replaceWith(
            buildBindingExportAssignmentExpression(
              this.metadata,
              exportedNames,
              assignment,
            ),
          );
          requeueInParent(path);
        }
      } else if (left.isMemberExpression()) {
        // No change needed
      } else {
        const ids = left.getOuterBindingIdentifiers();
        const id = Object.keys(ids)
          .filter(localName => imported.has(localName))
          .pop();
        if (id) {
          path.node.right = t.sequenceExpression([
            path.node.right,
            buildImportThrow(id),
          ]);
        }
        // Complex ({a, b, c} = {}); export { a, c };
        // =>   ({a, b, c} = {}), (exports.a = a, exports.c = c);
        const items = [];
        Object.keys(ids).forEach(localName => {
          // redeclared in this scope
          if (
            scope.getBinding(localName) !== path.scope.getBinding(localName)
          ) {
            return;
          }
          const exportedNames = exported.get(localName) || [];
          if (exportedNames.length > 0) {
            items.push(
              buildBindingExportAssignmentExpression(
                this.metadata,
                exportedNames,
                t.identifier(localName),
              ),
            );
          }
        });
        if (items.length > 0) {
          let node = t.sequenceExpression(items);
          if (path.parentPath.isExpressionStatement()) {
            node = t.expressionStatement(node);
            node._blockHoist = path.parentPath.node._blockHoist;
          }
          const statement = path.insertAfter(node)[0];
          requeueInParent(statement);
        }
      }
    },
  },
};

// </from> /home/qfox/apps/babel/packages/babel-helper-module-transforms/src/rewrite-live-references.js

// <from> /home/qfox/apps/babel/packages/babel-helper-module-transforms/src/normalize-and-load-metadata.js

import { basename, extname } from "path";
import splitExportDeclaration from "@babel/helper-split-export-declaration";
export type ModuleMetadata = {
  exportName: string,
  // The name of the variable that will reference an object containing export names.
  exportNameListName: null | string,
  // Lookup from local binding to export information.
  local: Map<string, LocalExportMetadata>,
  // Lookup of source file to source file metadata.
  source: Map<string, SourceModuleMetadata>,
};
export type InteropType = "default" | "namespace" | "none";
export type SourceModuleMetadata = {
  // A unique variable name to use for this namespace object. Centralized for simplicity.
  name: string,
  loc: ?BabelNodeSourceLocation,
  interop: InteropType,
  // Local binding to reference from this source namespace. Key: Local name, value: Import name
  imports: Map<string, string>,
  // Local names that reference namespace object.
  importsNamespace: Set<string>,
  // Reexports to create for namespace. Key: Export name, value: Import name
  reexports: Map<string, string>,
  // List of names to re-export namespace as.
  reexportNamespace: Set<string>,
  // Tracks if the source should be re-exported.
  reexportAll: null | {
    loc: ?BabelNodeSourceLocation,
  },
};
export type LocalExportMetadata = {
  name: Array<string>, // names of exports
  kind: "import" | "hoisted" | "block" | "var",
};
/**
 * Check if the module has any exports that need handling.
 */
export function hasExports(metadata: ModuleMetadata) {
  const { local, source } = metadata;
  return (
    local.size > 0 ||
    Array.from(source).some(([, meta]) => {
      return (
        meta.reexports.size > 0 ||
        meta.reexportNamespace.size > 0 ||
        !!meta.reexportAll
      );
    })
  );
}
/**
 * Check if a given source is an anonymous import, e.g. "import 'foo';"
 */
export function isSideEffectImport(source: SourceModuleMetadata) {
  return (
    source.imports.size === 0 &&
    source.importsNamespace.size === 0 &&
    source.reexports.size === 0 &&
    source.reexportNamespace.size === 0 &&
    !source.reexportAll
  );
}
/**
 * Remove all imports and exports from the file, and return all metadata
 * needed to reconstruct the module's behavior.
 */
export default function normalizeModuleAndLoadMetadata(
  programPath: NodePath,
  exportName?: string,
  {
    noInterop = false,
    loose = false,
    lazy = false,
    esNamespaceOnly = false,
  } = {},
): ModuleMetadata {
  if (!exportName) {
    exportName = programPath.scope.generateUidIdentifier("exports").name;
  }
  nameAnonymousExports(programPath);
  const { local, source } = getModuleMetadata(programPath, { loose, lazy });
  removeModuleDeclarations(programPath);
  // Reuse the imported namespace name if there is one.
  for (const [, metadata] of source) {
    if (metadata.importsNamespace.size > 0) {
      // This is kind of gross. If we stop using `loose: true` we should
      // just make this destructuring assignment.
      metadata.name = metadata.importsNamespace.values().next().value;
    }
    if (noInterop) metadata.interop = "none";
    else if (esNamespaceOnly) {
      // Both the default and namespace interops pass through __esModule
      // objects, but the namespace interop is used to enable Babel's
      // destructuring-like interop behavior for normal CommonJS.
      // Since some tooling has started to remove that behavior, we expose
      // it as the `esNamespace` option.
      if (metadata.interop === "namespace") {
        metadata.interop = "default";
      }
    }
  }
  return {
    exportName,
    exportNameListName: null,
    local,
    source,
  };
}
/**
 * Get metadata about the imports and exports present in this module.
 */
function getModuleMetadata(
  programPath: NodePath,
  { loose, lazy }: { loose: boolean, lazy: boolean },
) {
  const localData = getLocalExportMetadata(programPath, loose);
  const sourceData = new Map();
  const getData = sourceNode => {
    const source = sourceNode.value;
    let data = sourceData.get(source);
    if (!data) {
      data = {
        name: programPath.scope.generateUidIdentifier(
          basename(source, extname(source)),
        ).name,
        interop: "none",
        loc: null,
        // Data about the requested sources and names.
        imports: new Map(),
        importsNamespace: new Set(),
        // Metadata about data that is passed directly from source to export.
        reexports: new Map(),
        reexportNamespace: new Set(),
        reexportAll: null,
        lazy: false,
      };
      sourceData.set(source, data);
    }
    return data;
  };
  programPath.get("body").forEach(child => {
    if (child.isImportDeclaration()) {
      const data = getData(child.node.source);
      if (!data.loc) data.loc = child.node.loc;
      child.get("specifiers").forEach(spec => {
        if (spec.isImportDefaultSpecifier()) {
          const localName = spec.get("local").node.name;
          data.imports.set(localName, "default");
          const reexport = localData.get(localName);
          if (reexport) {
            localData.delete(localName);
            reexport.names.forEach(name => {
              data.reexports.set(name, "default");
            });
          }
        } else if (spec.isImportNamespaceSpecifier()) {
          const localName = spec.get("local").node.name;
          data.importsNamespace.add(localName);
          const reexport = localData.get(localName);
          if (reexport) {
            localData.delete(localName);
            reexport.names.forEach(name => {
              data.reexportNamespace.add(name);
            });
          }
        } else if (spec.isImportSpecifier()) {
          const importName = spec.get("imported").node.name;
          const localName = spec.get("local").node.name;
          data.imports.set(localName, importName);
          const reexport = localData.get(localName);
          if (reexport) {
            localData.delete(localName);
            reexport.names.forEach(name => {
              data.reexports.set(name, importName);
            });
          }
        }
      });
    } else if (child.isExportAllDeclaration()) {
      const data = getData(child.node.source);
      if (!data.loc) data.loc = child.node.loc;
      data.reexportAll = {
        loc: child.node.loc,
      };
    } else if (child.isExportNamedDeclaration() && child.node.source) {
      const data = getData(child.node.source);
      if (!data.loc) data.loc = child.node.loc;
      child.get("specifiers").forEach(spec => {
        if (!spec.isExportSpecifier()) {
          throw spec.buildCodeFrameError("Unexpected export specifier type");
        }
        const importName = spec.get("local").node.name;
        const exportName = spec.get("exported").node.name;
        data.reexports.set(exportName, importName);
        if (exportName === "__esModule") {
          throw exportName.buildCodeFrameError('Illegal export "__esModule".');
        }
      });
    }
  });
  for (const metadata of sourceData.values()) {
    let needsDefault = false;
    let needsNamed = false;
    if (metadata.importsNamespace.size > 0) {
      needsDefault = true;
      needsNamed = true;
    }
    if (metadata.reexportAll) {
      needsNamed = true;
    }
    for (const importName of metadata.imports.values()) {
      if (importName === "default") needsDefault = true;
      else needsNamed = true;
    }
    for (const importName of metadata.reexports.values()) {
      if (importName === "default") needsDefault = true;
      else needsNamed = true;
    }
    if (needsDefault && needsNamed) {
      // TODO(logan): Using the namespace interop here is unfortunate. Revisit.
      metadata.interop = "namespace";
    } else if (needsDefault) {
      metadata.interop = "default";
    }
  }
  for (const [source, metadata] of sourceData) {
    if (
      lazy !== false &&
      !(isSideEffectImport(metadata) || metadata.reexportAll)
    ) {
      if (lazy === true) {
        // 'true' means that local relative files are eagerly loaded and
        // dependency modules are loaded lazily.
        metadata.lazy = !/\./.test(source);
      } else if (Array.isArray(lazy)) {
        metadata.lazy = lazy.indexOf(source);
      } else if (typeof lazy === "function") {
        metadata.lazy = lazy(source);
      } else {
        throw new Error(`.lazy must be a boolean, string array, or function`);
      }
    }
  }
  return {
    local: localData,
    source: sourceData,
  };
}
/**
 * Get metadata about local variables that are exported.
 */
function getLocalExportMetadata(
  programPath: NodePath,
  loose: boolean,
): Map<string, LocalExportMetadata> {
  const bindingKindLookup = new Map();
  programPath.get("body").forEach(child => {
    let kind;
    if (child.isImportDeclaration()) {
      kind = "import";
    } else {
      if (child.isExportDefaultDeclaration()) child = child.get("declaration");
      if (child.isExportNamedDeclaration()) {
        if (child.node.declaration) {
          child = child.get("declaration");
        } else if (
          loose &&
          child.node.source &&
          child.get("source").isStringLiteral()
        ) {
          child.node.specifiers.forEach(specifier => {
            bindingKindLookup.set(specifier.local.name, "block");
          });
          return;
        }
      }
      if (child.isFunctionDeclaration()) {
        kind = "hoisted";
      } else if (child.isClassDeclaration()) {
        kind = "block";
      } else if (child.isVariableDeclaration({ kind: "var" })) {
        kind = "var";
      } else if (child.isVariableDeclaration()) {
        kind = "block";
      } else {
        return;
      }
    }
    Object.keys(child.getOuterBindingIdentifiers()).forEach(name => {
      bindingKindLookup.set(name, kind);
    });
  });
  const localMetadata = new Map();
  const getLocalMetadata = idPath => {
    const localName = idPath.node.name;
    let metadata = localMetadata.get(localName);
    if (!metadata) {
      const kind = bindingKindLookup.get(localName);
      if (kind === undefined) {
        throw idPath.buildCodeFrameError(
          `Exporting local "${localName}", which is not declared.`,
        );
      }
      metadata = {
        names: [],
        kind,
      };
      localMetadata.set(localName, metadata);
    }
    return metadata;
  };
  programPath.get("body").forEach(child => {
    if (child.isExportNamedDeclaration() && (loose || !child.node.source)) {
      if (child.node.declaration) {
        const declaration = child.get("declaration");
        const ids = declaration.getOuterBindingIdentifierPaths();
        Object.keys(ids).forEach(name => {
          if (name === "__esModule") {
            throw declaration.buildCodeFrameError(
              'Illegal export "__esModule".',
            );
          }
          getLocalMetadata(ids[name]).names.push(name);
        });
      } else {
        child.get("specifiers").forEach(spec => {
          const local = spec.get("local");
          const exported = spec.get("exported");
          if (exported.node.name === "__esModule") {
            throw exported.buildCodeFrameError('Illegal export "__esModule".');
          }
          getLocalMetadata(local).names.push(exported.node.name);
        });
      }
    } else if (child.isExportDefaultDeclaration()) {
      const declaration = child.get("declaration");
      if (
        declaration.isFunctionDeclaration() ||
        declaration.isClassDeclaration()
      ) {
        getLocalMetadata(declaration.get("id")).names.push("default");
      } else {
        // These should have been removed by the nameAnonymousExports() call.
        throw declaration.buildCodeFrameError(
          "Unexpected default expression export.",
        );
      }
    }
  });
  return localMetadata;
}
/**
 * Ensure that all exported values have local binding names.
 */
function nameAnonymousExports(programPath: NodePath) {
  // Name anonymous exported locals.
  programPath.get("body").forEach(child => {
    if (!child.isExportDefaultDeclaration()) return;
    splitExportDeclaration(child);
  });
}
function removeModuleDeclarations(programPath: NodePath) {
  programPath.get("body").forEach(child => {
    if (child.isImportDeclaration()) {
      child.remove();
    } else if (child.isExportNamedDeclaration()) {
      if (child.node.declaration) {
        child.node.declaration._blockHoist = child.node._blockHoist;
        child.replaceWith(child.node.declaration);
      } else {
        child.remove();
      }
    } else if (child.isExportDefaultDeclaration()) {
      // export default foo;
      const declaration = child.get("declaration");
      if (
        declaration.isFunctionDeclaration() ||
        declaration.isClassDeclaration()
      ) {
        declaration._blockHoist = child.node._blockHoist;
        child.replaceWith(declaration);
      } else {
        // These should have been removed by the nameAnonymousExports() call.
        throw declaration.buildCodeFrameError(
          "Unexpected default expression export.",
        );
      }
    } else if (child.isExportAllDeclaration()) {
      child.remove();
    }
  });
}

// </from> /home/qfox/apps/babel/packages/babel-helper-module-transforms/src/normalize-and-load-metadata.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-duplicate-keys/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import { types as t } from "@babel/core";
function getName(key) {
  if (t.isIdentifier(key)) {
    return key.name;
  }
  return key.value.toString();
}
export default declare(api => {
  api.assertVersion(7);
  return {
    visitor: {
      ObjectExpression(path) {
        const { node } = path;
        const plainProps = node.properties.filter(
          prop => !t.isSpreadElement(prop) && !prop.computed,
        );
        // A property is a duplicate key if:
        // * the property is a data property, and is preceeded by a data,
        //   getter, or setter property of the same name.
        // * the property is a getter property, and is preceeded by a data or
        //   getter property of the same name.
        // * the property is a setter property, and is preceeded by a data or
        //   setter property of the same name.
        const alreadySeenData = Object.create(null);
        const alreadySeenGetters = Object.create(null);
        const alreadySeenSetters = Object.create(null);
        for (const prop of plainProps) {
          const name = getName(prop.key);
          let isDuplicate = false;
          switch (prop.kind) {
            case "get":
              if (alreadySeenData[name] || alreadySeenGetters[name]) {
                isDuplicate = true;
              }
              alreadySeenGetters[name] = true;
              break;
            case "set":
              if (alreadySeenData[name] || alreadySeenSetters[name]) {
                isDuplicate = true;
              }
              alreadySeenSetters[name] = true;
              break;
            default:
              if (
                alreadySeenData[name] ||
                alreadySeenGetters[name] ||
                alreadySeenSetters[name]
              ) {
                isDuplicate = true;
              }
              alreadySeenData[name] = true;
          }
          if (isDuplicate) {
            // Rely on the computed properties transform to split the property
            // assignment out of the object literal.
            prop.computed = true;
            prop.key = t.stringLiteral(name);
          }
        }
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-duplicate-keys/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/traverse/traverseFast.js

// @flow
import { VISITOR_KEYS } from "../definitions";
/**
 * A prefix AST traversal implementation meant for simple searching
 * and processing.
 */
export default function traverseFast(
  node: Object,
  enter: (node: Node, opts?: Object) => void,
  opts?: Object,
): void {
  if (!node) return;
  const keys = VISITOR_KEYS[node.type];
  if (!keys) return;
  opts = opts || {};
  enter(node, opts);
  for (const key of keys) {
    const subNode = node[key];
    if (Array.isArray(subNode)) {
      for (const node of subNode) {
        traverseFast(node, enter, opts);
      }
    } else {
      traverseFast(subNode, enter, opts);
    }
  }
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/traverse/traverseFast.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/traverse/traverse.js

// @flow
import { VISITOR_KEYS } from "../definitions";
export type TraversalAncestors = Array<{
  node: BabelNode,
  key: string,
  index?: number,
}>;
export type TraversalHandler<T> = (BabelNode, TraversalAncestors, T) => void;
export type TraversalHandlers<T> = {
  enter?: TraversalHandler<T>,
  exit?: TraversalHandler<T>,
};
/**
 * A general AST traversal with both prefix and postfix handlers, and a
 * state object. Exposes ancestry data to each handler so that more complex
 * AST data can be taken into account.
 */
export default function traverse<T>(
  node: BabelNode,
  handlers: TraversalHandler<T> | TraversalHandlers<T>,
  state?: T,
): void {
  if (typeof handlers === "function") {
    handlers = { enter: handlers };
  }
  const { enter, exit } = (handlers: TraversalHandlers<T>);
  traverseSimpleImpl(node, enter, exit, state, []);
}
function traverseSimpleImpl<T>(
  node: Object,
  enter: ?Function,
  exit: ?Function,
  state: ?T,
  ancestors: TraversalAncestors,
) {
  const keys = VISITOR_KEYS[node.type];
  if (!keys) return;
  if (enter) enter(node, ancestors, state);
  for (const key of keys) {
    const subNode = node[key];
    if (Array.isArray(subNode)) {
      for (let i = 0; i < subNode.length; i++) {
        const child = subNode[i];
        if (!child) continue;
        ancestors.push({
          node,
          key,
          index: i,
        });
        traverseSimpleImpl(child, enter, exit, state, ancestors);
        ancestors.pop();
      }
    } else if (subNode) {
      ancestors.push({
        node,
        key,
      });
      traverseSimpleImpl(subNode, enter, exit, state, ancestors);
      ancestors.pop();
    }
  }
  if (exit) exit(node, ancestors, state);
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/traverse/traverse.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/converters/toBlock.js

// @flow
import {
  isBlockStatement,
  isFunction,
  isEmptyStatement,
  isStatement,
} from "../validators/generated";
import {
  returnStatement,
  expressionStatement,
  blockStatement,
} from "../builders/generated";
export default function toBlock(node: Object, parent: Object): Object {
  if (isBlockStatement(node)) {
    return node;
  }
  let blockNodes = [];
  if (isEmptyStatement(node)) {
    blockNodes = [];
  } else {
    if (!isStatement(node)) {
      if (isFunction(parent)) {
        node = returnStatement(node);
      } else {
        node = expressionStatement(node);
      }
    }
    blockNodes = [node];
  }
  return blockStatement(blockNodes);
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/converters/toBlock.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/converters/toComputedKey.js

// @flow
import { isIdentifier } from "../validators/generated";
import { stringLiteral } from "../builders/generated";
export default function toComputedKey(
  node: Object,
  key: Object = node.key || node.property,
): Object {
  if (!node.computed && isIdentifier(key)) key = stringLiteral(key.name);
  return key;
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/converters/toComputedKey.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/converters/toStatement.js

// @flow
import {
  isStatement,
  isFunction,
  isClass,
  isAssignmentExpression,
} from "../validators/generated";
import { expressionStatement } from "../builders/generated";
export default function toStatement(node: Object, ignore?: boolean) {
  if (isStatement(node)) {
    return node;
  }
  let mustHaveId = false;
  let newType;
  if (isClass(node)) {
    mustHaveId = true;
    newType = "ClassDeclaration";
  } else if (isFunction(node)) {
    mustHaveId = true;
    newType = "FunctionDeclaration";
  } else if (isAssignmentExpression(node)) {
    return expressionStatement(node);
  }
  if (mustHaveId && !node.id) {
    newType = false;
  }
  if (!newType) {
    if (ignore) {
      return false;
    } else {
      throw new Error(`cannot turn ${node.type} to a statement`);
    }
  }
  node.type = newType;
  return node;
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/converters/toStatement.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/converters/toExpression.js

// @flow
import {
  isExpression,
  isFunction,
  isClass,
  isExpressionStatement,
} from "../validators/generated";
export default function toExpression(node: Object): Object {
  if (isExpressionStatement(node)) {
    node = node.expression;
  }
  // return unmodified node
  // important for things like ArrowFunctions where
  // type change from ArrowFunction to FunctionExpression
  // produces bugs like -> `()=>a` to `function () a`
  // without generating a BlockStatement for it
  // ref: https://github.com/babel/babili/issues/130
  if (isExpression(node)) {
    return node;
  }
  // convert all classes and functions
  // ClassDeclaration -> ClassExpression
  // FunctionDeclaration, ObjectMethod, ClassMethod -> FunctionExpression
  if (isClass(node)) {
    node.type = "ClassExpression";
  } else if (isFunction(node)) {
    node.type = "FunctionExpression";
  }
  // if it's still not an expression
  if (!isExpression(node)) {
    throw new Error(`cannot turn ${node.type} to an expression`);
  }
  return node;
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/converters/toExpression.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/converters/toBindingIdentifierName.js

// @flow
import toIdentifier from "./toIdentifier";
export default function toBindingIdentifierName(name: string): string {
  name = toIdentifier(name);
  if (name === "eval" || name === "arguments") name = "_" + name;
  return name;
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/converters/toBindingIdentifierName.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/converters/toIdentifier.js

// @flow
import isValidIdentifier from "../validators/isValidIdentifier";
export default function toIdentifier(name: string): string {
  name = name + "";
  // replace all non-valid identifiers with dashes
  name = name.replace(/[^a-zA-Z0-9$_]/g, "-");
  // remove all dashes and numbers from start of name
  name = name.replace(/^[-0-9]+/, "");
  // camel case
  name = name.replace(/[-\s]+(.)?/g, function(match, c) {
    return c ? c.toUpperCase() : "";
  });
  if (!isValidIdentifier(name)) {
    name = `_${name}`;
  }
  return name || "_";
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/converters/toIdentifier.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/converters/gatherSequenceExpressions.js

// @flow
import getBindingIdentifiers from "../retrievers/getBindingIdentifiers";
import {
  isExpression,
  isExpressionStatement,
  isVariableDeclaration,
  isIfStatement,
  isBlockStatement,
  isEmptyStatement,
} from "../validators/generated";
import {
  sequenceExpression,
  assignmentExpression,
  conditionalExpression,
} from "../builders/generated";
import cloneNode from "../clone/cloneNode";
export default function gatherSequenceExpressions(
  nodes: Array<Object>,
  scope: Scope,
  declars: Array<Object>,
): ?Object {
  const exprs = [];
  let ensureLastUndefined = true;
  for (const node of nodes) {
    ensureLastUndefined = false;
    if (isExpression(node)) {
      exprs.push(node);
    } else if (isExpressionStatement(node)) {
      exprs.push(node.expression);
    } else if (isVariableDeclaration(node)) {
      if (node.kind !== "var") return; // bailed
      for (const declar of (node.declarations: Array<any>)) {
        const bindings = getBindingIdentifiers(declar);
        for (const key in bindings) {
          declars.push({
            kind: node.kind,
            id: cloneNode(bindings[key]),
          });
        }
        if (declar.init) {
          exprs.push(assignmentExpression("=", declar.id, declar.init));
        }
      }
      ensureLastUndefined = true;
    } else if (isIfStatement(node)) {
      const consequent = node.consequent
        ? gatherSequenceExpressions([node.consequent], scope, declars)
        : scope.buildUndefinedNode();
      const alternate = node.alternate
        ? gatherSequenceExpressions([node.alternate], scope, declars)
        : scope.buildUndefinedNode();
      if (!consequent || !alternate) return; // bailed
      exprs.push(conditionalExpression(node.test, consequent, alternate));
    } else if (isBlockStatement(node)) {
      const body = gatherSequenceExpressions(node.body, scope, declars);
      if (!body) return; // bailed
      exprs.push(body);
    } else if (isEmptyStatement(node)) {
      // empty statement so ensure the last item is undefined if we're last
      ensureLastUndefined = true;
    } else {
      // bailed, we can't turn this statement into an expression
      return;
    }
  }
  if (ensureLastUndefined) {
    exprs.push(scope.buildUndefinedNode());
  }
  if (exprs.length === 1) {
    return exprs[0];
  } else {
    return sequenceExpression(exprs);
  }
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/converters/gatherSequenceExpressions.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/converters/ensureBlock.js

// @flow
import toBlock from "./toBlock";
/**
 * Ensure the `key` (defaults to "body") of a `node` is a block.
 * Casting it to a block if it is not.
 *
 * Returns the BlockStatement
 */
export default function ensureBlock(
  node: Object,
  key: string = "body",
): Object {
  return (node[key] = toBlock(node[key], node));
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/converters/ensureBlock.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/converters/toKeyAlias.js

// @flow
import { isIdentifier, isStringLiteral } from "../validators/generated";
import cloneNode from "../clone/cloneNode";
import removePropertiesDeep from "../modifications/removePropertiesDeep";
export default function toKeyAlias(
  node: Object,
  key: Object = node.key,
): string {
  let alias;
  if (node.kind === "method") {
    return toKeyAlias.increment() + "";
  } else if (isIdentifier(key)) {
    alias = key.name;
  } else if (isStringLiteral(key)) {
    alias = JSON.stringify(key.value);
  } else {
    alias = JSON.stringify(removePropertiesDeep(cloneNode(key)));
  }
  if (node.computed) {
    alias = `[${alias}]`;
  }
  if (node.static) {
    alias = `static:${alias}`;
  }
  return alias;
}
toKeyAlias.uid = 0;
toKeyAlias.increment = function() {
  if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {
    return (toKeyAlias.uid = 0);
  } else {
    return toKeyAlias.uid++;
  }
};

// </from> /home/qfox/apps/babel/packages/babel-types/src/converters/toKeyAlias.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/converters/toSequenceExpression.js

// @flow
import gatherSequenceExpressions from "./gatherSequenceExpressions";
/**
 * Turn an array of statement `nodes` into a `SequenceExpression`.
 *
 * Variable declarations are turned into simple assignments and their
 * declarations hoisted to the top of the current scope.
 *
 * Expression statements are just resolved to their expression.
 */
export default function toSequenceExpression(
  nodes: Array<Object>,
  scope: Scope,
): ?Object {
  if (!nodes || !nodes.length) return;
  const declars = [];
  const result = gatherSequenceExpressions(nodes, scope, declars);
  if (!result) return;
  for (const declar of declars) {
    scope.push(declar);
  }
  return result;
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/converters/toSequenceExpression.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/converters/valueToNode.js

// @flow
import isPlainObject from "lodash/isPlainObject";
import isRegExp from "lodash/isRegExp";
import isValidIdentifier from "../validators/isValidIdentifier";
import {
  identifier,
  booleanLiteral,
  nullLiteral,
  stringLiteral,
  numericLiteral,
  regExpLiteral,
  arrayExpression,
  objectProperty,
  objectExpression,
  unaryExpression,
  binaryExpression,
} from "../builders/generated";
export default function valueToNode(value: any): Object {
  // undefined
  if (value === undefined) {
    return identifier("undefined");
  }
  // boolean
  if (value === true || value === false) {
    return booleanLiteral(value);
  }
  // null
  if (value === null) {
    return nullLiteral();
  }
  // strings
  if (typeof value === "string") {
    return stringLiteral(value);
  }
  // numbers
  if (typeof value === "number") {
    let result;
    if (Number.isFinite(value)) {
      result = numericLiteral(Math.abs(value));
    } else {
      let numerator;
      if (Number.isNaN(value)) {
        // NaN
        numerator = numericLiteral(0);
      } else {
        // Infinity / -Infinity
        numerator = numericLiteral(1);
      }
      result = binaryExpression("/", numerator, numericLiteral(0));
    }
    if (value < 0 || Object.is(value, -0)) {
      result = unaryExpression("-", result);
    }
    return result;
  }
  // regexes
  if (isRegExp(value)) {
    const pattern = value.source;
    const flags = value.toString().match(/\/([a-z]+|)$/)[1];
    return regExpLiteral(pattern, flags);
  }
  // array
  if (Array.isArray(value)) {
    return arrayExpression(value.map(valueToNode));
  }
  // object
  if (isPlainObject(value)) {
    const props = [];
    for (const key in value) {
      let nodeKey;
      if (isValidIdentifier(key)) {
        nodeKey = identifier(key);
      } else {
        nodeKey = stringLiteral(key);
      }
      props.push(objectProperty(nodeKey, valueToNode(value[key])));
    }
    return objectExpression(props);
  }
  throw new Error("don't know how to turn this value into a node");
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/converters/valueToNode.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/builders/flow/createUnionTypeAnnotation.js

// @flow
import { unionTypeAnnotation } from "../generated";
import removeTypeDuplicates from "../../modifications/flow/removeTypeDuplicates";
/**
 * Takes an array of `types` and flattens them, removing duplicates and
 * returns a `UnionTypeAnnotation` node containg them.
 */
export default function createUnionTypeAnnotation(
  types: Array<Object>,
): Object {
  const flattened = removeTypeDuplicates(types);
  if (flattened.length === 1) {
    return flattened[0];
  } else {
    return unionTypeAnnotation(flattened);
  }
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/builders/flow/createUnionTypeAnnotation.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/builders/flow/createTypeAnnotationBasedOnTypeof.js

// @flow
import {
  stringTypeAnnotation,
  numberTypeAnnotation,
  voidTypeAnnotation,
  booleanTypeAnnotation,
  genericTypeAnnotation,
  identifier,
} from "../generated";
/**
 * Create a type annotation based on typeof expression.
 */
export default function createTypeAnnotationBasedOnTypeof(
  type: string,
): Object {
  if (type === "string") {
    return stringTypeAnnotation();
  } else if (type === "number") {
    return numberTypeAnnotation();
  } else if (type === "undefined") {
    return voidTypeAnnotation();
  } else if (type === "boolean") {
    return booleanTypeAnnotation();
  } else if (type === "function") {
    return genericTypeAnnotation(identifier("Function"));
  } else if (type === "object") {
    return genericTypeAnnotation(identifier("Object"));
  } else if (type === "symbol") {
    return genericTypeAnnotation(identifier("Symbol"));
  } else {
    throw new Error("Invalid typeof value");
  }
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/builders/flow/createTypeAnnotationBasedOnTypeof.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/builders/generated/index.js

// @flow
/*
 * This file is auto-generated! Do not modify it directly.
 * To re-generate run 'make build'
 */
import builder from "../builder";
export function ArrayExpression(...args: Array<any>): Object {
  return builder("ArrayExpression", ...args);
}
export { ArrayExpression as arrayExpression };
export function AssignmentExpression(...args: Array<any>): Object {
  return builder("AssignmentExpression", ...args);
}
export { AssignmentExpression as assignmentExpression };
export function BinaryExpression(...args: Array<any>): Object {
  return builder("BinaryExpression", ...args);
}
export { BinaryExpression as binaryExpression };
export function InterpreterDirective(...args: Array<any>): Object {
  return builder("InterpreterDirective", ...args);
}
export { InterpreterDirective as interpreterDirective };
export function Directive(...args: Array<any>): Object {
  return builder("Directive", ...args);
}
export { Directive as directive };
export function DirectiveLiteral(...args: Array<any>): Object {
  return builder("DirectiveLiteral", ...args);
}
export { DirectiveLiteral as directiveLiteral };
export function BlockStatement(...args: Array<any>): Object {
  return builder("BlockStatement", ...args);
}
export { BlockStatement as blockStatement };
export function BreakStatement(...args: Array<any>): Object {
  return builder("BreakStatement", ...args);
}
export { BreakStatement as breakStatement };
export function CallExpression(...args: Array<any>): Object {
  return builder("CallExpression", ...args);
}
export { CallExpression as callExpression };
export function CatchClause(...args: Array<any>): Object {
  return builder("CatchClause", ...args);
}
export { CatchClause as catchClause };
export function ConditionalExpression(...args: Array<any>): Object {
  return builder("ConditionalExpression", ...args);
}
export { ConditionalExpression as conditionalExpression };
export function ContinueStatement(...args: Array<any>): Object {
  return builder("ContinueStatement", ...args);
}
export { ContinueStatement as continueStatement };
export function DebuggerStatement(...args: Array<any>): Object {
  return builder("DebuggerStatement", ...args);
}
export { DebuggerStatement as debuggerStatement };
export function DoWhileStatement(...args: Array<any>): Object {
  return builder("DoWhileStatement", ...args);
}
export { DoWhileStatement as doWhileStatement };
export function EmptyStatement(...args: Array<any>): Object {
  return builder("EmptyStatement", ...args);
}
export { EmptyStatement as emptyStatement };
export function ExpressionStatement(...args: Array<any>): Object {
  return builder("ExpressionStatement", ...args);
}
export { ExpressionStatement as expressionStatement };
export function File(...args: Array<any>): Object {
  return builder("File", ...args);
}
export { File as file };
export function ForInStatement(...args: Array<any>): Object {
  return builder("ForInStatement", ...args);
}
export { ForInStatement as forInStatement };
export function ForStatement(...args: Array<any>): Object {
  return builder("ForStatement", ...args);
}
export { ForStatement as forStatement };
export function FunctionDeclaration(...args: Array<any>): Object {
  return builder("FunctionDeclaration", ...args);
}
export { FunctionDeclaration as functionDeclaration };
export function FunctionExpression(...args: Array<any>): Object {
  return builder("FunctionExpression", ...args);
}
export { FunctionExpression as functionExpression };
export function Identifier(...args: Array<any>): Object {
  return builder("Identifier", ...args);
}
export { Identifier as identifier };
export function IfStatement(...args: Array<any>): Object {
  return builder("IfStatement", ...args);
}
export { IfStatement as ifStatement };
export function LabeledStatement(...args: Array<any>): Object {
  return builder("LabeledStatement", ...args);
}
export { LabeledStatement as labeledStatement };
export function StringLiteral(...args: Array<any>): Object {
  return builder("StringLiteral", ...args);
}
export { StringLiteral as stringLiteral };
export function NumericLiteral(...args: Array<any>): Object {
  return builder("NumericLiteral", ...args);
}
export { NumericLiteral as numericLiteral };
export function NullLiteral(...args: Array<any>): Object {
  return builder("NullLiteral", ...args);
}
export { NullLiteral as nullLiteral };
export function BooleanLiteral(...args: Array<any>): Object {
  return builder("BooleanLiteral", ...args);
}
export { BooleanLiteral as booleanLiteral };
export function RegExpLiteral(...args: Array<any>): Object {
  return builder("RegExpLiteral", ...args);
}
export { RegExpLiteral as regExpLiteral };
export function LogicalExpression(...args: Array<any>): Object {
  return builder("LogicalExpression", ...args);
}
export { LogicalExpression as logicalExpression };
export function MemberExpression(...args: Array<any>): Object {
  return builder("MemberExpression", ...args);
}
export { MemberExpression as memberExpression };
export function NewExpression(...args: Array<any>): Object {
  return builder("NewExpression", ...args);
}
export { NewExpression as newExpression };
export function Program(...args: Array<any>): Object {
  return builder("Program", ...args);
}
export { Program as program };
export function ObjectExpression(...args: Array<any>): Object {
  return builder("ObjectExpression", ...args);
}
export { ObjectExpression as objectExpression };
export function ObjectMethod(...args: Array<any>): Object {
  return builder("ObjectMethod", ...args);
}
export { ObjectMethod as objectMethod };
export function ObjectProperty(...args: Array<any>): Object {
  return builder("ObjectProperty", ...args);
}
export { ObjectProperty as objectProperty };
export function RestElement(...args: Array<any>): Object {
  return builder("RestElement", ...args);
}
export { RestElement as restElement };
export function ReturnStatement(...args: Array<any>): Object {
  return builder("ReturnStatement", ...args);
}
export { ReturnStatement as returnStatement };
export function SequenceExpression(...args: Array<any>): Object {
  return builder("SequenceExpression", ...args);
}
export { SequenceExpression as sequenceExpression };
export function SwitchCase(...args: Array<any>): Object {
  return builder("SwitchCase", ...args);
}
export { SwitchCase as switchCase };
export function SwitchStatement(...args: Array<any>): Object {
  return builder("SwitchStatement", ...args);
}
export { SwitchStatement as switchStatement };
export function ThisExpression(...args: Array<any>): Object {
  return builder("ThisExpression", ...args);
}
export { ThisExpression as thisExpression };
export function ThrowStatement(...args: Array<any>): Object {
  return builder("ThrowStatement", ...args);
}
export { ThrowStatement as throwStatement };
export function TryStatement(...args: Array<any>): Object {
  return builder("TryStatement", ...args);
}
export { TryStatement as tryStatement };
export function UnaryExpression(...args: Array<any>): Object {
  return builder("UnaryExpression", ...args);
}
export { UnaryExpression as unaryExpression };
export function UpdateExpression(...args: Array<any>): Object {
  return builder("UpdateExpression", ...args);
}
export { UpdateExpression as updateExpression };
export function VariableDeclaration(...args: Array<any>): Object {
  return builder("VariableDeclaration", ...args);
}
export { VariableDeclaration as variableDeclaration };
export function VariableDeclarator(...args: Array<any>): Object {
  return builder("VariableDeclarator", ...args);
}
export { VariableDeclarator as variableDeclarator };
export function WhileStatement(...args: Array<any>): Object {
  return builder("WhileStatement", ...args);
}
export { WhileStatement as whileStatement };
export function WithStatement(...args: Array<any>): Object {
  return builder("WithStatement", ...args);
}
export { WithStatement as withStatement };
export function AssignmentPattern(...args: Array<any>): Object {
  return builder("AssignmentPattern", ...args);
}
export { AssignmentPattern as assignmentPattern };
export function ArrayPattern(...args: Array<any>): Object {
  return builder("ArrayPattern", ...args);
}
export { ArrayPattern as arrayPattern };
export function ArrowFunctionExpression(...args: Array<any>): Object {
  return builder("ArrowFunctionExpression", ...args);
}
export { ArrowFunctionExpression as arrowFunctionExpression };
export function ClassBody(...args: Array<any>): Object {
  return builder("ClassBody", ...args);
}
export { ClassBody as classBody };
export function ClassDeclaration(...args: Array<any>): Object {
  return builder("ClassDeclaration", ...args);
}
export { ClassDeclaration as classDeclaration };
export function ClassExpression(...args: Array<any>): Object {
  return builder("ClassExpression", ...args);
}
export { ClassExpression as classExpression };
export function ExportAllDeclaration(...args: Array<any>): Object {
  return builder("ExportAllDeclaration", ...args);
}
export { ExportAllDeclaration as exportAllDeclaration };
export function ExportDefaultDeclaration(...args: Array<any>): Object {
  return builder("ExportDefaultDeclaration", ...args);
}
export { ExportDefaultDeclaration as exportDefaultDeclaration };
export function ExportNamedDeclaration(...args: Array<any>): Object {
  return builder("ExportNamedDeclaration", ...args);
}
export { ExportNamedDeclaration as exportNamedDeclaration };
export function ExportSpecifier(...args: Array<any>): Object {
  return builder("ExportSpecifier", ...args);
}
export { ExportSpecifier as exportSpecifier };
export function ForOfStatement(...args: Array<any>): Object {
  return builder("ForOfStatement", ...args);
}
export { ForOfStatement as forOfStatement };
export function ImportDeclaration(...args: Array<any>): Object {
  return builder("ImportDeclaration", ...args);
}
export { ImportDeclaration as importDeclaration };
export function ImportDefaultSpecifier(...args: Array<any>): Object {
  return builder("ImportDefaultSpecifier", ...args);
}
export { ImportDefaultSpecifier as importDefaultSpecifier };
export function ImportNamespaceSpecifier(...args: Array<any>): Object {
  return builder("ImportNamespaceSpecifier", ...args);
}
export { ImportNamespaceSpecifier as importNamespaceSpecifier };
export function ImportSpecifier(...args: Array<any>): Object {
  return builder("ImportSpecifier", ...args);
}
export { ImportSpecifier as importSpecifier };
export function MetaProperty(...args: Array<any>): Object {
  return builder("MetaProperty", ...args);
}
export { MetaProperty as metaProperty };
export function ClassMethod(...args: Array<any>): Object {
  return builder("ClassMethod", ...args);
}
export { ClassMethod as classMethod };
export function ObjectPattern(...args: Array<any>): Object {
  return builder("ObjectPattern", ...args);
}
export { ObjectPattern as objectPattern };
export function SpreadElement(...args: Array<any>): Object {
  return builder("SpreadElement", ...args);
}
export { SpreadElement as spreadElement };
export function Super(...args: Array<any>): Object {
  return builder("Super", ...args);
}
export { Super as super };
export function TaggedTemplateExpression(...args: Array<any>): Object {
  return builder("TaggedTemplateExpression", ...args);
}
export { TaggedTemplateExpression as taggedTemplateExpression };
export function TemplateElement(...args: Array<any>): Object {
  return builder("TemplateElement", ...args);
}
export { TemplateElement as templateElement };
export function TemplateLiteral(...args: Array<any>): Object {
  return builder("TemplateLiteral", ...args);
}
export { TemplateLiteral as templateLiteral };
export function YieldExpression(...args: Array<any>): Object {
  return builder("YieldExpression", ...args);
}
export { YieldExpression as yieldExpression };
export function AnyTypeAnnotation(...args: Array<any>): Object {
  return builder("AnyTypeAnnotation", ...args);
}
export { AnyTypeAnnotation as anyTypeAnnotation };
export function ArrayTypeAnnotation(...args: Array<any>): Object {
  return builder("ArrayTypeAnnotation", ...args);
}
export { ArrayTypeAnnotation as arrayTypeAnnotation };
export function BooleanTypeAnnotation(...args: Array<any>): Object {
  return builder("BooleanTypeAnnotation", ...args);
}
export { BooleanTypeAnnotation as booleanTypeAnnotation };
export function BooleanLiteralTypeAnnotation(...args: Array<any>): Object {
  return builder("BooleanLiteralTypeAnnotation", ...args);
}
export { BooleanLiteralTypeAnnotation as booleanLiteralTypeAnnotation };
export function NullLiteralTypeAnnotation(...args: Array<any>): Object {
  return builder("NullLiteralTypeAnnotation", ...args);
}
export { NullLiteralTypeAnnotation as nullLiteralTypeAnnotation };
export function ClassImplements(...args: Array<any>): Object {
  return builder("ClassImplements", ...args);
}
export { ClassImplements as classImplements };
export function DeclareClass(...args: Array<any>): Object {
  return builder("DeclareClass", ...args);
}
export { DeclareClass as declareClass };
export function DeclareFunction(...args: Array<any>): Object {
  return builder("DeclareFunction", ...args);
}
export { DeclareFunction as declareFunction };
export function DeclareInterface(...args: Array<any>): Object {
  return builder("DeclareInterface", ...args);
}
export { DeclareInterface as declareInterface };
export function DeclareModule(...args: Array<any>): Object {
  return builder("DeclareModule", ...args);
}
export { DeclareModule as declareModule };
export function DeclareModuleExports(...args: Array<any>): Object {
  return builder("DeclareModuleExports", ...args);
}
export { DeclareModuleExports as declareModuleExports };
export function DeclareTypeAlias(...args: Array<any>): Object {
  return builder("DeclareTypeAlias", ...args);
}
export { DeclareTypeAlias as declareTypeAlias };
export function DeclareOpaqueType(...args: Array<any>): Object {
  return builder("DeclareOpaqueType", ...args);
}
export { DeclareOpaqueType as declareOpaqueType };
export function DeclareVariable(...args: Array<any>): Object {
  return builder("DeclareVariable", ...args);
}
export { DeclareVariable as declareVariable };
export function DeclareExportDeclaration(...args: Array<any>): Object {
  return builder("DeclareExportDeclaration", ...args);
}
export { DeclareExportDeclaration as declareExportDeclaration };
export function DeclareExportAllDeclaration(...args: Array<any>): Object {
  return builder("DeclareExportAllDeclaration", ...args);
}
export { DeclareExportAllDeclaration as declareExportAllDeclaration };
export function DeclaredPredicate(...args: Array<any>): Object {
  return builder("DeclaredPredicate", ...args);
}
export { DeclaredPredicate as declaredPredicate };
export function ExistsTypeAnnotation(...args: Array<any>): Object {
  return builder("ExistsTypeAnnotation", ...args);
}
export { ExistsTypeAnnotation as existsTypeAnnotation };
export function FunctionTypeAnnotation(...args: Array<any>): Object {
  return builder("FunctionTypeAnnotation", ...args);
}
export { FunctionTypeAnnotation as functionTypeAnnotation };
export function FunctionTypeParam(...args: Array<any>): Object {
  return builder("FunctionTypeParam", ...args);
}
export { FunctionTypeParam as functionTypeParam };
export function GenericTypeAnnotation(...args: Array<any>): Object {
  return builder("GenericTypeAnnotation", ...args);
}
export { GenericTypeAnnotation as genericTypeAnnotation };
export function InferredPredicate(...args: Array<any>): Object {
  return builder("InferredPredicate", ...args);
}
export { InferredPredicate as inferredPredicate };
export function InterfaceExtends(...args: Array<any>): Object {
  return builder("InterfaceExtends", ...args);
}
export { InterfaceExtends as interfaceExtends };
export function InterfaceDeclaration(...args: Array<any>): Object {
  return builder("InterfaceDeclaration", ...args);
}
export { InterfaceDeclaration as interfaceDeclaration };
export function InterfaceTypeAnnotation(...args: Array<any>): Object {
  return builder("InterfaceTypeAnnotation", ...args);
}
export { InterfaceTypeAnnotation as interfaceTypeAnnotation };
export function IntersectionTypeAnnotation(...args: Array<any>): Object {
  return builder("IntersectionTypeAnnotation", ...args);
}
export { IntersectionTypeAnnotation as intersectionTypeAnnotation };
export function MixedTypeAnnotation(...args: Array<any>): Object {
  return builder("MixedTypeAnnotation", ...args);
}
export { MixedTypeAnnotation as mixedTypeAnnotation };
export function EmptyTypeAnnotation(...args: Array<any>): Object {
  return builder("EmptyTypeAnnotation", ...args);
}
export { EmptyTypeAnnotation as emptyTypeAnnotation };
export function NullableTypeAnnotation(...args: Array<any>): Object {
  return builder("NullableTypeAnnotation", ...args);
}
export { NullableTypeAnnotation as nullableTypeAnnotation };
export function NumberLiteralTypeAnnotation(...args: Array<any>): Object {
  return builder("NumberLiteralTypeAnnotation", ...args);
}
export { NumberLiteralTypeAnnotation as numberLiteralTypeAnnotation };
export function NumberTypeAnnotation(...args: Array<any>): Object {
  return builder("NumberTypeAnnotation", ...args);
}
export { NumberTypeAnnotation as numberTypeAnnotation };
export function ObjectTypeAnnotation(...args: Array<any>): Object {
  return builder("ObjectTypeAnnotation", ...args);
}
export { ObjectTypeAnnotation as objectTypeAnnotation };
export function ObjectTypeInternalSlot(...args: Array<any>): Object {
  return builder("ObjectTypeInternalSlot", ...args);
}
export { ObjectTypeInternalSlot as objectTypeInternalSlot };
export function ObjectTypeCallProperty(...args: Array<any>): Object {
  return builder("ObjectTypeCallProperty", ...args);
}
export { ObjectTypeCallProperty as objectTypeCallProperty };
export function ObjectTypeIndexer(...args: Array<any>): Object {
  return builder("ObjectTypeIndexer", ...args);
}
export { ObjectTypeIndexer as objectTypeIndexer };
export function ObjectTypeProperty(...args: Array<any>): Object {
  return builder("ObjectTypeProperty", ...args);
}
export { ObjectTypeProperty as objectTypeProperty };
export function ObjectTypeSpreadProperty(...args: Array<any>): Object {
  return builder("ObjectTypeSpreadProperty", ...args);
}
export { ObjectTypeSpreadProperty as objectTypeSpreadProperty };
export function OpaqueType(...args: Array<any>): Object {
  return builder("OpaqueType", ...args);
}
export { OpaqueType as opaqueType };
export function QualifiedTypeIdentifier(...args: Array<any>): Object {
  return builder("QualifiedTypeIdentifier", ...args);
}
export { QualifiedTypeIdentifier as qualifiedTypeIdentifier };
export function StringLiteralTypeAnnotation(...args: Array<any>): Object {
  return builder("StringLiteralTypeAnnotation", ...args);
}
export { StringLiteralTypeAnnotation as stringLiteralTypeAnnotation };
export function StringTypeAnnotation(...args: Array<any>): Object {
  return builder("StringTypeAnnotation", ...args);
}
export { StringTypeAnnotation as stringTypeAnnotation };
export function ThisTypeAnnotation(...args: Array<any>): Object {
  return builder("ThisTypeAnnotation", ...args);
}
export { ThisTypeAnnotation as thisTypeAnnotation };
export function TupleTypeAnnotation(...args: Array<any>): Object {
  return builder("TupleTypeAnnotation", ...args);
}
export { TupleTypeAnnotation as tupleTypeAnnotation };
export function TypeofTypeAnnotation(...args: Array<any>): Object {
  return builder("TypeofTypeAnnotation", ...args);
}
export { TypeofTypeAnnotation as typeofTypeAnnotation };
export function TypeAlias(...args: Array<any>): Object {
  return builder("TypeAlias", ...args);
}
export { TypeAlias as typeAlias };
export function TypeAnnotation(...args: Array<any>): Object {
  return builder("TypeAnnotation", ...args);
}
export { TypeAnnotation as typeAnnotation };
export function TypeCastExpression(...args: Array<any>): Object {
  return builder("TypeCastExpression", ...args);
}
export { TypeCastExpression as typeCastExpression };
export function TypeParameter(...args: Array<any>): Object {
  return builder("TypeParameter", ...args);
}
export { TypeParameter as typeParameter };
export function TypeParameterDeclaration(...args: Array<any>): Object {
  return builder("TypeParameterDeclaration", ...args);
}
export { TypeParameterDeclaration as typeParameterDeclaration };
export function TypeParameterInstantiation(...args: Array<any>): Object {
  return builder("TypeParameterInstantiation", ...args);
}
export { TypeParameterInstantiation as typeParameterInstantiation };
export function UnionTypeAnnotation(...args: Array<any>): Object {
  return builder("UnionTypeAnnotation", ...args);
}
export { UnionTypeAnnotation as unionTypeAnnotation };
export function Variance(...args: Array<any>): Object {
  return builder("Variance", ...args);
}
export { Variance as variance };
export function VoidTypeAnnotation(...args: Array<any>): Object {
  return builder("VoidTypeAnnotation", ...args);
}
export { VoidTypeAnnotation as voidTypeAnnotation };
export function JSXAttribute(...args: Array<any>): Object {
  return builder("JSXAttribute", ...args);
}
export { JSXAttribute as jsxAttribute };
export { JSXAttribute as jSXAttribute };
export function JSXClosingElement(...args: Array<any>): Object {
  return builder("JSXClosingElement", ...args);
}
export { JSXClosingElement as jsxClosingElement };
export { JSXClosingElement as jSXClosingElement };
export function JSXElement(...args: Array<any>): Object {
  return builder("JSXElement", ...args);
}
export { JSXElement as jsxElement };
export { JSXElement as jSXElement };
export function JSXEmptyExpression(...args: Array<any>): Object {
  return builder("JSXEmptyExpression", ...args);
}
export { JSXEmptyExpression as jsxEmptyExpression };
export { JSXEmptyExpression as jSXEmptyExpression };
export function JSXExpressionContainer(...args: Array<any>): Object {
  return builder("JSXExpressionContainer", ...args);
}
export { JSXExpressionContainer as jsxExpressionContainer };
export { JSXExpressionContainer as jSXExpressionContainer };
export function JSXSpreadChild(...args: Array<any>): Object {
  return builder("JSXSpreadChild", ...args);
}
export { JSXSpreadChild as jsxSpreadChild };
export { JSXSpreadChild as jSXSpreadChild };
export function JSXIdentifier(...args: Array<any>): Object {
  return builder("JSXIdentifier", ...args);
}
export { JSXIdentifier as jsxIdentifier };
export { JSXIdentifier as jSXIdentifier };
export function JSXMemberExpression(...args: Array<any>): Object {
  return builder("JSXMemberExpression", ...args);
}
export { JSXMemberExpression as jsxMemberExpression };
export { JSXMemberExpression as jSXMemberExpression };
export function JSXNamespacedName(...args: Array<any>): Object {
  return builder("JSXNamespacedName", ...args);
}
export { JSXNamespacedName as jsxNamespacedName };
export { JSXNamespacedName as jSXNamespacedName };
export function JSXOpeningElement(...args: Array<any>): Object {
  return builder("JSXOpeningElement", ...args);
}
export { JSXOpeningElement as jsxOpeningElement };
export { JSXOpeningElement as jSXOpeningElement };
export function JSXSpreadAttribute(...args: Array<any>): Object {
  return builder("JSXSpreadAttribute", ...args);
}
export { JSXSpreadAttribute as jsxSpreadAttribute };
export { JSXSpreadAttribute as jSXSpreadAttribute };
export function JSXText(...args: Array<any>): Object {
  return builder("JSXText", ...args);
}
export { JSXText as jsxText };
export { JSXText as jSXText };
export function JSXFragment(...args: Array<any>): Object {
  return builder("JSXFragment", ...args);
}
export { JSXFragment as jsxFragment };
export { JSXFragment as jSXFragment };
export function JSXOpeningFragment(...args: Array<any>): Object {
  return builder("JSXOpeningFragment", ...args);
}
export { JSXOpeningFragment as jsxOpeningFragment };
export { JSXOpeningFragment as jSXOpeningFragment };
export function JSXClosingFragment(...args: Array<any>): Object {
  return builder("JSXClosingFragment", ...args);
}
export { JSXClosingFragment as jsxClosingFragment };
export { JSXClosingFragment as jSXClosingFragment };
export function Noop(...args: Array<any>): Object {
  return builder("Noop", ...args);
}
export { Noop as noop };
export function ParenthesizedExpression(...args: Array<any>): Object {
  return builder("ParenthesizedExpression", ...args);
}
export { ParenthesizedExpression as parenthesizedExpression };
export function AwaitExpression(...args: Array<any>): Object {
  return builder("AwaitExpression", ...args);
}
export { AwaitExpression as awaitExpression };
export function BindExpression(...args: Array<any>): Object {
  return builder("BindExpression", ...args);
}
export { BindExpression as bindExpression };
export function ClassProperty(...args: Array<any>): Object {
  return builder("ClassProperty", ...args);
}
export { ClassProperty as classProperty };
export function OptionalMemberExpression(...args: Array<any>): Object {
  return builder("OptionalMemberExpression", ...args);
}
export { OptionalMemberExpression as optionalMemberExpression };
export function OptionalCallExpression(...args: Array<any>): Object {
  return builder("OptionalCallExpression", ...args);
}
export { OptionalCallExpression as optionalCallExpression };
export function ClassPrivateProperty(...args: Array<any>): Object {
  return builder("ClassPrivateProperty", ...args);
}
export { ClassPrivateProperty as classPrivateProperty };
export function Import(...args: Array<any>): Object {
  return builder("Import", ...args);
}
export { Import as import };
export function Decorator(...args: Array<any>): Object {
  return builder("Decorator", ...args);
}
export { Decorator as decorator };
export function DoExpression(...args: Array<any>): Object {
  return builder("DoExpression", ...args);
}
export { DoExpression as doExpression };
export function ExportDefaultSpecifier(...args: Array<any>): Object {
  return builder("ExportDefaultSpecifier", ...args);
}
export { ExportDefaultSpecifier as exportDefaultSpecifier };
export function ExportNamespaceSpecifier(...args: Array<any>): Object {
  return builder("ExportNamespaceSpecifier", ...args);
}
export { ExportNamespaceSpecifier as exportNamespaceSpecifier };
export function PrivateName(...args: Array<any>): Object {
  return builder("PrivateName", ...args);
}
export { PrivateName as privateName };
export function BigIntLiteral(...args: Array<any>): Object {
  return builder("BigIntLiteral", ...args);
}
export { BigIntLiteral as bigIntLiteral };
export function TSParameterProperty(...args: Array<any>): Object {
  return builder("TSParameterProperty", ...args);
}
export { TSParameterProperty as tsParameterProperty };
export { TSParameterProperty as tSParameterProperty };
export function TSDeclareFunction(...args: Array<any>): Object {
  return builder("TSDeclareFunction", ...args);
}
export { TSDeclareFunction as tsDeclareFunction };
export { TSDeclareFunction as tSDeclareFunction };
export function TSDeclareMethod(...args: Array<any>): Object {
  return builder("TSDeclareMethod", ...args);
}
export { TSDeclareMethod as tsDeclareMethod };
export { TSDeclareMethod as tSDeclareMethod };
export function TSQualifiedName(...args: Array<any>): Object {
  return builder("TSQualifiedName", ...args);
}
export { TSQualifiedName as tsQualifiedName };
export { TSQualifiedName as tSQualifiedName };
export function TSCallSignatureDeclaration(...args: Array<any>): Object {
  return builder("TSCallSignatureDeclaration", ...args);
}
export { TSCallSignatureDeclaration as tsCallSignatureDeclaration };
export { TSCallSignatureDeclaration as tSCallSignatureDeclaration };
export function TSConstructSignatureDeclaration(...args: Array<any>): Object {
  return builder("TSConstructSignatureDeclaration", ...args);
}
export { TSConstructSignatureDeclaration as tsConstructSignatureDeclaration };
export { TSConstructSignatureDeclaration as tSConstructSignatureDeclaration };
export function TSPropertySignature(...args: Array<any>): Object {
  return builder("TSPropertySignature", ...args);
}
export { TSPropertySignature as tsPropertySignature };
export { TSPropertySignature as tSPropertySignature };
export function TSMethodSignature(...args: Array<any>): Object {
  return builder("TSMethodSignature", ...args);
}
export { TSMethodSignature as tsMethodSignature };
export { TSMethodSignature as tSMethodSignature };
export function TSIndexSignature(...args: Array<any>): Object {
  return builder("TSIndexSignature", ...args);
}
export { TSIndexSignature as tsIndexSignature };
export { TSIndexSignature as tSIndexSignature };
export function TSAnyKeyword(...args: Array<any>): Object {
  return builder("TSAnyKeyword", ...args);
}
export { TSAnyKeyword as tsAnyKeyword };
export { TSAnyKeyword as tSAnyKeyword };
export function TSUnknownKeyword(...args: Array<any>): Object {
  return builder("TSUnknownKeyword", ...args);
}
export { TSUnknownKeyword as tsUnknownKeyword };
export { TSUnknownKeyword as tSUnknownKeyword };
export function TSNumberKeyword(...args: Array<any>): Object {
  return builder("TSNumberKeyword", ...args);
}
export { TSNumberKeyword as tsNumberKeyword };
export { TSNumberKeyword as tSNumberKeyword };
export function TSObjectKeyword(...args: Array<any>): Object {
  return builder("TSObjectKeyword", ...args);
}
export { TSObjectKeyword as tsObjectKeyword };
export { TSObjectKeyword as tSObjectKeyword };
export function TSBooleanKeyword(...args: Array<any>): Object {
  return builder("TSBooleanKeyword", ...args);
}
export { TSBooleanKeyword as tsBooleanKeyword };
export { TSBooleanKeyword as tSBooleanKeyword };
export function TSStringKeyword(...args: Array<any>): Object {
  return builder("TSStringKeyword", ...args);
}
export { TSStringKeyword as tsStringKeyword };
export { TSStringKeyword as tSStringKeyword };
export function TSSymbolKeyword(...args: Array<any>): Object {
  return builder("TSSymbolKeyword", ...args);
}
export { TSSymbolKeyword as tsSymbolKeyword };
export { TSSymbolKeyword as tSSymbolKeyword };
export function TSVoidKeyword(...args: Array<any>): Object {
  return builder("TSVoidKeyword", ...args);
}
export { TSVoidKeyword as tsVoidKeyword };
export { TSVoidKeyword as tSVoidKeyword };
export function TSUndefinedKeyword(...args: Array<any>): Object {
  return builder("TSUndefinedKeyword", ...args);
}
export { TSUndefinedKeyword as tsUndefinedKeyword };
export { TSUndefinedKeyword as tSUndefinedKeyword };
export function TSNullKeyword(...args: Array<any>): Object {
  return builder("TSNullKeyword", ...args);
}
export { TSNullKeyword as tsNullKeyword };
export { TSNullKeyword as tSNullKeyword };
export function TSNeverKeyword(...args: Array<any>): Object {
  return builder("TSNeverKeyword", ...args);
}
export { TSNeverKeyword as tsNeverKeyword };
export { TSNeverKeyword as tSNeverKeyword };
export function TSThisType(...args: Array<any>): Object {
  return builder("TSThisType", ...args);
}
export { TSThisType as tsThisType };
export { TSThisType as tSThisType };
export function TSFunctionType(...args: Array<any>): Object {
  return builder("TSFunctionType", ...args);
}
export { TSFunctionType as tsFunctionType };
export { TSFunctionType as tSFunctionType };
export function TSConstructorType(...args: Array<any>): Object {
  return builder("TSConstructorType", ...args);
}
export { TSConstructorType as tsConstructorType };
export { TSConstructorType as tSConstructorType };
export function TSTypeReference(...args: Array<any>): Object {
  return builder("TSTypeReference", ...args);
}
export { TSTypeReference as tsTypeReference };
export { TSTypeReference as tSTypeReference };
export function TSTypePredicate(...args: Array<any>): Object {
  return builder("TSTypePredicate", ...args);
}
export { TSTypePredicate as tsTypePredicate };
export { TSTypePredicate as tSTypePredicate };
export function TSTypeQuery(...args: Array<any>): Object {
  return builder("TSTypeQuery", ...args);
}
export { TSTypeQuery as tsTypeQuery };
export { TSTypeQuery as tSTypeQuery };
export function TSTypeLiteral(...args: Array<any>): Object {
  return builder("TSTypeLiteral", ...args);
}
export { TSTypeLiteral as tsTypeLiteral };
export { TSTypeLiteral as tSTypeLiteral };
export function TSArrayType(...args: Array<any>): Object {
  return builder("TSArrayType", ...args);
}
export { TSArrayType as tsArrayType };
export { TSArrayType as tSArrayType };
export function TSTupleType(...args: Array<any>): Object {
  return builder("TSTupleType", ...args);
}
export { TSTupleType as tsTupleType };
export { TSTupleType as tSTupleType };
export function TSOptionalType(...args: Array<any>): Object {
  return builder("TSOptionalType", ...args);
}
export { TSOptionalType as tsOptionalType };
export { TSOptionalType as tSOptionalType };
export function TSUnionType(...args: Array<any>): Object {
  return builder("TSUnionType", ...args);
}
export { TSUnionType as tsUnionType };
export { TSUnionType as tSUnionType };
export function TSIntersectionType(...args: Array<any>): Object {
  return builder("TSIntersectionType", ...args);
}
export { TSIntersectionType as tsIntersectionType };
export { TSIntersectionType as tSIntersectionType };
export function TSConditionalType(...args: Array<any>): Object {
  return builder("TSConditionalType", ...args);
}
export { TSConditionalType as tsConditionalType };
export { TSConditionalType as tSConditionalType };
export function TSInferType(...args: Array<any>): Object {
  return builder("TSInferType", ...args);
}
export { TSInferType as tsInferType };
export { TSInferType as tSInferType };
export function TSParenthesizedType(...args: Array<any>): Object {
  return builder("TSParenthesizedType", ...args);
}
export { TSParenthesizedType as tsParenthesizedType };
export { TSParenthesizedType as tSParenthesizedType };
export function TSTypeOperator(...args: Array<any>): Object {
  return builder("TSTypeOperator", ...args);
}
export { TSTypeOperator as tsTypeOperator };
export { TSTypeOperator as tSTypeOperator };
export function TSIndexedAccessType(...args: Array<any>): Object {
  return builder("TSIndexedAccessType", ...args);
}
export { TSIndexedAccessType as tsIndexedAccessType };
export { TSIndexedAccessType as tSIndexedAccessType };
export function TSMappedType(...args: Array<any>): Object {
  return builder("TSMappedType", ...args);
}
export { TSMappedType as tsMappedType };
export { TSMappedType as tSMappedType };
export function TSLiteralType(...args: Array<any>): Object {
  return builder("TSLiteralType", ...args);
}
export { TSLiteralType as tsLiteralType };
export { TSLiteralType as tSLiteralType };
export function TSExpressionWithTypeArguments(...args: Array<any>): Object {
  return builder("TSExpressionWithTypeArguments", ...args);
}
export { TSExpressionWithTypeArguments as tsExpressionWithTypeArguments };
export { TSExpressionWithTypeArguments as tSExpressionWithTypeArguments };
export function TSInterfaceDeclaration(...args: Array<any>): Object {
  return builder("TSInterfaceDeclaration", ...args);
}
export { TSInterfaceDeclaration as tsInterfaceDeclaration };
export { TSInterfaceDeclaration as tSInterfaceDeclaration };
export function TSInterfaceBody(...args: Array<any>): Object {
  return builder("TSInterfaceBody", ...args);
}
export { TSInterfaceBody as tsInterfaceBody };
export { TSInterfaceBody as tSInterfaceBody };
export function TSTypeAliasDeclaration(...args: Array<any>): Object {
  return builder("TSTypeAliasDeclaration", ...args);
}
export { TSTypeAliasDeclaration as tsTypeAliasDeclaration };
export { TSTypeAliasDeclaration as tSTypeAliasDeclaration };
export function TSAsExpression(...args: Array<any>): Object {
  return builder("TSAsExpression", ...args);
}
export { TSAsExpression as tsAsExpression };
export { TSAsExpression as tSAsExpression };
export function TSTypeAssertion(...args: Array<any>): Object {
  return builder("TSTypeAssertion", ...args);
}
export { TSTypeAssertion as tsTypeAssertion };
export { TSTypeAssertion as tSTypeAssertion };
export function TSEnumDeclaration(...args: Array<any>): Object {
  return builder("TSEnumDeclaration", ...args);
}
export { TSEnumDeclaration as tsEnumDeclaration };
export { TSEnumDeclaration as tSEnumDeclaration };
export function TSEnumMember(...args: Array<any>): Object {
  return builder("TSEnumMember", ...args);
}
export { TSEnumMember as tsEnumMember };
export { TSEnumMember as tSEnumMember };
export function TSModuleDeclaration(...args: Array<any>): Object {
  return builder("TSModuleDeclaration", ...args);
}
export { TSModuleDeclaration as tsModuleDeclaration };
export { TSModuleDeclaration as tSModuleDeclaration };
export function TSModuleBlock(...args: Array<any>): Object {
  return builder("TSModuleBlock", ...args);
}
export { TSModuleBlock as tsModuleBlock };
export { TSModuleBlock as tSModuleBlock };
export function TSImportEqualsDeclaration(...args: Array<any>): Object {
  return builder("TSImportEqualsDeclaration", ...args);
}
export { TSImportEqualsDeclaration as tsImportEqualsDeclaration };
export { TSImportEqualsDeclaration as tSImportEqualsDeclaration };
export function TSExternalModuleReference(...args: Array<any>): Object {
  return builder("TSExternalModuleReference", ...args);
}
export { TSExternalModuleReference as tsExternalModuleReference };
export { TSExternalModuleReference as tSExternalModuleReference };
export function TSNonNullExpression(...args: Array<any>): Object {
  return builder("TSNonNullExpression", ...args);
}
export { TSNonNullExpression as tsNonNullExpression };
export { TSNonNullExpression as tSNonNullExpression };
export function TSExportAssignment(...args: Array<any>): Object {
  return builder("TSExportAssignment", ...args);
}
export { TSExportAssignment as tsExportAssignment };
export { TSExportAssignment as tSExportAssignment };
export function TSNamespaceExportDeclaration(...args: Array<any>): Object {
  return builder("TSNamespaceExportDeclaration", ...args);
}
export { TSNamespaceExportDeclaration as tsNamespaceExportDeclaration };
export { TSNamespaceExportDeclaration as tSNamespaceExportDeclaration };
export function TSTypeAnnotation(...args: Array<any>): Object {
  return builder("TSTypeAnnotation", ...args);
}
export { TSTypeAnnotation as tsTypeAnnotation };
export { TSTypeAnnotation as tSTypeAnnotation };
export function TSTypeParameterInstantiation(...args: Array<any>): Object {
  return builder("TSTypeParameterInstantiation", ...args);
}
export { TSTypeParameterInstantiation as tsTypeParameterInstantiation };
export { TSTypeParameterInstantiation as tSTypeParameterInstantiation };
export function TSTypeParameterDeclaration(...args: Array<any>): Object {
  return builder("TSTypeParameterDeclaration", ...args);
}
export { TSTypeParameterDeclaration as tsTypeParameterDeclaration };
export { TSTypeParameterDeclaration as tSTypeParameterDeclaration };
export function TSTypeParameter(...args: Array<any>): Object {
  return builder("TSTypeParameter", ...args);
}
export { TSTypeParameter as tsTypeParameter };
export { TSTypeParameter as tSTypeParameter };
export function NumberLiteral(...args: Array<any>): Object {
  console.trace(
    "The node type NumberLiteral has been renamed to NumericLiteral",
  );
  return NumberLiteral("NumberLiteral", ...args);
}
export { NumberLiteral as numberLiteral };
export function RegexLiteral(...args: Array<any>): Object {
  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
  return RegexLiteral("RegexLiteral", ...args);
}
export { RegexLiteral as regexLiteral };
export function RestProperty(...args: Array<any>): Object {
  console.trace("The node type RestProperty has been renamed to RestElement");
  return RestProperty("RestProperty", ...args);
}
export { RestProperty as restProperty };
export function SpreadProperty(...args: Array<any>): Object {
  console.trace(
    "The node type SpreadProperty has been renamed to SpreadElement",
  );
  return SpreadProperty("SpreadProperty", ...args);
}
export { SpreadProperty as spreadProperty };

// </from> /home/qfox/apps/babel/packages/babel-types/src/builders/generated/index.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/builders/builder.js

// @flow
import loClone from "lodash/clone";
import { NODE_FIELDS, BUILDER_KEYS } from "../definitions";
import validate from "../validators/validate";
export default function builder(type: string, ...args: Array<any>): Object {
  const keys = BUILDER_KEYS[type];
  const countArgs = args.length;
  if (countArgs > keys.length) {
    throw new Error(
      `${type}: Too many arguments passed. Received ${countArgs} but can receive no more than ${
        keys.length
      }`,
    );
  }
  const node = { type };
  let i = 0;
  keys.forEach(key => {
    const field = NODE_FIELDS[type][key];
    let arg;
    if (i < countArgs) arg = args[i];
    if (arg === undefined) arg = loClone(field.default);
    node[key] = arg;
    i++;
  });
  for (const key in node) {
    validate(node, key, node[key]);
  }
  return node;
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/builders/builder.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/builders/react/buildChildren.js

// @flow
import {
  isJSXText,
  isJSXExpressionContainer,
  isJSXEmptyExpression,
} from "../../validators/generated";
import cleanJSXElementLiteralChild from "../../utils/react/cleanJSXElementLiteralChild";
export default function buildChildren(node: Object): Array<Object> {
  const elements = [];
  for (let i = 0; i < node.children.length; i++) {
    let child = node.children[i];
    if (isJSXText(child)) {
      cleanJSXElementLiteralChild(child, elements);
      continue;
    }
    if (isJSXExpressionContainer(child)) child = child.expression;
    if (isJSXEmptyExpression(child)) continue;
    elements.push(child);
  }
  return elements;
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/builders/react/buildChildren.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/modifications/removeProperties.js

// @flow
import { COMMENT_KEYS } from "../constants";
const CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];
const CLEAR_KEYS_PLUS_COMMENTS = COMMENT_KEYS.concat(["comments"]).concat(
  CLEAR_KEYS,
);
/**
 * Remove all of the _* properties from a node along with the additional metadata
 * properties like location data and raw token data.
 */
export default function removeProperties(
  node: Object,
  opts?: Object = {},
): void {
  const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
  for (const key of map) {
    if (node[key] != null) node[key] = undefined;
  }
  for (const key in node) {
    if (key[0] === "_" && node[key] != null) node[key] = undefined;
  }
  const symbols: Array<Symbol> = Object.getOwnPropertySymbols(node);
  for (const sym of symbols) {
    node[sym] = null;
  }
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/modifications/removeProperties.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/modifications/inherits.js

// @flow
import { INHERIT_KEYS } from "../constants";
import inheritsComments from "../comments/inheritsComments";
/**
 * Inherit all contextual properties from `parent` node to `child` node.
 */
export default function inherits<T: Object>(child: T, parent: Object): T {
  if (!child || !parent) return child;
  // optionally inherit specific properties if not null
  for (const key of (INHERIT_KEYS.optional: Array<string>)) {
    if (child[key] == null) {
      child[key] = parent[key];
    }
  }
  // force inherit "private" properties
  for (const key in parent) {
    if (key[0] === "_" && key !== "__clone") child[key] = parent[key];
  }
  // force inherit select properties
  for (const key of (INHERIT_KEYS.force: Array<string>)) {
    child[key] = parent[key];
  }
  inheritsComments(child, parent);
  return child;
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/modifications/inherits.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/modifications/removePropertiesDeep.js

// @flow
import traverseFast from "../traverse/traverseFast";
import removeProperties from "./removeProperties";
export default function removePropertiesDeep<T: Object>(
  tree: T,
  opts?: Object,
): T {
  traverseFast(tree, removeProperties, opts);
  return tree;
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/modifications/removePropertiesDeep.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/modifications/prependToMemberExpression.js

// @flow
import { memberExpression } from "../builders/generated";
/**
 * Prepend a node to a member expression.
 */
export default function prependToMemberExpression<T: Object>(
  member: T,
  prepend: Object,
): T {
  member.object = memberExpression(prepend, member.object);
  return member;
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/modifications/prependToMemberExpression.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/modifications/flow/removeTypeDuplicates.js

// @flow
import {
  isAnyTypeAnnotation,
  isGenericTypeAnnotation,
  isUnionTypeAnnotation,
  isFlowBaseAnnotation,
} from "../../validators/generated";
/**
 * Dedupe type annotations.
 */
export default function removeTypeDuplicates(
  nodes: Array<Object>,
): Array<Object> {
  const generics = {};
  const bases = {};
  // store union type groups to circular references
  const typeGroups = [];
  const types = [];
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (!node) continue;
    // detect duplicates
    if (types.indexOf(node) >= 0) {
      continue;
    }
    // this type matches anything
    if (isAnyTypeAnnotation(node)) {
      return [node];
    }
    if (isFlowBaseAnnotation(node)) {
      bases[node.type] = node;
      continue;
    }
    if (isUnionTypeAnnotation(node)) {
      if (typeGroups.indexOf(node.types) < 0) {
        nodes = nodes.concat(node.types);
        typeGroups.push(node.types);
      }
      continue;
    }
    // find a matching generic type and merge and deduplicate the type parameters
    if (isGenericTypeAnnotation(node)) {
      const name = node.id.name;
      if (generics[name]) {
        let existing = generics[name];
        if (existing.typeParameters) {
          if (node.typeParameters) {
            existing.typeParameters.params = removeTypeDuplicates(
              existing.typeParameters.params.concat(node.typeParameters.params),
            );
          }
        } else {
          existing = node.typeParameters;
        }
      } else {
        generics[name] = node;
      }
      continue;
    }
    types.push(node);
  }
  // add back in bases
  for (const type in bases) {
    types.push(bases[type]);
  }
  // add back in generics
  for (const name in generics) {
    types.push(generics[name]);
  }
  return types;
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/modifications/flow/removeTypeDuplicates.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/modifications/appendToMemberExpression.js

// @flow
import { memberExpression } from "../builders/generated";
/**
 * Append a node to a member expression.
 */
export default function appendToMemberExpression<T: Object>(
  member: T,
  append: Object,
  computed?: boolean = false,
): T {
  member.object = memberExpression(
    member.object,
    member.property,
    member.computed,
  );
  member.property = append;
  member.computed = !!computed;
  return member;
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/modifications/appendToMemberExpression.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/index.js

// @flow
import isReactComponent from "./validators/react/isReactComponent";
import isCompatTag from "./validators/react/isCompatTag";
import buildChildren from "./builders/react/buildChildren";
// asserts
export { default as assertNode } from "./asserts/assertNode";
export * from "./asserts/generated";
//builders
export {
  default as createTypeAnnotationBasedOnTypeof,
} from "./builders/flow/createTypeAnnotationBasedOnTypeof";
export {
  default as createUnionTypeAnnotation,
} from "./builders/flow/createUnionTypeAnnotation";
export * from "./builders/generated";
// clone
export { default as cloneNode } from "./clone/cloneNode";
export { default as clone } from "./clone/clone";
export { default as cloneDeep } from "./clone/cloneDeep";
export { default as cloneWithoutLoc } from "./clone/cloneWithoutLoc";
// comments
export { default as addComment } from "./comments/addComment";
export { default as addComments } from "./comments/addComments";
export {
  default as inheritInnerComments,
} from "./comments/inheritInnerComments";
export {
  default as inheritLeadingComments,
} from "./comments/inheritLeadingComments";
export { default as inheritsComments } from "./comments/inheritsComments";
export {
  default as inheritTrailingComments,
} from "./comments/inheritTrailingComments";
export { default as removeComments } from "./comments/removeComments";
// constants
export * from "./constants/generated";
export * from "./constants";
// converters
export { default as ensureBlock } from "./converters/ensureBlock";
export {
  default as toBindingIdentifierName,
} from "./converters/toBindingIdentifierName";
export { default as toBlock } from "./converters/toBlock";
export { default as toComputedKey } from "./converters/toComputedKey";
export { default as toExpression } from "./converters/toExpression";
export { default as toIdentifier } from "./converters/toIdentifier";
export { default as toKeyAlias } from "./converters/toKeyAlias";
export {
  default as toSequenceExpression,
} from "./converters/toSequenceExpression";
export { default as toStatement } from "./converters/toStatement";
export { default as valueToNode } from "./converters/valueToNode";
// definitions
export * from "./definitions";
// modifications
export {
  default as appendToMemberExpression,
} from "./modifications/appendToMemberExpression";
export { default as inherits } from "./modifications/inherits";
export {
  default as prependToMemberExpression,
} from "./modifications/prependToMemberExpression";
export { default as removeProperties } from "./modifications/removeProperties";
export {
  default as removePropertiesDeep,
} from "./modifications/removePropertiesDeep";
export {
  default as removeTypeDuplicates,
} from "./modifications/flow/removeTypeDuplicates";
// retrievers
export {
  default as getBindingIdentifiers,
} from "./retrievers/getBindingIdentifiers";
export {
  default as getOuterBindingIdentifiers,
} from "./retrievers/getOuterBindingIdentifiers";
// traverse
export { default as traverse } from "./traverse/traverse";
export type * from "./traverse/traverse";
export { default as traverseFast } from "./traverse/traverseFast";
// utils
export { default as shallowEqual } from "./utils/shallowEqual";
// validators
export { default as is } from "./validators/is";
export { default as isBinding } from "./validators/isBinding";
export { default as isBlockScoped } from "./validators/isBlockScoped";
export { default as isImmutable } from "./validators/isImmutable";
export { default as isLet } from "./validators/isLet";
export { default as isNode } from "./validators/isNode";
export { default as isNodesEquivalent } from "./validators/isNodesEquivalent";
export { default as isReferenced } from "./validators/isReferenced";
export { default as isScope } from "./validators/isScope";
export { default as isSpecifierDefault } from "./validators/isSpecifierDefault";
export { default as isType } from "./validators/isType";
export {
  default as isValidES3Identifier,
} from "./validators/isValidES3Identifier";
export { default as isValidIdentifier } from "./validators/isValidIdentifier";
export { default as isVar } from "./validators/isVar";
export { default as matchesPattern } from "./validators/matchesPattern";
export { default as validate } from "./validators/validate";
export {
  default as buildMatchMemberExpression,
} from "./validators/buildMatchMemberExpression";
export * from "./validators/generated";
// react
export const react = {
  isReactComponent,
  isCompatTag,
  buildChildren,
};

// </from> /home/qfox/apps/babel/packages/babel-types/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/validators/isReferenced.js

// @flow
/**
 * Check if the input `node` is a reference to a bound variable.
 */
export default function isReferenced(node: Object, parent: Object): boolean {
  switch (parent.type) {
    // yes: PARENT[NODE]
    // yes: NODE.child
    // no: parent.NODE
    case "MemberExpression":
    case "JSXMemberExpression":
    case "OptionalMemberExpression":
      if (parent.property === node) {
        return !!parent.computed;
      }
      return parent.object === node;
    // no: let NODE = init;
    // yes: let id = NODE;
    case "VariableDeclarator":
      return parent.init === node;
    // yes: () => NODE
    // no: (NODE) => {}
    case "ArrowFunctionExpression":
      return parent.body === node;
    // no: export { foo as NODE };
    // yes: export { NODE as foo };
    // no: export { NODE as foo } from "foo";
    case "ExportSpecifier":
      if (parent.source) {
        return false;
      }
      return parent.local === node;
    // yes: { [NODE]: "" }
    // no: { NODE: "" }
    // depends: { NODE }
    case "ObjectProperty":
    // no: class { NODE = value; }
    // yes: class { [NODE] = value; }
    // yes: class { key = NODE; }
    case "ClassProperty":
    case "ClassPrivateProperty":
    // no: class { NODE() {} }
    // yes: class { [NODE]() {} }
    case "ClassMethod":
    case "ObjectMethod":
      if (parent.key === node) {
        return !!parent.computed;
      }
      return parent.value === node;
    // no: class NODE {}
    // yes: class Foo extends NODE {}
    case "ClassDeclaration":
    case "ClassExpression":
      return parent.superClass === node;
    // yes: left = NODE;
    // no: NODE = right;
    case "AssignmentExpression":
      return parent.right === node;
    // no: [NODE = foo] = [];
    // yes: [foo = NODE] = [];
    case "AssignmentPattern":
      return parent.right === node;
    // no: NODE: for (;;) {}
    case "LabeledStatement":
      return false;
    // no: try {} catch (NODE) {}
    case "CatchClause":
      return false;
    // no: function foo(...NODE) {}
    case "RestElement":
      return false;
    case "BreakStatement":
    case "ContinueStatement":
      return false;
    // no: function NODE() {}
    // no: function foo(NODE) {}
    case "FunctionDeclaration":
    case "FunctionExpression":
      return false;
    // no: export NODE from "foo";
    // no: export * as NODE from "foo";
    case "ExportNamespaceSpecifier":
    case "ExportDefaultSpecifier":
      return false;
    // no: import NODE from "foo";
    // no: import * as NODE from "foo";
    // no: import { NODE as foo } from "foo";
    // no: import { foo as NODE } from "foo";
    // no: import NODE from "bar";
    case "ImportDefaultSpecifier":
    case "ImportNamespaceSpecifier":
    case "ImportSpecifier":
      return false;
    // no: <div NODE="foo" />
    case "JSXAttribute":
      return false;
    // no: [NODE] = [];
    // no: ({ NODE }) = [];
    case "ObjectPattern":
    case "ArrayPattern":
      return false;
    // no: new.NODE
    // no: NODE.target
    case "MetaProperty":
      return false;
    // yes: type X = { somePropert: NODE }
    // no: type X = { NODE: OtherType }
    case "ObjectTypeProperty":
      return parent.key !== node;
  }
  return true;
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/validators/isReferenced.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/validators/isValidES3Identifier.js

// @flow
import isValidIdentifier from "./isValidIdentifier";
const RESERVED_WORDS_ES3_ONLY: Set<string> = new Set([
  "abstract",
  "boolean",
  "byte",
  "char",
  "double",
  "enum",
  "final",
  "float",
  "goto",
  "implements",
  "int",
  "interface",
  "long",
  "native",
  "package",
  "private",
  "protected",
  "public",
  "short",
  "static",
  "synchronized",
  "throws",
  "transient",
  "volatile",
]);
/**
 * Check if the input `name` is a valid identifier name according to the ES3 specification.
 *
 * Additional ES3 reserved words are
 */
export default function isValidES3Identifier(name: string): boolean {
  return isValidIdentifier(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/validators/isValidES3Identifier.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/validators/isScope.js

// @flow
import {
  isFunction,
  isCatchClause,
  isBlockStatement,
  isScopable,
} from "./generated";
/**
 * Check if the input `node` is a scope.
 */
export default function isScope(node: Object, parent: Object): boolean {
  if (isBlockStatement(node) && isFunction(parent, { body: node })) {
    return false;
  }
  if (isBlockStatement(node) && isCatchClause(parent, { body: node })) {
    return false;
  }
  return isScopable(node);
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/validators/isScope.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/validators/validate.js

// @flow
import { NODE_FIELDS } from "../definitions";
export default function validate(node?: Object, key: string, val: any): void {
  if (!node) return;
  const fields = NODE_FIELDS[node.type];
  if (!fields) return;
  const field = fields[key];
  if (!field || !field.validate) return;
  if (field.optional && val == null) return;
  field.validate(node, key, val);
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/validators/validate.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/validators/isType.js

// @flow
import { FLIPPED_ALIAS_KEYS, ALIAS_KEYS } from "../definitions";
/**
 * Test if a `nodeType` is a `targetType` or if `targetType` is an alias of `nodeType`.
 */
export default function isType(nodeType: string, targetType: string): boolean {
  if (nodeType === targetType) return true;
  // This is a fast-path. If the test above failed, but an alias key is found, then the
  // targetType was a primary node type, so there's no need to check the aliases.
  if (ALIAS_KEYS[targetType]) return false;
  const aliases: ?Array<string> = FLIPPED_ALIAS_KEYS[targetType];
  if (aliases) {
    if (aliases[0] === nodeType) return true;
    for (const alias of aliases) {
      if (nodeType === alias) return true;
    }
  }
  return false;
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/validators/isType.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/validators/matchesPattern.js

import { isIdentifier, isMemberExpression, isStringLiteral } from "./generated";
/**
 * Determines whether or not the input node `member` matches the
 * input `match`.
 *
 * For example, given the match `React.createClass` it would match the
 * parsed nodes of `React.createClass` and `React["createClass"]`.
 */
export default function matchesPattern(
  member: Object,
  match: string | Array<string>,
  allowPartial?: boolean,
): boolean {
  // not a member expression
  if (!isMemberExpression(member)) return false;
  const parts = Array.isArray(match) ? match : match.split(".");
  const nodes = [];
  let node;
  for (node = member; isMemberExpression(node); node = node.object) {
    nodes.push(node.property);
  }
  nodes.push(node);
  if (nodes.length < parts.length) return false;
  if (!allowPartial && nodes.length > parts.length) return false;
  for (let i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
    const node = nodes[j];
    let value;
    if (isIdentifier(node)) {
      value = node.name;
    } else if (isStringLiteral(node)) {
      value = node.value;
    } else {
      return false;
    }
    if (parts[i] !== value) return false;
  }
  return true;
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/validators/matchesPattern.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/validators/isVar.js

// @flow
import { isVariableDeclaration } from "./generated";
import { BLOCK_SCOPED_SYMBOL } from "../constants";
/**
 * Check if the input `node` is a variable declaration.
 */
export default function isVar(node: Object): boolean {
  return (
    isVariableDeclaration(node, { kind: "var" }) && !node[BLOCK_SCOPED_SYMBOL]
  );
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/validators/isVar.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/validators/isBlockScoped.js

// @flow
import { isClassDeclaration, isFunctionDeclaration } from "./generated";
import isLet from "./isLet";
/**
 * Check if the input `node` is block scoped.
 */
export default function isBlockScoped(node: Object): boolean {
  return isFunctionDeclaration(node) || isClassDeclaration(node) || isLet(node);
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/validators/isBlockScoped.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/validators/isBinding.js

// @flow
import getBindingIdentifiers from "../retrievers/getBindingIdentifiers";
/**
 * Check if the input `node` is a binding identifier.
 */
export default function isBinding(node: Object, parent: Object): boolean {
  const keys = getBindingIdentifiers.keys[parent.type];
  if (keys) {
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const val = parent[key];
      if (Array.isArray(val)) {
        if (val.indexOf(node) >= 0) return true;
      } else {
        if (val === node) return true;
      }
    }
  }
  return false;
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/validators/isBinding.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/validators/isLet.js

// @flow
import { isVariableDeclaration } from "./generated";
import { BLOCK_SCOPED_SYMBOL } from "../constants";
/**
 * Check if the input `node` is a `let` variable declaration.
 */
export default function isLet(node: Object): boolean {
  return (
    isVariableDeclaration(node) &&
    (node.kind !== "var" || node[BLOCK_SCOPED_SYMBOL])
  );
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/validators/isLet.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/validators/generated/index.js

// @flow
/*
 * This file is auto-generated! Do not modify it directly.
 * To re-generate run 'make build'
 */
import shallowEqual from "../../utils/shallowEqual";
export function isArrayExpression(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ArrayExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isAssignmentExpression(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "AssignmentExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isBinaryExpression(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "BinaryExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isInterpreterDirective(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "InterpreterDirective") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isDirective(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "Directive") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isDirectiveLiteral(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DirectiveLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isBlockStatement(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "BlockStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isBreakStatement(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "BreakStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isCallExpression(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "CallExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isCatchClause(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "CatchClause") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isConditionalExpression(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ConditionalExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isContinueStatement(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ContinueStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isDebuggerStatement(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DebuggerStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isDoWhileStatement(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DoWhileStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isEmptyStatement(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "EmptyStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isExpressionStatement(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ExpressionStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isFile(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "File") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isForInStatement(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ForInStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isForStatement(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ForStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isFunctionDeclaration(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "FunctionDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isFunctionExpression(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "FunctionExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isIdentifier(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "Identifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isIfStatement(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "IfStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isLabeledStatement(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "LabeledStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isStringLiteral(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "StringLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isNumericLiteral(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "NumericLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isNullLiteral(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "NullLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isBooleanLiteral(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "BooleanLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isRegExpLiteral(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "RegExpLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isLogicalExpression(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "LogicalExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isMemberExpression(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "MemberExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isNewExpression(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "NewExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isProgram(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "Program") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isObjectExpression(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ObjectExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isObjectMethod(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ObjectMethod") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isObjectProperty(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ObjectProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isRestElement(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "RestElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isReturnStatement(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ReturnStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isSequenceExpression(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "SequenceExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isSwitchCase(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "SwitchCase") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isSwitchStatement(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "SwitchStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isThisExpression(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ThisExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isThrowStatement(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ThrowStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTryStatement(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TryStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isUnaryExpression(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "UnaryExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isUpdateExpression(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "UpdateExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isVariableDeclaration(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "VariableDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isVariableDeclarator(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "VariableDeclarator") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isWhileStatement(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "WhileStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isWithStatement(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "WithStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isAssignmentPattern(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "AssignmentPattern") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isArrayPattern(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ArrayPattern") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isArrowFunctionExpression(
  node: Object,
  opts?: Object,
): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ArrowFunctionExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isClassBody(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ClassBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isClassDeclaration(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ClassDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isClassExpression(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ClassExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isExportAllDeclaration(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ExportAllDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isExportDefaultDeclaration(
  node: Object,
  opts?: Object,
): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ExportDefaultDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isExportNamedDeclaration(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ExportNamedDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isExportSpecifier(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ExportSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isForOfStatement(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ForOfStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isImportDeclaration(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ImportDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isImportDefaultSpecifier(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ImportDefaultSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isImportNamespaceSpecifier(
  node: Object,
  opts?: Object,
): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ImportNamespaceSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isImportSpecifier(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ImportSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isMetaProperty(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "MetaProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isClassMethod(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ClassMethod") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isObjectPattern(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ObjectPattern") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isSpreadElement(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "SpreadElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isSuper(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "Super") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTaggedTemplateExpression(
  node: Object,
  opts?: Object,
): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TaggedTemplateExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTemplateElement(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TemplateElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTemplateLiteral(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TemplateLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isYieldExpression(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "YieldExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isAnyTypeAnnotation(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "AnyTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isArrayTypeAnnotation(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ArrayTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isBooleanTypeAnnotation(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "BooleanTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isBooleanLiteralTypeAnnotation(
  node: Object,
  opts?: Object,
): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "BooleanLiteralTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isNullLiteralTypeAnnotation(
  node: Object,
  opts?: Object,
): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "NullLiteralTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isClassImplements(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ClassImplements") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isDeclareClass(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DeclareClass") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isDeclareFunction(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DeclareFunction") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isDeclareInterface(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DeclareInterface") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isDeclareModule(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DeclareModule") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isDeclareModuleExports(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DeclareModuleExports") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isDeclareTypeAlias(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DeclareTypeAlias") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isDeclareOpaqueType(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DeclareOpaqueType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isDeclareVariable(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DeclareVariable") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isDeclareExportDeclaration(
  node: Object,
  opts?: Object,
): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DeclareExportDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isDeclareExportAllDeclaration(
  node: Object,
  opts?: Object,
): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DeclareExportAllDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isDeclaredPredicate(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DeclaredPredicate") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isExistsTypeAnnotation(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ExistsTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isFunctionTypeAnnotation(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "FunctionTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isFunctionTypeParam(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "FunctionTypeParam") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isGenericTypeAnnotation(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "GenericTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isInferredPredicate(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "InferredPredicate") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isInterfaceExtends(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "InterfaceExtends") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isInterfaceDeclaration(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "InterfaceDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isInterfaceTypeAnnotation(
  node: Object,
  opts?: Object,
): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "InterfaceTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isIntersectionTypeAnnotation(
  node: Object,
  opts?: Object,
): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "IntersectionTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isMixedTypeAnnotation(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "MixedTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isEmptyTypeAnnotation(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "EmptyTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isNullableTypeAnnotation(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "NullableTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isNumberLiteralTypeAnnotation(
  node: Object,
  opts?: Object,
): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "NumberLiteralTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isNumberTypeAnnotation(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "NumberTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isObjectTypeAnnotation(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ObjectTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isObjectTypeInternalSlot(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ObjectTypeInternalSlot") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isObjectTypeCallProperty(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ObjectTypeCallProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isObjectTypeIndexer(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ObjectTypeIndexer") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isObjectTypeProperty(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ObjectTypeProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isObjectTypeSpreadProperty(
  node: Object,
  opts?: Object,
): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ObjectTypeSpreadProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isOpaqueType(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "OpaqueType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isQualifiedTypeIdentifier(
  node: Object,
  opts?: Object,
): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "QualifiedTypeIdentifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isStringLiteralTypeAnnotation(
  node: Object,
  opts?: Object,
): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "StringLiteralTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isStringTypeAnnotation(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "StringTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isThisTypeAnnotation(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ThisTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTupleTypeAnnotation(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TupleTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTypeofTypeAnnotation(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TypeofTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTypeAlias(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TypeAlias") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTypeAnnotation(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTypeCastExpression(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TypeCastExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTypeParameter(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TypeParameter") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTypeParameterDeclaration(
  node: Object,
  opts?: Object,
): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TypeParameterDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTypeParameterInstantiation(
  node: Object,
  opts?: Object,
): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TypeParameterInstantiation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isUnionTypeAnnotation(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "UnionTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isVariance(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "Variance") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isVoidTypeAnnotation(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "VoidTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isJSXAttribute(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXAttribute") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isJSXClosingElement(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXClosingElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isJSXElement(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isJSXEmptyExpression(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXEmptyExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isJSXExpressionContainer(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXExpressionContainer") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isJSXSpreadChild(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXSpreadChild") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isJSXIdentifier(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXIdentifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isJSXMemberExpression(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXMemberExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isJSXNamespacedName(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXNamespacedName") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isJSXOpeningElement(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXOpeningElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isJSXSpreadAttribute(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXSpreadAttribute") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isJSXText(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXText") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isJSXFragment(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXFragment") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isJSXOpeningFragment(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXOpeningFragment") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isJSXClosingFragment(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXClosingFragment") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isNoop(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "Noop") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isParenthesizedExpression(
  node: Object,
  opts?: Object,
): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ParenthesizedExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isAwaitExpression(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "AwaitExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isBindExpression(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "BindExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isClassProperty(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ClassProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isOptionalMemberExpression(
  node: Object,
  opts?: Object,
): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "OptionalMemberExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isOptionalCallExpression(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "OptionalCallExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isClassPrivateProperty(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ClassPrivateProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isImport(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "Import") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isDecorator(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "Decorator") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isDoExpression(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DoExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isExportDefaultSpecifier(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ExportDefaultSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isExportNamespaceSpecifier(
  node: Object,
  opts?: Object,
): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ExportNamespaceSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isPrivateName(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "PrivateName") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isBigIntLiteral(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "BigIntLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSParameterProperty(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSParameterProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSDeclareFunction(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSDeclareFunction") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSDeclareMethod(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSDeclareMethod") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSQualifiedName(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSQualifiedName") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSCallSignatureDeclaration(
  node: Object,
  opts?: Object,
): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSCallSignatureDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSConstructSignatureDeclaration(
  node: Object,
  opts?: Object,
): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSConstructSignatureDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSPropertySignature(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSPropertySignature") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSMethodSignature(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSMethodSignature") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSIndexSignature(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSIndexSignature") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSAnyKeyword(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSAnyKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSUnknownKeyword(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSUnknownKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSNumberKeyword(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSNumberKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSObjectKeyword(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSObjectKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSBooleanKeyword(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSBooleanKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSStringKeyword(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSStringKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSSymbolKeyword(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSSymbolKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSVoidKeyword(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSVoidKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSUndefinedKeyword(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSUndefinedKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSNullKeyword(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSNullKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSNeverKeyword(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSNeverKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSThisType(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSThisType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSFunctionType(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSFunctionType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSConstructorType(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSConstructorType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSTypeReference(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSTypeReference") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSTypePredicate(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSTypePredicate") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSTypeQuery(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSTypeQuery") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSTypeLiteral(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSTypeLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSArrayType(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSArrayType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSTupleType(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSTupleType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSOptionalType(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSOptionalType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSUnionType(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSUnionType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSIntersectionType(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSIntersectionType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSConditionalType(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSConditionalType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSInferType(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSInferType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSParenthesizedType(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSParenthesizedType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSTypeOperator(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSTypeOperator") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSIndexedAccessType(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSIndexedAccessType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSMappedType(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSMappedType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSLiteralType(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSLiteralType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSExpressionWithTypeArguments(
  node: Object,
  opts?: Object,
): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSExpressionWithTypeArguments") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSInterfaceDeclaration(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSInterfaceDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSInterfaceBody(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSInterfaceBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSTypeAliasDeclaration(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSTypeAliasDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSAsExpression(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSAsExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSTypeAssertion(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSTypeAssertion") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSEnumDeclaration(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSEnumDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSEnumMember(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSEnumMember") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSModuleDeclaration(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSModuleDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSModuleBlock(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSModuleBlock") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSImportEqualsDeclaration(
  node: Object,
  opts?: Object,
): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSImportEqualsDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSExternalModuleReference(
  node: Object,
  opts?: Object,
): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSExternalModuleReference") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSNonNullExpression(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSNonNullExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSExportAssignment(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSExportAssignment") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSNamespaceExportDeclaration(
  node: Object,
  opts?: Object,
): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSNamespaceExportDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSTypeAnnotation(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSTypeParameterInstantiation(
  node: Object,
  opts?: Object,
): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSTypeParameterInstantiation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSTypeParameterDeclaration(
  node: Object,
  opts?: Object,
): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSTypeParameterDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSTypeParameter(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSTypeParameter") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isExpression(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "Expression" ||
    "ArrayExpression" === nodeType ||
    "AssignmentExpression" === nodeType ||
    "BinaryExpression" === nodeType ||
    "CallExpression" === nodeType ||
    "ConditionalExpression" === nodeType ||
    "FunctionExpression" === nodeType ||
    "Identifier" === nodeType ||
    "StringLiteral" === nodeType ||
    "NumericLiteral" === nodeType ||
    "NullLiteral" === nodeType ||
    "BooleanLiteral" === nodeType ||
    "RegExpLiteral" === nodeType ||
    "LogicalExpression" === nodeType ||
    "MemberExpression" === nodeType ||
    "NewExpression" === nodeType ||
    "ObjectExpression" === nodeType ||
    "SequenceExpression" === nodeType ||
    "ThisExpression" === nodeType ||
    "UnaryExpression" === nodeType ||
    "UpdateExpression" === nodeType ||
    "ArrowFunctionExpression" === nodeType ||
    "ClassExpression" === nodeType ||
    "MetaProperty" === nodeType ||
    "Super" === nodeType ||
    "TaggedTemplateExpression" === nodeType ||
    "TemplateLiteral" === nodeType ||
    "YieldExpression" === nodeType ||
    "TypeCastExpression" === nodeType ||
    "JSXElement" === nodeType ||
    "JSXFragment" === nodeType ||
    "ParenthesizedExpression" === nodeType ||
    "AwaitExpression" === nodeType ||
    "BindExpression" === nodeType ||
    "OptionalMemberExpression" === nodeType ||
    "OptionalCallExpression" === nodeType ||
    "Import" === nodeType ||
    "DoExpression" === nodeType ||
    "BigIntLiteral" === nodeType ||
    "TSAsExpression" === nodeType ||
    "TSTypeAssertion" === nodeType ||
    "TSNonNullExpression" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isBinary(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "Binary" ||
    "BinaryExpression" === nodeType ||
    "LogicalExpression" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isScopable(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "Scopable" ||
    "BlockStatement" === nodeType ||
    "CatchClause" === nodeType ||
    "DoWhileStatement" === nodeType ||
    "ForInStatement" === nodeType ||
    "ForStatement" === nodeType ||
    "FunctionDeclaration" === nodeType ||
    "FunctionExpression" === nodeType ||
    "Program" === nodeType ||
    "ObjectMethod" === nodeType ||
    "SwitchStatement" === nodeType ||
    "WhileStatement" === nodeType ||
    "ArrowFunctionExpression" === nodeType ||
    "ClassDeclaration" === nodeType ||
    "ClassExpression" === nodeType ||
    "ForOfStatement" === nodeType ||
    "ClassMethod" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isBlockParent(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "BlockParent" ||
    "BlockStatement" === nodeType ||
    "CatchClause" === nodeType ||
    "DoWhileStatement" === nodeType ||
    "ForInStatement" === nodeType ||
    "ForStatement" === nodeType ||
    "FunctionDeclaration" === nodeType ||
    "FunctionExpression" === nodeType ||
    "Program" === nodeType ||
    "ObjectMethod" === nodeType ||
    "SwitchStatement" === nodeType ||
    "WhileStatement" === nodeType ||
    "ArrowFunctionExpression" === nodeType ||
    "ForOfStatement" === nodeType ||
    "ClassMethod" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isBlock(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "Block" ||
    "BlockStatement" === nodeType ||
    "Program" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isStatement(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "Statement" ||
    "BlockStatement" === nodeType ||
    "BreakStatement" === nodeType ||
    "ContinueStatement" === nodeType ||
    "DebuggerStatement" === nodeType ||
    "DoWhileStatement" === nodeType ||
    "EmptyStatement" === nodeType ||
    "ExpressionStatement" === nodeType ||
    "ForInStatement" === nodeType ||
    "ForStatement" === nodeType ||
    "FunctionDeclaration" === nodeType ||
    "IfStatement" === nodeType ||
    "LabeledStatement" === nodeType ||
    "ReturnStatement" === nodeType ||
    "SwitchStatement" === nodeType ||
    "ThrowStatement" === nodeType ||
    "TryStatement" === nodeType ||
    "VariableDeclaration" === nodeType ||
    "WhileStatement" === nodeType ||
    "WithStatement" === nodeType ||
    "ClassDeclaration" === nodeType ||
    "ExportAllDeclaration" === nodeType ||
    "ExportDefaultDeclaration" === nodeType ||
    "ExportNamedDeclaration" === nodeType ||
    "ForOfStatement" === nodeType ||
    "ImportDeclaration" === nodeType ||
    "DeclareClass" === nodeType ||
    "DeclareFunction" === nodeType ||
    "DeclareInterface" === nodeType ||
    "DeclareModule" === nodeType ||
    "DeclareModuleExports" === nodeType ||
    "DeclareTypeAlias" === nodeType ||
    "DeclareOpaqueType" === nodeType ||
    "DeclareVariable" === nodeType ||
    "DeclareExportDeclaration" === nodeType ||
    "DeclareExportAllDeclaration" === nodeType ||
    "InterfaceDeclaration" === nodeType ||
    "OpaqueType" === nodeType ||
    "TypeAlias" === nodeType ||
    "TSDeclareFunction" === nodeType ||
    "TSInterfaceDeclaration" === nodeType ||
    "TSTypeAliasDeclaration" === nodeType ||
    "TSEnumDeclaration" === nodeType ||
    "TSModuleDeclaration" === nodeType ||
    "TSImportEqualsDeclaration" === nodeType ||
    "TSExportAssignment" === nodeType ||
    "TSNamespaceExportDeclaration" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTerminatorless(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "Terminatorless" ||
    "BreakStatement" === nodeType ||
    "ContinueStatement" === nodeType ||
    "ReturnStatement" === nodeType ||
    "ThrowStatement" === nodeType ||
    "YieldExpression" === nodeType ||
    "AwaitExpression" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isCompletionStatement(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "CompletionStatement" ||
    "BreakStatement" === nodeType ||
    "ContinueStatement" === nodeType ||
    "ReturnStatement" === nodeType ||
    "ThrowStatement" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isConditional(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "Conditional" ||
    "ConditionalExpression" === nodeType ||
    "IfStatement" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isLoop(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "Loop" ||
    "DoWhileStatement" === nodeType ||
    "ForInStatement" === nodeType ||
    "ForStatement" === nodeType ||
    "WhileStatement" === nodeType ||
    "ForOfStatement" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isWhile(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "While" ||
    "DoWhileStatement" === nodeType ||
    "WhileStatement" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isExpressionWrapper(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "ExpressionWrapper" ||
    "ExpressionStatement" === nodeType ||
    "TypeCastExpression" === nodeType ||
    "ParenthesizedExpression" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isFor(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "For" ||
    "ForInStatement" === nodeType ||
    "ForStatement" === nodeType ||
    "ForOfStatement" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isForXStatement(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "ForXStatement" ||
    "ForInStatement" === nodeType ||
    "ForOfStatement" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isFunction(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "Function" ||
    "FunctionDeclaration" === nodeType ||
    "FunctionExpression" === nodeType ||
    "ObjectMethod" === nodeType ||
    "ArrowFunctionExpression" === nodeType ||
    "ClassMethod" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isFunctionParent(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "FunctionParent" ||
    "FunctionDeclaration" === nodeType ||
    "FunctionExpression" === nodeType ||
    "ObjectMethod" === nodeType ||
    "ArrowFunctionExpression" === nodeType ||
    "ClassMethod" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isPureish(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "Pureish" ||
    "FunctionDeclaration" === nodeType ||
    "FunctionExpression" === nodeType ||
    "StringLiteral" === nodeType ||
    "NumericLiteral" === nodeType ||
    "NullLiteral" === nodeType ||
    "BooleanLiteral" === nodeType ||
    "ArrowFunctionExpression" === nodeType ||
    "ClassDeclaration" === nodeType ||
    "ClassExpression" === nodeType ||
    "BigIntLiteral" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isDeclaration(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "Declaration" ||
    "FunctionDeclaration" === nodeType ||
    "VariableDeclaration" === nodeType ||
    "ClassDeclaration" === nodeType ||
    "ExportAllDeclaration" === nodeType ||
    "ExportDefaultDeclaration" === nodeType ||
    "ExportNamedDeclaration" === nodeType ||
    "ImportDeclaration" === nodeType ||
    "DeclareClass" === nodeType ||
    "DeclareFunction" === nodeType ||
    "DeclareInterface" === nodeType ||
    "DeclareModule" === nodeType ||
    "DeclareModuleExports" === nodeType ||
    "DeclareTypeAlias" === nodeType ||
    "DeclareOpaqueType" === nodeType ||
    "DeclareVariable" === nodeType ||
    "DeclareExportDeclaration" === nodeType ||
    "DeclareExportAllDeclaration" === nodeType ||
    "InterfaceDeclaration" === nodeType ||
    "OpaqueType" === nodeType ||
    "TypeAlias" === nodeType ||
    "TSDeclareFunction" === nodeType ||
    "TSInterfaceDeclaration" === nodeType ||
    "TSTypeAliasDeclaration" === nodeType ||
    "TSEnumDeclaration" === nodeType ||
    "TSModuleDeclaration" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isPatternLike(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "PatternLike" ||
    "Identifier" === nodeType ||
    "RestElement" === nodeType ||
    "AssignmentPattern" === nodeType ||
    "ArrayPattern" === nodeType ||
    "ObjectPattern" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isLVal(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "LVal" ||
    "Identifier" === nodeType ||
    "MemberExpression" === nodeType ||
    "RestElement" === nodeType ||
    "AssignmentPattern" === nodeType ||
    "ArrayPattern" === nodeType ||
    "ObjectPattern" === nodeType ||
    "TSParameterProperty" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSEntityName(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "TSEntityName" ||
    "Identifier" === nodeType ||
    "TSQualifiedName" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isLiteral(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "Literal" ||
    "StringLiteral" === nodeType ||
    "NumericLiteral" === nodeType ||
    "NullLiteral" === nodeType ||
    "BooleanLiteral" === nodeType ||
    "RegExpLiteral" === nodeType ||
    "TemplateLiteral" === nodeType ||
    "BigIntLiteral" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isImmutable(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "Immutable" ||
    "StringLiteral" === nodeType ||
    "NumericLiteral" === nodeType ||
    "NullLiteral" === nodeType ||
    "BooleanLiteral" === nodeType ||
    "JSXAttribute" === nodeType ||
    "JSXClosingElement" === nodeType ||
    "JSXElement" === nodeType ||
    "JSXExpressionContainer" === nodeType ||
    "JSXSpreadChild" === nodeType ||
    "JSXOpeningElement" === nodeType ||
    "JSXText" === nodeType ||
    "JSXFragment" === nodeType ||
    "JSXOpeningFragment" === nodeType ||
    "JSXClosingFragment" === nodeType ||
    "BigIntLiteral" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isUserWhitespacable(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "UserWhitespacable" ||
    "ObjectMethod" === nodeType ||
    "ObjectProperty" === nodeType ||
    "ObjectTypeInternalSlot" === nodeType ||
    "ObjectTypeCallProperty" === nodeType ||
    "ObjectTypeIndexer" === nodeType ||
    "ObjectTypeProperty" === nodeType ||
    "ObjectTypeSpreadProperty" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isMethod(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "Method" ||
    "ObjectMethod" === nodeType ||
    "ClassMethod" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isObjectMember(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "ObjectMember" ||
    "ObjectMethod" === nodeType ||
    "ObjectProperty" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isProperty(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "Property" ||
    "ObjectProperty" === nodeType ||
    "ClassProperty" === nodeType ||
    "ClassPrivateProperty" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isUnaryLike(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "UnaryLike" ||
    "UnaryExpression" === nodeType ||
    "SpreadElement" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isPattern(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "Pattern" ||
    "AssignmentPattern" === nodeType ||
    "ArrayPattern" === nodeType ||
    "ObjectPattern" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isClass(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "Class" ||
    "ClassDeclaration" === nodeType ||
    "ClassExpression" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isModuleDeclaration(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "ModuleDeclaration" ||
    "ExportAllDeclaration" === nodeType ||
    "ExportDefaultDeclaration" === nodeType ||
    "ExportNamedDeclaration" === nodeType ||
    "ImportDeclaration" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isExportDeclaration(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "ExportDeclaration" ||
    "ExportAllDeclaration" === nodeType ||
    "ExportDefaultDeclaration" === nodeType ||
    "ExportNamedDeclaration" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isModuleSpecifier(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "ModuleSpecifier" ||
    "ExportSpecifier" === nodeType ||
    "ImportDefaultSpecifier" === nodeType ||
    "ImportNamespaceSpecifier" === nodeType ||
    "ImportSpecifier" === nodeType ||
    "ExportDefaultSpecifier" === nodeType ||
    "ExportNamespaceSpecifier" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isFlow(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "Flow" ||
    "AnyTypeAnnotation" === nodeType ||
    "ArrayTypeAnnotation" === nodeType ||
    "BooleanTypeAnnotation" === nodeType ||
    "BooleanLiteralTypeAnnotation" === nodeType ||
    "NullLiteralTypeAnnotation" === nodeType ||
    "ClassImplements" === nodeType ||
    "DeclareClass" === nodeType ||
    "DeclareFunction" === nodeType ||
    "DeclareInterface" === nodeType ||
    "DeclareModule" === nodeType ||
    "DeclareModuleExports" === nodeType ||
    "DeclareTypeAlias" === nodeType ||
    "DeclareOpaqueType" === nodeType ||
    "DeclareVariable" === nodeType ||
    "DeclareExportDeclaration" === nodeType ||
    "DeclareExportAllDeclaration" === nodeType ||
    "DeclaredPredicate" === nodeType ||
    "ExistsTypeAnnotation" === nodeType ||
    "FunctionTypeAnnotation" === nodeType ||
    "FunctionTypeParam" === nodeType ||
    "GenericTypeAnnotation" === nodeType ||
    "InferredPredicate" === nodeType ||
    "InterfaceExtends" === nodeType ||
    "InterfaceDeclaration" === nodeType ||
    "InterfaceTypeAnnotation" === nodeType ||
    "IntersectionTypeAnnotation" === nodeType ||
    "MixedTypeAnnotation" === nodeType ||
    "EmptyTypeAnnotation" === nodeType ||
    "NullableTypeAnnotation" === nodeType ||
    "NumberLiteralTypeAnnotation" === nodeType ||
    "NumberTypeAnnotation" === nodeType ||
    "ObjectTypeAnnotation" === nodeType ||
    "ObjectTypeInternalSlot" === nodeType ||
    "ObjectTypeCallProperty" === nodeType ||
    "ObjectTypeIndexer" === nodeType ||
    "ObjectTypeProperty" === nodeType ||
    "ObjectTypeSpreadProperty" === nodeType ||
    "OpaqueType" === nodeType ||
    "QualifiedTypeIdentifier" === nodeType ||
    "StringLiteralTypeAnnotation" === nodeType ||
    "StringTypeAnnotation" === nodeType ||
    "ThisTypeAnnotation" === nodeType ||
    "TupleTypeAnnotation" === nodeType ||
    "TypeofTypeAnnotation" === nodeType ||
    "TypeAlias" === nodeType ||
    "TypeAnnotation" === nodeType ||
    "TypeCastExpression" === nodeType ||
    "TypeParameter" === nodeType ||
    "TypeParameterDeclaration" === nodeType ||
    "TypeParameterInstantiation" === nodeType ||
    "UnionTypeAnnotation" === nodeType ||
    "Variance" === nodeType ||
    "VoidTypeAnnotation" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isFlowType(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "FlowType" ||
    "AnyTypeAnnotation" === nodeType ||
    "ArrayTypeAnnotation" === nodeType ||
    "BooleanTypeAnnotation" === nodeType ||
    "BooleanLiteralTypeAnnotation" === nodeType ||
    "NullLiteralTypeAnnotation" === nodeType ||
    "ExistsTypeAnnotation" === nodeType ||
    "FunctionTypeAnnotation" === nodeType ||
    "GenericTypeAnnotation" === nodeType ||
    "InterfaceTypeAnnotation" === nodeType ||
    "IntersectionTypeAnnotation" === nodeType ||
    "MixedTypeAnnotation" === nodeType ||
    "EmptyTypeAnnotation" === nodeType ||
    "NullableTypeAnnotation" === nodeType ||
    "NumberLiteralTypeAnnotation" === nodeType ||
    "NumberTypeAnnotation" === nodeType ||
    "ObjectTypeAnnotation" === nodeType ||
    "StringLiteralTypeAnnotation" === nodeType ||
    "StringTypeAnnotation" === nodeType ||
    "ThisTypeAnnotation" === nodeType ||
    "TupleTypeAnnotation" === nodeType ||
    "TypeofTypeAnnotation" === nodeType ||
    "UnionTypeAnnotation" === nodeType ||
    "VoidTypeAnnotation" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isFlowBaseAnnotation(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "FlowBaseAnnotation" ||
    "AnyTypeAnnotation" === nodeType ||
    "BooleanTypeAnnotation" === nodeType ||
    "NullLiteralTypeAnnotation" === nodeType ||
    "MixedTypeAnnotation" === nodeType ||
    "EmptyTypeAnnotation" === nodeType ||
    "NumberTypeAnnotation" === nodeType ||
    "StringTypeAnnotation" === nodeType ||
    "ThisTypeAnnotation" === nodeType ||
    "VoidTypeAnnotation" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isFlowDeclaration(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "FlowDeclaration" ||
    "DeclareClass" === nodeType ||
    "DeclareFunction" === nodeType ||
    "DeclareInterface" === nodeType ||
    "DeclareModule" === nodeType ||
    "DeclareModuleExports" === nodeType ||
    "DeclareTypeAlias" === nodeType ||
    "DeclareOpaqueType" === nodeType ||
    "DeclareVariable" === nodeType ||
    "DeclareExportDeclaration" === nodeType ||
    "DeclareExportAllDeclaration" === nodeType ||
    "InterfaceDeclaration" === nodeType ||
    "OpaqueType" === nodeType ||
    "TypeAlias" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isFlowPredicate(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "FlowPredicate" ||
    "DeclaredPredicate" === nodeType ||
    "InferredPredicate" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isJSX(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "JSX" ||
    "JSXAttribute" === nodeType ||
    "JSXClosingElement" === nodeType ||
    "JSXElement" === nodeType ||
    "JSXEmptyExpression" === nodeType ||
    "JSXExpressionContainer" === nodeType ||
    "JSXSpreadChild" === nodeType ||
    "JSXIdentifier" === nodeType ||
    "JSXMemberExpression" === nodeType ||
    "JSXNamespacedName" === nodeType ||
    "JSXOpeningElement" === nodeType ||
    "JSXSpreadAttribute" === nodeType ||
    "JSXText" === nodeType ||
    "JSXFragment" === nodeType ||
    "JSXOpeningFragment" === nodeType ||
    "JSXClosingFragment" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isPrivate(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "Private" ||
    "ClassPrivateProperty" === nodeType ||
    "PrivateName" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSTypeElement(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "TSTypeElement" ||
    "TSCallSignatureDeclaration" === nodeType ||
    "TSConstructSignatureDeclaration" === nodeType ||
    "TSPropertySignature" === nodeType ||
    "TSMethodSignature" === nodeType ||
    "TSIndexSignature" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isTSType(node: Object, opts?: Object): boolean {
  if (!node) return false;
  const nodeType = node.type;
  if (
    nodeType === "TSType" ||
    "TSAnyKeyword" === nodeType ||
    "TSUnknownKeyword" === nodeType ||
    "TSNumberKeyword" === nodeType ||
    "TSObjectKeyword" === nodeType ||
    "TSBooleanKeyword" === nodeType ||
    "TSStringKeyword" === nodeType ||
    "TSSymbolKeyword" === nodeType ||
    "TSVoidKeyword" === nodeType ||
    "TSUndefinedKeyword" === nodeType ||
    "TSNullKeyword" === nodeType ||
    "TSNeverKeyword" === nodeType ||
    "TSThisType" === nodeType ||
    "TSFunctionType" === nodeType ||
    "TSConstructorType" === nodeType ||
    "TSTypeReference" === nodeType ||
    "TSTypePredicate" === nodeType ||
    "TSTypeQuery" === nodeType ||
    "TSTypeLiteral" === nodeType ||
    "TSArrayType" === nodeType ||
    "TSTupleType" === nodeType ||
    "TSOptionalType" === nodeType ||
    "TSUnionType" === nodeType ||
    "TSIntersectionType" === nodeType ||
    "TSConditionalType" === nodeType ||
    "TSInferType" === nodeType ||
    "TSParenthesizedType" === nodeType ||
    "TSTypeOperator" === nodeType ||
    "TSIndexedAccessType" === nodeType ||
    "TSMappedType" === nodeType ||
    "TSLiteralType" === nodeType ||
    "TSExpressionWithTypeArguments" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isNumberLiteral(node: Object, opts?: Object): boolean {
  console.trace(
    "The node type NumberLiteral has been renamed to NumericLiteral",
  );
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "NumberLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isRegexLiteral(node: Object, opts?: Object): boolean {
  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "RegexLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isRestProperty(node: Object, opts?: Object): boolean {
  console.trace("The node type RestProperty has been renamed to RestElement");
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "RestProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}
export function isSpreadProperty(node: Object, opts?: Object): boolean {
  console.trace(
    "The node type SpreadProperty has been renamed to SpreadElement",
  );
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "SpreadProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }
  return false;
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/validators/generated/index.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/validators/buildMatchMemberExpression.js

import matchesPattern from "./matchesPattern";
/**
 * Build a function that when called will return whether or not the
 * input `node` `MemberExpression` matches the input `match`.
 *
 * For example, given the match `React.createClass` it would match the
 * parsed nodes of `React.createClass` and `React["createClass"]`.
 */
export default function buildMatchMemberExpression(
  match: string,
  allowPartial?: boolean,
): Object => boolean {
  const parts = match.split(".");
  return (member: Object): boolean =>
    matchesPattern(member, parts, allowPartial);
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/validators/buildMatchMemberExpression.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/validators/isImmutable.js

// @flow
import isType from "./isType";
import { isIdentifier } from "./generated";
/**
 * Check if the input `node` is definitely immutable.
 */
export default function isImmutable(node: Object): boolean {
  if (isType(node.type, "Immutable")) return true;
  if (isIdentifier(node)) {
    if (node.name === "undefined") {
      // immutable!
      return true;
    } else {
      // no idea...
      return false;
    }
  }
  return false;
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/validators/isImmutable.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/validators/isValidIdentifier.js

// @flow
import esutils from "esutils";
/**
 * Check if the input `name` is a valid identifier name
 * and isn't a reserved word.
 */
export default function isValidIdentifier(name: string): boolean {
  if (
    typeof name !== "string" ||
    esutils.keyword.isReservedWordES6(name, true)
  ) {
    return false;
  } else if (name === "await") {
    // invalid in module, valid in script; better be safe (see #4952)
    return false;
  } else {
    return esutils.keyword.isIdentifierNameES6(name);
  }
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/validators/isValidIdentifier.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/validators/isNode.js

// @flow
import { VISITOR_KEYS } from "../definitions";
export default function isNode(node?: Object): boolean {
  return !!(node && VISITOR_KEYS[node.type]);
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/validators/isNode.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/validators/is.js

// @flow
import shallowEqual from "../utils/shallowEqual";
import isType from "./isType";
/**
 * Returns whether `node` is of given `type`.
 *
 * For better performance, use this instead of `is[Type]` when `type` is unknown.
 */
export default function is(type: string, node: Object, opts?: Object): boolean {
  if (!node) return false;
  const matches = isType(node.type, type);
  if (!matches) return false;
  if (typeof opts === "undefined") {
    return true;
  } else {
    return shallowEqual(node, opts);
  }
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/validators/is.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/validators/isNodesEquivalent.js

// @flow
import { NODE_FIELDS, VISITOR_KEYS } from "../definitions";
/**
 * Check if two nodes are equivalent
 */
export default function isNodesEquivalent(a: any, b: any): boolean {
  if (
    typeof a !== "object" ||
    typeof b !== "object" ||
    a == null ||
    b == null
  ) {
    return a === b;
  }
  if (a.type !== b.type) {
    return false;
  }
  const fields = Object.keys(NODE_FIELDS[a.type] || a.type);
  const visitorKeys = VISITOR_KEYS[a.type];
  for (const field of fields) {
    if (typeof a[field] !== typeof b[field]) {
      return false;
    }
    if (Array.isArray(a[field])) {
      if (!Array.isArray(b[field])) {
        return false;
      }
      if (a[field].length !== b[field].length) {
        return false;
      }
      for (let i = 0; i < a[field].length; i++) {
        if (!isNodesEquivalent(a[field][i], b[field][i])) {
          return false;
        }
      }
      continue;
    }
    if (
      typeof a[field] === "object" &&
      (!visitorKeys || !visitorKeys.includes(field))
    ) {
      for (const key in a[field]) {
        if (a[field][key] !== b[field][key]) {
          return false;
        }
      }
      continue;
    }
    if (!isNodesEquivalent(a[field], b[field])) {
      return false;
    }
  }
  return true;
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/validators/isNodesEquivalent.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/validators/isSpecifierDefault.js

// @flow
import { isIdentifier, isImportDefaultSpecifier } from "./generated";
/**
 * Check if the input `specifier` is a `default` import or export.
 */
export default function isSpecifierDefault(specifier: Object): boolean {
  return (
    isImportDefaultSpecifier(specifier) ||
    isIdentifier(specifier.imported || specifier.exported, {
      name: "default",
    })
  );
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/validators/isSpecifierDefault.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/validators/react/isCompatTag.js

// @flow
export default function isCompatTag(tagName?: string): boolean {
  // Must start with a lowercase ASCII letter
  return !!tagName && /^[a-z]/.test(tagName);
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/validators/react/isCompatTag.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/validators/react/isReactComponent.js

// @flow
import buildMatchMemberExpression from "../buildMatchMemberExpression";
const isReactComponent = buildMatchMemberExpression("React.Component");
export default isReactComponent;

// </from> /home/qfox/apps/babel/packages/babel-types/src/validators/react/isReactComponent.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/utils/shallowEqual.js

// @flow
export default function shallowEqual(
  actual: Object,
  expected: Object,
): boolean {
  const keys = Object.keys(expected);
  for (const key of (keys: Array<string>)) {
    if (actual[key] !== expected[key]) {
      return false;
    }
  }
  return true;
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/utils/shallowEqual.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/utils/inherit.js

// @flow
import uniq from "lodash/uniq";
export default function inherit(
  key: string,
  child: Object,
  parent: Object,
): void {
  if (child && parent) {
    child[key] = uniq([].concat(child[key], parent[key]).filter(Boolean));
  }
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/utils/inherit.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/utils/react/cleanJSXElementLiteralChild.js

// @flow
import { stringLiteral } from "../../builders/generated";
export default function cleanJSXElementLiteralChild(
  child: { value: string },
  args: Array<Object>,
) {
  const lines = child.value.split(/\r\n|\n|\r/);
  let lastNonEmptyLine = 0;
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].match(/[^ \t]/)) {
      lastNonEmptyLine = i;
    }
  }
  let str = "";
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const isFirstLine = i === 0;
    const isLastLine = i === lines.length - 1;
    const isLastNonEmptyLine = i === lastNonEmptyLine;
    // replace rendered whitespace tabs with spaces
    let trimmedLine = line.replace(/\t/g, " ");
    // trim whitespace touching a newline
    if (!isFirstLine) {
      trimmedLine = trimmedLine.replace(/^[ ]+/, "");
    }
    // trim whitespace touching an endline
    if (!isLastLine) {
      trimmedLine = trimmedLine.replace(/[ ]+$/, "");
    }
    if (trimmedLine) {
      if (!isLastNonEmptyLine) {
        trimmedLine += " ";
      }
      str += trimmedLine;
    }
  }
  if (str) args.push(stringLiteral(str));
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/utils/react/cleanJSXElementLiteralChild.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/retrievers/getBindingIdentifiers.js

// @flow
import {
  isExportDeclaration,
  isIdentifier,
  isDeclaration,
  isFunctionDeclaration,
  isFunctionExpression,
} from "../validators/generated";
/**
 * Return a list of binding identifiers associated with the input `node`.
 */
export default function getBindingIdentifiers(
  node: Object,
  duplicates?: boolean,
  outerOnly?: boolean,
): { [string]: Object | Array<Object> } {
  let search = [].concat(node);
  const ids = Object.create(null);
  while (search.length) {
    const id = search.shift();
    if (!id) continue;
    const keys = getBindingIdentifiers.keys[id.type];
    if (isIdentifier(id)) {
      if (duplicates) {
        const _ids = (ids[id.name] = ids[id.name] || []);
        _ids.push(id);
      } else {
        ids[id.name] = id;
      }
      continue;
    }
    if (isExportDeclaration(id)) {
      if (isDeclaration(id.declaration)) {
        search.push(id.declaration);
      }
      continue;
    }
    if (outerOnly) {
      if (isFunctionDeclaration(id)) {
        search.push(id.id);
        continue;
      }
      if (isFunctionExpression(id)) {
        continue;
      }
    }
    if (keys) {
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        if (id[key]) {
          search = search.concat(id[key]);
        }
      }
    }
  }
  // $FlowIssue Object.create() seems broken
  return ids;
}
/**
 * Mapping of types to their identifier keys.
 */
getBindingIdentifiers.keys = {
  DeclareClass: ["id"],
  DeclareFunction: ["id"],
  DeclareModule: ["id"],
  DeclareVariable: ["id"],
  DeclareInterface: ["id"],
  DeclareTypeAlias: ["id"],
  DeclareOpaqueType: ["id"],
  InterfaceDeclaration: ["id"],
  TypeAlias: ["id"],
  OpaqueType: ["id"],
  CatchClause: ["param"],
  LabeledStatement: ["label"],
  UnaryExpression: ["argument"],
  AssignmentExpression: ["left"],
  ImportSpecifier: ["local"],
  ImportNamespaceSpecifier: ["local"],
  ImportDefaultSpecifier: ["local"],
  ImportDeclaration: ["specifiers"],
  ExportSpecifier: ["exported"],
  ExportNamespaceSpecifier: ["exported"],
  ExportDefaultSpecifier: ["exported"],
  FunctionDeclaration: ["id", "params"],
  FunctionExpression: ["id", "params"],
  ArrowFunctionExpression: ["params"],
  ObjectMethod: ["params"],
  ClassMethod: ["params"],
  ForInStatement: ["left"],
  ForOfStatement: ["left"],
  ClassDeclaration: ["id"],
  ClassExpression: ["id"],
  RestElement: ["argument"],
  UpdateExpression: ["argument"],
  ObjectProperty: ["value"],
  AssignmentPattern: ["left"],
  ArrayPattern: ["elements"],
  ObjectPattern: ["properties"],
  VariableDeclaration: ["declarations"],
  VariableDeclarator: ["id"],
};

// </from> /home/qfox/apps/babel/packages/babel-types/src/retrievers/getBindingIdentifiers.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/retrievers/getOuterBindingIdentifiers.js

// @flow
import getBindingIdentifiers from "./getBindingIdentifiers";
export default function getOuterBindingIdentifiers(
  node: Object,
  duplicates?: boolean,
): { [string]: Object | Array<Object> } {
  return getBindingIdentifiers(node, duplicates, true);
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/retrievers/getOuterBindingIdentifiers.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/definitions/index.js

// @flow
import toFastProperties from "to-fast-properties";
import "./core";
import "./es2015";
import "./flow";
import "./jsx";
import "./misc";
import "./experimental";
import "./typescript";
import {
  VISITOR_KEYS,
  ALIAS_KEYS,
  FLIPPED_ALIAS_KEYS,
  NODE_FIELDS,
  BUILDER_KEYS,
  DEPRECATED_KEYS,
} from "./utils";
// We do this here, because at this point the visitor keys should be ready and setup
toFastProperties(VISITOR_KEYS);
toFastProperties(ALIAS_KEYS);
toFastProperties(FLIPPED_ALIAS_KEYS);
toFastProperties(NODE_FIELDS);
toFastProperties(BUILDER_KEYS);
toFastProperties(DEPRECATED_KEYS);
const TYPES: Array<string> = Object.keys(VISITOR_KEYS)
  .concat(Object.keys(FLIPPED_ALIAS_KEYS))
  .concat(Object.keys(DEPRECATED_KEYS));
export {
  VISITOR_KEYS,
  ALIAS_KEYS,
  FLIPPED_ALIAS_KEYS,
  NODE_FIELDS,
  BUILDER_KEYS,
  DEPRECATED_KEYS,
  TYPES,
};

// </from> /home/qfox/apps/babel/packages/babel-types/src/definitions/index.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/definitions/core.js

// @flow
import isValidIdentifier from "../validators/isValidIdentifier";
import {
  BINARY_OPERATORS,
  LOGICAL_OPERATORS,
  UNARY_OPERATORS,
  UPDATE_OPERATORS,
} from "../constants";
import defineType, {
  assertValueType,
  assertNodeType,
  assertNodeOrValueType,
  assertEach,
  chain,
  assertOneOf,
} from "./utils";
defineType("ArrayExpression", {
  fields: {
    elements: {
      validate: chain(
        assertValueType("array"),
        assertEach(
          assertNodeOrValueType("null", "Expression", "SpreadElement"),
        ),
      ),
      default: [],
    },
  },
  visitor: ["elements"],
  aliases: ["Expression"],
});
defineType("AssignmentExpression", {
  fields: {
    operator: {
      validate: assertValueType("string"),
    },
    left: {
      validate: assertNodeType("LVal"),
    },
    right: {
      validate: assertNodeType("Expression"),
    },
  },
  builder: ["operator", "left", "right"],
  visitor: ["left", "right"],
  aliases: ["Expression"],
});
defineType("BinaryExpression", {
  builder: ["operator", "left", "right"],
  fields: {
    operator: {
      validate: assertOneOf(...BINARY_OPERATORS),
    },
    left: {
      validate: assertNodeType("Expression"),
    },
    right: {
      validate: assertNodeType("Expression"),
    },
  },
  visitor: ["left", "right"],
  aliases: ["Binary", "Expression"],
});
defineType("InterpreterDirective", {
  builder: ["value"],
  fields: {
    value: {
      validate: assertValueType("string"),
    },
  },
});
defineType("Directive", {
  visitor: ["value"],
  fields: {
    value: {
      validate: assertNodeType("DirectiveLiteral"),
    },
  },
});
defineType("DirectiveLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: assertValueType("string"),
    },
  },
});
defineType("BlockStatement", {
  builder: ["body", "directives"],
  visitor: ["directives", "body"],
  fields: {
    directives: {
      validate: chain(
        assertValueType("array"),
        assertEach(assertNodeType("Directive")),
      ),
      default: [],
    },
    body: {
      validate: chain(
        assertValueType("array"),
        assertEach(assertNodeType("Statement")),
      ),
    },
  },
  aliases: ["Scopable", "BlockParent", "Block", "Statement"],
});
defineType("BreakStatement", {
  visitor: ["label"],
  fields: {
    label: {
      validate: assertNodeType("Identifier"),
      optional: true,
    },
  },
  aliases: ["Statement", "Terminatorless", "CompletionStatement"],
});
defineType("CallExpression", {
  visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
  builder: ["callee", "arguments"],
  aliases: ["Expression"],
  fields: {
    callee: {
      validate: assertNodeType("Expression"),
    },
    arguments: {
      validate: chain(
        assertValueType("array"),
        assertEach(
          assertNodeType("Expression", "SpreadElement", "JSXNamespacedName"),
        ),
      ),
    },
    optional: {
      validate: assertOneOf(true, false),
      optional: true,
    },
    typeArguments: {
      validate: assertNodeType("TypeParameterInstantiation"),
      optional: true,
    },
    typeParameters: {
      validate: assertNodeType("TSTypeParameterInstantiation"),
      optional: true,
    },
  },
});
defineType("CatchClause", {
  visitor: ["param", "body"],
  fields: {
    param: {
      validate: assertNodeType("Identifier"),
      optional: true,
    },
    body: {
      validate: assertNodeType("BlockStatement"),
    },
  },
  aliases: ["Scopable", "BlockParent"],
});
defineType("ConditionalExpression", {
  visitor: ["test", "consequent", "alternate"],
  fields: {
    test: {
      validate: assertNodeType("Expression"),
    },
    consequent: {
      validate: assertNodeType("Expression"),
    },
    alternate: {
      validate: assertNodeType("Expression"),
    },
  },
  aliases: ["Expression", "Conditional"],
});
defineType("ContinueStatement", {
  visitor: ["label"],
  fields: {
    label: {
      validate: assertNodeType("Identifier"),
      optional: true,
    },
  },
  aliases: ["Statement", "Terminatorless", "CompletionStatement"],
});
defineType("DebuggerStatement", {
  aliases: ["Statement"],
});
defineType("DoWhileStatement", {
  visitor: ["test", "body"],
  fields: {
    test: {
      validate: assertNodeType("Expression"),
    },
    body: {
      validate: assertNodeType("Statement"),
    },
  },
  aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
});
defineType("EmptyStatement", {
  aliases: ["Statement"],
});
defineType("ExpressionStatement", {
  visitor: ["expression"],
  fields: {
    expression: {
      validate: assertNodeType("Expression"),
    },
  },
  aliases: ["Statement", "ExpressionWrapper"],
});
defineType("File", {
  builder: ["program", "comments", "tokens"],
  visitor: ["program"],
  fields: {
    program: {
      validate: assertNodeType("Program"),
    },
  },
});
defineType("ForInStatement", {
  visitor: ["left", "right", "body"],
  aliases: [
    "Scopable",
    "Statement",
    "For",
    "BlockParent",
    "Loop",
    "ForXStatement",
  ],
  fields: {
    left: {
      validate: assertNodeType("VariableDeclaration", "LVal"),
    },
    right: {
      validate: assertNodeType("Expression"),
    },
    body: {
      validate: assertNodeType("Statement"),
    },
  },
});
defineType("ForStatement", {
  visitor: ["init", "test", "update", "body"],
  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
  fields: {
    init: {
      validate: assertNodeType("VariableDeclaration", "Expression"),
      optional: true,
    },
    test: {
      validate: assertNodeType("Expression"),
      optional: true,
    },
    update: {
      validate: assertNodeType("Expression"),
      optional: true,
    },
    body: {
      validate: assertNodeType("Statement"),
    },
  },
});
export const functionCommon = {
  params: {
    validate: chain(
      assertValueType("array"),
      assertEach(assertNodeType("LVal")),
    ),
  },
  generator: {
    default: false,
    validate: assertValueType("boolean"),
  },
  async: {
    validate: assertValueType("boolean"),
    default: false,
  },
};
export const functionTypeAnnotationCommon = {
  returnType: {
    validate: assertNodeType("TypeAnnotation", "TSTypeAnnotation", "Noop"),
    optional: true,
  },
  typeParameters: {
    validate: assertNodeType(
      "TypeParameterDeclaration",
      "TSTypeParameterDeclaration",
      "Noop",
    ),
    optional: true,
  },
};
export const functionDeclarationCommon = {
  ...functionCommon,
  declare: {
    validate: assertValueType("boolean"),
    optional: true,
  },
  id: {
    validate: assertNodeType("Identifier"),
    optional: true, // May be null for `export default function`
  },
};
defineType("FunctionDeclaration", {
  builder: ["id", "params", "body", "generator", "async"],
  visitor: ["id", "params", "body", "returnType", "typeParameters"],
  fields: {
    ...functionDeclarationCommon,
    ...functionTypeAnnotationCommon,
    body: {
      validate: assertNodeType("BlockStatement"),
    },
  },
  aliases: [
    "Scopable",
    "Function",
    "BlockParent",
    "FunctionParent",
    "Statement",
    "Pureish",
    "Declaration",
  ],
});
defineType("FunctionExpression", {
  inherits: "FunctionDeclaration",
  aliases: [
    "Scopable",
    "Function",
    "BlockParent",
    "FunctionParent",
    "Expression",
    "Pureish",
  ],
  fields: {
    ...functionCommon,
    ...functionTypeAnnotationCommon,
    id: {
      validate: assertNodeType("Identifier"),
      optional: true,
    },
    body: {
      validate: assertNodeType("BlockStatement"),
    },
  },
});
export const patternLikeCommon = {
  typeAnnotation: {
    // TODO: @babel/plugin-transform-flow-comments puts a Noop here, is there a better way?
    validate: assertNodeType("TypeAnnotation", "TSTypeAnnotation", "Noop"),
    optional: true,
  },
  decorators: {
    validate: chain(
      assertValueType("array"),
      assertEach(assertNodeType("Decorator")),
    ),
  },
};
defineType("Identifier", {
  builder: ["name"],
  visitor: ["typeAnnotation"],
  aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
  fields: {
    ...patternLikeCommon,
    name: {
      validate: chain(function(node, key, val) {
        if (!isValidIdentifier(val)) {
          // throw new TypeError(`"${val}" is not a valid identifer name`);
        }
      }, assertValueType("string")),
    },
    optional: {
      validate: assertValueType("boolean"),
      optional: true,
    },
  },
});
defineType("IfStatement", {
  visitor: ["test", "consequent", "alternate"],
  aliases: ["Statement", "Conditional"],
  fields: {
    test: {
      validate: assertNodeType("Expression"),
    },
    consequent: {
      validate: assertNodeType("Statement"),
    },
    alternate: {
      optional: true,
      validate: assertNodeType("Statement"),
    },
  },
});
defineType("LabeledStatement", {
  visitor: ["label", "body"],
  aliases: ["Statement"],
  fields: {
    label: {
      validate: assertNodeType("Identifier"),
    },
    body: {
      validate: assertNodeType("Statement"),
    },
  },
});
defineType("StringLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: assertValueType("string"),
    },
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"],
});
defineType("NumericLiteral", {
  builder: ["value"],
  deprecatedAlias: "NumberLiteral",
  fields: {
    value: {
      validate: assertValueType("number"),
    },
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"],
});
defineType("NullLiteral", {
  aliases: ["Expression", "Pureish", "Literal", "Immutable"],
});
defineType("BooleanLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: assertValueType("boolean"),
    },
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"],
});
defineType("RegExpLiteral", {
  builder: ["pattern", "flags"],
  deprecatedAlias: "RegexLiteral",
  aliases: ["Expression", "Literal"],
  fields: {
    pattern: {
      validate: assertValueType("string"),
    },
    flags: {
      validate: assertValueType("string"),
      default: "",
    },
  },
});
defineType("LogicalExpression", {
  builder: ["operator", "left", "right"],
  visitor: ["left", "right"],
  aliases: ["Binary", "Expression"],
  fields: {
    operator: {
      validate: assertOneOf(...LOGICAL_OPERATORS),
    },
    left: {
      validate: assertNodeType("Expression"),
    },
    right: {
      validate: assertNodeType("Expression"),
    },
  },
});
defineType("MemberExpression", {
  builder: ["object", "property", "computed", "optional"],
  visitor: ["object", "property"],
  aliases: ["Expression", "LVal"],
  fields: {
    object: {
      validate: assertNodeType("Expression"),
    },
    property: {
      validate: (function() {
        const normal = assertNodeType("Identifier", "PrivateName");
        const computed = assertNodeType("Expression");
        return function(node, key, val) {
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
        };
      })(),
    },
    computed: {
      default: false,
    },
    optional: {
      validate: assertOneOf(true, false),
      optional: true,
    },
  },
});
defineType("NewExpression", { inherits: "CallExpression" });
defineType("Program", {
  // Note: We explicitly leave 'interpreter' out here because it is
  // conceptually comment-like, and Babel does not traverse comments either.
  visitor: ["directives", "body"],
  builder: ["body", "directives", "sourceType", "interpreter"],
  fields: {
    sourceFile: {
      validate: assertValueType("string"),
    },
    sourceType: {
      validate: assertOneOf("script", "module"),
      default: "script",
    },
    interpreter: {
      validate: assertNodeType("InterpreterDirective"),
      default: null,
      optional: true,
    },
    directives: {
      validate: chain(
        assertValueType("array"),
        assertEach(assertNodeType("Directive")),
      ),
      default: [],
    },
    body: {
      validate: chain(
        assertValueType("array"),
        assertEach(assertNodeType("Statement")),
      ),
    },
  },
  aliases: ["Scopable", "BlockParent", "Block"],
});
defineType("ObjectExpression", {
  visitor: ["properties"],
  aliases: ["Expression"],
  fields: {
    properties: {
      validate: chain(
        assertValueType("array"),
        assertEach(
          assertNodeType("ObjectMethod", "ObjectProperty", "SpreadElement"),
        ),
      ),
    },
  },
});
defineType("ObjectMethod", {
  builder: ["kind", "key", "params", "body", "computed"],
  fields: {
    ...functionCommon,
    ...functionTypeAnnotationCommon,
    kind: {
      validate: chain(
        assertValueType("string"),
        assertOneOf("method", "get", "set"),
      ),
      default: "method",
    },
    computed: {
      validate: assertValueType("boolean"),
      default: false,
    },
    key: {
      validate: (function() {
        const normal = assertNodeType(
          "Identifier",
          "StringLiteral",
          "NumericLiteral",
        );
        const computed = assertNodeType("Expression");
        return function(node, key, val) {
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
        };
      })(),
    },
    decorators: {
      validate: chain(
        assertValueType("array"),
        assertEach(assertNodeType("Decorator")),
      ),
    },
    body: {
      validate: assertNodeType("BlockStatement"),
    },
  },
  visitor: [
    "key",
    "params",
    "body",
    "decorators",
    "returnType",
    "typeParameters",
  ],
  aliases: [
    "UserWhitespacable",
    "Function",
    "Scopable",
    "BlockParent",
    "FunctionParent",
    "Method",
    "ObjectMember",
  ],
});
defineType("ObjectProperty", {
  builder: ["key", "value", "computed", "shorthand", "decorators"],
  fields: {
    computed: {
      validate: assertValueType("boolean"),
      default: false,
    },
    key: {
      validate: (function() {
        const normal = assertNodeType(
          "Identifier",
          "StringLiteral",
          "NumericLiteral",
        );
        const computed = assertNodeType("Expression");
        return function(node, key, val) {
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
        };
      })(),
    },
    value: {
      // Value may be PatternLike if this is an AssignmentProperty
      // https://github.com/babel/babylon/issues/434
      validate: assertNodeType("Expression", "PatternLike"),
    },
    shorthand: {
      validate: assertValueType("boolean"),
      default: false,
    },
    decorators: {
      validate: chain(
        assertValueType("array"),
        assertEach(assertNodeType("Decorator")),
      ),
      optional: true,
    },
  },
  visitor: ["key", "value", "decorators"],
  aliases: ["UserWhitespacable", "Property", "ObjectMember"],
});
defineType("RestElement", {
  visitor: ["argument", "typeAnnotation"],
  builder: ["argument"],
  aliases: ["LVal", "PatternLike"],
  deprecatedAlias: "RestProperty",
  fields: {
    ...patternLikeCommon,
    argument: {
      validate: assertNodeType("LVal"),
    },
  },
});
defineType("ReturnStatement", {
  visitor: ["argument"],
  aliases: ["Statement", "Terminatorless", "CompletionStatement"],
  fields: {
    argument: {
      validate: assertNodeType("Expression"),
      optional: true,
    },
  },
});
defineType("SequenceExpression", {
  visitor: ["expressions"],
  fields: {
    expressions: {
      validate: chain(
        assertValueType("array"),
        assertEach(assertNodeType("Expression")),
      ),
    },
  },
  aliases: ["Expression"],
});
defineType("SwitchCase", {
  visitor: ["test", "consequent"],
  fields: {
    test: {
      validate: assertNodeType("Expression"),
      optional: true,
    },
    consequent: {
      validate: chain(
        assertValueType("array"),
        assertEach(assertNodeType("Statement")),
      ),
    },
  },
});
defineType("SwitchStatement", {
  visitor: ["discriminant", "cases"],
  aliases: ["Statement", "BlockParent", "Scopable"],
  fields: {
    discriminant: {
      validate: assertNodeType("Expression"),
    },
    cases: {
      validate: chain(
        assertValueType("array"),
        assertEach(assertNodeType("SwitchCase")),
      ),
    },
  },
});
defineType("ThisExpression", {
  aliases: ["Expression"],
});
defineType("ThrowStatement", {
  visitor: ["argument"],
  aliases: ["Statement", "Terminatorless", "CompletionStatement"],
  fields: {
    argument: {
      validate: assertNodeType("Expression"),
    },
  },
});
// todo: at least handler or finalizer should be set to be valid
defineType("TryStatement", {
  visitor: ["block", "handler", "finalizer"],
  aliases: ["Statement"],
  fields: {
    block: {
      validate: assertNodeType("BlockStatement"),
    },
    handler: {
      optional: true,
      validate: assertNodeType("CatchClause"),
    },
    finalizer: {
      optional: true,
      validate: assertNodeType("BlockStatement"),
    },
  },
});
defineType("UnaryExpression", {
  builder: ["operator", "argument", "prefix"],
  fields: {
    prefix: {
      default: true,
    },
    argument: {
      validate: assertNodeType("Expression"),
    },
    operator: {
      validate: assertOneOf(...UNARY_OPERATORS),
    },
  },
  visitor: ["argument"],
  aliases: ["UnaryLike", "Expression"],
});
defineType("UpdateExpression", {
  builder: ["operator", "argument", "prefix"],
  fields: {
    prefix: {
      default: false,
    },
    argument: {
      validate: assertNodeType("Expression"),
    },
    operator: {
      validate: assertOneOf(...UPDATE_OPERATORS),
    },
  },
  visitor: ["argument"],
  aliases: ["Expression"],
});
defineType("VariableDeclaration", {
  builder: ["kind", "declarations"],
  visitor: ["declarations"],
  aliases: ["Statement", "Declaration"],
  fields: {
    declare: {
      validate: assertValueType("boolean"),
      optional: true,
    },
    kind: {
      validate: chain(
        assertValueType("string"),
        assertOneOf("var", "let", "const"),
      ),
    },
    declarations: {
      validate: chain(
        assertValueType("array"),
        assertEach(assertNodeType("VariableDeclarator")),
      ),
    },
  },
});
defineType("VariableDeclarator", {
  visitor: ["id", "init"],
  fields: {
    id: {
      validate: assertNodeType("LVal"),
    },
    definite: {
      optional: true,
      validate: assertValueType("boolean"),
    },
    init: {
      optional: true,
      validate: assertNodeType("Expression"),
    },
  },
});
defineType("WhileStatement", {
  visitor: ["test", "body"],
  aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
  fields: {
    test: {
      validate: assertNodeType("Expression"),
    },
    body: {
      validate: assertNodeType("BlockStatement", "Statement"),
    },
  },
});
defineType("WithStatement", {
  visitor: ["object", "body"],
  aliases: ["Statement"],
  fields: {
    object: {
      validate: assertNodeType("Expression"),
    },
    body: {
      validate: assertNodeType("BlockStatement", "Statement"),
    },
  },
});

// </from> /home/qfox/apps/babel/packages/babel-types/src/definitions/core.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/definitions/misc.js

// @flow
import defineType, { assertNodeType } from "./utils";
defineType("Noop", {
  visitor: [],
});
defineType("ParenthesizedExpression", {
  visitor: ["expression"],
  aliases: ["Expression", "ExpressionWrapper"],
  fields: {
    expression: {
      validate: assertNodeType("Expression"),
    },
  },
});

// </from> /home/qfox/apps/babel/packages/babel-types/src/definitions/misc.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/definitions/experimental.js

// @flow
import defineType, {
  assertEach,
  assertNodeType,
  assertValueType,
  chain,
} from "./utils";
import { classMethodOrPropertyCommon } from "./es2015";
defineType("AwaitExpression", {
  builder: ["argument"],
  visitor: ["argument"],
  aliases: ["Expression", "Terminatorless"],
  fields: {
    argument: {
      validate: assertNodeType("Expression"),
    },
  },
});
defineType("BindExpression", {
  visitor: ["object", "callee"],
  aliases: ["Expression"],
  fields: {
    // todo
  },
});
defineType("ClassProperty", {
  visitor: ["key", "value", "typeAnnotation", "decorators"],
  builder: ["key", "value", "typeAnnotation", "decorators", "computed"],
  aliases: ["Property"],
  fields: {
    ...classMethodOrPropertyCommon,
    value: {
      validate: assertNodeType("Expression"),
      optional: true,
    },
    definite: {
      validate: assertValueType("boolean"),
      optional: true,
    },
    typeAnnotation: {
      validate: assertNodeType("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: true,
    },
    decorators: {
      validate: chain(
        assertValueType("array"),
        assertEach(assertNodeType("Decorator")),
      ),
      optional: true,
    },
    readonly: {
      validate: assertValueType("boolean"),
      optional: true,
    },
  },
});
defineType("OptionalMemberExpression", {
  builder: ["object", "property", "computed", "optional"],
  visitor: ["object", "property"],
  aliases: ["Expression"],
  fields: {
    object: {
      validate: assertNodeType("Expression"),
    },
    property: {
      validate: (function() {
        const normal = assertNodeType("Identifier");
        const computed = assertNodeType("Expression");
        return function(node, key, val) {
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
        };
      })(),
    },
    computed: {
      default: false,
    },
    optional: {
      validate: assertValueType("boolean"),
    },
  },
});
defineType("OptionalCallExpression", {
  visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
  builder: ["callee", "arguments", "optional"],
  aliases: ["Expression"],
  fields: {
    callee: {
      validate: assertNodeType("Expression"),
    },
    arguments: {
      validate: chain(
        assertValueType("array"),
        assertEach(
          assertNodeType("Expression", "SpreadElement", "JSXNamespacedName"),
        ),
      ),
    },
    optional: {
      validate: assertValueType("boolean"),
    },
    typeArguments: {
      validate: assertNodeType("TypeParameterInstantiation"),
      optional: true,
    },
    typeParameters: {
      validate: assertNodeType("TSTypeParameterInstantiation"),
      optional: true,
    },
  },
});
defineType("ClassPrivateProperty", {
  visitor: ["key", "value"],
  builder: ["key", "value"],
  aliases: ["Property", "Private"],
  fields: {
    key: {
      validate: assertNodeType("PrivateName"),
    },
    value: {
      validate: assertNodeType("Expression"),
      optional: true,
    },
  },
});
defineType("Import", {
  aliases: ["Expression"],
});
defineType("Decorator", {
  visitor: ["expression"],
  fields: {
    expression: {
      validate: assertNodeType("Expression"),
    },
  },
});
defineType("DoExpression", {
  visitor: ["body"],
  aliases: ["Expression"],
  fields: {
    body: {
      validate: assertNodeType("BlockStatement"),
    },
  },
});
defineType("ExportDefaultSpecifier", {
  visitor: ["exported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    exported: {
      validate: assertNodeType("Identifier"),
    },
  },
});
defineType("ExportNamespaceSpecifier", {
  visitor: ["exported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    exported: {
      validate: assertNodeType("Identifier"),
    },
  },
});
defineType("PrivateName", {
  visitor: ["id"],
  aliases: ["Private"],
  fields: {
    id: {
      validate: assertNodeType("Identifier"),
    },
  },
});
defineType("BigIntLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: assertValueType("string"),
    },
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"],
});

// </from> /home/qfox/apps/babel/packages/babel-types/src/definitions/experimental.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/definitions/flow.js

// @flow
import defineType, {
  arrayOfType,
  assertOneOf,
  assertValueType,
  validate,
  validateOptional,
  validateOptionalType,
  validateType,
} from "./utils";
const defineInterfaceishType = (
  name: string,
  typeParameterType: string = "TypeParameterDeclaration",
) => {
  defineType(name, {
    builder: ["id", "typeParameters", "extends", "body"],
    visitor: [
      "id",
      "typeParameters",
      "extends",
      "mixins",
      "implements",
      "body",
    ],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: validateType("Identifier"),
      typeParameters: validateOptionalType(typeParameterType),
      extends: validateOptional(arrayOfType("InterfaceExtends")),
      mixins: validateOptional(arrayOfType("InterfaceExtends")),
      implements: validateOptional(arrayOfType("ClassImplements")),
      body: validateType("ObjectTypeAnnotation"),
    },
  });
};
defineType("AnyTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"],
});
defineType("ArrayTypeAnnotation", {
  visitor: ["elementType"],
  aliases: ["Flow", "FlowType"],
  fields: {
    elementType: validateType("FlowType"),
  },
});
defineType("BooleanTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"],
});
defineType("BooleanLiteralTypeAnnotation", {
  builder: ["value"],
  aliases: ["Flow", "FlowType"],
  fields: {
    value: validate(assertValueType("boolean")),
  },
});
defineType("NullLiteralTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"],
});
defineType("ClassImplements", {
  visitor: ["id", "typeParameters"],
  aliases: ["Flow"],
  fields: {
    id: validateType("Identifier"),
    typeParameters: validateOptionalType("TypeParameterInstantiation"),
  },
});
defineInterfaceishType("DeclareClass", "TypeParameterInstantiation");
defineType("DeclareFunction", {
  visitor: ["id"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: validateType("Identifier"),
    predicate: validateOptionalType("DeclaredPredicate"),
  },
});
defineInterfaceishType("DeclareInterface");
defineType("DeclareModule", {
  builder: ["id", "body", "kind"],
  visitor: ["id", "body"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: validateType(["Identifier", "StringLiteral"]),
    body: validateType("BlockStatement"),
    kind: validateOptional(assertOneOf("CommonJS", "ES")),
  },
});
defineType("DeclareModuleExports", {
  visitor: ["typeAnnotation"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    typeAnnotation: validateType("TypeAnnotation"),
  },
});
defineType("DeclareTypeAlias", {
  visitor: ["id", "typeParameters", "right"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: validateType("Identifier"),
    typeParameters: validateOptionalType("TypeParameterDeclaration"),
    right: validateType("FlowType"),
  },
});
defineType("DeclareOpaqueType", {
  visitor: ["id", "typeParameters", "supertype"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: validateType("Identifier"),
    typeParameters: validateOptionalType("TypeParameterDeclaration"),
    supertype: validateOptionalType("FlowType"),
  },
});
defineType("DeclareVariable", {
  visitor: ["id"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: validateType("Identifier"),
  },
});
defineType("DeclareExportDeclaration", {
  visitor: ["declaration", "specifiers", "source"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    declaration: validateOptionalType("Flow"),
    specifiers: validateOptional(
      arrayOfType(["ExportSpecifier", "ExportNamespaceSpecifier"]),
    ),
    source: validateOptionalType("StringLiteral"),
    default: validateOptional(assertValueType("boolean")),
  },
});
defineType("DeclareExportAllDeclaration", {
  visitor: ["source"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    source: validateType("StringLiteral"),
    exportKind: validateOptional(assertOneOf(["type", "value"])),
  },
});
defineType("DeclaredPredicate", {
  visitor: ["value"],
  aliases: ["Flow", "FlowPredicate"],
  fields: {
    value: validateType("Flow"),
  },
});
defineType("ExistsTypeAnnotation", {
  aliases: ["Flow", "FlowType"],
});
defineType("FunctionTypeAnnotation", {
  visitor: ["typeParameters", "params", "rest", "returnType"],
  aliases: ["Flow", "FlowType"],
  fields: {
    typeParameters: validateOptionalType("TypeParameterDeclaration"),
    params: validate(arrayOfType("FunctionTypeParam")),
    rest: validateOptionalType("FunctionTypeParam"),
    returnType: validateType("FlowType"),
  },
});
defineType("FunctionTypeParam", {
  visitor: ["name", "typeAnnotation"],
  aliases: ["Flow"],
  fields: {
    name: validateOptionalType("Identifier"),
    typeAnnotation: validateType("FlowType"),
    optional: validateOptional(assertValueType("boolean")),
  },
});
defineType("GenericTypeAnnotation", {
  visitor: ["id", "typeParameters"],
  aliases: ["Flow", "FlowType"],
  fields: {
    id: validateType("Identifier"),
    typeParameters: validateOptionalType("TypeParameterInstantiation"),
  },
});
defineType("InferredPredicate", {
  aliases: ["Flow", "FlowPredicate"],
});
defineType("InterfaceExtends", {
  visitor: ["id", "typeParameters"],
  aliases: ["Flow"],
  fields: {
    id: validateType("Identifier"),
    typeParameters: validateOptionalType("TypeParameterInstantiation"),
  },
});
defineInterfaceishType("InterfaceDeclaration");
defineType("InterfaceTypeAnnotation", {
  visitor: ["extends", "body"],
  aliases: ["Flow", "FlowType"],
  fields: {
    extends: validateOptional(arrayOfType("InterfaceExtends")),
    body: validateType("ObjectTypeAnnotation"),
  },
});
defineType("IntersectionTypeAnnotation", {
  visitor: ["types"],
  aliases: ["Flow", "FlowType"],
  fields: {
    types: validate(arrayOfType("FlowType")),
  },
});
defineType("MixedTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"],
});
defineType("EmptyTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"],
});
defineType("NullableTypeAnnotation", {
  visitor: ["typeAnnotation"],
  aliases: ["Flow", "FlowType"],
  fields: {
    typeAnnotation: validateType("FlowType"),
  },
});
defineType("NumberLiteralTypeAnnotation", {
  builder: ["value"],
  aliases: ["Flow", "FlowType"],
  fields: {
    value: validate(assertValueType("number")),
  },
});
defineType("NumberTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"],
});
defineType("ObjectTypeAnnotation", {
  visitor: ["properties", "indexers", "callProperties", "internalSlots"],
  aliases: ["Flow", "FlowType"],
  builder: [
    "properties",
    "indexers",
    "callProperties",
    "internalSlots",
    "exact",
  ],
  fields: {
    properties: validate(
      arrayOfType(["ObjectTypeProperty", "ObjectTypeSpreadProperty"]),
    ),
    indexers: validateOptional(arrayOfType("ObjectTypeIndexer")),
    callProperties: validateOptional(arrayOfType("ObjectTypeCallProperty")),
    internalSlots: validateOptional(arrayOfType("ObjectTypeInternalSlot")),
    exact: {
      validate: assertValueType("boolean"),
      default: false,
    },
  },
});
defineType("ObjectTypeInternalSlot", {
  visitor: ["id", "value", "optional", "static", "method"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {
    id: validateType("Identifier"),
    value: validateType("FlowType"),
    optional: validate(assertValueType("boolean")),
    static: validate(assertValueType("boolean")),
    method: validate(assertValueType("boolean")),
  },
});
defineType("ObjectTypeCallProperty", {
  visitor: ["value"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {
    value: validateType("FlowType"),
    static: validate(assertValueType("boolean")),
  },
});
defineType("ObjectTypeIndexer", {
  visitor: ["id", "key", "value", "variance"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {
    id: validateOptionalType("Identifier"),
    key: validateType("FlowType"),
    value: validateType("FlowType"),
    static: validate(assertValueType("boolean")),
    variance: validateOptionalType("Variance"),
  },
});
defineType("ObjectTypeProperty", {
  visitor: ["key", "value", "variance"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {
    key: validateType(["Identifier", "StringLiteral"]),
    value: validateType("FlowType"),
    kind: validate(assertOneOf("init", "get", "set")),
    static: validate(assertValueType("boolean")),
    proto: validate(assertValueType("boolean")),
    optional: validate(assertValueType("boolean")),
    variance: validateOptionalType("Variance"),
  },
});
defineType("ObjectTypeSpreadProperty", {
  visitor: ["argument"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {
    argument: validateType("FlowType"),
  },
});
defineType("OpaqueType", {
  visitor: ["id", "typeParameters", "supertype", "impltype"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: validateType("Identifier"),
    typeParameters: validateOptionalType("TypeParameterDeclaration"),
    supertype: validateOptionalType("FlowType"),
    impltype: validateType("FlowType"),
  },
});
defineType("QualifiedTypeIdentifier", {
  visitor: ["id", "qualification"],
  aliases: ["Flow"],
  fields: {
    id: validateType("Identifier"),
    qualification: validateType(["Identifier", "QualifiedTypeIdentifier"]),
  },
});
defineType("StringLiteralTypeAnnotation", {
  builder: ["value"],
  aliases: ["Flow", "FlowType"],
  fields: {
    value: validate(assertValueType("string")),
  },
});
defineType("StringTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"],
});
defineType("ThisTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"],
});
defineType("TupleTypeAnnotation", {
  visitor: ["types"],
  aliases: ["Flow", "FlowType"],
  fields: {
    types: validate(arrayOfType("FlowType")),
  },
});
defineType("TypeofTypeAnnotation", {
  visitor: ["argument"],
  aliases: ["Flow", "FlowType"],
  fields: {
    argument: validateType("FlowType"),
  },
});
defineType("TypeAlias", {
  visitor: ["id", "typeParameters", "right"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: validateType("Identifier"),
    typeParameters: validateOptionalType("TypeParameterDeclaration"),
    right: validateType("FlowType"),
  },
});
defineType("TypeAnnotation", {
  aliases: ["Flow"],
  visitor: ["typeAnnotation"],
  fields: {
    typeAnnotation: validateType("FlowType"),
  },
});
defineType("TypeCastExpression", {
  visitor: ["expression", "typeAnnotation"],
  aliases: ["Flow", "ExpressionWrapper", "Expression"],
  fields: {
    expression: validateType("Expression"),
    typeAnnotation: validateType("TypeAnnotation"),
  },
});
defineType("TypeParameter", {
  aliases: ["Flow"],
  visitor: ["bound", "default", "variance"],
  fields: {
    name: validate(assertValueType("string")),
    bound: validateOptionalType("TypeAnnotation"),
    default: validateOptionalType("FlowType"),
    variance: validateOptionalType("Variance"),
  },
});
defineType("TypeParameterDeclaration", {
  aliases: ["Flow"],
  visitor: ["params"],
  fields: {
    params: validate(arrayOfType("TypeParameter")),
  },
});
defineType("TypeParameterInstantiation", {
  aliases: ["Flow"],
  visitor: ["params"],
  fields: {
    params: validate(arrayOfType("FlowType")),
  },
});
defineType("UnionTypeAnnotation", {
  visitor: ["types"],
  aliases: ["Flow", "FlowType"],
  fields: {
    types: validate(arrayOfType("FlowType")),
  },
});
defineType("Variance", {
  aliases: ["Flow"],
  builder: ["kind"],
  fields: {
    kind: validate(assertOneOf("minus", "plus")),
  },
});
defineType("VoidTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"],
});

// </from> /home/qfox/apps/babel/packages/babel-types/src/definitions/flow.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/definitions/es2015.js

// @flow
import defineType, {
  assertNodeType,
  assertValueType,
  chain,
  assertEach,
  assertOneOf,
} from "./utils";
import {
  functionCommon,
  functionTypeAnnotationCommon,
  patternLikeCommon,
} from "./core";
defineType("AssignmentPattern", {
  visitor: ["left", "right"],
  builder: ["left", "right"],
  aliases: ["Pattern", "PatternLike", "LVal"],
  fields: {
    ...patternLikeCommon,
    left: {
      validate: assertNodeType("Identifier", "ObjectPattern", "ArrayPattern"),
    },
    right: {
      validate: assertNodeType("Expression"),
    },
    decorators: {
      validate: chain(
        assertValueType("array"),
        assertEach(assertNodeType("Decorator")),
      ),
    },
  },
});
defineType("ArrayPattern", {
  visitor: ["elements", "typeAnnotation"],
  builder: ["elements"],
  aliases: ["Pattern", "PatternLike", "LVal"],
  fields: {
    ...patternLikeCommon,
    elements: {
      validate: chain(
        assertValueType("array"),
        assertEach(assertNodeType("PatternLike")),
      ),
    },
    decorators: {
      validate: chain(
        assertValueType("array"),
        assertEach(assertNodeType("Decorator")),
      ),
    },
  },
});
defineType("ArrowFunctionExpression", {
  builder: ["params", "body", "async"],
  visitor: ["params", "body", "returnType", "typeParameters"],
  aliases: [
    "Scopable",
    "Function",
    "BlockParent",
    "FunctionParent",
    "Expression",
    "Pureish",
  ],
  fields: {
    ...functionCommon,
    ...functionTypeAnnotationCommon,
    expression: {
      // https://github.com/babel/babylon/issues/505
      validate: assertValueType("boolean"),
    },
    body: {
      validate: assertNodeType("BlockStatement", "Expression"),
    },
  },
});
defineType("ClassBody", {
  visitor: ["body"],
  fields: {
    body: {
      validate: chain(
        assertValueType("array"),
        assertEach(
          assertNodeType(
            "ClassMethod",
            "ClassProperty",
            "ClassPrivateProperty",
            "TSDeclareMethod",
            "TSIndexSignature",
          ),
        ),
      ),
    },
  },
});
const classCommon = {
  typeParameters: {
    validate: assertNodeType(
      "TypeParameterDeclaration",
      "TSTypeParameterDeclaration",
      "Noop",
    ),
    optional: true,
  },
  body: {
    validate: assertNodeType("ClassBody"),
  },
  superClass: {
    optional: true,
    validate: assertNodeType("Expression"),
  },
  superTypeParameters: {
    validate: assertNodeType(
      "TypeParameterInstantiation",
      "TSTypeParameterInstantiation",
    ),
    optional: true,
  },
  implements: {
    validate: chain(
      assertValueType("array"),
      assertEach(
        assertNodeType("TSExpressionWithTypeArguments", "ClassImplements"),
      ),
    ),
    optional: true,
  },
};
defineType("ClassDeclaration", {
  builder: ["id", "superClass", "body", "decorators"],
  visitor: [
    "id",
    "body",
    "superClass",
    "mixins",
    "typeParameters",
    "superTypeParameters",
    "implements",
    "decorators",
  ],
  aliases: ["Scopable", "Class", "Statement", "Declaration", "Pureish"],
  fields: {
    ...classCommon,
    declare: {
      validate: assertValueType("boolean"),
      optional: true,
    },
    abstract: {
      validate: assertValueType("boolean"),
      optional: true,
    },
    id: {
      validate: assertNodeType("Identifier"),
      optional: true, // Missing if this is the child of an ExportDefaultDeclaration.
    },
    decorators: {
      validate: chain(
        assertValueType("array"),
        assertEach(assertNodeType("Decorator")),
      ),
      optional: true,
    },
  },
});
defineType("ClassExpression", {
  inherits: "ClassDeclaration",
  aliases: ["Scopable", "Class", "Expression", "Pureish"],
  fields: {
    ...classCommon,
    id: {
      optional: true,
      validate: assertNodeType("Identifier"),
    },
    body: {
      validate: assertNodeType("ClassBody"),
    },
    superClass: {
      optional: true,
      validate: assertNodeType("Expression"),
    },
    decorators: {
      validate: chain(
        assertValueType("array"),
        assertEach(assertNodeType("Decorator")),
      ),
      optional: true,
    },
  },
});
defineType("ExportAllDeclaration", {
  visitor: ["source"],
  aliases: [
    "Statement",
    "Declaration",
    "ModuleDeclaration",
    "ExportDeclaration",
  ],
  fields: {
    source: {
      validate: assertNodeType("StringLiteral"),
    },
  },
});
defineType("ExportDefaultDeclaration", {
  visitor: ["declaration"],
  aliases: [
    "Statement",
    "Declaration",
    "ModuleDeclaration",
    "ExportDeclaration",
  ],
  fields: {
    declaration: {
      validate: assertNodeType(
        "FunctionDeclaration",
        "TSDeclareFunction",
        "ClassDeclaration",
        "Expression",
      ),
    },
  },
});
defineType("ExportNamedDeclaration", {
  visitor: ["declaration", "specifiers", "source"],
  aliases: [
    "Statement",
    "Declaration",
    "ModuleDeclaration",
    "ExportDeclaration",
  ],
  fields: {
    declaration: {
      validate: assertNodeType("Declaration"),
      optional: true,
    },
    specifiers: {
      validate: chain(
        assertValueType("array"),
        assertEach(
          assertNodeType(
            "ExportSpecifier",
            "ExportDefaultSpecifier",
            "ExportNamespaceSpecifier",
          ),
        ),
      ),
    },
    source: {
      validate: assertNodeType("StringLiteral"),
      optional: true,
    },
  },
});
defineType("ExportSpecifier", {
  visitor: ["local", "exported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: assertNodeType("Identifier"),
    },
    exported: {
      validate: assertNodeType("Identifier"),
    },
  },
});
defineType("ForOfStatement", {
  visitor: ["left", "right", "body"],
  aliases: [
    "Scopable",
    "Statement",
    "For",
    "BlockParent",
    "Loop",
    "ForXStatement",
  ],
  fields: {
    left: {
      validate: assertNodeType("VariableDeclaration", "LVal"),
    },
    right: {
      validate: assertNodeType("Expression"),
    },
    body: {
      validate: assertNodeType("Statement"),
    },
    await: {
      default: false,
      validate: assertValueType("boolean"),
    },
  },
});
defineType("ImportDeclaration", {
  visitor: ["specifiers", "source"],
  aliases: ["Statement", "Declaration", "ModuleDeclaration"],
  fields: {
    specifiers: {
      validate: chain(
        assertValueType("array"),
        assertEach(
          assertNodeType(
            "ImportSpecifier",
            "ImportDefaultSpecifier",
            "ImportNamespaceSpecifier",
          ),
        ),
      ),
    },
    source: {
      validate: assertNodeType("StringLiteral"),
    },
  },
});
defineType("ImportDefaultSpecifier", {
  visitor: ["local"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: assertNodeType("Identifier"),
    },
  },
});
defineType("ImportNamespaceSpecifier", {
  visitor: ["local"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: assertNodeType("Identifier"),
    },
  },
});
defineType("ImportSpecifier", {
  visitor: ["local", "imported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: assertNodeType("Identifier"),
    },
    imported: {
      validate: assertNodeType("Identifier"),
    },
    importKind: {
      // Handle Flowtype's extension "import {typeof foo} from"
      validate: assertOneOf(null, "type", "typeof"),
    },
  },
});
defineType("MetaProperty", {
  visitor: ["meta", "property"],
  aliases: ["Expression"],
  fields: {
    // todo: limit to new.target
    meta: {
      validate: assertNodeType("Identifier"),
    },
    property: {
      validate: assertNodeType("Identifier"),
    },
  },
});
export const classMethodOrPropertyCommon = {
  abstract: {
    validate: assertValueType("boolean"),
    optional: true,
  },
  accessibility: {
    validate: chain(
      assertValueType("string"),
      assertOneOf("public", "private", "protected"),
    ),
    optional: true,
  },
  static: {
    validate: assertValueType("boolean"),
    optional: true,
  },
  computed: {
    default: false,
    validate: assertValueType("boolean"),
  },
  optional: {
    validate: assertValueType("boolean"),
    optional: true,
  },
  key: {
    validate: chain(
      (function() {
        const normal = assertNodeType(
          "Identifier",
          "StringLiteral",
          "NumericLiteral",
        );
        const computed = assertNodeType("Expression");
        return function(node: Object, key: string, val: any) {
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
        };
      })(),
      assertNodeType(
        "Identifier",
        "StringLiteral",
        "NumericLiteral",
        "Expression",
      ),
    ),
  },
};
export const classMethodOrDeclareMethodCommon = {
  ...functionCommon,
  ...classMethodOrPropertyCommon,
  kind: {
    validate: chain(
      assertValueType("string"),
      assertOneOf("get", "set", "method", "constructor"),
    ),
    default: "method",
  },
  access: {
    validate: chain(
      assertValueType("string"),
      assertOneOf("public", "private", "protected"),
    ),
    optional: true,
  },
  decorators: {
    validate: chain(
      assertValueType("array"),
      assertEach(assertNodeType("Decorator")),
    ),
    optional: true,
  },
};
defineType("ClassMethod", {
  aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
  builder: ["kind", "key", "params", "body", "computed", "static"],
  visitor: [
    "key",
    "params",
    "body",
    "decorators",
    "returnType",
    "typeParameters",
  ],
  fields: {
    ...classMethodOrDeclareMethodCommon,
    ...functionTypeAnnotationCommon,
    body: {
      validate: assertNodeType("BlockStatement"),
    },
  },
});
defineType("ObjectPattern", {
  visitor: ["properties", "typeAnnotation"],
  builder: ["properties"],
  aliases: ["Pattern", "PatternLike", "LVal"],
  fields: {
    ...patternLikeCommon,
    properties: {
      validate: chain(
        assertValueType("array"),
        assertEach(assertNodeType("RestElement", "ObjectProperty")),
      ),
    },
  },
});
defineType("SpreadElement", {
  visitor: ["argument"],
  aliases: ["UnaryLike"],
  deprecatedAlias: "SpreadProperty",
  fields: {
    argument: {
      validate: assertNodeType("Expression"),
    },
  },
});
defineType("Super", {
  aliases: ["Expression"],
});
defineType("TaggedTemplateExpression", {
  visitor: ["tag", "quasi"],
  aliases: ["Expression"],
  fields: {
    tag: {
      validate: assertNodeType("Expression"),
    },
    quasi: {
      validate: assertNodeType("TemplateLiteral"),
    },
    typeParameters: {
      validate: assertNodeType(
        "TypeParameterInstantiation",
        "TSTypeParameterInstantiation",
      ),
      optional: true,
    },
  },
});
defineType("TemplateElement", {
  builder: ["value", "tail"],
  fields: {
    value: {
      // todo: flatten `raw` into main node
    },
    tail: {
      validate: assertValueType("boolean"),
      default: false,
    },
  },
});
defineType("TemplateLiteral", {
  visitor: ["quasis", "expressions"],
  aliases: ["Expression", "Literal"],
  fields: {
    quasis: {
      validate: chain(
        assertValueType("array"),
        assertEach(assertNodeType("TemplateElement")),
      ),
    },
    expressions: {
      validate: chain(
        assertValueType("array"),
        assertEach(assertNodeType("Expression")),
      ),
    },
  },
});
defineType("YieldExpression", {
  builder: ["argument", "delegate"],
  visitor: ["argument"],
  aliases: ["Expression", "Terminatorless"],
  fields: {
    delegate: {
      validate: assertValueType("boolean"),
      default: false,
    },
    argument: {
      optional: true,
      validate: assertNodeType("Expression"),
    },
  },
});

// </from> /home/qfox/apps/babel/packages/babel-types/src/definitions/es2015.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/definitions/typescript.js

// @flow
import defineType, {
  arrayOfType,
  assertEach,
  assertNodeType,
  assertOneOf,
  assertValueType,
  chain,
  validate,
  validateArrayOfType,
  validateOptional,
  validateOptionalType,
  validateType,
} from "./utils";
import { functionDeclarationCommon } from "./core";
import { classMethodOrDeclareMethodCommon } from "./es2015";
const bool = assertValueType("boolean");
const tSFunctionTypeAnnotationCommon = {
  returnType: {
    validate: assertNodeType("TSTypeAnnotation", "Noop"),
    optional: true,
  },
  typeParameters: {
    validate: assertNodeType("TSTypeParameterDeclaration", "Noop"),
    optional: true,
  },
};
defineType("TSParameterProperty", {
  aliases: ["LVal"], // TODO: This isn't usable in general as an LVal. Should have a "Parameter" alias.
  visitor: ["parameter"],
  fields: {
    accessibility: {
      validate: assertOneOf("public", "private", "protected"),
      optional: true,
    },
    readonly: {
      validate: assertValueType("boolean"),
      optional: true,
    },
    parameter: {
      validate: assertNodeType("Identifier", "AssignmentPattern"),
    },
  },
});
defineType("TSDeclareFunction", {
  aliases: ["Statement", "Declaration"],
  visitor: ["id", "typeParameters", "params", "returnType"],
  fields: {
    ...functionDeclarationCommon,
    ...tSFunctionTypeAnnotationCommon,
  },
});
defineType("TSDeclareMethod", {
  visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
  fields: {
    ...classMethodOrDeclareMethodCommon,
    ...tSFunctionTypeAnnotationCommon,
  },
});
defineType("TSQualifiedName", {
  aliases: ["TSEntityName"],
  visitor: ["left", "right"],
  fields: {
    left: validateType("TSEntityName"),
    right: validateType("Identifier"),
  },
});
const signatureDeclarationCommon = {
  typeParameters: validateOptionalType("TSTypeParameterDeclaration"),
  parameters: validateArrayOfType(["Identifier", "RestElement"]),
  typeAnnotation: validateOptionalType("TSTypeAnnotation"),
};
const callConstructSignatureDeclaration = {
  aliases: ["TSTypeElement"],
  visitor: ["typeParameters", "parameters", "typeAnnotation"],
  fields: signatureDeclarationCommon,
};
defineType("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
defineType(
  "TSConstructSignatureDeclaration",
  callConstructSignatureDeclaration,
);
const namedTypeElementCommon = {
  key: validateType("Expression"),
  computed: validate(bool),
  optional: validateOptional(bool),
};
defineType("TSPropertySignature", {
  aliases: ["TSTypeElement"],
  visitor: ["key", "typeAnnotation", "initializer"],
  fields: {
    ...namedTypeElementCommon,
    readonly: validateOptional(bool),
    typeAnnotation: validateOptionalType("TSTypeAnnotation"),
    initializer: validateOptionalType("Expression"),
  },
});
defineType("TSMethodSignature", {
  aliases: ["TSTypeElement"],
  visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
  fields: {
    ...signatureDeclarationCommon,
    ...namedTypeElementCommon,
  },
});
defineType("TSIndexSignature", {
  aliases: ["TSTypeElement"],
  visitor: ["parameters", "typeAnnotation"],
  fields: {
    readonly: validateOptional(bool),
    parameters: validateArrayOfType("Identifier"), // Length must be 1
    typeAnnotation: validateOptionalType("TSTypeAnnotation"),
  },
});
const tsKeywordTypes = [
  "TSAnyKeyword",
  "TSUnknownKeyword",
  "TSNumberKeyword",
  "TSObjectKeyword",
  "TSBooleanKeyword",
  "TSStringKeyword",
  "TSSymbolKeyword",
  "TSVoidKeyword",
  "TSUndefinedKeyword",
  "TSNullKeyword",
  "TSNeverKeyword",
];
for (const type of tsKeywordTypes) {
  defineType(type, {
    aliases: ["TSType"],
    visitor: [],
    fields: {},
  });
}
defineType("TSThisType", {
  aliases: ["TSType"],
  visitor: [],
  fields: {},
});
const fnOrCtr = {
  aliases: ["TSType"],
  visitor: ["typeParameters", "typeAnnotation"],
  fields: signatureDeclarationCommon,
};
defineType("TSFunctionType", fnOrCtr);
defineType("TSConstructorType", fnOrCtr);
defineType("TSTypeReference", {
  aliases: ["TSType"],
  visitor: ["typeName", "typeParameters"],
  fields: {
    typeName: validateType("TSEntityName"),
    typeParameters: validateOptionalType("TSTypeParameterInstantiation"),
  },
});
defineType("TSTypePredicate", {
  aliases: ["TSType"],
  visitor: ["parameterName", "typeAnnotation"],
  fields: {
    parameterName: validateType(["Identifier", "TSThisType"]),
    typeAnnotation: validateType("TSTypeAnnotation"),
  },
});
defineType("TSTypeQuery", {
  aliases: ["TSType"],
  visitor: ["exprName"],
  fields: {
    exprName: validateType("TSEntityName"),
  },
});
defineType("TSTypeLiteral", {
  aliases: ["TSType"],
  visitor: ["members"],
  fields: {
    members: validateArrayOfType("TSTypeElement"),
  },
});
defineType("TSArrayType", {
  aliases: ["TSType"],
  visitor: ["elementType"],
  fields: {
    elementType: validateType("TSType"),
  },
});
defineType("TSTupleType", {
  aliases: ["TSType"],
  visitor: ["elementTypes"],
  fields: {
    elementTypes: validateArrayOfType("TSType"),
  },
});
defineType("TSOptionalType", {
  aliases: ["TSType"],
  visitor: ["typeAnnotation"],
  fields: {
    typeAnnotation: validateType("TSType"),
  },
});
const unionOrIntersection = {
  aliases: ["TSType"],
  visitor: ["types"],
  fields: {
    types: validateArrayOfType("TSType"),
  },
};
defineType("TSUnionType", unionOrIntersection);
defineType("TSIntersectionType", unionOrIntersection);
defineType("TSConditionalType", {
  aliases: ["TSType"],
  visitor: ["checkType", "extendsType", "trueType", "falseType"],
  fields: {
    checkType: validateType("TSType"),
    extendsType: validateType("TSType"),
    trueType: validateType("TSType"),
    falseType: validateType("TSType"),
  },
});
defineType("TSInferType", {
  aliases: ["TSType"],
  visitor: ["typeParameter"],
  fields: {
    typeParameter: validateType("TSTypeParameter"),
  },
});
defineType("TSParenthesizedType", {
  aliases: ["TSType"],
  visitor: ["typeAnnotation"],
  fields: {
    typeAnnotation: validateType("TSType"),
  },
});
defineType("TSTypeOperator", {
  aliases: ["TSType"],
  visitor: ["typeAnnotation"],
  fields: {
    operator: validate(assertValueType("string")),
    typeAnnotation: validateType("TSType"),
  },
});
defineType("TSIndexedAccessType", {
  aliases: ["TSType"],
  visitor: ["objectType", "indexType"],
  fields: {
    objectType: validateType("TSType"),
    indexType: validateType("TSType"),
  },
});
defineType("TSMappedType", {
  aliases: ["TSType"],
  visitor: ["typeParameter", "typeAnnotation"],
  fields: {
    readonly: validateOptional(bool),
    typeParameter: validateType("TSTypeParameter"),
    optional: validateOptional(bool),
    typeAnnotation: validateOptionalType("TSType"),
  },
});
defineType("TSLiteralType", {
  aliases: ["TSType"],
  visitor: ["literal"],
  fields: {
    literal: validateType([
      "NumericLiteral",
      "StringLiteral",
      "BooleanLiteral",
    ]),
  },
});
defineType("TSExpressionWithTypeArguments", {
  aliases: ["TSType"],
  visitor: ["expression", "typeParameters"],
  fields: {
    expression: validateType("TSEntityName"),
    typeParameters: validateOptionalType("TSTypeParameterInstantiation"),
  },
});
defineType("TSInterfaceDeclaration", {
  // "Statement" alias prevents a semicolon from appearing after it in an export declaration.
  aliases: ["Statement", "Declaration"],
  visitor: ["id", "typeParameters", "extends", "body"],
  fields: {
    declare: validateOptional(bool),
    id: validateType("Identifier"),
    typeParameters: validateOptionalType("TSTypeParameterDeclaration"),
    extends: validateOptional(arrayOfType("TSExpressionWithTypeArguments")),
    body: validateType("TSInterfaceBody"),
  },
});
defineType("TSInterfaceBody", {
  visitor: ["body"],
  fields: {
    body: validateArrayOfType("TSTypeElement"),
  },
});
defineType("TSTypeAliasDeclaration", {
  aliases: ["Statement", "Declaration"],
  visitor: ["id", "typeParameters", "typeAnnotation"],
  fields: {
    declare: validateOptional(bool),
    id: validateType("Identifier"),
    typeParameters: validateOptionalType("TSTypeParameterDeclaration"),
    typeAnnotation: validateType("TSType"),
  },
});
defineType("TSAsExpression", {
  aliases: ["Expression"],
  visitor: ["expression", "typeAnnotation"],
  fields: {
    expression: validateType("Expression"),
    typeAnnotation: validateType("TSType"),
  },
});
defineType("TSTypeAssertion", {
  aliases: ["Expression"],
  visitor: ["typeAnnotation", "expression"],
  fields: {
    typeAnnotation: validateType("TSType"),
    expression: validateType("Expression"),
  },
});
defineType("TSEnumDeclaration", {
  // "Statement" alias prevents a semicolon from appearing after it in an export declaration.
  aliases: ["Statement", "Declaration"],
  visitor: ["id", "members"],
  fields: {
    declare: validateOptional(bool),
    const: validateOptional(bool),
    id: validateType("Identifier"),
    members: validateArrayOfType("TSEnumMember"),
    initializer: validateOptionalType("Expression"),
  },
});
defineType("TSEnumMember", {
  visitor: ["id", "initializer"],
  fields: {
    id: validateType(["Identifier", "StringLiteral"]),
    initializer: validateOptionalType("Expression"),
  },
});
defineType("TSModuleDeclaration", {
  aliases: ["Statement", "Declaration"],
  visitor: ["id", "body"],
  fields: {
    declare: validateOptional(bool),
    global: validateOptional(bool),
    id: validateType(["Identifier", "StringLiteral"]),
    body: validateType(["TSModuleBlock", "TSModuleDeclaration"]),
  },
});
defineType("TSModuleBlock", {
  visitor: ["body"],
  fields: {
    body: validateArrayOfType("Statement"),
  },
});
defineType("TSImportEqualsDeclaration", {
  aliases: ["Statement"],
  visitor: ["id", "moduleReference"],
  fields: {
    isExport: validate(bool),
    id: validateType("Identifier"),
    moduleReference: validateType([
      "TSEntityName",
      "TSExternalModuleReference",
    ]),
  },
});
defineType("TSExternalModuleReference", {
  visitor: ["expression"],
  fields: {
    expression: validateType("StringLiteral"),
  },
});
defineType("TSNonNullExpression", {
  aliases: ["Expression"],
  visitor: ["expression"],
  fields: {
    expression: validateType("Expression"),
  },
});
defineType("TSExportAssignment", {
  aliases: ["Statement"],
  visitor: ["expression"],
  fields: {
    expression: validateType("Expression"),
  },
});
defineType("TSNamespaceExportDeclaration", {
  aliases: ["Statement"],
  visitor: ["id"],
  fields: {
    id: validateType("Identifier"),
  },
});
defineType("TSTypeAnnotation", {
  visitor: ["typeAnnotation"],
  fields: {
    typeAnnotation: {
      validate: assertNodeType("TSType"),
    },
  },
});
defineType("TSTypeParameterInstantiation", {
  visitor: ["params"],
  fields: {
    params: {
      validate: chain(
        assertValueType("array"),
        assertEach(assertNodeType("TSType")),
      ),
    },
  },
});
defineType("TSTypeParameterDeclaration", {
  visitor: ["params"],
  fields: {
    params: {
      validate: chain(
        assertValueType("array"),
        assertEach(assertNodeType("TSTypeParameter")),
      ),
    },
  },
});
defineType("TSTypeParameter", {
  visitor: ["constraint", "default"],
  fields: {
    name: {
      validate: assertValueType("string"),
    },
    constraint: {
      validate: assertNodeType("TSType"),
      optional: true,
    },
    default: {
      validate: assertNodeType("TSType"),
      optional: true,
    },
  },
});

// </from> /home/qfox/apps/babel/packages/babel-types/src/definitions/typescript.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/definitions/jsx.js

// @flow
import defineType, {
  assertNodeType,
  assertValueType,
  chain,
  assertEach,
} from "./utils";
defineType("JSXAttribute", {
  visitor: ["name", "value"],
  aliases: ["JSX", "Immutable"],
  fields: {
    name: {
      validate: assertNodeType("JSXIdentifier", "JSXNamespacedName"),
    },
    value: {
      optional: true,
      validate: assertNodeType(
        "JSXElement",
        "JSXFragment",
        "StringLiteral",
        "JSXExpressionContainer",
      ),
    },
  },
});
defineType("JSXClosingElement", {
  visitor: ["name"],
  aliases: ["JSX", "Immutable"],
  fields: {
    name: {
      validate: assertNodeType("JSXIdentifier", "JSXMemberExpression"),
    },
  },
});
defineType("JSXElement", {
  builder: ["openingElement", "closingElement", "children", "selfClosing"],
  visitor: ["openingElement", "children", "closingElement"],
  aliases: ["JSX", "Immutable", "Expression"],
  fields: {
    openingElement: {
      validate: assertNodeType("JSXOpeningElement"),
    },
    closingElement: {
      optional: true,
      validate: assertNodeType("JSXClosingElement"),
    },
    children: {
      validate: chain(
        assertValueType("array"),
        assertEach(
          assertNodeType(
            "JSXText",
            "JSXExpressionContainer",
            "JSXSpreadChild",
            "JSXElement",
            "JSXFragment",
          ),
        ),
      ),
    },
  },
});
defineType("JSXEmptyExpression", {
  aliases: ["JSX"],
});
defineType("JSXExpressionContainer", {
  visitor: ["expression"],
  aliases: ["JSX", "Immutable"],
  fields: {
    expression: {
      validate: assertNodeType("Expression"),
    },
  },
});
defineType("JSXSpreadChild", {
  visitor: ["expression"],
  aliases: ["JSX", "Immutable"],
  fields: {
    expression: {
      validate: assertNodeType("Expression"),
    },
  },
});
defineType("JSXIdentifier", {
  builder: ["name"],
  aliases: ["JSX"],
  fields: {
    name: {
      validate: assertValueType("string"),
    },
  },
});
defineType("JSXMemberExpression", {
  visitor: ["object", "property"],
  aliases: ["JSX"],
  fields: {
    object: {
      validate: assertNodeType("JSXMemberExpression", "JSXIdentifier"),
    },
    property: {
      validate: assertNodeType("JSXIdentifier"),
    },
  },
});
defineType("JSXNamespacedName", {
  visitor: ["namespace", "name"],
  aliases: ["JSX"],
  fields: {
    namespace: {
      validate: assertNodeType("JSXIdentifier"),
    },
    name: {
      validate: assertNodeType("JSXIdentifier"),
    },
  },
});
defineType("JSXOpeningElement", {
  builder: ["name", "attributes", "selfClosing"],
  visitor: ["name", "attributes"],
  aliases: ["JSX", "Immutable"],
  fields: {
    name: {
      validate: assertNodeType("JSXIdentifier", "JSXMemberExpression"),
    },
    selfClosing: {
      default: false,
      validate: assertValueType("boolean"),
    },
    attributes: {
      validate: chain(
        assertValueType("array"),
        assertEach(assertNodeType("JSXAttribute", "JSXSpreadAttribute")),
      ),
    },
    typeParameters: {
      validate: assertNodeType(
        "TypeParameterInstantiation",
        "TSTypeParameterInstantiation",
      ),
      optional: true,
    },
  },
});
defineType("JSXSpreadAttribute", {
  visitor: ["argument"],
  aliases: ["JSX"],
  fields: {
    argument: {
      validate: assertNodeType("Expression"),
    },
  },
});
defineType("JSXText", {
  aliases: ["JSX", "Immutable"],
  builder: ["value"],
  fields: {
    value: {
      validate: assertValueType("string"),
    },
  },
});
defineType("JSXFragment", {
  builder: ["openingFragment", "closingFragment", "children"],
  visitor: ["openingFragment", "children", "closingFragment"],
  aliases: ["JSX", "Immutable", "Expression"],
  fields: {
    openingFragment: {
      validate: assertNodeType("JSXOpeningFragment"),
    },
    closingFragment: {
      validate: assertNodeType("JSXClosingFragment"),
    },
    children: {
      validate: chain(
        assertValueType("array"),
        assertEach(
          assertNodeType(
            "JSXText",
            "JSXExpressionContainer",
            "JSXSpreadChild",
            "JSXElement",
            "JSXFragment",
          ),
        ),
      ),
    },
  },
});
defineType("JSXOpeningFragment", {
  aliases: ["JSX", "Immutable"],
});
defineType("JSXClosingFragment", {
  aliases: ["JSX", "Immutable"],
});

// </from> /home/qfox/apps/babel/packages/babel-types/src/definitions/jsx.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/definitions/utils.js

// @flow
import is from "../validators/is";
export const VISITOR_KEYS: { [string]: Array<string> } = {};
export const ALIAS_KEYS: { [string]: Array<string> } = {};
export const FLIPPED_ALIAS_KEYS: { [string]: Array<string> } = {};
export const NODE_FIELDS: { [string]: {} } = {};
export const BUILDER_KEYS: { [string]: Array<string> } = {};
export const DEPRECATED_KEYS: { [string]: string } = {};
function getType(val) {
  if (Array.isArray(val)) {
    return "array";
  } else if (val === null) {
    return "null";
  } else if (val === undefined) {
    return "undefined";
  } else {
    return typeof val;
  }
}
// TODO: Import and use Node instead of any
type Validator = (any, string, any) => void;
type FieldOptions = {
  default?: any,
  optional?: boolean,
  validate?: Validator,
};
export function validate(validate: Validator): FieldOptions {
  return { validate };
}
export function typeIs(typeName: string | string[]) {
  return typeof typeName === "string"
    ? assertNodeType(typeName)
    : assertNodeType(...typeName);
}
export function validateType(typeName: string | string[]) {
  return validate(typeIs(typeName));
}
export function validateOptional(validate: Validator): FieldOptions {
  return { validate, optional: true };
}
export function validateOptionalType(
  typeName: string | string[],
): FieldOptions {
  return { validate: typeIs(typeName), optional: true };
}
export function arrayOf(elementType: Validator): Validator {
  return chain(assertValueType("array"), assertEach(elementType));
}
export function arrayOfType(typeName: string | string[]) {
  return arrayOf(typeIs(typeName));
}
export function validateArrayOfType(typeName: string | string[]) {
  return validate(arrayOfType(typeName));
}
export function assertEach(callback: Validator): Validator {
  function validator(node, key, val) {
    if (!Array.isArray(val)) return;
    for (let i = 0; i < val.length; i++) {
      callback(node, `${key}[${i}]`, val[i]);
    }
  }
  validator.each = callback;
  return validator;
}
export function assertOneOf(...values: Array<any>): Validator {
  function validate(node: Object, key: string, val: any) {
    if (values.indexOf(val) < 0) {
      throw new TypeError(
        `Property ${key} expected value to be one of ${JSON.stringify(
          values,
        )} but got ${JSON.stringify(val)}`,
      );
    }
  }
  validate.oneOf = values;
  return validate;
}
export function assertNodeType(...types: Array<string>): Validator {
  function validate(node, key, val) {
    let valid = false;
    for (const type of types) {
      if (is(type, val)) {
        valid = true;
        break;
      }
    }
    if (!valid) {
      throw new TypeError(
        `Property ${key} of ${
          node.type
        } expected node to be of a type ${JSON.stringify(types)} ` +
          `but instead got ${JSON.stringify(val && val.type)}`,
      );
    }
  }
  validate.oneOfNodeTypes = types;
  return validate;
}
export function assertNodeOrValueType(...types: Array<string>): Validator {
  function validate(node, key, val) {
    let valid = false;
    for (const type of types) {
      if (getType(val) === type || is(type, val)) {
        valid = true;
        break;
      }
    }
    if (!valid) {
      throw new TypeError(
        `Property ${key} of ${
          node.type
        } expected node to be of a type ${JSON.stringify(types)} ` +
          `but instead got ${JSON.stringify(val && val.type)}`,
      );
    }
  }
  validate.oneOfNodeOrValueTypes = types;
  return validate;
}
export function assertValueType(type: string): Validator {
  function validate(node, key, val) {
    const valid = getType(val) === type;
    if (!valid) {
      throw new TypeError(
        `Property ${key} expected type of ${type} but got ${getType(val)}`,
      );
    }
  }
  validate.type = type;
  return validate;
}
export function chain(...fns: Array<Validator>): Validator {
  function validate(...args) {
    for (const fn of fns) {
      fn(...args);
    }
  }
  validate.chainOf = fns;
  return validate;
}
export default function defineType(
  type: string,
  opts: {
    fields?: {
      [string]: FieldOptions,
    },
    visitor?: Array<string>,
    aliases?: Array<string>,
    builder?: Array<string>,
    inherits?: string,
    deprecatedAlias?: string,
  } = {},
) {
  const inherits = (opts.inherits && store[opts.inherits]) || {};
  const fields: Object = opts.fields || inherits.fields || {};
  const visitor: Array<string> = opts.visitor || inherits.visitor || [];
  const aliases: Array<string> = opts.aliases || inherits.aliases || [];
  const builder: Array<string> =
    opts.builder || inherits.builder || opts.visitor || [];
  if (opts.deprecatedAlias) {
    DEPRECATED_KEYS[opts.deprecatedAlias] = type;
  }
  // ensure all field keys are represented in `fields`
  for (const key of (visitor.concat(builder): Array<string>)) {
    fields[key] = fields[key] || {};
  }
  for (const key in fields) {
    const field = fields[key];
    if (builder.indexOf(key) === -1) {
      field.optional = true;
    }
    if (field.default === undefined) {
      field.default = null;
    } else if (!field.validate) {
      field.validate = assertValueType(getType(field.default));
    }
  }
  VISITOR_KEYS[type] = opts.visitor = visitor;
  BUILDER_KEYS[type] = opts.builder = builder;
  NODE_FIELDS[type] = opts.fields = fields;
  ALIAS_KEYS[type] = opts.aliases = aliases;
  aliases.forEach(alias => {
    FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
    FLIPPED_ALIAS_KEYS[alias].push(type);
  });
  store[type] = opts;
}
const store = {};

// </from> /home/qfox/apps/babel/packages/babel-types/src/definitions/utils.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/comments/addComments.js

// @flow
/**
 * Add comments of certain type to a node.
 */
export default function addComments<T: Object>(
  node: T,
  type: string,
  comments: Array<Object>,
): T {
  if (!comments || !node) return node;
  const key = `${type}Comments`;
  if (node[key]) {
    if (type === "leading") {
      node[key] = comments.concat(node[key]);
    } else {
      node[key] = node[key].concat(comments);
    }
  } else {
    node[key] = comments;
  }
  return node;
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/comments/addComments.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/comments/inheritTrailingComments.js

// @flow
import inherit from "../utils/inherit";
export default function inheritTrailingComments(
  child: Object,
  parent: Object,
): void {
  inherit("trailingComments", child, parent);
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/comments/inheritTrailingComments.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/comments/removeComments.js

// @flow
import { COMMENT_KEYS } from "../constants";
/**
 * Remove comment properties from a node.
 */
export default function removeComments<T: Object>(node: T): T {
  COMMENT_KEYS.forEach(key => {
    node[key] = null;
  });
  return node;
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/comments/removeComments.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/comments/inheritLeadingComments.js

// @flow
import inherit from "../utils/inherit";
export default function inheritLeadingComments(
  child: Object,
  parent: Object,
): void {
  inherit("leadingComments", child, parent);
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/comments/inheritLeadingComments.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/comments/inheritsComments.js

// @flow
import inheritTrailingComments from "./inheritTrailingComments";
import inheritLeadingComments from "./inheritLeadingComments";
import inheritInnerComments from "./inheritInnerComments";
/**
 * Inherit all unique comments from `parent` node to `child` node.
 */
export default function inheritsComments<T: Object>(
  child: T,
  parent: Object,
): T {
  inheritTrailingComments(child, parent);
  inheritLeadingComments(child, parent);
  inheritInnerComments(child, parent);
  return child;
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/comments/inheritsComments.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/comments/addComment.js

// @flow
import addComments from "./addComments";
/**
 * Add comment of certain type to a node.
 */
export default function addComment<T: Object>(
  node: T,
  type: string,
  content: string,
  line?: boolean,
): T {
  return addComments(node, type, [
    {
      type: line ? "CommentLine" : "CommentBlock",
      value: content,
    },
  ]);
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/comments/addComment.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/comments/inheritInnerComments.js

// @flow
import inherit from "../utils/inherit";
export default function inheritInnerComments(
  child: Object,
  parent: Object,
): void {
  inherit("innerComments", child, parent);
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/comments/inheritInnerComments.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/constants/index.js

// @flow
export const STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
export const FLATTENABLE_KEYS = ["body", "expressions"];
export const FOR_INIT_KEYS = ["left", "init"];
export const COMMENT_KEYS = [
  "leadingComments",
  "trailingComments",
  "innerComments",
];
export const LOGICAL_OPERATORS = ["||", "&&", "??"];
export const UPDATE_OPERATORS = ["++", "--"];
export const BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
export const EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
export const COMPARISON_BINARY_OPERATORS = [
  ...EQUALITY_BINARY_OPERATORS,
  "in",
  "instanceof",
];
export const BOOLEAN_BINARY_OPERATORS = [
  ...COMPARISON_BINARY_OPERATORS,
  ...BOOLEAN_NUMBER_BINARY_OPERATORS,
];
export const NUMBER_BINARY_OPERATORS = [
  "-",
  "/",
  "%",
  "*",
  "**",
  "&",
  "|",
  ">>",
  ">>>",
  "<<",
  "^",
];
export const BINARY_OPERATORS = [
  "+",
  ...NUMBER_BINARY_OPERATORS,
  ...BOOLEAN_BINARY_OPERATORS,
];
export const BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
export const NUMBER_UNARY_OPERATORS = ["+", "-", "~"];
export const STRING_UNARY_OPERATORS = ["typeof"];
export const UNARY_OPERATORS = [
  "void",
  "throw",
  ...BOOLEAN_UNARY_OPERATORS,
  ...NUMBER_UNARY_OPERATORS,
  ...STRING_UNARY_OPERATORS,
];
export const INHERIT_KEYS = {
  optional: ["typeAnnotation", "typeParameters", "returnType"],
  force: ["start", "loc", "end"],
};
export const BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
export const NOT_LOCAL_BINDING = Symbol.for(
  "should not be considered a local binding",
);

// </from> /home/qfox/apps/babel/packages/babel-types/src/constants/index.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/constants/generated/index.js

// @flow
/*
 * This file is auto-generated! Do not modify it directly.
 * To re-generate run 'make build'
 */
import { FLIPPED_ALIAS_KEYS } from "../../definitions";
export const EXPRESSION_TYPES = FLIPPED_ALIAS_KEYS["Expression"];
export const BINARY_TYPES = FLIPPED_ALIAS_KEYS["Binary"];
export const SCOPABLE_TYPES = FLIPPED_ALIAS_KEYS["Scopable"];
export const BLOCKPARENT_TYPES = FLIPPED_ALIAS_KEYS["BlockParent"];
export const BLOCK_TYPES = FLIPPED_ALIAS_KEYS["Block"];
export const STATEMENT_TYPES = FLIPPED_ALIAS_KEYS["Statement"];
export const TERMINATORLESS_TYPES = FLIPPED_ALIAS_KEYS["Terminatorless"];
export const COMPLETIONSTATEMENT_TYPES =
  FLIPPED_ALIAS_KEYS["CompletionStatement"];
export const CONDITIONAL_TYPES = FLIPPED_ALIAS_KEYS["Conditional"];
export const LOOP_TYPES = FLIPPED_ALIAS_KEYS["Loop"];
export const WHILE_TYPES = FLIPPED_ALIAS_KEYS["While"];
export const EXPRESSIONWRAPPER_TYPES = FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
export const FOR_TYPES = FLIPPED_ALIAS_KEYS["For"];
export const FORXSTATEMENT_TYPES = FLIPPED_ALIAS_KEYS["ForXStatement"];
export const FUNCTION_TYPES = FLIPPED_ALIAS_KEYS["Function"];
export const FUNCTIONPARENT_TYPES = FLIPPED_ALIAS_KEYS["FunctionParent"];
export const PUREISH_TYPES = FLIPPED_ALIAS_KEYS["Pureish"];
export const DECLARATION_TYPES = FLIPPED_ALIAS_KEYS["Declaration"];
export const PATTERNLIKE_TYPES = FLIPPED_ALIAS_KEYS["PatternLike"];
export const LVAL_TYPES = FLIPPED_ALIAS_KEYS["LVal"];
export const TSENTITYNAME_TYPES = FLIPPED_ALIAS_KEYS["TSEntityName"];
export const LITERAL_TYPES = FLIPPED_ALIAS_KEYS["Literal"];
export const IMMUTABLE_TYPES = FLIPPED_ALIAS_KEYS["Immutable"];
export const USERWHITESPACABLE_TYPES = FLIPPED_ALIAS_KEYS["UserWhitespacable"];
export const METHOD_TYPES = FLIPPED_ALIAS_KEYS["Method"];
export const OBJECTMEMBER_TYPES = FLIPPED_ALIAS_KEYS["ObjectMember"];
export const PROPERTY_TYPES = FLIPPED_ALIAS_KEYS["Property"];
export const UNARYLIKE_TYPES = FLIPPED_ALIAS_KEYS["UnaryLike"];
export const PATTERN_TYPES = FLIPPED_ALIAS_KEYS["Pattern"];
export const CLASS_TYPES = FLIPPED_ALIAS_KEYS["Class"];
export const MODULEDECLARATION_TYPES = FLIPPED_ALIAS_KEYS["ModuleDeclaration"];
export const EXPORTDECLARATION_TYPES = FLIPPED_ALIAS_KEYS["ExportDeclaration"];
export const MODULESPECIFIER_TYPES = FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
export const FLOW_TYPES = FLIPPED_ALIAS_KEYS["Flow"];
export const FLOWTYPE_TYPES = FLIPPED_ALIAS_KEYS["FlowType"];
export const FLOWBASEANNOTATION_TYPES =
  FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
export const FLOWDECLARATION_TYPES = FLIPPED_ALIAS_KEYS["FlowDeclaration"];
export const FLOWPREDICATE_TYPES = FLIPPED_ALIAS_KEYS["FlowPredicate"];
export const JSX_TYPES = FLIPPED_ALIAS_KEYS["JSX"];
export const PRIVATE_TYPES = FLIPPED_ALIAS_KEYS["Private"];
export const TSTYPEELEMENT_TYPES = FLIPPED_ALIAS_KEYS["TSTypeElement"];
export const TSTYPE_TYPES = FLIPPED_ALIAS_KEYS["TSType"];

// </from> /home/qfox/apps/babel/packages/babel-types/src/constants/generated/index.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/clone/cloneNode.js

import { NODE_FIELDS } from "../definitions";
const has = Function.call.bind(Object.prototype.hasOwnProperty);
function cloneIfNode(obj, deep) {
  if (
    obj &&
    typeof obj.type === "string" &&
    // CommentLine and CommentBlock are used in File#comments, but they are
    // not defined in babel-types
    obj.type !== "CommentLine" &&
    obj.type !== "CommentBlock"
  ) {
    return cloneNode(obj, deep);
  }
  return obj;
}
function cloneIfNodeOrArray(obj, deep) {
  if (Array.isArray(obj)) {
    return obj.map(node => cloneIfNode(node, deep));
  }
  return cloneIfNode(obj, deep);
}
/**
 * Create a clone of a `node` including only properties belonging to the node.
 * If the second parameter is `false`, cloneNode performs a shallow clone.
 */
export default function cloneNode<T: Object>(node: T, deep: boolean = true): T {
  if (!node) return node;
  const { type } = node;
  const newNode = (({ type }: any): T);
  // Special-case identifiers since they are the most cloned nodes.
  if (type === "Identifier") {
    newNode.name = node.name;
  } else if (!has(NODE_FIELDS, type)) {
    throw new Error(`Unknown node type: "${type}"`);
  } else {
    for (const field of Object.keys(NODE_FIELDS[type])) {
      if (has(node, field)) {
        newNode[field] = deep
          ? cloneIfNodeOrArray(node[field], true)
          : node[field];
      }
    }
  }
  if (has(node, "loc")) {
    newNode.loc = node.loc;
  }
  if (has(node, "leadingComments")) {
    newNode.leadingComments = node.leadingComments;
  }
  if (has(node, "innerComments")) {
    newNode.innerComments = node.innerCmments;
  }
  if (has(node, "trailingComments")) {
    newNode.trailingComments = node.trailingComments;
  }
  if (has(node, "extra")) {
    newNode.extra = {
      ...node.extra,
    };
  }
  return newNode;
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/clone/cloneNode.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/clone/clone.js

// @flow
import cloneNode from "./cloneNode";
/**
 * Create a shallow clone of a `node`, including only
 * properties belonging to the node.
 * @deprecated Use t.cloneNode instead.
 */
export default function clone<T: Object>(node: T): T {
  return cloneNode(node, /* deep */ false);
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/clone/clone.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/clone/cloneWithoutLoc.js

// @flow
import clone from "./clone";
/**
 * Create a shallow clone of a `node` excluding `_private` and location properties.
 */
export default function cloneWithoutLoc<T: Object>(node: T): T {
  const newNode = clone(node);
  newNode.loc = null;
  return newNode;
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/clone/cloneWithoutLoc.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/clone/cloneDeep.js

// @flow
import cloneNode from "./cloneNode";
/**
 * Create a deep clone of a `node` and all of it's child nodes
 * including only properties belonging to the node.
 * @deprecated Use t.cloneNode instead.
 */
export default function cloneDeep<T: Object>(node: T): T {
  return cloneNode(node);
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/clone/cloneDeep.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/asserts/generated/index.js

// @flow
/*
 * This file is auto-generated! Do not modify it directly.
 * To re-generate run 'make build'
 */
import is from "../../validators/is";
function assert(type: string, node: Object, opts?: Object): void {
  if (!is(type, node, opts)) {
    throw new Error(
      `Expected type "${type}" with option ${JSON.stringify(
        opts,
      )}, but instead got "${node.type}".`,
    );
  }
}
export function assertArrayExpression(node: Object, opts?: Object = {}): void {
  assert("ArrayExpression", node, opts);
}
export function assertAssignmentExpression(
  node: Object,
  opts?: Object = {},
): void {
  assert("AssignmentExpression", node, opts);
}
export function assertBinaryExpression(node: Object, opts?: Object = {}): void {
  assert("BinaryExpression", node, opts);
}
export function assertInterpreterDirective(
  node: Object,
  opts?: Object = {},
): void {
  assert("InterpreterDirective", node, opts);
}
export function assertDirective(node: Object, opts?: Object = {}): void {
  assert("Directive", node, opts);
}
export function assertDirectiveLiteral(node: Object, opts?: Object = {}): void {
  assert("DirectiveLiteral", node, opts);
}
export function assertBlockStatement(node: Object, opts?: Object = {}): void {
  assert("BlockStatement", node, opts);
}
export function assertBreakStatement(node: Object, opts?: Object = {}): void {
  assert("BreakStatement", node, opts);
}
export function assertCallExpression(node: Object, opts?: Object = {}): void {
  assert("CallExpression", node, opts);
}
export function assertCatchClause(node: Object, opts?: Object = {}): void {
  assert("CatchClause", node, opts);
}
export function assertConditionalExpression(
  node: Object,
  opts?: Object = {},
): void {
  assert("ConditionalExpression", node, opts);
}
export function assertContinueStatement(
  node: Object,
  opts?: Object = {},
): void {
  assert("ContinueStatement", node, opts);
}
export function assertDebuggerStatement(
  node: Object,
  opts?: Object = {},
): void {
  assert("DebuggerStatement", node, opts);
}
export function assertDoWhileStatement(node: Object, opts?: Object = {}): void {
  assert("DoWhileStatement", node, opts);
}
export function assertEmptyStatement(node: Object, opts?: Object = {}): void {
  assert("EmptyStatement", node, opts);
}
export function assertExpressionStatement(
  node: Object,
  opts?: Object = {},
): void {
  assert("ExpressionStatement", node, opts);
}
export function assertFile(node: Object, opts?: Object = {}): void {
  assert("File", node, opts);
}
export function assertForInStatement(node: Object, opts?: Object = {}): void {
  assert("ForInStatement", node, opts);
}
export function assertForStatement(node: Object, opts?: Object = {}): void {
  assert("ForStatement", node, opts);
}
export function assertFunctionDeclaration(
  node: Object,
  opts?: Object = {},
): void {
  assert("FunctionDeclaration", node, opts);
}
export function assertFunctionExpression(
  node: Object,
  opts?: Object = {},
): void {
  assert("FunctionExpression", node, opts);
}
export function assertIdentifier(node: Object, opts?: Object = {}): void {
  assert("Identifier", node, opts);
}
export function assertIfStatement(node: Object, opts?: Object = {}): void {
  assert("IfStatement", node, opts);
}
export function assertLabeledStatement(node: Object, opts?: Object = {}): void {
  assert("LabeledStatement", node, opts);
}
export function assertStringLiteral(node: Object, opts?: Object = {}): void {
  assert("StringLiteral", node, opts);
}
export function assertNumericLiteral(node: Object, opts?: Object = {}): void {
  assert("NumericLiteral", node, opts);
}
export function assertNullLiteral(node: Object, opts?: Object = {}): void {
  assert("NullLiteral", node, opts);
}
export function assertBooleanLiteral(node: Object, opts?: Object = {}): void {
  assert("BooleanLiteral", node, opts);
}
export function assertRegExpLiteral(node: Object, opts?: Object = {}): void {
  assert("RegExpLiteral", node, opts);
}
export function assertLogicalExpression(
  node: Object,
  opts?: Object = {},
): void {
  assert("LogicalExpression", node, opts);
}
export function assertMemberExpression(node: Object, opts?: Object = {}): void {
  assert("MemberExpression", node, opts);
}
export function assertNewExpression(node: Object, opts?: Object = {}): void {
  assert("NewExpression", node, opts);
}
export function assertProgram(node: Object, opts?: Object = {}): void {
  assert("Program", node, opts);
}
export function assertObjectExpression(node: Object, opts?: Object = {}): void {
  assert("ObjectExpression", node, opts);
}
export function assertObjectMethod(node: Object, opts?: Object = {}): void {
  assert("ObjectMethod", node, opts);
}
export function assertObjectProperty(node: Object, opts?: Object = {}): void {
  assert("ObjectProperty", node, opts);
}
export function assertRestElement(node: Object, opts?: Object = {}): void {
  assert("RestElement", node, opts);
}
export function assertReturnStatement(node: Object, opts?: Object = {}): void {
  assert("ReturnStatement", node, opts);
}
export function assertSequenceExpression(
  node: Object,
  opts?: Object = {},
): void {
  assert("SequenceExpression", node, opts);
}
export function assertSwitchCase(node: Object, opts?: Object = {}): void {
  assert("SwitchCase", node, opts);
}
export function assertSwitchStatement(node: Object, opts?: Object = {}): void {
  assert("SwitchStatement", node, opts);
}
export function assertThisExpression(node: Object, opts?: Object = {}): void {
  assert("ThisExpression", node, opts);
}
export function assertThrowStatement(node: Object, opts?: Object = {}): void {
  assert("ThrowStatement", node, opts);
}
export function assertTryStatement(node: Object, opts?: Object = {}): void {
  assert("TryStatement", node, opts);
}
export function assertUnaryExpression(node: Object, opts?: Object = {}): void {
  assert("UnaryExpression", node, opts);
}
export function assertUpdateExpression(node: Object, opts?: Object = {}): void {
  assert("UpdateExpression", node, opts);
}
export function assertVariableDeclaration(
  node: Object,
  opts?: Object = {},
): void {
  assert("VariableDeclaration", node, opts);
}
export function assertVariableDeclarator(
  node: Object,
  opts?: Object = {},
): void {
  assert("VariableDeclarator", node, opts);
}
export function assertWhileStatement(node: Object, opts?: Object = {}): void {
  assert("WhileStatement", node, opts);
}
export function assertWithStatement(node: Object, opts?: Object = {}): void {
  assert("WithStatement", node, opts);
}
export function assertAssignmentPattern(
  node: Object,
  opts?: Object = {},
): void {
  assert("AssignmentPattern", node, opts);
}
export function assertArrayPattern(node: Object, opts?: Object = {}): void {
  assert("ArrayPattern", node, opts);
}
export function assertArrowFunctionExpression(
  node: Object,
  opts?: Object = {},
): void {
  assert("ArrowFunctionExpression", node, opts);
}
export function assertClassBody(node: Object, opts?: Object = {}): void {
  assert("ClassBody", node, opts);
}
export function assertClassDeclaration(node: Object, opts?: Object = {}): void {
  assert("ClassDeclaration", node, opts);
}
export function assertClassExpression(node: Object, opts?: Object = {}): void {
  assert("ClassExpression", node, opts);
}
export function assertExportAllDeclaration(
  node: Object,
  opts?: Object = {},
): void {
  assert("ExportAllDeclaration", node, opts);
}
export function assertExportDefaultDeclaration(
  node: Object,
  opts?: Object = {},
): void {
  assert("ExportDefaultDeclaration", node, opts);
}
export function assertExportNamedDeclaration(
  node: Object,
  opts?: Object = {},
): void {
  assert("ExportNamedDeclaration", node, opts);
}
export function assertExportSpecifier(node: Object, opts?: Object = {}): void {
  assert("ExportSpecifier", node, opts);
}
export function assertForOfStatement(node: Object, opts?: Object = {}): void {
  assert("ForOfStatement", node, opts);
}
export function assertImportDeclaration(
  node: Object,
  opts?: Object = {},
): void {
  assert("ImportDeclaration", node, opts);
}
export function assertImportDefaultSpecifier(
  node: Object,
  opts?: Object = {},
): void {
  assert("ImportDefaultSpecifier", node, opts);
}
export function assertImportNamespaceSpecifier(
  node: Object,
  opts?: Object = {},
): void {
  assert("ImportNamespaceSpecifier", node, opts);
}
export function assertImportSpecifier(node: Object, opts?: Object = {}): void {
  assert("ImportSpecifier", node, opts);
}
export function assertMetaProperty(node: Object, opts?: Object = {}): void {
  assert("MetaProperty", node, opts);
}
export function assertClassMethod(node: Object, opts?: Object = {}): void {
  assert("ClassMethod", node, opts);
}
export function assertObjectPattern(node: Object, opts?: Object = {}): void {
  assert("ObjectPattern", node, opts);
}
export function assertSpreadElement(node: Object, opts?: Object = {}): void {
  assert("SpreadElement", node, opts);
}
export function assertSuper(node: Object, opts?: Object = {}): void {
  assert("Super", node, opts);
}
export function assertTaggedTemplateExpression(
  node: Object,
  opts?: Object = {},
): void {
  assert("TaggedTemplateExpression", node, opts);
}
export function assertTemplateElement(node: Object, opts?: Object = {}): void {
  assert("TemplateElement", node, opts);
}
export function assertTemplateLiteral(node: Object, opts?: Object = {}): void {
  assert("TemplateLiteral", node, opts);
}
export function assertYieldExpression(node: Object, opts?: Object = {}): void {
  assert("YieldExpression", node, opts);
}
export function assertAnyTypeAnnotation(
  node: Object,
  opts?: Object = {},
): void {
  assert("AnyTypeAnnotation", node, opts);
}
export function assertArrayTypeAnnotation(
  node: Object,
  opts?: Object = {},
): void {
  assert("ArrayTypeAnnotation", node, opts);
}
export function assertBooleanTypeAnnotation(
  node: Object,
  opts?: Object = {},
): void {
  assert("BooleanTypeAnnotation", node, opts);
}
export function assertBooleanLiteralTypeAnnotation(
  node: Object,
  opts?: Object = {},
): void {
  assert("BooleanLiteralTypeAnnotation", node, opts);
}
export function assertNullLiteralTypeAnnotation(
  node: Object,
  opts?: Object = {},
): void {
  assert("NullLiteralTypeAnnotation", node, opts);
}
export function assertClassImplements(node: Object, opts?: Object = {}): void {
  assert("ClassImplements", node, opts);
}
export function assertDeclareClass(node: Object, opts?: Object = {}): void {
  assert("DeclareClass", node, opts);
}
export function assertDeclareFunction(node: Object, opts?: Object = {}): void {
  assert("DeclareFunction", node, opts);
}
export function assertDeclareInterface(node: Object, opts?: Object = {}): void {
  assert("DeclareInterface", node, opts);
}
export function assertDeclareModule(node: Object, opts?: Object = {}): void {
  assert("DeclareModule", node, opts);
}
export function assertDeclareModuleExports(
  node: Object,
  opts?: Object = {},
): void {
  assert("DeclareModuleExports", node, opts);
}
export function assertDeclareTypeAlias(node: Object, opts?: Object = {}): void {
  assert("DeclareTypeAlias", node, opts);
}
export function assertDeclareOpaqueType(
  node: Object,
  opts?: Object = {},
): void {
  assert("DeclareOpaqueType", node, opts);
}
export function assertDeclareVariable(node: Object, opts?: Object = {}): void {
  assert("DeclareVariable", node, opts);
}
export function assertDeclareExportDeclaration(
  node: Object,
  opts?: Object = {},
): void {
  assert("DeclareExportDeclaration", node, opts);
}
export function assertDeclareExportAllDeclaration(
  node: Object,
  opts?: Object = {},
): void {
  assert("DeclareExportAllDeclaration", node, opts);
}
export function assertDeclaredPredicate(
  node: Object,
  opts?: Object = {},
): void {
  assert("DeclaredPredicate", node, opts);
}
export function assertExistsTypeAnnotation(
  node: Object,
  opts?: Object = {},
): void {
  assert("ExistsTypeAnnotation", node, opts);
}
export function assertFunctionTypeAnnotation(
  node: Object,
  opts?: Object = {},
): void {
  assert("FunctionTypeAnnotation", node, opts);
}
export function assertFunctionTypeParam(
  node: Object,
  opts?: Object = {},
): void {
  assert("FunctionTypeParam", node, opts);
}
export function assertGenericTypeAnnotation(
  node: Object,
  opts?: Object = {},
): void {
  assert("GenericTypeAnnotation", node, opts);
}
export function assertInferredPredicate(
  node: Object,
  opts?: Object = {},
): void {
  assert("InferredPredicate", node, opts);
}
export function assertInterfaceExtends(node: Object, opts?: Object = {}): void {
  assert("InterfaceExtends", node, opts);
}
export function assertInterfaceDeclaration(
  node: Object,
  opts?: Object = {},
): void {
  assert("InterfaceDeclaration", node, opts);
}
export function assertInterfaceTypeAnnotation(
  node: Object,
  opts?: Object = {},
): void {
  assert("InterfaceTypeAnnotation", node, opts);
}
export function assertIntersectionTypeAnnotation(
  node: Object,
  opts?: Object = {},
): void {
  assert("IntersectionTypeAnnotation", node, opts);
}
export function assertMixedTypeAnnotation(
  node: Object,
  opts?: Object = {},
): void {
  assert("MixedTypeAnnotation", node, opts);
}
export function assertEmptyTypeAnnotation(
  node: Object,
  opts?: Object = {},
): void {
  assert("EmptyTypeAnnotation", node, opts);
}
export function assertNullableTypeAnnotation(
  node: Object,
  opts?: Object = {},
): void {
  assert("NullableTypeAnnotation", node, opts);
}
export function assertNumberLiteralTypeAnnotation(
  node: Object,
  opts?: Object = {},
): void {
  assert("NumberLiteralTypeAnnotation", node, opts);
}
export function assertNumberTypeAnnotation(
  node: Object,
  opts?: Object = {},
): void {
  assert("NumberTypeAnnotation", node, opts);
}
export function assertObjectTypeAnnotation(
  node: Object,
  opts?: Object = {},
): void {
  assert("ObjectTypeAnnotation", node, opts);
}
export function assertObjectTypeInternalSlot(
  node: Object,
  opts?: Object = {},
): void {
  assert("ObjectTypeInternalSlot", node, opts);
}
export function assertObjectTypeCallProperty(
  node: Object,
  opts?: Object = {},
): void {
  assert("ObjectTypeCallProperty", node, opts);
}
export function assertObjectTypeIndexer(
  node: Object,
  opts?: Object = {},
): void {
  assert("ObjectTypeIndexer", node, opts);
}
export function assertObjectTypeProperty(
  node: Object,
  opts?: Object = {},
): void {
  assert("ObjectTypeProperty", node, opts);
}
export function assertObjectTypeSpreadProperty(
  node: Object,
  opts?: Object = {},
): void {
  assert("ObjectTypeSpreadProperty", node, opts);
}
export function assertOpaqueType(node: Object, opts?: Object = {}): void {
  assert("OpaqueType", node, opts);
}
export function assertQualifiedTypeIdentifier(
  node: Object,
  opts?: Object = {},
): void {
  assert("QualifiedTypeIdentifier", node, opts);
}
export function assertStringLiteralTypeAnnotation(
  node: Object,
  opts?: Object = {},
): void {
  assert("StringLiteralTypeAnnotation", node, opts);
}
export function assertStringTypeAnnotation(
  node: Object,
  opts?: Object = {},
): void {
  assert("StringTypeAnnotation", node, opts);
}
export function assertThisTypeAnnotation(
  node: Object,
  opts?: Object = {},
): void {
  assert("ThisTypeAnnotation", node, opts);
}
export function assertTupleTypeAnnotation(
  node: Object,
  opts?: Object = {},
): void {
  assert("TupleTypeAnnotation", node, opts);
}
export function assertTypeofTypeAnnotation(
  node: Object,
  opts?: Object = {},
): void {
  assert("TypeofTypeAnnotation", node, opts);
}
export function assertTypeAlias(node: Object, opts?: Object = {}): void {
  assert("TypeAlias", node, opts);
}
export function assertTypeAnnotation(node: Object, opts?: Object = {}): void {
  assert("TypeAnnotation", node, opts);
}
export function assertTypeCastExpression(
  node: Object,
  opts?: Object = {},
): void {
  assert("TypeCastExpression", node, opts);
}
export function assertTypeParameter(node: Object, opts?: Object = {}): void {
  assert("TypeParameter", node, opts);
}
export function assertTypeParameterDeclaration(
  node: Object,
  opts?: Object = {},
): void {
  assert("TypeParameterDeclaration", node, opts);
}
export function assertTypeParameterInstantiation(
  node: Object,
  opts?: Object = {},
): void {
  assert("TypeParameterInstantiation", node, opts);
}
export function assertUnionTypeAnnotation(
  node: Object,
  opts?: Object = {},
): void {
  assert("UnionTypeAnnotation", node, opts);
}
export function assertVariance(node: Object, opts?: Object = {}): void {
  assert("Variance", node, opts);
}
export function assertVoidTypeAnnotation(
  node: Object,
  opts?: Object = {},
): void {
  assert("VoidTypeAnnotation", node, opts);
}
export function assertJSXAttribute(node: Object, opts?: Object = {}): void {
  assert("JSXAttribute", node, opts);
}
export function assertJSXClosingElement(
  node: Object,
  opts?: Object = {},
): void {
  assert("JSXClosingElement", node, opts);
}
export function assertJSXElement(node: Object, opts?: Object = {}): void {
  assert("JSXElement", node, opts);
}
export function assertJSXEmptyExpression(
  node: Object,
  opts?: Object = {},
): void {
  assert("JSXEmptyExpression", node, opts);
}
export function assertJSXExpressionContainer(
  node: Object,
  opts?: Object = {},
): void {
  assert("JSXExpressionContainer", node, opts);
}
export function assertJSXSpreadChild(node: Object, opts?: Object = {}): void {
  assert("JSXSpreadChild", node, opts);
}
export function assertJSXIdentifier(node: Object, opts?: Object = {}): void {
  assert("JSXIdentifier", node, opts);
}
export function assertJSXMemberExpression(
  node: Object,
  opts?: Object = {},
): void {
  assert("JSXMemberExpression", node, opts);
}
export function assertJSXNamespacedName(
  node: Object,
  opts?: Object = {},
): void {
  assert("JSXNamespacedName", node, opts);
}
export function assertJSXOpeningElement(
  node: Object,
  opts?: Object = {},
): void {
  assert("JSXOpeningElement", node, opts);
}
export function assertJSXSpreadAttribute(
  node: Object,
  opts?: Object = {},
): void {
  assert("JSXSpreadAttribute", node, opts);
}
export function assertJSXText(node: Object, opts?: Object = {}): void {
  assert("JSXText", node, opts);
}
export function assertJSXFragment(node: Object, opts?: Object = {}): void {
  assert("JSXFragment", node, opts);
}
export function assertJSXOpeningFragment(
  node: Object,
  opts?: Object = {},
): void {
  assert("JSXOpeningFragment", node, opts);
}
export function assertJSXClosingFragment(
  node: Object,
  opts?: Object = {},
): void {
  assert("JSXClosingFragment", node, opts);
}
export function assertNoop(node: Object, opts?: Object = {}): void {
  assert("Noop", node, opts);
}
export function assertParenthesizedExpression(
  node: Object,
  opts?: Object = {},
): void {
  assert("ParenthesizedExpression", node, opts);
}
export function assertAwaitExpression(node: Object, opts?: Object = {}): void {
  assert("AwaitExpression", node, opts);
}
export function assertBindExpression(node: Object, opts?: Object = {}): void {
  assert("BindExpression", node, opts);
}
export function assertClassProperty(node: Object, opts?: Object = {}): void {
  assert("ClassProperty", node, opts);
}
export function assertOptionalMemberExpression(
  node: Object,
  opts?: Object = {},
): void {
  assert("OptionalMemberExpression", node, opts);
}
export function assertOptionalCallExpression(
  node: Object,
  opts?: Object = {},
): void {
  assert("OptionalCallExpression", node, opts);
}
export function assertClassPrivateProperty(
  node: Object,
  opts?: Object = {},
): void {
  assert("ClassPrivateProperty", node, opts);
}
export function assertImport(node: Object, opts?: Object = {}): void {
  assert("Import", node, opts);
}
export function assertDecorator(node: Object, opts?: Object = {}): void {
  assert("Decorator", node, opts);
}
export function assertDoExpression(node: Object, opts?: Object = {}): void {
  assert("DoExpression", node, opts);
}
export function assertExportDefaultSpecifier(
  node: Object,
  opts?: Object = {},
): void {
  assert("ExportDefaultSpecifier", node, opts);
}
export function assertExportNamespaceSpecifier(
  node: Object,
  opts?: Object = {},
): void {
  assert("ExportNamespaceSpecifier", node, opts);
}
export function assertPrivateName(node: Object, opts?: Object = {}): void {
  assert("PrivateName", node, opts);
}
export function assertBigIntLiteral(node: Object, opts?: Object = {}): void {
  assert("BigIntLiteral", node, opts);
}
export function assertTSParameterProperty(
  node: Object,
  opts?: Object = {},
): void {
  assert("TSParameterProperty", node, opts);
}
export function assertTSDeclareFunction(
  node: Object,
  opts?: Object = {},
): void {
  assert("TSDeclareFunction", node, opts);
}
export function assertTSDeclareMethod(node: Object, opts?: Object = {}): void {
  assert("TSDeclareMethod", node, opts);
}
export function assertTSQualifiedName(node: Object, opts?: Object = {}): void {
  assert("TSQualifiedName", node, opts);
}
export function assertTSCallSignatureDeclaration(
  node: Object,
  opts?: Object = {},
): void {
  assert("TSCallSignatureDeclaration", node, opts);
}
export function assertTSConstructSignatureDeclaration(
  node: Object,
  opts?: Object = {},
): void {
  assert("TSConstructSignatureDeclaration", node, opts);
}
export function assertTSPropertySignature(
  node: Object,
  opts?: Object = {},
): void {
  assert("TSPropertySignature", node, opts);
}
export function assertTSMethodSignature(
  node: Object,
  opts?: Object = {},
): void {
  assert("TSMethodSignature", node, opts);
}
export function assertTSIndexSignature(node: Object, opts?: Object = {}): void {
  assert("TSIndexSignature", node, opts);
}
export function assertTSAnyKeyword(node: Object, opts?: Object = {}): void {
  assert("TSAnyKeyword", node, opts);
}
export function assertTSUnknownKeyword(node: Object, opts?: Object = {}): void {
  assert("TSUnknownKeyword", node, opts);
}
export function assertTSNumberKeyword(node: Object, opts?: Object = {}): void {
  assert("TSNumberKeyword", node, opts);
}
export function assertTSObjectKeyword(node: Object, opts?: Object = {}): void {
  assert("TSObjectKeyword", node, opts);
}
export function assertTSBooleanKeyword(node: Object, opts?: Object = {}): void {
  assert("TSBooleanKeyword", node, opts);
}
export function assertTSStringKeyword(node: Object, opts?: Object = {}): void {
  assert("TSStringKeyword", node, opts);
}
export function assertTSSymbolKeyword(node: Object, opts?: Object = {}): void {
  assert("TSSymbolKeyword", node, opts);
}
export function assertTSVoidKeyword(node: Object, opts?: Object = {}): void {
  assert("TSVoidKeyword", node, opts);
}
export function assertTSUndefinedKeyword(
  node: Object,
  opts?: Object = {},
): void {
  assert("TSUndefinedKeyword", node, opts);
}
export function assertTSNullKeyword(node: Object, opts?: Object = {}): void {
  assert("TSNullKeyword", node, opts);
}
export function assertTSNeverKeyword(node: Object, opts?: Object = {}): void {
  assert("TSNeverKeyword", node, opts);
}
export function assertTSThisType(node: Object, opts?: Object = {}): void {
  assert("TSThisType", node, opts);
}
export function assertTSFunctionType(node: Object, opts?: Object = {}): void {
  assert("TSFunctionType", node, opts);
}
export function assertTSConstructorType(
  node: Object,
  opts?: Object = {},
): void {
  assert("TSConstructorType", node, opts);
}
export function assertTSTypeReference(node: Object, opts?: Object = {}): void {
  assert("TSTypeReference", node, opts);
}
export function assertTSTypePredicate(node: Object, opts?: Object = {}): void {
  assert("TSTypePredicate", node, opts);
}
export function assertTSTypeQuery(node: Object, opts?: Object = {}): void {
  assert("TSTypeQuery", node, opts);
}
export function assertTSTypeLiteral(node: Object, opts?: Object = {}): void {
  assert("TSTypeLiteral", node, opts);
}
export function assertTSArrayType(node: Object, opts?: Object = {}): void {
  assert("TSArrayType", node, opts);
}
export function assertTSTupleType(node: Object, opts?: Object = {}): void {
  assert("TSTupleType", node, opts);
}
export function assertTSOptionalType(node: Object, opts?: Object = {}): void {
  assert("TSOptionalType", node, opts);
}
export function assertTSUnionType(node: Object, opts?: Object = {}): void {
  assert("TSUnionType", node, opts);
}
export function assertTSIntersectionType(
  node: Object,
  opts?: Object = {},
): void {
  assert("TSIntersectionType", node, opts);
}
export function assertTSConditionalType(
  node: Object,
  opts?: Object = {},
): void {
  assert("TSConditionalType", node, opts);
}
export function assertTSInferType(node: Object, opts?: Object = {}): void {
  assert("TSInferType", node, opts);
}
export function assertTSParenthesizedType(
  node: Object,
  opts?: Object = {},
): void {
  assert("TSParenthesizedType", node, opts);
}
export function assertTSTypeOperator(node: Object, opts?: Object = {}): void {
  assert("TSTypeOperator", node, opts);
}
export function assertTSIndexedAccessType(
  node: Object,
  opts?: Object = {},
): void {
  assert("TSIndexedAccessType", node, opts);
}
export function assertTSMappedType(node: Object, opts?: Object = {}): void {
  assert("TSMappedType", node, opts);
}
export function assertTSLiteralType(node: Object, opts?: Object = {}): void {
  assert("TSLiteralType", node, opts);
}
export function assertTSExpressionWithTypeArguments(
  node: Object,
  opts?: Object = {},
): void {
  assert("TSExpressionWithTypeArguments", node, opts);
}
export function assertTSInterfaceDeclaration(
  node: Object,
  opts?: Object = {},
): void {
  assert("TSInterfaceDeclaration", node, opts);
}
export function assertTSInterfaceBody(node: Object, opts?: Object = {}): void {
  assert("TSInterfaceBody", node, opts);
}
export function assertTSTypeAliasDeclaration(
  node: Object,
  opts?: Object = {},
): void {
  assert("TSTypeAliasDeclaration", node, opts);
}
export function assertTSAsExpression(node: Object, opts?: Object = {}): void {
  assert("TSAsExpression", node, opts);
}
export function assertTSTypeAssertion(node: Object, opts?: Object = {}): void {
  assert("TSTypeAssertion", node, opts);
}
export function assertTSEnumDeclaration(
  node: Object,
  opts?: Object = {},
): void {
  assert("TSEnumDeclaration", node, opts);
}
export function assertTSEnumMember(node: Object, opts?: Object = {}): void {
  assert("TSEnumMember", node, opts);
}
export function assertTSModuleDeclaration(
  node: Object,
  opts?: Object = {},
): void {
  assert("TSModuleDeclaration", node, opts);
}
export function assertTSModuleBlock(node: Object, opts?: Object = {}): void {
  assert("TSModuleBlock", node, opts);
}
export function assertTSImportEqualsDeclaration(
  node: Object,
  opts?: Object = {},
): void {
  assert("TSImportEqualsDeclaration", node, opts);
}
export function assertTSExternalModuleReference(
  node: Object,
  opts?: Object = {},
): void {
  assert("TSExternalModuleReference", node, opts);
}
export function assertTSNonNullExpression(
  node: Object,
  opts?: Object = {},
): void {
  assert("TSNonNullExpression", node, opts);
}
export function assertTSExportAssignment(
  node: Object,
  opts?: Object = {},
): void {
  assert("TSExportAssignment", node, opts);
}
export function assertTSNamespaceExportDeclaration(
  node: Object,
  opts?: Object = {},
): void {
  assert("TSNamespaceExportDeclaration", node, opts);
}
export function assertTSTypeAnnotation(node: Object, opts?: Object = {}): void {
  assert("TSTypeAnnotation", node, opts);
}
export function assertTSTypeParameterInstantiation(
  node: Object,
  opts?: Object = {},
): void {
  assert("TSTypeParameterInstantiation", node, opts);
}
export function assertTSTypeParameterDeclaration(
  node: Object,
  opts?: Object = {},
): void {
  assert("TSTypeParameterDeclaration", node, opts);
}
export function assertTSTypeParameter(node: Object, opts?: Object = {}): void {
  assert("TSTypeParameter", node, opts);
}
export function assertExpression(node: Object, opts?: Object = {}): void {
  assert("Expression", node, opts);
}
export function assertBinary(node: Object, opts?: Object = {}): void {
  assert("Binary", node, opts);
}
export function assertScopable(node: Object, opts?: Object = {}): void {
  assert("Scopable", node, opts);
}
export function assertBlockParent(node: Object, opts?: Object = {}): void {
  assert("BlockParent", node, opts);
}
export function assertBlock(node: Object, opts?: Object = {}): void {
  assert("Block", node, opts);
}
export function assertStatement(node: Object, opts?: Object = {}): void {
  assert("Statement", node, opts);
}
export function assertTerminatorless(node: Object, opts?: Object = {}): void {
  assert("Terminatorless", node, opts);
}
export function assertCompletionStatement(
  node: Object,
  opts?: Object = {},
): void {
  assert("CompletionStatement", node, opts);
}
export function assertConditional(node: Object, opts?: Object = {}): void {
  assert("Conditional", node, opts);
}
export function assertLoop(node: Object, opts?: Object = {}): void {
  assert("Loop", node, opts);
}
export function assertWhile(node: Object, opts?: Object = {}): void {
  assert("While", node, opts);
}
export function assertExpressionWrapper(
  node: Object,
  opts?: Object = {},
): void {
  assert("ExpressionWrapper", node, opts);
}
export function assertFor(node: Object, opts?: Object = {}): void {
  assert("For", node, opts);
}
export function assertForXStatement(node: Object, opts?: Object = {}): void {
  assert("ForXStatement", node, opts);
}
export function assertFunction(node: Object, opts?: Object = {}): void {
  assert("Function", node, opts);
}
export function assertFunctionParent(node: Object, opts?: Object = {}): void {
  assert("FunctionParent", node, opts);
}
export function assertPureish(node: Object, opts?: Object = {}): void {
  assert("Pureish", node, opts);
}
export function assertDeclaration(node: Object, opts?: Object = {}): void {
  assert("Declaration", node, opts);
}
export function assertPatternLike(node: Object, opts?: Object = {}): void {
  assert("PatternLike", node, opts);
}
export function assertLVal(node: Object, opts?: Object = {}): void {
  assert("LVal", node, opts);
}
export function assertTSEntityName(node: Object, opts?: Object = {}): void {
  assert("TSEntityName", node, opts);
}
export function assertLiteral(node: Object, opts?: Object = {}): void {
  assert("Literal", node, opts);
}
export function assertImmutable(node: Object, opts?: Object = {}): void {
  assert("Immutable", node, opts);
}
export function assertUserWhitespacable(
  node: Object,
  opts?: Object = {},
): void {
  assert("UserWhitespacable", node, opts);
}
export function assertMethod(node: Object, opts?: Object = {}): void {
  assert("Method", node, opts);
}
export function assertObjectMember(node: Object, opts?: Object = {}): void {
  assert("ObjectMember", node, opts);
}
export function assertProperty(node: Object, opts?: Object = {}): void {
  assert("Property", node, opts);
}
export function assertUnaryLike(node: Object, opts?: Object = {}): void {
  assert("UnaryLike", node, opts);
}
export function assertPattern(node: Object, opts?: Object = {}): void {
  assert("Pattern", node, opts);
}
export function assertClass(node: Object, opts?: Object = {}): void {
  assert("Class", node, opts);
}
export function assertModuleDeclaration(
  node: Object,
  opts?: Object = {},
): void {
  assert("ModuleDeclaration", node, opts);
}
export function assertExportDeclaration(
  node: Object,
  opts?: Object = {},
): void {
  assert("ExportDeclaration", node, opts);
}
export function assertModuleSpecifier(node: Object, opts?: Object = {}): void {
  assert("ModuleSpecifier", node, opts);
}
export function assertFlow(node: Object, opts?: Object = {}): void {
  assert("Flow", node, opts);
}
export function assertFlowType(node: Object, opts?: Object = {}): void {
  assert("FlowType", node, opts);
}
export function assertFlowBaseAnnotation(
  node: Object,
  opts?: Object = {},
): void {
  assert("FlowBaseAnnotation", node, opts);
}
export function assertFlowDeclaration(node: Object, opts?: Object = {}): void {
  assert("FlowDeclaration", node, opts);
}
export function assertFlowPredicate(node: Object, opts?: Object = {}): void {
  assert("FlowPredicate", node, opts);
}
export function assertJSX(node: Object, opts?: Object = {}): void {
  assert("JSX", node, opts);
}
export function assertPrivate(node: Object, opts?: Object = {}): void {
  assert("Private", node, opts);
}
export function assertTSTypeElement(node: Object, opts?: Object = {}): void {
  assert("TSTypeElement", node, opts);
}
export function assertTSType(node: Object, opts?: Object = {}): void {
  assert("TSType", node, opts);
}
export function assertNumberLiteral(node: Object, opts: Object): void {
  console.trace(
    "The node type NumberLiteral has been renamed to NumericLiteral",
  );
  assert("NumberLiteral", node, opts);
}
export function assertRegexLiteral(node: Object, opts: Object): void {
  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
  assert("RegexLiteral", node, opts);
}
export function assertRestProperty(node: Object, opts: Object): void {
  console.trace("The node type RestProperty has been renamed to RestElement");
  assert("RestProperty", node, opts);
}
export function assertSpreadProperty(node: Object, opts: Object): void {
  console.trace(
    "The node type SpreadProperty has been renamed to SpreadElement",
  );
  assert("SpreadProperty", node, opts);
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/asserts/generated/index.js

// <from> /home/qfox/apps/babel/packages/babel-types/src/asserts/assertNode.js

// @flow
import isNode from "../validators/isNode";
export default function assertNode(node?: Object): void {
  if (!isNode(node)) {
    const type = (node && node.type) || JSON.stringify(node);
    throw new TypeError(`Not a valid node of type "${type}"`);
  }
}

// </from> /home/qfox/apps/babel/packages/babel-types/src/asserts/assertNode.js

// <from> /home/qfox/apps/babel/packages/babel-types/scripts/generators/generateAsserts.js

"use strict";
const definitions = require("../../lib/definitions");
function addAssertHelper(type) {
  return `export function assert${type}(node: Object, opts?: Object = {}): void {
    assert("${type}", node, opts) }
  `;
}
module.exports = function generateAsserts() {
  let output = `// @flow
/*
 * This file is auto-generated! Do not modify it directly.
 * To re-generate run 'make build'
 */
import is from "../../validators/is";
function assert(type: string, node: Object, opts?: Object): void {
  if (!is(type, node, opts)) {
    throw new Error(
      \`Expected type "\${type}" with option \${JSON.stringify(opts)}, but instead got "\${node.type}".\`,
    );
  }
}\n\n`;
  Object.keys(definitions.VISITOR_KEYS).forEach(type => {
    output += addAssertHelper(type);
  });
  Object.keys(definitions.FLIPPED_ALIAS_KEYS).forEach(type => {
    output += addAssertHelper(type);
  });
  Object.keys(definitions.DEPRECATED_KEYS).forEach(type => {
    const newType = definitions.DEPRECATED_KEYS[type];
    output += `export function assert${type}(node: Object, opts: Object): void {
  console.trace("The node type ${type} has been renamed to ${newType}");
  assert("${type}", node, opts);
}\n`;
  });
  return output;
};

// </from> /home/qfox/apps/babel/packages/babel-types/scripts/generators/generateAsserts.js

// <from> /home/qfox/apps/babel/packages/babel-types/scripts/generators/generateBuilders.js

"use strict";
const definitions = require("../../lib/definitions");
const formatBuilderName = require("../utils/formatBuilderName");
const lowerFirst = require("../utils/lowerFirst");
module.exports = function generateBuilders() {
  let output = `// @flow
/*
 * This file is auto-generated! Do not modify it directly.
 * To re-generate run 'make build'
 */
import builder from "../builder";\n\n`;
  Object.keys(definitions.BUILDER_KEYS).forEach(type => {
    output += `export function ${type}(...args: Array<any>): Object { return builder("${type}", ...args); }
export { ${type} as ${formatBuilderName(type)} };\n`;
    // This is needed for backwards compatibility.
    // It should be removed in the next major version.
    // JSXIdentifier -> jSXIdentifier
    if (/^[A-Z]{2}/.test(type)) {
      output += `export { ${type} as ${lowerFirst(type)} }\n`;
    }
  });
  Object.keys(definitions.DEPRECATED_KEYS).forEach(type => {
    const newType = definitions.DEPRECATED_KEYS[type];
    output += `export function ${type}(...args: Array<any>): Object {
  console.trace("The node type ${type} has been renamed to ${newType}");
  return ${type}("${type}", ...args);
}
export { ${type} as ${formatBuilderName(type)} };\n`;
    // This is needed for backwards compatibility.
    // It should be removed in the next major version.
    // JSXIdentifier -> jSXIdentifier
    if (/^[A-Z]{2}/.test(type)) {
      output += `export { ${type} as ${lowerFirst(type)} }\n`;
    }
  });
  return output;
};

// </from> /home/qfox/apps/babel/packages/babel-types/scripts/generators/generateBuilders.js

// <from> /home/qfox/apps/babel/packages/babel-types/scripts/generators/generateConstants.js

"use strict";
const definitions = require("../../lib/definitions");
module.exports = function generateConstants() {
  let output = `// @flow
/*
 * This file is auto-generated! Do not modify it directly.
 * To re-generate run 'make build'
 */
import { FLIPPED_ALIAS_KEYS } from "../../definitions";\n\n`;
  Object.keys(definitions.FLIPPED_ALIAS_KEYS).forEach(type => {
    output += `export const ${type.toUpperCase()}_TYPES = FLIPPED_ALIAS_KEYS["${type}"];\n`;
  });
  return output;
};

// </from> /home/qfox/apps/babel/packages/babel-types/scripts/generators/generateConstants.js

// <from> /home/qfox/apps/babel/packages/babel-types/scripts/generators/generateValidators.js

"use strict";
const definitions = require("../../lib/definitions");
function addIsHelper(type, aliasKeys, deprecated) {
  const targetType = JSON.stringify(type);
  let aliasSource = "";
  if (aliasKeys) {
    aliasSource =
      " || " +
      aliasKeys.map(JSON.stringify).join(" === nodeType || ") +
      " === nodeType";
  }
  return `export function is${type}(node: Object, opts?: Object): boolean {
    ${deprecated || ""}
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === ${targetType}${aliasSource}) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }
    return false;
  }
  `;
}
module.exports = function generateValidators() {
  let output = `// @flow
/*
 * This file is auto-generated! Do not modify it directly.
 * To re-generate run 'make build'
 */
import shallowEqual from "../../utils/shallowEqual";\n\n`;
  Object.keys(definitions.VISITOR_KEYS).forEach(type => {
    output += addIsHelper(type);
  });
  Object.keys(definitions.FLIPPED_ALIAS_KEYS).forEach(type => {
    output += addIsHelper(type, definitions.FLIPPED_ALIAS_KEYS[type]);
  });
  Object.keys(definitions.DEPRECATED_KEYS).forEach(type => {
    const newType = definitions.DEPRECATED_KEYS[type];
    const deprecated = `console.trace("The node type ${type} has been renamed to ${newType}");`;
    output += addIsHelper(type, null, deprecated);
  });
  return output;
};

// </from> /home/qfox/apps/babel/packages/babel-types/scripts/generators/generateValidators.js

// <from> /home/qfox/apps/babel/packages/babel-types/scripts/utils/lowerFirst.js

"use strict";
module.exports = function lowerFirst(string) {
  return string[0].toLowerCase() + string.slice(1);
};

// </from> /home/qfox/apps/babel/packages/babel-types/scripts/utils/lowerFirst.js

// <from> /home/qfox/apps/babel/packages/babel-types/scripts/utils/formatBuilderName.js

"use strict";
const toLowerCase = Function.call.bind("".toLowerCase);
module.exports = function formatBuilderName(type) {
  // FunctionExpression -> functionExpression
  // JSXIdentifier -> jsxIdentifier
  return type.replace(/^([A-Z](?=[a-z])|[A-Z]+(?=[A-Z]))/, toLowerCase);
};

// </from> /home/qfox/apps/babel/packages/babel-types/scripts/utils/formatBuilderName.js

// <from> /home/qfox/apps/babel/packages/babel-types/scripts/utils/formatCode.js

"use strict";
const prettier = require("prettier");
module.exports = function formatCode(code, filename) {
  filename = filename || __filename;
  const prettierConfig = prettier.resolveConfig.sync(filename);
  return prettier.format(code, prettierConfig);
};

// </from> /home/qfox/apps/babel/packages/babel-types/scripts/utils/formatCode.js

// <from> /home/qfox/apps/babel/packages/babel-types/scripts/generateTypeHelpers.js

"use strict";
const fs = require("fs");
const path = require("path");
const generateBuilders = require("./generators/generateBuilders");
const generateValidators = require("./generators/generateValidators");
const generateAsserts = require("./generators/generateAsserts");
const generateConstants = require("./generators/generateConstants");
const format = require("./utils/formatCode");
const baseDir = path.join(__dirname, "../src");
function writeFile(content, location) {
  const file = path.join(baseDir, location);
  try {
    fs.mkdirSync(path.dirname(file));
  } catch (error) {
    if (error.code !== "EEXIST") {
      throw error;
    }
  }
  fs.writeFileSync(file, format(content, file));
}
console.log("Generating @babel/types dynamic functions");
writeFile(generateBuilders(), "builders/generated/index.js");
writeFile(generateValidators(), "validators/generated/index.js");
writeFile(generateAsserts(), "asserts/generated/index.js");
writeFile(generateConstants(), "constants/generated/index.js");

// </from> /home/qfox/apps/babel/packages/babel-types/scripts/generateTypeHelpers.js

// <from> /home/qfox/apps/babel/packages/babel-helper-builder-react-jsx/src/index.js

import esutils from "esutils";
import * as t from "@babel/types";
type ElementState = {
  tagExpr: Object, // tag node
  tagName: ?string, // raw string tag name
  args: Array<Object>, // array of call arguments
  call?: Object, // optional call property that can be set to override the call expression returned
};
export default function(opts) {
  const visitor = {};
  visitor.JSXNamespacedName = function(path) {
    if (opts.throwIfNamespace) {
      throw path.buildCodeFrameError(
        `Namespace tags are not supported by default. React's JSX doesn't support namespace tags. \
You can turn on the 'throwIfNamespace' flag to bypass this warning.`,
      );
    }
  };
  visitor.JSXElement = {
    exit(path, file) {
      const callExpr = buildElementCall(path, file);
      if (callExpr) {
        path.replaceWith(t.inherits(callExpr, path.node));
      }
    },
  };
  visitor.JSXFragment = {
    exit(path, file) {
      if (opts.compat) {
        throw path.buildCodeFrameError(
          "Fragment tags are only supported in React 16 and up.",
        );
      }
      const callExpr = buildFragmentCall(path, file);
      if (callExpr) {
        path.replaceWith(t.inherits(callExpr, path.node));
      }
    },
  };
  return visitor;
  function convertJSXIdentifier(node, parent) {
    if (t.isJSXIdentifier(node)) {
      if (node.name === "this" && t.isReferenced(node, parent)) {
        return t.thisExpression();
      } else if (esutils.keyword.isIdentifierNameES6(node.name)) {
        node.type = "Identifier";
      } else {
        return t.stringLiteral(node.name);
      }
    } else if (t.isJSXMemberExpression(node)) {
      return t.memberExpression(
        convertJSXIdentifier(node.object, node),
        convertJSXIdentifier(node.property, node),
      );
    } else if (t.isJSXNamespacedName(node)) {
      /**
       * If there is flag "throwIfNamespace"
       * print XMLNamespace like string literal
       */
      return t.stringLiteral(`${node.namespace.name}:${node.name.name}`);
    }
    return node;
  }
  function convertAttributeValue(node) {
    if (t.isJSXExpressionContainer(node)) {
      return node.expression;
    } else {
      return node;
    }
  }
  function convertAttribute(node) {
    const value = convertAttributeValue(node.value || t.booleanLiteral(true));
    if (t.isStringLiteral(value) && !t.isJSXExpressionContainer(node.value)) {
      value.value = value.value.replace(/\n\s+/g, " ");
      // "raw" JSXText should not be used from a StringLiteral because it needs to be escaped.
      if (value.extra && value.extra.raw) {
        delete value.extra.raw;
      }
    }
    if (t.isJSXNamespacedName(node.name)) {
      node.name = t.stringLiteral(
        node.name.namespace.name + ":" + node.name.name.name,
      );
    } else if (esutils.keyword.isIdentifierNameES6(node.name.name)) {
      node.name.type = "Identifier";
    } else {
      node.name = t.stringLiteral(node.name.name);
    }
    return t.inherits(t.objectProperty(node.name, value), node);
  }
  function buildElementCall(path, file) {
    if (opts.filter && !opts.filter(path.node, file)) return;
    const openingPath = path.get("openingElement");
    openingPath.parent.children = t.react.buildChildren(openingPath.parent);
    const tagExpr = convertJSXIdentifier(
      openingPath.node.name,
      openingPath.node,
    );
    const args = [];
    let tagName;
    if (t.isIdentifier(tagExpr)) {
      tagName = tagExpr.name;
    } else if (t.isLiteral(tagExpr)) {
      tagName = tagExpr.value;
    }
    const state: ElementState = {
      tagExpr: tagExpr,
      tagName: tagName,
      args: args,
    };
    if (opts.pre) {
      opts.pre(state, file);
    }
    let attribs = openingPath.node.attributes;
    if (attribs.length) {
      attribs = buildOpeningElementAttributes(attribs, file);
    } else {
      attribs = t.nullLiteral();
    }
    args.push(attribs, ...path.node.children);
    if (opts.post) {
      opts.post(state, file);
    }
    return state.call || t.callExpression(state.callee, args);
  }
  function pushProps(_props, objs) {
    if (!_props.length) return _props;
    objs.push(t.objectExpression(_props));
    return [];
  }
  /**
   * The logic for this is quite terse. It's because we need to
   * support spread elements. We loop over all attributes,
   * breaking on spreads, we then push a new object containing
   * all prior attributes to an array for later processing.
   */
  function buildOpeningElementAttributes(attribs, file) {
    let _props = [];
    const objs = [];
    const useBuiltIns = file.opts.useBuiltIns || false;
    if (typeof useBuiltIns !== "boolean") {
      throw new Error(
        "transform-react-jsx currently only accepts a boolean option for " +
          "useBuiltIns (defaults to false)",
      );
    }
    while (attribs.length) {
      const prop = attribs.shift();
      if (t.isJSXSpreadAttribute(prop)) {
        _props = pushProps(_props, objs);
        objs.push(prop.argument);
      } else {
        _props.push(convertAttribute(prop));
      }
    }
    pushProps(_props, objs);
    if (objs.length === 1) {
      // only one object
      attribs = objs[0];
    } else {
      // looks like we have multiple objects
      if (!t.isObjectExpression(objs[0])) {
        objs.unshift(t.objectExpression([]));
      }
      const helper = useBuiltIns
        ? t.memberExpression(t.identifier("Object"), t.identifier("assign"))
        : file.addHelper("extends");
      // spread it
      attribs = t.callExpression(helper, objs);
    }
    return attribs;
  }
  function buildFragmentCall(path, file) {
    if (opts.filter && !opts.filter(path.node, file)) return;
    const openingPath = path.get("openingElement");
    openingPath.parent.children = t.react.buildChildren(openingPath.parent);
    const args = [];
    const tagName = null;
    const tagExpr = file.get("jsxFragIdentifier")();
    const state: ElementState = {
      tagExpr: tagExpr,
      tagName: tagName,
      args: args,
    };
    if (opts.pre) {
      opts.pre(state, file);
    }
    // no attributes are allowed with <> syntax
    args.push(t.nullLiteral(), ...path.node.children);
    if (opts.post) {
      opts.post(state, file);
    }
    file.set("usedFragment", true);
    return state.call || t.callExpression(state.callee, args);
  }
}

// </from> /home/qfox/apps/babel/packages/babel-helper-builder-react-jsx/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-regenerator/src/index.js

export { default } from "regenerator-transform";

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-regenerator/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-syntax-decorators/src/index.js

import { declare } from "@babel/helper-plugin-utils";
export default declare((api, options) => {
  api.assertVersion(7);
  const { legacy = false } = options;
  if (typeof legacy !== "boolean") {
    throw new Error("'legacy' must be a boolean.");
  }
  const { decoratorsBeforeExport } = options;
  if (decoratorsBeforeExport === undefined) {
    if (!legacy) {
      throw new Error(
        "The '@babel/plugin-syntax-decorators' plugin requires a" +
          " 'decoratorsBeforeExport' option, whose value must be a boolean." +
          " If you want to use the legacy decorators semantics, you can set" +
          " the 'legacy: true' option.",
      );
    }
  } else {
    if (legacy) {
      throw new Error(
        "'decoratorsBeforeExport' can't be used with legacy decorators.",
      );
    }
    if (typeof decoratorsBeforeExport !== "boolean") {
      throw new Error("'decoratorsBeforeExport' must be a boolean.");
    }
  }
  return {
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push(
        legacy
          ? "decorators-legacy"
          : ["decorators", { decoratorsBeforeExport }],
      );
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-syntax-decorators/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-syntax-optional-chaining/src/index.js

import { declare } from "@babel/helper-plugin-utils";
export default declare(api => {
  api.assertVersion(7);
  return {
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("optionalChaining");
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-syntax-optional-chaining/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-syntax-throw-expressions/src/index.js

import { declare } from "@babel/helper-plugin-utils";
export default declare(api => {
  api.assertVersion(7);
  return {
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("throwExpressions");
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-syntax-throw-expressions/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-runtime-corejs2/core-js/map.js

module.exports = require("core-js/library/fn/map");
// </from> /home/qfox/apps/babel/packages/babel-runtime-corejs2/core-js/map.js

// <from> /home/qfox/apps/babel/packages/babel-runtime-corejs2/helpers/toArray.js

var arrayWithHoles = require("./arrayWithHoles");
var iterableToArray = require("./iterableToArray");
var nonIterableRest = require("./nonIterableRest");
function _toArray(arr) {
  return arrayWithHoles(arr) || iterableToArray(arr) || nonIterableRest();
}
module.exports = _toArray;
// </from> /home/qfox/apps/babel/packages/babel-runtime-corejs2/helpers/toArray.js

// <from> /home/qfox/apps/babel/packages/babel-runtime-corejs2/helpers/esm/toArray.js

import arrayWithHoles from "./arrayWithHoles";
import iterableToArray from "./iterableToArray";
import nonIterableRest from "./nonIterableRest";
export default function _toArray(arr) {
  return arrayWithHoles(arr) || iterableToArray(arr) || nonIterableRest();
}
// </from> /home/qfox/apps/babel/packages/babel-runtime-corejs2/helpers/esm/toArray.js

// <from> /home/qfox/apps/babel/packages/babel-runtime-corejs2/helpers/esm/temporalRef.js

import undef from "./temporalUndefined";
export default function _temporalRef(val, name) {
  if (val === undef) {
    throw new ReferenceError(name + " is not defined - temporal dead zone");
  } else {
    return val;
  }
}
// </from> /home/qfox/apps/babel/packages/babel-runtime-corejs2/helpers/esm/temporalRef.js

// <from> /home/qfox/apps/babel/packages/babel-runtime-corejs2/helpers/esm/iterableToArray.js

import _Array$from from "../../core-js/array/from";
import _isIterable from "../../core-js/is-iterable";
export default function _iterableToArray(iter) {
  if (_isIterable(Object(iter)) || Object.prototype.toString.call(iter) === "[object Arguments]") return _Array$from(iter);
}
// </from> /home/qfox/apps/babel/packages/babel-runtime-corejs2/helpers/esm/iterableToArray.js

// <from> /home/qfox/apps/babel/packages/babel-runtime-corejs2/helpers/temporalRef.js

var temporalUndefined = require("./temporalUndefined");
function _temporalRef(val, name) {
  if (val === temporalUndefined) {
    throw new ReferenceError(name + " is not defined - temporal dead zone");
  } else {
    return val;
  }
}
module.exports = _temporalRef;
// </from> /home/qfox/apps/babel/packages/babel-runtime-corejs2/helpers/temporalRef.js

// <from> /home/qfox/apps/babel/packages/babel-runtime-corejs2/helpers/iterableToArray.js

var _Array$from = require("../core-js/array/from");
var _isIterable = require("../core-js/is-iterable");
function _iterableToArray(iter) {
  if (_isIterable(Object(iter)) || Object.prototype.toString.call(iter) === "[object Arguments]") return _Array$from(iter);
}
module.exports = _iterableToArray;
// </from> /home/qfox/apps/babel/packages/babel-runtime-corejs2/helpers/iterableToArray.js

// <from> /home/qfox/apps/babel/packages/babel-runtime-corejs2/regenerator/index.js

module.exports = require("regenerator-runtime");

// </from> /home/qfox/apps/babel/packages/babel-runtime-corejs2/regenerator/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-react-jsx-self/src/index.js

/**
 * This adds a __self={this} JSX attribute to all JSX elements, which React will use
 * to generate some runtime warnings.
 *
 *
 * == JSX Literals ==
 *
 * <sometag />
 *
 * becomes:
 *
 * <sometag __self={this} />
 */
import { declare } from "@babel/helper-plugin-utils";
import { types as t } from "@babel/core";
const TRACE_ID = "__self";
export default declare(api => {
  api.assertVersion(7);
  const visitor = {
    JSXOpeningElement({ node }) {
      const id = t.jsxIdentifier(TRACE_ID);
      const trace = t.thisExpression();
      node.attributes.push(t.jsxAttribute(id, t.jsxExpressionContainer(trace)));
    },
  };
  return {
    visitor,
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-react-jsx-self/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-proposal-logical-assignment-operators/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import syntaxLogicalAssignmentOperators from "@babel/plugin-syntax-logical-assignment-operators";
import { types as t } from "@babel/core";
export default declare(api => {
  api.assertVersion(7);
  return {
    inherits: syntaxLogicalAssignmentOperators,
    visitor: {
      AssignmentExpression(path) {
        const { node, scope } = path;
        const { operator, left, right } = node;
        if (operator !== "||=" && operator !== "&&=" && operator !== "??=") {
          return;
        }
        const lhs = t.cloneNode(left);
        if (t.isMemberExpression(left)) {
          const { object, property, computed } = left;
          const memo = scope.maybeGenerateMemoised(object);
          if (memo) {
            left.object = memo;
            lhs.object = t.assignmentExpression("=", t.cloneNode(memo), object);
          }
          if (computed) {
            const memo = scope.maybeGenerateMemoised(property);
            if (memo) {
              left.property = memo;
              lhs.property = t.assignmentExpression(
                "=",
                t.cloneNode(memo),
                property,
              );
            }
          }
        }
        path.replaceWith(
          t.logicalExpression(
            operator.slice(0, -1),
            lhs,
            t.assignmentExpression("=", left, right),
          ),
        );
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-proposal-logical-assignment-operators/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-preset-env-standalone/src/index.js

/* global VERSION */
import { registerPreset } from "@babel/standalone";
import babelPresetEnv from "@babel/preset-env";
registerPreset("env", babelPresetEnv);
export const version = VERSION;

// </from> /home/qfox/apps/babel/packages/babel-preset-env-standalone/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-preset-env-standalone/src/available-plugins.js

import { availablePlugins, registerPlugin } from "@babel/standalone";
const notIncludedPlugins = {
  "transform-new-target": require("@babel/plugin-transform-new-target"),
  "proposal-json-strings": require("@babel/plugin-proposal-json-strings"),
};
Object.keys(notIncludedPlugins).forEach(pluginName => {
  if (!availablePlugins[pluginName]) {
    registerPlugin(pluginName, notIncludedPlugins[pluginName]);
  }
});
export default availablePlugins;

// </from> /home/qfox/apps/babel/packages/babel-preset-env-standalone/src/available-plugins.js

// <from> /home/qfox/apps/babel/packages/babel-preset-env-standalone/src/caniuse-lite-regions.js

module.exports = {};

// </from> /home/qfox/apps/babel/packages/babel-preset-env-standalone/src/caniuse-lite-regions.js

// <from> /home/qfox/apps/babel/packages/babel-helper-split-export-declaration/src/index.js

import * as t from "@babel/types";
export default function splitExportDeclaration(exportDeclaration) {
  if (!exportDeclaration.isExportDeclaration()) {
    throw new Error("Only export declarations can be splitted.");
  }
  // build specifiers that point back to this export declaration
  const isDefault = exportDeclaration.isExportDefaultDeclaration();
  const declaration = exportDeclaration.get("declaration");
  const isClassDeclaration = declaration.isClassDeclaration();
  if (isDefault) {
    const standaloneDeclaration =
      declaration.isFunctionDeclaration() || isClassDeclaration;
    const scope = declaration.isScope()
      ? declaration.scope.parent
      : declaration.scope;
    let id = declaration.node.id;
    let needBindingRegistration = false;
    if (!id) {
      needBindingRegistration = true;
      id = scope.generateUidIdentifier("default");
      if (
        standaloneDeclaration ||
        declaration.isFunctionExpression() ||
        declaration.isClassExpression()
      ) {
        declaration.node.id = t.cloneNode(id);
      }
    }
    const updatedDeclaration = standaloneDeclaration
      ? declaration
      : t.variableDeclaration("var", [
          t.variableDeclarator(t.cloneNode(id), declaration.node),
        ]);
    const updatedExportDeclaration = t.exportNamedDeclaration(null, [
      t.exportSpecifier(t.cloneNode(id), t.identifier("default")),
    ]);
    exportDeclaration.insertAfter(updatedExportDeclaration);
    exportDeclaration.replaceWith(updatedDeclaration);
    if (needBindingRegistration) {
      scope.registerBinding(
        isClassDeclaration ? "let" : "var",
        exportDeclaration,
      );
    }
    return exportDeclaration;
  }
  if (exportDeclaration.get("specifiers").length > 0) {
    throw new Error("It doesn't make sense to split exported specifiers.");
  }
  const bindingIdentifiers = declaration.getOuterBindingIdentifiers();
  const specifiers = Object.keys(bindingIdentifiers).map(name => {
    return t.exportSpecifier(t.identifier(name), t.identifier(name));
  });
  const aliasDeclar = t.exportNamedDeclaration(null, specifiers);
  exportDeclaration.insertAfter(aliasDeclar);
  exportDeclaration.replaceWith(declaration.node);
  return exportDeclaration;
}

// </from> /home/qfox/apps/babel/packages/babel-helper-split-export-declaration/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-computed-properties/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import { template, types as t } from "@babel/core";
export default declare((api, options) => {
  api.assertVersion(7);
  const { loose } = options;
  const pushComputedProps = loose
    ? pushComputedPropsLoose
    : pushComputedPropsSpec;
  const buildMutatorMapAssign = template(`
    MUTATOR_MAP_REF[KEY] = MUTATOR_MAP_REF[KEY] || {};
    MUTATOR_MAP_REF[KEY].KIND = VALUE;
  `);
  function getValue(prop) {
    if (t.isObjectProperty(prop)) {
      return prop.value;
    } else if (t.isObjectMethod(prop)) {
      return t.functionExpression(
        null,
        prop.params,
        prop.body,
        prop.generator,
        prop.async,
      );
    }
  }
  function pushAssign(objId, prop, body) {
    if (prop.kind === "get" && prop.kind === "set") {
      pushMutatorDefine(objId, prop, body);
    } else {
      body.push(
        t.expressionStatement(
          t.assignmentExpression(
            "=",
            t.memberExpression(
              t.cloneNode(objId),
              prop.key,
              prop.computed || t.isLiteral(prop.key),
            ),
            getValue(prop),
          ),
        ),
      );
    }
  }
  function pushMutatorDefine({ body, getMutatorId, scope }, prop) {
    let key =
      !prop.computed && t.isIdentifier(prop.key)
        ? t.stringLiteral(prop.key.name)
        : prop.key;
    const maybeMemoise = scope.maybeGenerateMemoised(key);
    if (maybeMemoise) {
      body.push(
        t.expressionStatement(t.assignmentExpression("=", maybeMemoise, key)),
      );
      key = maybeMemoise;
    }
    body.push(
      ...buildMutatorMapAssign({
        MUTATOR_MAP_REF: getMutatorId(),
        KEY: t.cloneNode(key),
        VALUE: getValue(prop),
        KIND: t.identifier(prop.kind),
      }),
    );
  }
  function pushComputedPropsLoose(info) {
    for (const prop of info.computedProps) {
      if (prop.kind === "get" || prop.kind === "set") {
        pushMutatorDefine(info, prop);
      } else {
        pushAssign(t.cloneNode(info.objId), prop, info.body);
      }
    }
  }
  function pushComputedPropsSpec(info) {
    const { objId, body, computedProps, state } = info;
    for (const prop of computedProps) {
      const key = t.toComputedKey(prop);
      if (prop.kind === "get" || prop.kind === "set") {
        pushMutatorDefine(info, prop);
      } else if (t.isStringLiteral(key, { value: "__proto__" })) {
        pushAssign(objId, prop, body);
      } else {
        if (computedProps.length === 1) {
          return t.callExpression(state.addHelper("defineProperty"), [
            info.initPropExpression,
            key,
            getValue(prop),
          ]);
        } else {
          body.push(
            t.expressionStatement(
              t.callExpression(state.addHelper("defineProperty"), [
                t.cloneNode(objId),
                key,
                getValue(prop),
              ]),
            ),
          );
        }
      }
    }
  }
  return {
    visitor: {
      ObjectExpression: {
        exit(path, state) {
          const { node, parent, scope } = path;
          let hasComputed = false;
          for (const prop of (node.properties: Array<Object>)) {
            hasComputed = prop.computed === true;
            if (hasComputed) break;
          }
          if (!hasComputed) return;
          // put all getters/setters into the first object expression as well as all initialisers up
          // to the first computed property
          const initProps = [];
          const computedProps = [];
          let foundComputed = false;
          for (const prop of node.properties) {
            if (prop.computed) {
              foundComputed = true;
            }
            if (foundComputed) {
              computedProps.push(prop);
            } else {
              initProps.push(prop);
            }
          }
          const objId = scope.generateUidIdentifierBasedOnNode(parent);
          const initPropExpression = t.objectExpression(initProps);
          const body = [];
          body.push(
            t.variableDeclaration("var", [
              t.variableDeclarator(objId, initPropExpression),
            ]),
          );
          let mutatorRef;
          const getMutatorId = function() {
            if (!mutatorRef) {
              mutatorRef = scope.generateUidIdentifier("mutatorMap");
              body.push(
                t.variableDeclaration("var", [
                  t.variableDeclarator(mutatorRef, t.objectExpression([])),
                ]),
              );
            }
            return t.cloneNode(mutatorRef);
          };
          const single = pushComputedProps({
            scope,
            objId,
            body,
            computedProps,
            initPropExpression,
            getMutatorId,
            state,
          });
          if (mutatorRef) {
            body.push(
              t.expressionStatement(
                t.callExpression(
                  state.addHelper("defineEnumerableProperties"),
                  [t.cloneNode(objId), t.cloneNode(mutatorRef)],
                ),
              ),
            );
          }
          if (single) {
            path.replaceWith(single);
          } else {
            body.push(t.expressionStatement(t.cloneNode(objId)));
            path.replaceWithMultiple(body);
          }
        },
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-computed-properties/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-new-target/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import { types as t } from "@babel/core";
export default declare(api => {
  api.assertVersion(7);
  return {
    name: "transform-new-target",
    visitor: {
      MetaProperty(path) {
        const meta = path.get("meta");
        const property = path.get("property");
        const { scope } = path;
        if (
          meta.isIdentifier({ name: "new" }) &&
          property.isIdentifier({ name: "target" })
        ) {
          const func = path.findParent(path => {
            if (path.isClass()) return true;
            if (path.isFunction() && !path.isArrowFunctionExpression()) {
              if (path.isClassMethod({ kind: "constructor" })) {
                return false;
              }
              return true;
            }
            return false;
          });
          if (!func) {
            throw path.buildCodeFrameError(
              "new.target must be under a (non-arrow) function or a class.",
            );
          }
          const { node } = func;
          if (!node.id) {
            if (func.isMethod()) {
              path.replaceWith(scope.buildUndefinedNode());
              return;
            }
            node.id = scope.generateUidIdentifier("target");
          }
          const constructor = t.memberExpression(
            t.thisExpression(),
            t.identifier("constructor"),
          );
          if (func.isClass()) {
            path.replaceWith(constructor);
            return;
          }
          path.replaceWith(
            t.conditionalExpression(
              t.binaryExpression(
                "instanceof",
                t.thisExpression(),
                t.cloneNode(node.id),
              ),
              constructor,
              scope.buildUndefinedNode(),
            ),
          );
        }
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-new-target/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-for-of/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import { template, types as t } from "@babel/core";
export default declare((api, options) => {
  api.assertVersion(7);
  const { loose, assumeArray } = options;
  if (loose === true && assumeArray === true) {
    throw new Error(
      `The loose and assumeArray options cannot be used together in @babel/plugin-transform-for-of`,
    );
  }
  if (assumeArray) {
    return {
      visitor: {
        ForOfStatement(path) {
          const { scope } = path;
          const { left, right, body } = path.node;
          const i = scope.generateUidIdentifier("i");
          let array = scope.maybeGenerateMemoised(right, true);
          const inits = [t.variableDeclarator(i, t.numericLiteral(0))];
          if (array) {
            inits.push(t.variableDeclarator(array, right));
          } else {
            array = right;
          }
          const item = t.memberExpression(
            t.cloneNode(array),
            t.cloneNode(i),
            true,
          );
          let assignment;
          if (t.isVariableDeclaration(left)) {
            assignment = left;
            assignment.declarations[0].init = item;
          } else {
            assignment = t.expressionStatement(
              t.assignmentExpression("=", left, item),
            );
          }
          const block = t.toBlock(body);
          block.body.unshift(assignment);
          path.replaceWith(
            t.forStatement(
              t.variableDeclaration("let", inits),
              t.binaryExpression(
                "<",
                t.cloneNode(i),
                t.memberExpression(t.cloneNode(array), t.identifier("length")),
              ),
              t.updateExpression("++", t.cloneNode(i)),
              block,
            ),
          );
        },
      },
    };
  }
  const pushComputedProps = loose
    ? pushComputedPropsLoose
    : pushComputedPropsSpec;
  const buildForOfArray = template(`
    for (var KEY = 0; KEY < ARR.length; KEY++) BODY;
  `);
  const buildForOfLoose = template(`
    for (var LOOP_OBJECT = OBJECT,
             IS_ARRAY = Array.isArray(LOOP_OBJECT),
             INDEX = 0,
             LOOP_OBJECT = IS_ARRAY ? LOOP_OBJECT : LOOP_OBJECT[Symbol.iterator]();;) {
      INTERMEDIATE;
      if (IS_ARRAY) {
        if (INDEX >= LOOP_OBJECT.length) break;
        ID = LOOP_OBJECT[INDEX++];
      } else {
        INDEX = LOOP_OBJECT.next();
        if (INDEX.done) break;
        ID = INDEX.value;
      }
    }
  `);
  const buildForOf = template(`
    var ITERATOR_COMPLETION = true;
    var ITERATOR_HAD_ERROR_KEY = false;
    var ITERATOR_ERROR_KEY = undefined;
    try {
      for (
        var ITERATOR_KEY = OBJECT[Symbol.iterator](), STEP_KEY;
        !(ITERATOR_COMPLETION = (STEP_KEY = ITERATOR_KEY.next()).done);
        ITERATOR_COMPLETION = true
      ) {}
    } catch (err) {
      ITERATOR_HAD_ERROR_KEY = true;
      ITERATOR_ERROR_KEY = err;
    } finally {
      try {
        if (!ITERATOR_COMPLETION && ITERATOR_KEY.return != null) {
          ITERATOR_KEY.return();
        }
      } finally {
        if (ITERATOR_HAD_ERROR_KEY) {
          throw ITERATOR_ERROR_KEY;
        }
      }
    }
  `);
  function _ForOfStatementArray(path) {
    const { node, scope } = path;
    const nodes = [];
    let right = node.right;
    if (!t.isIdentifier(right) || !scope.hasBinding(right.name)) {
      const uid = scope.generateUid("arr");
      nodes.push(
        t.variableDeclaration("var", [
          t.variableDeclarator(t.identifier(uid), right),
        ]),
      );
      right = t.identifier(uid);
    }
    const iterationKey = scope.generateUidIdentifier("i");
    let loop = buildForOfArray({
      BODY: node.body,
      KEY: iterationKey,
      ARR: right,
    });
    t.inherits(loop, node);
    t.ensureBlock(loop);
    const iterationValue = t.memberExpression(
      t.cloneNode(right),
      t.cloneNode(iterationKey),
      true,
    );
    const left = node.left;
    if (t.isVariableDeclaration(left)) {
      left.declarations[0].init = iterationValue;
      loop.body.body.unshift(left);
    } else {
      loop.body.body.unshift(
        t.expressionStatement(
          t.assignmentExpression("=", left, iterationValue),
        ),
      );
    }
    if (path.parentPath.isLabeledStatement()) {
      loop = t.labeledStatement(path.parentPath.node.label, loop);
    }
    nodes.push(loop);
    return nodes;
  }
  function replaceWithArray(path) {
    if (path.parentPath.isLabeledStatement()) {
      path.parentPath.replaceWithMultiple(_ForOfStatementArray(path));
    } else {
      path.replaceWithMultiple(_ForOfStatementArray(path));
    }
  }
  return {
    visitor: {
      ForOfStatement(path, state) {
        const right = path.get("right");
        if (
          right.isArrayExpression() ||
          right.isGenericType("Array") ||
          t.isArrayTypeAnnotation(right.getTypeAnnotation())
        ) {
          replaceWithArray(path);
          return;
        }
        const { node } = path;
        const build = pushComputedProps(path, state);
        const declar = build.declar;
        const loop = build.loop;
        const block = loop.body;
        // ensure that it's a block so we can take all its statements
        path.ensureBlock();
        // add the value declaration to the new loop body
        if (declar) {
          block.body.push(declar);
        }
        // push the rest of the original loop body onto our new body
        block.body = block.body.concat(node.body.body);
        t.inherits(loop, node);
        t.inherits(loop.body, node.body);
        if (build.replaceParent) {
          path.parentPath.replaceWithMultiple(build.node);
          path.remove();
        } else {
          path.replaceWithMultiple(build.node);
        }
      },
    },
  };
  function pushComputedPropsLoose(path, file) {
    const { node, scope, parent } = path;
    const { left } = node;
    let declar, id, intermediate;
    if (
      t.isIdentifier(left) ||
      t.isPattern(left) ||
      t.isMemberExpression(left)
    ) {
      // for (i of test), for ({ i } of test)
      id = left;
      intermediate = null;
    } else if (t.isVariableDeclaration(left)) {
      // for (let i of test)
      id = scope.generateUidIdentifier("ref");
      declar = t.variableDeclaration(left.kind, [
        t.variableDeclarator(left.declarations[0].id, t.identifier(id.name)),
      ]);
      intermediate = t.variableDeclaration("var", [
        t.variableDeclarator(t.identifier(id.name)),
      ]);
    } else {
      throw file.buildCodeFrameError(
        left,
        `Unknown node type ${left.type} in ForStatement`,
      );
    }
    const iteratorKey = scope.generateUidIdentifier("iterator");
    const isArrayKey = scope.generateUidIdentifier("isArray");
    const loop = buildForOfLoose({
      LOOP_OBJECT: iteratorKey,
      IS_ARRAY: isArrayKey,
      OBJECT: node.right,
      INDEX: scope.generateUidIdentifier("i"),
      ID: id,
      INTERMEDIATE: intermediate,
    });
    //
    const isLabeledParent = t.isLabeledStatement(parent);
    let labeled;
    if (isLabeledParent) {
      labeled = t.labeledStatement(parent.label, loop);
    }
    return {
      replaceParent: isLabeledParent,
      declar: declar,
      node: labeled || loop,
      loop: loop,
    };
  }
  function pushComputedPropsSpec(path, file) {
    const { node, scope, parent } = path;
    const left = node.left;
    let declar;
    const stepKey = scope.generateUid("step");
    const stepValue = t.memberExpression(
      t.identifier(stepKey),
      t.identifier("value"),
    );
    if (
      t.isIdentifier(left) ||
      t.isPattern(left) ||
      t.isMemberExpression(left)
    ) {
      // for (i of test), for ({ i } of test)
      declar = t.expressionStatement(
        t.assignmentExpression("=", left, stepValue),
      );
    } else if (t.isVariableDeclaration(left)) {
      // for (let i of test)
      declar = t.variableDeclaration(left.kind, [
        t.variableDeclarator(left.declarations[0].id, stepValue),
      ]);
    } else {
      throw file.buildCodeFrameError(
        left,
        `Unknown node type ${left.type} in ForStatement`,
      );
    }
    const template = buildForOf({
      ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier("didIteratorError"),
      ITERATOR_COMPLETION: scope.generateUidIdentifier(
        "iteratorNormalCompletion",
      ),
      ITERATOR_ERROR_KEY: scope.generateUidIdentifier("iteratorError"),
      ITERATOR_KEY: scope.generateUidIdentifier("iterator"),
      STEP_KEY: t.identifier(stepKey),
      OBJECT: node.right,
    });
    const isLabeledParent = t.isLabeledStatement(parent);
    const tryBody = template[3].block.body;
    const loop = tryBody[0];
    if (isLabeledParent) {
      tryBody[0] = t.labeledStatement(parent.label, loop);
    }
    //
    return {
      replaceParent: isLabeledParent,
      declar: declar,
      loop: loop,
      node: template,
    };
  }
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-for-of/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-syntax-async-generators/src/index.js

import { declare } from "@babel/helper-plugin-utils";
export default declare(api => {
  api.assertVersion(7);
  return {
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("asyncGenerators");
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-syntax-async-generators/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-helper-transform-fixture-test-runner/src/index.js

/* eslint-env jest */
import * as babel from "@babel/core";
import { buildExternalHelpers } from "@babel/core";
import getFixtures from "@babel/helper-fixtures";
import sourceMap from "source-map";
import { codeFrameColumns } from "@babel/code-frame";
import defaults from "lodash/defaults";
import includes from "lodash/includes";
import escapeRegExp from "lodash/escapeRegExp";
import * as helpers from "./helpers";
import extend from "lodash/extend";
import merge from "lodash/merge";
import resolve from "resolve";
import assert from "assert";
import fs from "fs";
import path from "path";
import vm from "vm";
import checkDuplicatedNodes from "babel-check-duplicated-nodes";
import diff from "jest-diff";
const moduleCache = {};
const testContext = vm.createContext({
  ...helpers,
  process: process,
  transform: babel.transform,
  setTimeout: setTimeout,
  setImmediate: setImmediate,
  expect,
});
testContext.global = testContext;
// Initialize the test context with the polyfill, and then freeze the global to prevent implicit
// global creation in tests, which could cause things to bleed between tests.
runModuleInTestContext("@babel/polyfill", __filename);
// Populate the "babelHelpers" global with Babel's helper utilities.
runCodeInTestContext(buildExternalHelpers(), {
  filename: path.join(__dirname, "babel-helpers-in-memory.js"),
});
/**
 * A basic implementation of CommonJS so we can execute `@babel/polyfill` inside our test context.
 * This allows us to run our unittests
 */
function runModuleInTestContext(id: string, relativeFilename: string) {
  const filename = resolve.sync(id, {
    basedir: path.dirname(relativeFilename),
  });
  // Expose Node-internal modules if the tests want them. Note, this will not execute inside
  // the context's global scope.
  if (filename === id) return require(id);
  if (moduleCache[filename]) return moduleCache[filename].exports;
  const module = (moduleCache[filename] = {
    id: filename,
    exports: {},
  });
  const dirname = path.dirname(filename);
  const req = id => runModuleInTestContext(id, filename);
  const src = fs.readFileSync(filename, "utf8");
  const code = `(function (exports, require, module, __filename, __dirname) {${src}\n});`;
  vm.runInContext(code, testContext, {
    filename,
    displayErrors: true,
  }).call(module.exports, module.exports, req, module, filename, dirname);
  return module.exports;
}
/**
 * Run the given snippet of code inside a CommonJS module.
 *
 * Exposed for unit tests, not for use as an API.
 */
export function runCodeInTestContext(code: string, opts: { filename: string }) {
  const filename = opts.filename;
  const dirname = path.dirname(filename);
  const req = id => runModuleInTestContext(id, filename);
  const module = {
    id: filename,
    exports: {},
  };
  const oldCwd = process.cwd();
  try {
    if (opts.filename) process.chdir(path.dirname(opts.filename));
    // Expose the test options as "opts", but otherwise run the test in a CommonJS-like environment.
    // Note: This isn't doing .call(module.exports, ...) because some of our tests currently
    // rely on 'this === global'.
    const src = `(function(exports, require, module, __filename, __dirname, opts) {${code}\n});`;
    return vm.runInContext(src, testContext, {
      filename,
      displayErrors: true,
    })(module.exports, req, module, filename, dirname, opts);
  } finally {
    process.chdir(oldCwd);
  }
}
function wrapPackagesArray(type, names, optionsDir) {
  return (names || []).map(function(val) {
    if (typeof val === "string") val = [val];
    // relative path (outside of monorepo)
    if (val[0][0] === ".") {
      if (!optionsDir) {
        throw new Error(
          "Please provide an options.json in test dir when using a " +
            "relative plugin path.",
        );
      }
      val[0] = path.resolve(optionsDir, val[0]);
    } else {
      const monorepoPath = __dirname + "/../../babel-" + type + "-" + val[0];
      if (fs.existsSync(monorepoPath)) {
        val[0] = monorepoPath;
      }
    }
    return val;
  });
}
function run(task) {
  const actual = task.actual;
  const expected = task.expect;
  const exec = task.exec;
  const opts = task.options;
  const optionsDir = task.optionsDir;
  function getOpts(self) {
    const newOpts = merge(
      {
        cwd: path.dirname(self.loc),
        filename: self.loc,
        filenameRelative: self.filename,
        sourceFileName: self.filename,
        sourceType: "script",
        babelrc: false,
        inputSourceMap: task.inputSourceMap || undefined,
      },
      opts,
    );
    newOpts.plugins = wrapPackagesArray("plugin", newOpts.plugins, optionsDir);
    newOpts.presets = wrapPackagesArray(
      "preset",
      newOpts.presets,
      optionsDir,
    ).map(function(val) {
      if (val.length > 3) {
        throw new Error(
          "Unexpected extra options " +
            JSON.stringify(val.slice(3)) +
            " passed to preset.",
        );
      }
      return val;
    });
    return newOpts;
  }
  let execCode = exec.code;
  let result;
  let resultExec;
  if (execCode) {
    const execOpts = getOpts(exec);
    result = babel.transform(execCode, execOpts);
    checkDuplicatedNodes(babel, result.ast);
    execCode = result.code;
    try {
      resultExec = runCodeInTestContext(execCode, execOpts);
    } catch (err) {
      // Pass empty location to include the whole file in the output.
      err.message =
        `${exec.loc}: ${err.message}\n` + codeFrameColumns(execCode, {});
      throw err;
    }
  }
  let actualCode = actual.code;
  const expectCode = expected.code;
  if (!execCode || actualCode) {
    result = babel.transform(actualCode, getOpts(actual));
    const expectedCode = result.code.replace(
      escapeRegExp(path.resolve(__dirname, "../../../")),
      "<CWD>",
    );
    checkDuplicatedNodes(babel, result.ast);
    if (
      !expected.code &&
      expectedCode &&
      !opts.throws &&
      fs.statSync(path.dirname(expected.loc)).isDirectory() &&
      !process.env.CI
    ) {
      const expectedFile = expected.loc.replace(
        /\.m?js$/,
        result.sourceType === "module" ? ".mjs" : ".js",
      );
      console.log(`New test file created: ${expectedFile}`);
      fs.writeFileSync(expectedFile, `${expectedCode}\n`);
      if (expected.loc !== expectedFile) {
        try {
          fs.unlinkSync(expected.loc);
        } catch (e) {}
      }
    } else {
      actualCode = expectedCode.trim();
      try {
        expect(actualCode).toEqualFile({
          filename: expected.loc,
          code: expectCode,
        });
      } catch (e) {
        if (!process.env.OVERWRITE) throw e;
        console.log(`Updated test file: ${expected.loc}`);
        fs.writeFileSync(expected.loc, `${expectedCode}\n`);
      }
      if (actualCode) {
        expect(expected.loc).toMatch(
          result.sourceType === "module" ? /\.mjs$/ : /\.js$/,
        );
      }
    }
  }
  if (task.sourceMap) {
    expect(result.map).toEqual(task.sourceMap);
  }
  if (task.sourceMappings) {
    const consumer = new sourceMap.SourceMapConsumer(result.map);
    task.sourceMappings.forEach(function(mapping) {
      const actual = mapping.original;
      const expected = consumer.originalPositionFor(mapping.generated);
      expect({ line: expected.line, column: expected.column }).toEqual(actual);
    });
  }
  if (execCode && resultExec) {
    return resultExec;
  }
}
const toEqualFile = () => ({
  compare: (actual, { filename, code }) => {
    const pass = actual === code;
    return {
      pass,
      message: () => {
        const diffString = diff(code, actual, {
          expand: false,
        });
        return (
          `Expected ${filename} to match transform output.\n` +
          `To autogenerate a passing version of this file, delete the file and re-run the tests.\n\n` +
          `Diff:\n\n${diffString}`
        );
      },
    };
  },
  negativeCompare: () => {
    throw new Error("Negation unsupported");
  },
});
export default function(
  fixturesLoc: string,
  name: string,
  suiteOpts = {},
  taskOpts = {},
  dynamicOpts?: Function,
) {
  const suites = getFixtures(fixturesLoc);
  for (const testSuite of suites) {
    if (includes(suiteOpts.ignoreSuites, testSuite.title)) continue;
    describe(name + "/" + testSuite.title, function() {
      jest.addMatchers({
        toEqualFile,
      });
      for (const task of testSuite.tests) {
        if (
          includes(suiteOpts.ignoreTasks, task.title) ||
          includes(suiteOpts.ignoreTasks, testSuite.title + "/" + task.title)
        ) {
          continue;
        }
        const testFn = task.disabled ? it.skip : it;
        testFn(
          task.title,
          function() {
            function runTask() {
              run(task);
            }
            defaults(task.options, {
              sourceMap: !!(task.sourceMappings || task.sourceMap),
            });
            extend(task.options, taskOpts);
            if (dynamicOpts) dynamicOpts(task.options, task);
            const throwMsg = task.options.throws;
            if (throwMsg) {
              // internal api doesn't have this option but it's best not to pollute
              // the options object with useless options
              delete task.options.throws;
              assert.throws(runTask, function(err) {
                return throwMsg === true || err.message.indexOf(throwMsg) >= 0;
              });
            } else {
              if (task.exec.code) {
                const result = run(task);
                if (result && typeof result.then === "function") {
                  return result;
                }
              } else {
                runTask();
              }
            }
          },
        );
      }
    });
  }
}

// </from> /home/qfox/apps/babel/packages/babel-helper-transform-fixture-test-runner/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-helper-transform-fixture-test-runner/src/helpers.js

export function assertNoOwnProperties(obj) {
  expect(Object.getOwnPropertyNames(obj)).toHaveLength(0);
}
export function multiline(arr) {
  return arr.join("\n");
}

// </from> /home/qfox/apps/babel/packages/babel-helper-transform-fixture-test-runner/src/helpers.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-syntax-logical-assignment-operators/src/index.js

import { declare } from "@babel/helper-plugin-utils";
export default declare(api => {
  api.assertVersion(7);
  return {
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("logicalAssignment");
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-syntax-logical-assignment-operators/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-async-to-generator/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import remapAsyncToGenerator from "@babel/helper-remap-async-to-generator";
import { addNamed } from "@babel/helper-module-imports";
import { types as t } from "@babel/core";
export default declare((api, options) => {
  api.assertVersion(7);
  const { method, module } = options;
  if (method && module) {
    return {
      visitor: {
        Function(path, state) {
          if (!path.node.async || path.node.generator) return;
          let wrapAsync = state.methodWrapper;
          if (wrapAsync) {
            wrapAsync = t.cloneNode(wrapAsync);
          } else {
            wrapAsync = state.methodWrapper = addNamed(path, method, module);
          }
          remapAsyncToGenerator(path, { wrapAsync });
        },
      },
    };
  }
  return {
    visitor: {
      Function(path, state) {
        if (!path.node.async || path.node.generator) return;
        remapAsyncToGenerator(path, {
          wrapAsync: state.addHelper("asyncToGenerator"),
        });
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-async-to-generator/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-syntax-do-expressions/src/index.js

import { declare } from "@babel/helper-plugin-utils";
export default declare(api => {
  api.assertVersion(7);
  return {
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("doExpressions");
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-syntax-do-expressions/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-node/src/_babel-node.js

import commander from "commander";
import Module from "module";
import { inspect } from "util";
import path from "path";
import repl from "repl";
import * as babel from "@babel/core";
import vm from "vm";
import "@babel/polyfill";
import register from "@babel/register";
import pkg from "../package.json";
const program = new commander.Command("babel-node");
function collect(value, previousValue): Array<string> {
  // If the user passed the option with no value, like "babel-node file.js --presets", do nothing.
  if (typeof value !== "string") return previousValue;
  const values = value.split(",");
  return previousValue ? previousValue.concat(values) : values;
}
program.option("-e, --eval [script]", "Evaluate script");
program.option(
  "--no-babelrc",
  "Specify whether or not to use .babelrc and .babelignore files",
);
program.option("-r, --require [module]", "Require module");
program.option("-p, --print [code]", "Evaluate script and print result");
program.option(
  "-o, --only [globs]",
  "A comma-separated list of glob patterns to compile",
  collect,
);
program.option(
  "-i, --ignore [globs]",
  "A comma-separated list of glob patterns to skip compiling",
  collect,
);
program.option(
  "-x, --extensions [extensions]",
  "List of extensions to hook into [.es6,.js,.es,.jsx,.mjs]",
  collect,
);
program.option(
  "--config-file [path]",
  "Path to the babel config file to use. Defaults to working directory babel.config.js",
);
program.option(
  "--env-name [name]",
  "The name of the 'env' to use when loading configs and plugins. " +
    "Defaults to the value of BABEL_ENV, or else NODE_ENV, or else 'development'.",
);
program.option("-w, --plugins [string]", "", collect);
program.option("-b, --presets [string]", "", collect);
program.version(pkg.version);
program.usage("[options] [ -e script | script.js ] [arguments]");
program.parse(process.argv);
register({
  caller: {
    name: "@babel/node",
  },
  extensions: program.extensions,
  ignore: program.ignore,
  only: program.only,
  plugins: program.plugins,
  presets: program.presets,
  configFile: program.configFile,
  envName: program.envName,
  // Commander will default the "--no-" arguments to true, but we want to
  // leave them undefined so that @babel/core can handle the
  // default-assignment logic on its own.
  babelrc: program.babelrc === true ? undefined : program.babelrc,
});
const replPlugin = ({ types: t }) => ({
  visitor: {
    ModuleDeclaration(path) {
      throw path.buildCodeFrameError("Modules aren't supported in the REPL");
    },
    VariableDeclaration(path) {
      if (path.node.kind !== "var") {
        throw path.buildCodeFrameError(
          "Only `var` variables are supported in the REPL",
        );
      }
    },
    Program(path) {
      if (path.get("body").some(child => child.isExpressionStatement())) return;
      // If the executed code doesn't evaluate to a value,
      // prevent implicit strict mode from printing 'use strict'.
      path.pushContainer(
        "body",
        t.expressionStatement(t.identifier("undefined")),
      );
    },
  },
});
const _eval = function(code, filename) {
  code = code.trim();
  if (!code) return undefined;
  code = babel.transform(code, {
    filename: filename,
    presets: program.presets,
    plugins: (program.plugins || []).concat([replPlugin]),
  }).code;
  return vm.runInThisContext(code, {
    filename: filename,
  });
};
if (program.eval || program.print) {
  let code = program.eval;
  if (!code || code === true) code = program.print;
  global.__filename = "[eval]";
  global.__dirname = process.cwd();
  const module = new Module(global.__filename);
  module.filename = global.__filename;
  module.paths = Module._nodeModulePaths(global.__dirname);
  global.exports = module.exports;
  global.module = module;
  global.require = module.require.bind(module);
  const result = _eval(code, global.__filename);
  if (program.print) {
    const output = typeof result === "string" ? result : inspect(result);
    process.stdout.write(output + "\n");
  }
} else {
  if (program.args.length) {
    // slice all arguments up to the first filename since they're babel args that we handle
    let args = process.argv.slice(2);
    let i = 0;
    let ignoreNext = false;
    args.some(function(arg, i2) {
      if (ignoreNext) {
        ignoreNext = false;
        return;
      }
      if (arg[0] === "-") {
        const camelArg = arg
          .slice(2)
          .replace(/-(\w)/, (s, c) => c.toUpperCase());
        const parsedArg = program[camelArg];
        if (
          arg === "-r" ||
          arg === "--require" ||
          (parsedArg && parsedArg !== true)
        ) {
          ignoreNext = true;
        }
      } else {
        i = i2;
        return true;
      }
    });
    args = args.slice(i);
    // We have to handle require ourselves, as we want to require it in the context of babel-register
    if (program.require) {
      let requireFileName = program.require;
      if (!path.isAbsolute(requireFileName)) {
        requireFileName = path.join(process.cwd(), requireFileName);
      }
      require(requireFileName);
    }
    // make the filename absolute
    const filename = args[0];
    if (!path.isAbsolute(filename)) {
      args[0] = path.join(process.cwd(), filename);
    }
    // add back on node and concat the sliced args
    process.argv = ["node"].concat(args);
    process.execArgv.unshift(__filename);
    Module.runMain();
  } else {
    replStart();
  }
}
function replStart() {
  repl.start({
    prompt: "> ",
    input: process.stdin,
    output: process.stdout,
    eval: replEval,
    useGlobal: true,
  });
}
function replEval(code, context, filename, callback) {
  let err;
  let result;
  try {
    if (code[0] === "(" && code[code.length - 1] === ")") {
      code = code.slice(1, -1); // remove "(" and ")"
    }
    result = _eval(code, filename);
  } catch (e) {
    err = e;
  }
  callback(err, result);
}

// </from> /home/qfox/apps/babel/packages/babel-node/src/_babel-node.js

// <from> /home/qfox/apps/babel/packages/babel-node/src/babel-node.js

/**
 * This tiny wrapper file checks for known node flags and appends them
 * when found, before invoking the "real" _babel-node(1) executable.
 */
import getV8Flags from "v8flags";
import path from "path";
let args = [path.join(__dirname, "_babel-node")];
let babelArgs = process.argv.slice(2);
let userArgs;
// separate node arguments from script arguments
const argSeparator = babelArgs.indexOf("--");
if (argSeparator > -1) {
  userArgs = babelArgs.slice(argSeparator); // including the  --
  babelArgs = babelArgs.slice(0, argSeparator);
}
/**
 * Replace dashes with underscores in the v8Flag name
 * Also ensure that if the arg contains a value (e.g. --arg=true)
 * that only the flag is returned.
 */
function getNormalizedV8Flag(arg) {
  const matches = arg.match(/--(.+)/);
  if (matches) {
    return `--${matches[1].replace(/-/g, "_")}`;
  }
  return arg;
}
getV8Flags(function(err, v8Flags) {
  babelArgs.forEach(function(arg, index) {
    const flag = arg.split("=")[0];
    switch (flag) {
      case "-d":
        args.unshift("--debug");
        break;
      case "debug":
      case "--debug":
      case "--debug-brk":
      case "--inspect":
      case "--inspect-brk":
      case "--experimental-modules":
        args.unshift(arg);
        break;
      case "-r":
      case "--require":
        args.push(flag);
        args.push(babelArgs[index + 1]);
        delete babelArgs[index + 1];
        break;
      case "-gc":
        args.unshift("--expose-gc");
        break;
      case "--nolazy":
        args.unshift(flag);
        break;
      default:
        if (
          v8Flags.indexOf(getNormalizedV8Flag(flag)) >= 0 ||
          arg.indexOf("--trace") === 0
        ) {
          args.unshift(arg);
        } else {
          args.push(arg);
        }
        break;
    }
  });
  // append arguments passed after --
  if (argSeparator > -1) {
    args = args.concat(userArgs);
  }
  try {
    const kexec = require("kexec");
    kexec(process.argv[0], args);
  } catch (err) {
    if (err.code !== "MODULE_NOT_FOUND") throw err;
    const child_process = require("child_process");
    const proc = child_process.spawn(process.argv[0], args, {
      stdio: "inherit",
    });
    proc.on("exit", function(code, signal) {
      process.on("exit", function() {
        if (signal) {
          process.kill(process.pid, signal);
        } else {
          process.exit(code);
        }
      });
    });
    process.on("SIGINT", () => {
      proc.kill("SIGINT");
      process.exit(1);
    });
  }
});

// </from> /home/qfox/apps/babel/packages/babel-node/src/babel-node.js

// <from> /home/qfox/apps/babel/packages/babel-node/bin/babel-node.js

#!/usr/bin/env node
require("../lib/babel-node");

// </from> /home/qfox/apps/babel/packages/babel-node/bin/babel-node.js

// <from> /home/qfox/apps/babel/packages/babel-preset-stage-2/src/index.js

export default function() {
  throw new Error(`
As of v7.0.0-beta.55, we've removed Babel's Stage presets.
Please consider reading our blog post on this decision at
https://babeljs.io/blog/2018/07/27/removing-babels-stage-presets
for more details. TL;DR is that it's more beneficial in the
  long run to explicitly add which proposals to use.
For a more automatic migration, we have updated babel-upgrade,
https://github.com/babel/babel-upgrade to do this for you with
"npx babel-upgrade".
If you want the same configuration as before:
{
  "plugins": [
    // Stage 2
    ["@babel/plugin-proposal-decorators", { "legacy": true }],
    "@babel/plugin-proposal-function-sent",
    "@babel/plugin-proposal-export-namespace-from",
    "@babel/plugin-proposal-numeric-separator",
    "@babel/plugin-proposal-throw-expressions",
    // Stage 3
    "@babel/plugin-syntax-dynamic-import",
    "@babel/plugin-syntax-import-meta",
    ["@babel/plugin-proposal-class-properties", { "loose": false }],
    "@babel/plugin-proposal-json-strings"
  ]
}
If you're using the same configuration across many separate projects,
keep in mind that you can also create your own custom presets with
whichever plugins and presets you're looking to use.
module.exports = function() {
  return {
    plugins: [
      require("@babel/plugin-syntax-dynamic-import"),
      [require("@babel/plugin-proposal-decorators"), { "legacy": true }],
      [require("@babel/plugin-proposal-class-properties"), { "loose": false }],
    ],
    presets: [
      // ...
    ],
  };
};
`);
}

// </from> /home/qfox/apps/babel/packages/babel-preset-stage-2/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-react-constant-elements/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import { types as t } from "@babel/core";
import annotateAsPure from "@babel/helper-annotate-as-pure";
export default declare((api, options) => {
  api.assertVersion(7);
  const { allowMutablePropsOnTags } = options;
  if (
    allowMutablePropsOnTags != null &&
    !Array.isArray(allowMutablePropsOnTags)
  ) {
    throw new Error(
      ".allowMutablePropsOnTags must be an array, null, or undefined.",
    );
  }
  const HOISTED = new WeakSet();
  const immutabilityVisitor = {
    enter(path, state) {
      const stop = () => {
        state.isImmutable = false;
        path.stop();
      };
      if (path.isJSXClosingElement()) {
        path.skip();
        return;
      }
      // Elements with refs are not safe to hoist.
      if (
        path.isJSXIdentifier({ name: "ref" }) &&
        path.parentPath.isJSXAttribute({ name: path.node })
      ) {
        return stop();
      }
      // Ignore identifiers & JSX expressions.
      if (
        path.isJSXIdentifier() ||
        path.isIdentifier() ||
        path.isJSXMemberExpression()
      ) {
        return;
      }
      if (!path.isImmutable()) {
        // If it's not immutable, it may still be a pure expression, such as string concatenation.
        // It is still safe to hoist that, so long as its result is immutable.
        // If not, it is not safe to replace as mutable values (like objects) could be mutated after render.
        // https://github.com/facebook/react/issues/3226
        if (path.isPure()) {
          const expressionResult = path.evaluate();
          if (expressionResult.confident) {
            // We know the result; check its mutability.
            const { value } = expressionResult;
            const isMutable =
              (!state.mutablePropsAllowed &&
                (value && typeof value === "object")) ||
              typeof value === "function";
            if (!isMutable) {
              // It evaluated to an immutable value, so we can hoist it.
              path.skip();
              return;
            }
          } else if (t.isIdentifier(expressionResult.deopt)) {
            // It's safe to hoist here if the deopt reason is an identifier (e.g. func param).
            // The hoister will take care of how high up it can be hoisted.
            return;
          }
        }
        stop();
      }
    },
  };
  return {
    visitor: {
      JSXElement(path) {
        if (HOISTED.has(path.node)) return;
        HOISTED.add(path.node);
        const state = { isImmutable: true };
        // This transform takes the option `allowMutablePropsOnTags`, which is an array
        // of JSX tags to allow mutable props (such as objects, functions) on. Use sparingly
        // and only on tags you know will never modify their own props.
        if (allowMutablePropsOnTags != null) {
          // Get the element's name. If it's a member expression, we use the last part of the path.
          // So the option ["FormattedMessage"] would match "Intl.FormattedMessage".
          let namePath = path.get("openingElement.name");
          while (namePath.isJSXMemberExpression()) {
            namePath = namePath.get("property");
          }
          const elementName = namePath.node.name;
          state.mutablePropsAllowed =
            allowMutablePropsOnTags.indexOf(elementName) > -1;
        }
        // Traverse all props passed to this element for immutability.
        path.traverse(immutabilityVisitor, state);
        if (state.isImmutable) {
          const hoisted = path.hoist();
          if (hoisted) {
            annotateAsPure(hoisted);
          }
        }
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-react-constant-elements/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-syntax-class-properties/src/index.js

import { declare } from "@babel/helper-plugin-utils";
export default declare(api => {
  api.assertVersion(7);
  return {
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("classProperties", "classPrivateProperties");
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-syntax-class-properties/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-shorthand-properties/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import { types as t } from "@babel/core";
export default declare(api => {
  api.assertVersion(7);
  return {
    visitor: {
      ObjectMethod(path) {
        const { node } = path;
        if (node.kind === "method") {
          const func = t.functionExpression(
            null,
            node.params,
            node.body,
            node.generator,
            node.async,
          );
          func.returnType = node.returnType;
          path.replaceWith(t.objectProperty(node.key, func, node.computed));
        }
      },
      ObjectProperty({ node }) {
        if (node.shorthand) {
          node.shorthand = false;
        }
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-shorthand-properties/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-helper-explode-class/src/index.js

import bindifyDecorators from "@babel/helper-bindify-decorators";
import * as t from "@babel/types";
export default function(classPath) {
  classPath.assertClass();
  const memoisedExpressions = [];
  function maybeMemoise(path) {
    if (!path.node || path.isPure()) return;
    const uid = classPath.scope.generateDeclaredUidIdentifier();
    memoisedExpressions.push(t.assignmentExpression("=", uid, path.node));
    path.replaceWith(uid);
  }
  function memoiseDecorators(paths: Array<NodePath>) {
    if (!Array.isArray(paths) || !paths.length) return;
    // ensure correct evaluation order of decorators
    paths = paths.reverse();
    // bind decorators if they're member expressions
    bindifyDecorators(paths);
    for (const path of paths) {
      maybeMemoise(path);
    }
  }
  maybeMemoise(classPath.get("superClass"));
  memoiseDecorators(classPath.get("decorators"), true);
  const methods: Array<NodePath> = classPath.get("body.body");
  for (const methodPath of methods) {
    if (methodPath.is("computed")) {
      maybeMemoise(methodPath.get("key"));
    }
    if (methodPath.has("decorators")) {
      memoiseDecorators(classPath.get("decorators"));
    }
  }
  if (memoisedExpressions) {
    classPath.insertBefore(
      memoisedExpressions.map(expr => t.expressionStatement(expr)),
    );
  }
}

// </from> /home/qfox/apps/babel/packages/babel-helper-explode-class/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-syntax-jsx/src/index.js

import { declare } from "@babel/helper-plugin-utils";
export default declare(api => {
  api.assertVersion(7);
  return {
    manipulateOptions(opts, parserOpts) {
      // If the Typescript plugin already ran, it will have decided whether
      // or not this is a TSX file.
      if (
        parserOpts.plugins.some(
          p => (Array.isArray(p) ? p[0] : p) === "typescript",
        )
      ) {
        return;
      }
      parserOpts.plugins.push("jsx");
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-syntax-jsx/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-syntax-json-strings/src/index.js

import { declare } from "@babel/helper-plugin-utils";
export default declare(api => {
  api.assertVersion(7);
  return {
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("jsonStrings");
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-syntax-json-strings/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-helper-hoist-variables/src/index.js

import * as t from "@babel/types";
const visitor = {
  Scope(path, state) {
    if (state.kind === "let") path.skip();
  },
  Function(path) {
    path.skip();
  },
  VariableDeclaration(path, state) {
    if (state.kind && path.node.kind !== state.kind) return;
    const nodes = [];
    const declarations: Array<Object> = path.get("declarations");
    let firstId;
    for (const declar of declarations) {
      firstId = declar.node.id;
      if (declar.node.init) {
        nodes.push(
          t.expressionStatement(
            t.assignmentExpression("=", declar.node.id, declar.node.init),
          ),
        );
      }
      for (const name in declar.getBindingIdentifiers()) {
        state.emit(t.identifier(name), name, declar.node.init !== null);
      }
    }
    // for (var i in test)
    if (path.parentPath.isFor({ left: path.node })) {
      path.replaceWith(firstId);
    } else {
      path.replaceWithMultiple(nodes);
    }
  },
};
export default function(path, emit: Function, kind: "var" | "let" = "var") {
  path.traverse(visitor, { kind, emit });
}

// </from> /home/qfox/apps/babel/packages/babel-helper-hoist-variables/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-modules-amd/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import {
  isModule,
  rewriteModuleStatementsAndPrepareHeader,
  hasExports,
  isSideEffectImport,
  buildNamespaceInitStatements,
  ensureStatementsHoisted,
  wrapInterop,
} from "@babel/helper-module-transforms";
import { template, types as t } from "@babel/core";
const buildWrapper = template(`
  define(MODULE_NAME, AMD_ARGUMENTS, function(IMPORT_NAMES) {
  })
`);
export default declare((api, options) => {
  api.assertVersion(7);
  const { loose, allowTopLevelThis, strict, strictMode, noInterop } = options;
  return {
    visitor: {
      Program: {
        exit(path) {
          if (!isModule(path)) return;
          let moduleName = this.getModuleName();
          if (moduleName) moduleName = t.stringLiteral(moduleName);
          const { meta, headers } = rewriteModuleStatementsAndPrepareHeader(
            path,
            {
              loose,
              strict,
              strictMode,
              allowTopLevelThis,
              noInterop,
            },
          );
          const amdArgs = [];
          const importNames = [];
          if (hasExports(meta)) {
            amdArgs.push(t.stringLiteral("exports"));
            importNames.push(t.identifier(meta.exportName));
          }
          for (const [source, metadata] of meta.source) {
            amdArgs.push(t.stringLiteral(source));
            importNames.push(t.identifier(metadata.name));
            if (!isSideEffectImport(metadata)) {
              const interop = wrapInterop(
                path,
                t.identifier(metadata.name),
                metadata.interop,
              );
              if (interop) {
                const header = t.expressionStatement(
                  t.assignmentExpression(
                    "=",
                    t.identifier(metadata.name),
                    interop,
                  ),
                );
                header.loc = metadata.loc;
                headers.push(header);
              }
            }
            headers.push(
              ...buildNamespaceInitStatements(meta, metadata, loose),
            );
          }
          ensureStatementsHoisted(headers);
          path.unshiftContainer("body", headers);
          const { body, directives } = path.node;
          path.node.directives = [];
          path.node.body = [];
          const amdWrapper = path.pushContainer("body", [
            buildWrapper({
              MODULE_NAME: moduleName,
              AMD_ARGUMENTS: t.arrayExpression(amdArgs),
              IMPORT_NAMES: importNames,
            }),
          ])[0];
          const amdFactory = amdWrapper
            .get("expression.arguments")
            .filter(arg => arg.isFunctionExpression())[0]
            .get("body");
          amdFactory.pushContainer("directives", directives);
          amdFactory.pushContainer("body", body);
        },
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-modules-amd/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-flow-strip-types/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import syntaxFlow from "@babel/plugin-syntax-flow";
import { types as t } from "@babel/core";
export default declare(api => {
  api.assertVersion(7);
  const FLOW_DIRECTIVE = "@flow";
  let skipStrip = false;
  return {
    inherits: syntaxFlow,
    visitor: {
      Program(
        path,
        {
          file: {
            ast: { comments },
          },
          opts,
        },
      ) {
        skipStrip = false;
        let directiveFound = false;
        for (const comment of (comments: Array<Object>)) {
          if (comment.value.indexOf(FLOW_DIRECTIVE) >= 0) {
            directiveFound = true;
            // remove flow directive
            comment.value = comment.value.replace(FLOW_DIRECTIVE, "");
            // remove the comment completely if it only consists of whitespace and/or stars
            if (!comment.value.replace(/\*/g, "").trim()) comment.ignore = true;
          }
        }
        if (!directiveFound && opts.requireDirective) {
          skipStrip = true;
        }
      },
      ImportDeclaration(path) {
        if (skipStrip) return;
        if (!path.node.specifiers.length) return;
        let typeCount = 0;
        path.node.specifiers.forEach(({ importKind }) => {
          if (importKind === "type" || importKind === "typeof") {
            typeCount++;
          }
        });
        if (typeCount === path.node.specifiers.length) {
          path.remove();
        }
      },
      Flow(path) {
        if (skipStrip) {
          throw path.buildCodeFrameError(
            "A @flow directive is required when using Flow annotations with " +
              "the `requireDirective` option.",
          );
        }
        path.remove();
      },
      ClassProperty(path) {
        if (skipStrip) return;
        path.node.variance = null;
        path.node.typeAnnotation = null;
        if (!path.node.value) path.remove();
      },
      ClassPrivateProperty(path) {
        if (skipStrip) return;
        path.node.typeAnnotation = null;
      },
      Class(path) {
        if (skipStrip) return;
        path.node.implements = null;
        // We do this here instead of in a `ClassProperty` visitor because the class transform
        // would transform the class before we reached the class property.
        path.get("body.body").forEach(child => {
          if (child.isClassProperty()) {
            child.node.typeAnnotation = null;
            if (!child.node.value) child.remove();
          }
        });
      },
      AssignmentPattern({ node }) {
        if (skipStrip) return;
        node.left.optional = false;
      },
      Function({ node }) {
        if (skipStrip) return;
        for (let i = 0; i < node.params.length; i++) {
          const param = node.params[i];
          param.optional = false;
          if (param.type === "AssignmentPattern") {
            param.left.optional = false;
          }
        }
        node.predicate = null;
      },
      TypeCastExpression(path) {
        if (skipStrip) return;
        let { node } = path;
        do {
          node = node.expression;
        } while (t.isTypeCastExpression(node));
        path.replaceWith(node);
      },
      CallExpression({ node }) {
        if (skipStrip) return;
        node.typeArguments = null;
      },
      OptionalCallExpression({ node }) {
        if (skipStrip) return;
        node.typeArguments = null;
      },
      NewExpression({ node }) {
        if (skipStrip) return;
        node.typeArguments = null;
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-flow-strip-types/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-helper-fixtures/src/index.js

import cloneDeep from "lodash/cloneDeep";
import trimEnd from "lodash/trimEnd";
import resolve from "try-resolve";
import clone from "lodash/clone";
import extend from "lodash/extend";
import semver from "semver";
import path from "path";
import fs from "fs";
const nodeVersion = semver.clean(process.version.slice(1));
function humanize(val, noext) {
  if (noext) val = path.basename(val, path.extname(val));
  return val.replace(/-/g, " ");
}
type TestFile = {
  loc: string,
  code: string,
  filename: string,
};
type Test = {
  title: string,
  disabled: boolean,
  options: Object,
  exec: TestFile,
  actual: TestFile,
  expected: TestFile,
};
type Suite = {
  options: Object,
  tests: Array<Test>,
  title: string,
  filename: string,
};
function assertDirectory(loc) {
  if (!fs.statSync(loc).isDirectory()) {
    throw new Error(`Expected ${loc} to be a directory.`);
  }
}
function shouldIgnore(name, blacklist?: Array<string>) {
  if (blacklist && blacklist.indexOf(name) >= 0) {
    return true;
  }
  const ext = path.extname(name);
  const base = path.basename(name, ext);
  return (
    name[0] === "." || ext === ".md" || base === "LICENSE" || base === "options"
  );
}
const EXTENSIONS = [".js", ".mjs", ".ts", ".tsx"];
function findFile(filepath: string, allowJSON: boolean) {
  const matches = [];
  for (const ext of EXTENSIONS.concat(allowJSON ? ".json" : [])) {
    const name = filepath + ext;
    if (fs.existsSync(name)) matches.push(name);
  }
  if (matches.length > 1) {
    throw new Error(`Found conflicting file matches: ${matches.join(", ")}`);
  }
  return matches[0] || filepath + ".js";
}
export default function get(entryLoc): Array<Suite> {
  const suites = [];
  let rootOpts = {};
  const rootOptsLoc = resolve(entryLoc + "/options");
  if (rootOptsLoc) rootOpts = require(rootOptsLoc);
  for (const suiteName of fs.readdirSync(entryLoc)) {
    if (shouldIgnore(suiteName)) continue;
    const suite = {
      options: clone(rootOpts),
      tests: [],
      title: humanize(suiteName),
      filename: entryLoc + "/" + suiteName,
    };
    assertDirectory(suite.filename);
    suites.push(suite);
    const suiteOptsLoc = resolve(suite.filename + "/options");
    if (suiteOptsLoc) suite.options = require(suiteOptsLoc);
    for (const taskName of fs.readdirSync(suite.filename)) {
      push(taskName, suite.filename + "/" + taskName);
    }
    function push(taskName, taskDir) {
      const actualLoc = findFile(taskDir + "/input");
      const expectLoc = findFile(taskDir + "/output", true /* allowJSON */);
      let execLoc = findFile(taskDir + "/exec");
      const actualLocAlias =
        suiteName + "/" + taskName + "/" + path.basename(actualLoc);
      const expectLocAlias =
        suiteName + "/" + taskName + "/" + path.basename(actualLoc);
      let execLocAlias =
        suiteName + "/" + taskName + "/" + path.basename(actualLoc);
      if (fs.statSync(taskDir).isFile()) {
        const ext = path.extname(taskDir);
        if (EXTENSIONS.indexOf(ext) === -1) return;
        execLoc = taskDir;
        execLocAlias = suiteName + "/" + taskName;
      }
      const taskOpts = cloneDeep(suite.options);
      const taskOptsLoc = resolve(taskDir + "/options");
      if (taskOptsLoc) extend(taskOpts, require(taskOptsLoc));
      const test = {
        optionsDir: taskOptsLoc ? path.dirname(taskOptsLoc) : null,
        title: humanize(taskName, true),
        disabled: taskName[0] === ".",
        options: taskOpts,
        exec: {
          loc: execLoc,
          code: readFile(execLoc),
          filename: execLocAlias,
        },
        actual: {
          loc: actualLoc,
          code: readFile(actualLoc),
          filename: actualLocAlias,
        },
        expect: {
          loc: expectLoc,
          code: readFile(expectLoc),
          filename: expectLocAlias,
        },
      };
      // If there's node requirement, check it before pushing task
      if (taskOpts.minNodeVersion) {
        const minimumVersion = semver.clean(taskOpts.minNodeVersion);
        if (minimumVersion == null) {
          throw new Error(
            `'minNodeVersion' has invalid semver format: ${
              taskOpts.minNodeVersion
            }`,
          );
        }
        if (semver.lt(nodeVersion, minimumVersion)) {
          return;
        }
        // Delete to avoid option validation error
        delete taskOpts.minNodeVersion;
      }
      // traceur checks
      if (test.exec.code.indexOf("// Async.") >= 0) {
        return;
      }
      suite.tests.push(test);
      const sourceMappingsLoc = taskDir + "/source-mappings.json";
      if (fs.existsSync(sourceMappingsLoc)) {
        test.sourceMappings = JSON.parse(readFile(sourceMappingsLoc));
      }
      const sourceMapLoc = taskDir + "/source-map.json";
      if (fs.existsSync(sourceMapLoc)) {
        test.sourceMap = JSON.parse(readFile(sourceMapLoc));
      }
      const inputMapLoc = taskDir + "/input-source-map.json";
      if (fs.existsSync(inputMapLoc)) {
        test.inputSourceMap = JSON.parse(readFile(inputMapLoc));
      }
      if (taskOpts.throws) {
        if (test.expect.code) {
          throw new Error(
            "Test cannot throw and also return output code: " + expectLoc,
          );
        }
        if (test.sourceMappings) {
          throw new Error(
            "Test cannot throw and also return sourcemappings: " +
              sourceMappingsLoc,
          );
        }
        if (test.sourceMap) {
          throw new Error(
            "Test cannot throw and also return sourcemaps: " + sourceMapLoc,
          );
        }
      }
    }
  }
  return suites;
}
export function multiple(entryLoc, ignore?: Array<string>) {
  const categories = {};
  for (const name of fs.readdirSync(entryLoc)) {
    if (shouldIgnore(name, ignore)) continue;
    const loc = path.join(entryLoc, name);
    assertDirectory(loc);
    categories[name] = get(loc);
  }
  return categories;
}
export function readFile(filename) {
  if (fs.existsSync(filename)) {
    let file = trimEnd(fs.readFileSync(filename, "utf8"));
    file = file.replace(/\r\n/g, "\n");
    return file;
  } else {
    return "";
  }
}

// </from> /home/qfox/apps/babel/packages/babel-helper-fixtures/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-template/src/index.js

// @flow
import * as formatters from "./formatters";
import createTemplateBuilder from "./builder";
export const smart = createTemplateBuilder(formatters.smart);
export const statement = createTemplateBuilder(formatters.statement);
export const statements = createTemplateBuilder(formatters.statements);
export const expression = createTemplateBuilder(formatters.expression);
export const program = createTemplateBuilder(formatters.program);
type DefaultTemplateBuilder = typeof smart & {
  smart: typeof smart,
  statement: typeof statement,
  statements: typeof statements,
  expression: typeof expression,
  program: typeof program,
  ast: typeof smart.ast,
};
export default Object.assign(
  ((smart.bind(undefined): any): DefaultTemplateBuilder),
  {
    smart,
    statement,
    statements,
    expression,
    program,
    ast: smart.ast,
  },
);

// </from> /home/qfox/apps/babel/packages/babel-template/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-template/src/populate.js

// @flow
import * as t from "@babel/types";
export default function populatePlaceholders(
  metadata: Metadata,
  replacements: TemplateReplacements,
): BabelNodeFile {
  const ast = t.cloneNode(metadata.ast);
  if (replacements) {
    metadata.placeholders.forEach(placeholder => {
      if (
        !Object.prototype.hasOwnProperty.call(replacements, placeholder.name)
      ) {
        const placeholderName = placeholder.name;
        throw new Error(
          `Error: No substitution given for "${placeholderName}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${placeholderName}'])}
            - { placeholderPattern: /^${placeholderName}$/ }`,
        );
      }
    });
    Object.keys(replacements).forEach(key => {
      if (!metadata.placeholderNames.has(key)) {
        throw new Error(`Unknown substitution "${key}" given`);
      }
    });
  }
  // Process in reverse order to AST mutation doesn't change indices that
  // will be needed for later calls to `placeholder.resolve()`.
  metadata.placeholders
    .slice()
    .reverse()
    .forEach(placeholder => {
      try {
        applyReplacement(
          placeholder,
          ast,
          (replacements && replacements[placeholder.name]) || null,
        );
      } catch (e) {
        e.message = `@babel/template placeholder "${placeholder.name}": ${
          e.message
        }`;
        throw e;
      }
    });
  return ast;
}
function applyReplacement(
  placeholder: Placeholder,
  ast: BabelNodeFile,
  replacement: any,
) {
  // Track inserted nodes and clone them if they are inserted more than
  // once to avoid injecting the same node multiple times.
  if (placeholder.isDuplicate) {
    if (Array.isArray(replacement)) {
      replacement = replacement.map(node => t.cloneNode(node));
    } else if (typeof replacement === "object") {
      replacement = t.cloneNode(replacement);
    }
  }
  const { parent, key, index } = placeholder.resolve(ast);
  if (placeholder.type === "string") {
    if (typeof replacement === "string") {
      replacement = t.stringLiteral(replacement);
    }
    if (!replacement || !t.isStringLiteral(replacement)) {
      throw new Error("Expected string substitution");
    }
  } else if (placeholder.type === "statement") {
    if (index === undefined) {
      if (!replacement) {
        replacement = t.emptyStatement();
      } else if (Array.isArray(replacement)) {
        replacement = t.blockStatement(replacement);
      } else if (typeof replacement === "string") {
        replacement = t.expressionStatement(t.identifier(replacement));
      } else if (!t.isStatement(replacement)) {
        replacement = t.expressionStatement((replacement: any));
      }
    } else {
      if (replacement && !Array.isArray(replacement)) {
        if (typeof replacement === "string") {
          replacement = t.identifier(replacement);
        }
        if (!t.isStatement(replacement)) {
          replacement = t.expressionStatement((replacement: any));
        }
      }
    }
  } else if (placeholder.type === "param") {
    if (typeof replacement === "string") {
      replacement = t.identifier(replacement);
    }
    if (index === undefined) throw new Error("Assertion failure.");
  } else {
    if (typeof replacement === "string") {
      replacement = t.identifier(replacement);
    }
    if (Array.isArray(replacement)) {
      throw new Error("Cannot replace single expression with an array.");
    }
  }
  if (index === undefined) {
    t.validate(parent, key, replacement);
    (parent: any)[key] = replacement;
  } else {
    const items: Array<BabelNode> = (parent: any)[key].slice();
    if (placeholder.type === "statement" || placeholder.type === "param") {
      if (replacement == null) {
        items.splice(index, 1);
      } else if (Array.isArray(replacement)) {
        items.splice(index, 1, ...replacement);
      } else {
        items[index] = replacement;
      }
    } else {
      items[index] = replacement;
    }
    t.validate(parent, key, items);
    (parent: any)[key] = items;
  }
}

// </from> /home/qfox/apps/babel/packages/babel-template/src/populate.js

// <from> /home/qfox/apps/babel/packages/babel-template/src/formatters.js

// @flow
export type Formatter<T> = {
  code: string => string,
  validate: BabelNodeFile => void,
  unwrap: BabelNodeFile => T,
};
function makeStatementFormatter<T>(
  fn: (Array<BabelNodeStatement>) => T,
): Formatter<T> {
  return {
    // We need to prepend a ";" to force statement parsing so that
    // ExpressionStatement strings won't be parsed as directives.
    // Alongside that, we also prepend a comment so that when a syntax error
    // is encountered, the user will be less likely to get confused about
    // where the random semicolon came from.
    code: str => `/* @babel/template */;\n${str}`,
    validate: () => {},
    unwrap: (ast: BabelNodeFile): T => {
      return fn(ast.program.body.slice(1));
    },
  };
}
export const smart: Formatter<
  Array<BabelNodeStatement> | BabelNodeStatement,
> = makeStatementFormatter(body => {
  if (body.length > 1) {
    return body;
  } else {
    return body[0];
  }
});
export const statements: Formatter<
  Array<BabelNodeStatement>,
> = makeStatementFormatter(body => body);
export const statement: Formatter<BabelNodeStatement> = makeStatementFormatter(
  body => {
    // We do this validation when unwrapping since the replacement process
    // could have added or removed statements.
    if (body.length === 0) {
      throw new Error("Found nothing to return.");
    }
    if (body.length > 1) {
      throw new Error("Found multiple statements but wanted one");
    }
    return body[0];
  },
);
export const expression: Formatter<BabelNodeExpression> = {
  code: str => `(\n${str}\n)`,
  validate: ({ program }) => {
    if (program.body.length > 1) {
      throw new Error("Found multiple statements but wanted one");
    }
    // $FlowFixMe
    const expression = program.body[0].expression;
    if (expression.start === 0) {
      throw new Error("Parse result included parens.");
    }
  },
  // $FlowFixMe
  unwrap: ast => ast.program.body[0].expression,
};
export const program: Formatter<BabelNodeProgram> = {
  code: str => str,
  validate: () => {},
  unwrap: ast => ast.program,
};

// </from> /home/qfox/apps/babel/packages/babel-template/src/formatters.js

// <from> /home/qfox/apps/babel/packages/babel-template/src/literal.js

// @flow
import { normalizeReplacements, type TemplateOpts } from "./options";
import parseAndBuildMetadata from "./parse";
import populatePlaceholders from "./populate";
export default function literalTemplate<T>(
  formatter: Formatter<T>,
  tpl: Array<string>,
  opts: TemplateOpts,
): (Array<mixed>) => mixed => T {
  const { metadata, names } = buildLiteralData(formatter, tpl, opts);
  return (arg: Array<mixed>) => {
    const defaultReplacements = arg.reduce((acc, replacement, i) => {
      acc[names[i]] = replacement;
      return acc;
    }, {});
    return (arg: mixed) => {
      const replacements = normalizeReplacements(arg);
      if (replacements) {
        Object.keys(replacements).forEach(key => {
          if (Object.prototype.hasOwnProperty.call(defaultReplacements, key)) {
            throw new Error("Unexpected replacement overlap.");
          }
        });
      }
      return formatter.unwrap(
        populatePlaceholders(
          metadata,
          replacements
            ? Object.assign(replacements, defaultReplacements)
            : defaultReplacements,
        ),
      );
    };
  };
}
function buildLiteralData<T>(
  formatter: Formatter<T>,
  tpl: Array<string>,
  opts: TemplateOpts,
) {
  let names;
  let nameSet;
  let metadata;
  let prefix = "";
  do {
    // If there are cases where the template already contains $0 or any other
    // matching pattern, we keep adding "$" characters until a unique prefix
    // is found.
    prefix += "$";
    const result = buildTemplateCode(tpl, prefix);
    names = result.names;
    nameSet = new Set(names);
    metadata = parseAndBuildMetadata(formatter, formatter.code(result.code), {
      parser: opts.parser,
      // Explicitly include our generated names in the whitelist so users never
      // have to think about whether their placeholder pattern will match.
      placeholderWhitelist: new Set(
        result.names.concat(
          opts.placeholderWhitelist
            ? Array.from(opts.placeholderWhitelist)
            : [],
        ),
      ),
      placeholderPattern: opts.placeholderPattern,
      preserveComments: opts.preserveComments,
    });
  } while (
    metadata.placeholders.some(
      placeholder => placeholder.isDuplicate && nameSet.has(placeholder.name),
    )
  );
  return { metadata, names };
}
function buildTemplateCode(
  tpl: Array<string>,
  prefix: string,
): { names: Array<string>, code: string } {
  const names = [];
  let code = tpl[0];
  for (let i = 1; i < tpl.length; i++) {
    const value = `${prefix}${i - 1}`;
    names.push(value);
    code += value + tpl[i];
  }
  return { names, code };
}

// </from> /home/qfox/apps/babel/packages/babel-template/src/literal.js

// <from> /home/qfox/apps/babel/packages/babel-template/src/parse.js

// @flow
import * as t from "@babel/types";
import { parse } from "@babel/parser";
import { codeFrameColumns } from "@babel/code-frame";
export type Metadata = {
  ast: BabelNodeFile,
  placeholders: Array<Placeholder>,
  placeholderNames: Set<string>,
};
type PlaceholderType = "string" | "param" | "statement" | "other";
export type Placeholder = {|
  name: string,
  resolve: BabelNodeFile => { parent: BabelNode, key: string, index?: number },
  type: PlaceholderType,
  isDuplicate: boolean,
|};
const PATTERN = /^[_$A-Z0-9]+$/;
export default function parseAndBuildMetadata<T>(
  formatter: Formatter<T>,
  code: string,
  opts: TemplateOpts,
): Metadata {
  const ast = parseWithCodeFrame(code, opts.parser);
  const {
    placeholderWhitelist,
    placeholderPattern = PATTERN,
    preserveComments,
  } = opts;
  t.removePropertiesDeep(ast, {
    preserveComments,
  });
  formatter.validate(ast);
  const placeholders = [];
  const placeholderNames = new Set();
  t.traverse(ast, (placeholderVisitorHandler: TraversalHandler<*>), {
    placeholders,
    placeholderNames,
    placeholderWhitelist,
    placeholderPattern,
  });
  return {
    ast,
    placeholders,
    placeholderNames,
  };
}
function placeholderVisitorHandler(
  node: BabelNode,
  ancestors: TraversalAncestors,
  state: MetadataState,
) {
  let name;
  if (t.isIdentifier(node) || t.isJSXIdentifier(node)) {
    name = ((node: any): BabelNodeIdentifier).name;
  } else if (t.isStringLiteral(node)) {
    name = ((node: any): BabelNodeStringLiteral).value;
  } else {
    return;
  }
  if (
    (!state.placeholderPattern || !state.placeholderPattern.test(name)) &&
    (!state.placeholderWhitelist || !state.placeholderWhitelist.has(name))
  ) {
    return;
  }
  // Keep our own copy of the ancestors so we can use it in .resolve().
  ancestors = ancestors.slice();
  const { node: parent, key } = ancestors[ancestors.length - 1];
  let type: PlaceholderType;
  if (t.isStringLiteral(node)) {
    type = "string";
  } else if (
    (t.isNewExpression(parent) && key === "arguments") ||
    (t.isCallExpression(parent) && key === "arguments") ||
    (t.isFunction(parent) && key === "params")
  ) {
    type = "param";
  } else if (t.isExpressionStatement(parent)) {
    type = "statement";
    ancestors = ancestors.slice(0, -1);
  } else {
    type = "other";
  }
  state.placeholders.push({
    name,
    type,
    resolve: ast => resolveAncestors(ast, ancestors),
    isDuplicate: state.placeholderNames.has(name),
  });
  state.placeholderNames.add(name);
}
function resolveAncestors(ast: BabelNodeFile, ancestors: TraversalAncestors) {
  let parent: BabelNode = ast;
  for (let i = 0; i < ancestors.length - 1; i++) {
    const { key, index } = ancestors[i];
    if (index === undefined) {
      parent = (parent: any)[key];
    } else {
      parent = (parent: any)[key][index];
    }
  }
  const { key, index } = ancestors[ancestors.length - 1];
  return { parent, key, index };
}
type MetadataState = {
  placeholders: Array<Placeholder>,
  placeholderNames: Set<string>,
  placeholderWhitelist: Set<string> | void,
  placeholderPattern: RegExp | false,
};
function parseWithCodeFrame(code: string, parserOpts: {}): BabelNodeFile {
  parserOpts = {
    allowReturnOutsideFunction: true,
    allowSuperOutsideMethod: true,
    sourceType: "module",
    ...parserOpts,
  };
  try {
    // $FlowFixMe - The parser AST is not the same type as the babel-types type.
    return parse(code, parserOpts);
  } catch (err) {
    const loc = err.loc;
    if (loc) {
      err.message += "\n" + codeFrameColumns(code, { start: loc });
      err.code = "BABEL_TEMPLATE_PARSE_ERROR";
    }
    throw err;
  }
}

// </from> /home/qfox/apps/babel/packages/babel-template/src/parse.js

// <from> /home/qfox/apps/babel/packages/babel-template/src/string.js

// @flow
import { normalizeReplacements, type TemplateOpts } from "./options";
import parseAndBuildMetadata from "./parse";
import populatePlaceholders from "./populate";
export default function stringTemplate<T>(
  formatter: Formatter<T>,
  code: string,
  opts: TemplateOpts,
): mixed => T {
  code = formatter.code(code);
  let metadata;
  return (arg?: mixed) => {
    const replacements = normalizeReplacements(arg);
    if (!metadata) metadata = parseAndBuildMetadata(formatter, code, opts);
    return formatter.unwrap(populatePlaceholders(metadata, replacements));
  };
}

// </from> /home/qfox/apps/babel/packages/babel-template/src/string.js

// <from> /home/qfox/apps/babel/packages/babel-template/src/options.js

// @flow
/**
 * These are the options that 'babel-template' actually accepts and typechecks
 * when called. All other options are passed through to the parser.
 */
export type PublicOpts = {
  /**
   * A set of placeholder names to automatically accept, ignoring the given
   * pattern entirely.
   */
  placeholderWhitelist?: ?Set<string>,
  /**
   * A pattern to search for when looking for Identifier and StringLiteral
   * nodes that can be replaced.
   *
   * 'false' will disable placeholder searching entirely, leaving only the
   * 'placeholderWhitelist' value to find replacements.
   *
   * Defaults to /^[_$A-Z0-9]+$/.
   */
  placeholderPattern?: ?(RegExp | false),
  /**
   * 'true' to pass through comments from the template into the resulting AST,
   * or 'false' to automatically discard comments. Defaults to 'false'.
   */
  preserveComments?: ?boolean,
};
export type TemplateOpts = {|
  parser: {},
  placeholderWhitelist: Set<string> | void,
  placeholderPattern: RegExp | false | void,
  preserveComments: boolean | void,
|};
export function merge(a: TemplateOpts, b: TemplateOpts): TemplateOpts {
  const {
    placeholderWhitelist = a.placeholderWhitelist,
    placeholderPattern = a.placeholderPattern,
    preserveComments = a.preserveComments,
  } = b;
  return {
    parser: {
      ...a.parser,
      ...b.parser,
    },
    placeholderWhitelist,
    placeholderPattern,
    preserveComments,
  };
}
export function validate(opts: mixed): TemplateOpts {
  if (opts != null && typeof opts !== "object") {
    throw new Error("Unknown template options.");
  }
  const {
    placeholderWhitelist,
    placeholderPattern,
    preserveComments,
    ...parser
  } = opts || {};
  if (placeholderWhitelist != null && !(placeholderWhitelist instanceof Set)) {
    throw new Error(
      "'.placeholderWhitelist' must be a Set, null, or undefined",
    );
  }
  if (
    placeholderPattern != null &&
    !(placeholderPattern instanceof RegExp) &&
    placeholderPattern !== false
  ) {
    throw new Error(
      "'.placeholderPattern' must be a RegExp, false, null, or undefined",
    );
  }
  if (preserveComments != null && typeof preserveComments !== "boolean") {
    throw new Error(
      "'.preserveComments' must be a boolean, null, or undefined",
    );
  }
  return {
    parser,
    placeholderWhitelist: placeholderWhitelist || undefined,
    placeholderPattern:
      placeholderPattern == null ? undefined : placeholderPattern,
    preserveComments: preserveComments == null ? false : preserveComments,
  };
}
export type PublicReplacements = { [string]: mixed } | Array<mixed>;
export type TemplateReplacements = { [string]: mixed } | void;
export function normalizeReplacements(
  replacements: mixed,
): TemplateReplacements {
  if (Array.isArray(replacements)) {
    return replacements.reduce((acc, replacement, i) => {
      acc["$" + i] = replacement;
      return acc;
    }, {});
  } else if (typeof replacements === "object" || replacements == null) {
    return replacements || undefined;
  }
  throw new Error(
    "Template replacements must be an array, object, null, or undefined",
  );
}

// </from> /home/qfox/apps/babel/packages/babel-template/src/options.js

// <from> /home/qfox/apps/babel/packages/babel-template/src/builder.js

// @flow
import {
  merge,
  validate,
  type TemplateOpts,
  type PublicOpts,
  type PublicReplacements,
} from "./options";
import stringTemplate from "./string";
import literalTemplate from "./literal";
export type TemplateBuilder<T> = {
  // Build a new builder, merging the given options with the previous ones.
  (opts: PublicOpts): TemplateBuilder<T>,
  // Building from a string produces an AST builder function by default.
  (tpl: string, opts: ?PublicOpts): (?PublicReplacements) => T,
  // Building from a template literal produces an AST builder function by default.
  (tpl: Array<string>, ...args: Array<mixed>): (?PublicReplacements) => T,
  // Allow users to explicitly create templates that produce ASTs, skipping
  // the need for an intermediate function.
  ast: {
    (tpl: string, opts: ?PublicOpts): T,
    (tpl: Array<string>, ...args: Array<mixed>): T,
  },
};
// Prebuild the options that will be used when parsing a `.ast` template.
// These do not use a pattern because there is no way for users to pass in
// replacement patterns to begin with, and disabling pattern matching means
// users have more flexibility in what type of content they have in their
// template JS.
const NO_PLACEHOLDER: TemplateOpts = validate({
  placeholderPattern: false,
});
export default function createTemplateBuilder<T>(
  formatter: Formatter<T>,
  defaultOpts?: TemplateOpts,
): TemplateBuilder<T> {
  const templateFnCache = new WeakMap();
  const templateAstCache = new WeakMap();
  const cachedOpts = defaultOpts || validate(null);
  return Object.assign(
    ((tpl, ...args) => {
      if (typeof tpl === "string") {
        if (args.length > 1) throw new Error("Unexpected extra params.");
        return extendedTrace(
          stringTemplate(formatter, tpl, merge(cachedOpts, validate(args[0]))),
        );
      } else if (Array.isArray(tpl)) {
        let builder = templateFnCache.get(tpl);
        if (!builder) {
          builder = literalTemplate(formatter, tpl, cachedOpts);
          templateFnCache.set(tpl, builder);
        }
        return extendedTrace(builder(args));
      } else if (typeof tpl === "object" && tpl) {
        if (args.length > 0) throw new Error("Unexpected extra params.");
        return createTemplateBuilder(
          formatter,
          merge(cachedOpts, validate(tpl)),
        );
      }
      throw new Error(`Unexpected template param ${typeof tpl}`);
    }: Function),
    {
      ast: (tpl, ...args) => {
        if (typeof tpl === "string") {
          if (args.length > 1) throw new Error("Unexpected extra params.");
          return stringTemplate(
            formatter,
            tpl,
            merge(merge(cachedOpts, validate(args[0])), NO_PLACEHOLDER),
          )();
        } else if (Array.isArray(tpl)) {
          let builder = templateAstCache.get(tpl);
          if (!builder) {
            builder = literalTemplate(
              formatter,
              tpl,
              merge(cachedOpts, NO_PLACEHOLDER),
            );
            templateAstCache.set(tpl, builder);
          }
          return builder(args)();
        }
        throw new Error(`Unexpected template param ${typeof tpl}`);
      },
    },
  );
}
function extendedTrace<Arg, Result>(fn: Arg => Result): Arg => Result {
  // Since we lazy parse the template, we get the current stack so we have the
  // original stack to append if it errors when parsing
  let rootStack = "";
  try {
    // error stack gets populated in IE only on throw
    // (https://msdn.microsoft.com/en-us/library/hh699850(v=vs.94).aspx)
    throw new Error();
  } catch (error) {
    if (error.stack) {
      // error.stack does not exists in IE <= 9
      // We slice off the top 3 items in the stack to remove the call to
      // 'extendedTrace', and the anonymous builder function, with the final
      // stripped line being the error message itself since we threw it
      // in the first place and it doesn't matter.
      rootStack = error.stack
        .split("\n")
        .slice(3)
        .join("\n");
    }
  }
  return (arg: Arg) => {
    try {
      return fn(arg);
    } catch (err) {
      err.stack += `\n    =============\n${rootStack}`;
      throw err;
    }
  };
}

// </from> /home/qfox/apps/babel/packages/babel-template/src/builder.js

// <from> /home/qfox/apps/babel/packages/babel-code-frame/src/index.js

import highlight, { shouldHighlight, getChalk } from "@babel/highlight";
let deprecationWarningShown = false;
type Location = {
  column: number,
  line: number,
};
type NodeLocation = {
  end: Location,
  start: Location,
};
/**
 * Chalk styles for code frame token types.
 */
function getDefs(chalk) {
  return {
    gutter: chalk.grey,
    marker: chalk.red.bold,
    message: chalk.red.bold,
  };
}
/**
 * RegExp to test for newlines in terminal.
 */
const NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
/**
 * Extract what lines should be marked and highlighted.
 */
function getMarkerLines(
  loc: NodeLocation,
  source: Array<string>,
  opts: Object,
): { start: number, end: number, markerLines: Object } {
  const startLoc: Location = {
    column: 0,
    line: -1,
    ...loc.start,
  };
  const endLoc: Location = {
    ...startLoc,
    ...loc.end,
  };
  const { linesAbove = 2, linesBelow = 3 } = opts || {};
  const startLine = startLoc.line;
  const startColumn = startLoc.column;
  const endLine = endLoc.line;
  const endColumn = endLoc.column;
  let start = Math.max(startLine - (linesAbove + 1), 0);
  let end = Math.min(source.length, endLine + linesBelow);
  if (startLine === -1) {
    start = 0;
  }
  if (endLine === -1) {
    end = source.length;
  }
  const lineDiff = endLine - startLine;
  const markerLines = {};
  if (lineDiff) {
    for (let i = 0; i <= lineDiff; i++) {
      const lineNumber = i + startLine;
      if (!startColumn) {
        markerLines[lineNumber] = true;
      } else if (i === 0) {
        const sourceLength = source[lineNumber - 1].length;
        markerLines[lineNumber] = [startColumn, sourceLength - startColumn];
      } else if (i === lineDiff) {
        markerLines[lineNumber] = [0, endColumn];
      } else {
        const sourceLength = source[lineNumber - i].length;
        markerLines[lineNumber] = [0, sourceLength];
      }
    }
  } else {
    if (startColumn === endColumn) {
      if (startColumn) {
        markerLines[startLine] = [startColumn, 0];
      } else {
        markerLines[startLine] = true;
      }
    } else {
      markerLines[startLine] = [startColumn, endColumn - startColumn];
    }
  }
  return { start, end, markerLines };
}
export function codeFrameColumns(
  rawLines: string,
  loc: NodeLocation,
  opts: Object = {},
): string {
  const highlighted =
    (opts.highlightCode || opts.forceColor) && shouldHighlight(opts);
  const chalk = getChalk(opts);
  const defs = getDefs(chalk);
  const maybeHighlight = (chalkFn, string) => {
    return highlighted ? chalkFn(string) : string;
  };
  if (highlighted) rawLines = highlight(rawLines, opts);
  const lines = rawLines.split(NEWLINE);
  const { start, end, markerLines } = getMarkerLines(loc, lines, opts);
  const hasColumns = loc.start && typeof loc.start.column === "number";
  const numberMaxWidth = String(end).length;
  let frame = lines
    .slice(start, end)
    .map((line, index) => {
      const number = start + 1 + index;
      const paddedNumber = ` ${number}`.slice(-numberMaxWidth);
      const gutter = ` ${paddedNumber} | `;
      const hasMarker = markerLines[number];
      const lastMarkerLine = !markerLines[number + 1];
      if (hasMarker) {
        let markerLine = "";
        if (Array.isArray(hasMarker)) {
          const markerSpacing = line
            .slice(0, Math.max(hasMarker[0] - 1, 0))
            .replace(/[^\t]/g, " ");
          const numberOfMarkers = hasMarker[1] || 1;
          markerLine = [
            "\n ",
            maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")),
            markerSpacing,
            maybeHighlight(defs.marker, "^").repeat(numberOfMarkers),
          ].join("");
          if (lastMarkerLine && opts.message) {
            markerLine += " " + maybeHighlight(defs.message, opts.message);
          }
        }
        return [
          maybeHighlight(defs.marker, ">"),
          maybeHighlight(defs.gutter, gutter),
          line,
          markerLine,
        ].join("");
      } else {
        return ` ${maybeHighlight(defs.gutter, gutter)}${line}`;
      }
    })
    .join("\n");
  if (opts.message && !hasColumns) {
    frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}\n${frame}`;
  }
  if (highlighted) {
    return chalk.reset(frame);
  } else {
    return frame;
  }
}
/**
 * Create a code frame, adding line numbers, code highlighting, and pointing to a given position.
 */
export default function(
  rawLines: string,
  lineNumber: number,
  colNumber: ?number,
  opts: Object = {},
): string {
  if (!deprecationWarningShown) {
    deprecationWarningShown = true;
    const message =
      "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
    if (process.emitWarning) {
      // A string is directly supplied to emitWarning, because when supplying an
      // Error object node throws in the tests because of different contexts
      process.emitWarning(message, "DeprecationWarning");
    } else {
      const deprecationError = new Error(message);
      deprecationError.name = "DeprecationWarning";
      console.warn(new Error(message));
    }
  }
  colNumber = Math.max(colNumber, 0);
  const location: NodeLocation = {
    start: { column: colNumber, line: lineNumber },
  };
  return codeFrameColumns(rawLines, location, opts);
}

// </from> /home/qfox/apps/babel/packages/babel-code-frame/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-preset-stage-3/src/index.js

export default function() {
  throw new Error(`
As of v7.0.0-beta.55, we've removed Babel's Stage presets.
Please consider reading our blog post on this decision at
https://babeljs.io/blog/2018/07/27/removing-babels-stage-presets
for more details. TL;DR is that it's more beneficial in the
  long run to explicitly add which proposals to use.
For a more automatic migration, we have updated babel-upgrade,
https://github.com/babel/babel-upgrade to do this for you with
"npx babel-upgrade".
If you want the same configuration as before:
{
  "plugins": [
    "@babel/plugin-syntax-dynamic-import",
    "@babel/plugin-syntax-import-meta",
    ["@babel/plugin-proposal-class-properties", { "loose": false }],
    "@babel/plugin-proposal-json-strings"
  ]
}
If you're using the same configuration across many separate projects,
keep in mind that you can also create your own custom presets with
whichever plugins and presets you're looking to use.
module.exports = function() {
  return {
    plugins: [
      require("@babel/plugin-syntax-dynamic-import"),
      [require("@babel/plugin-proposal-decorators"), { "legacy": true }],
      [require("@babel/plugin-proposal-class-properties"), { "loose": false }],
    ],
    presets: [
      // ...
    ],
  };
};
`);
}

// </from> /home/qfox/apps/babel/packages/babel-preset-stage-3/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-helper-explode-assignable-expression/src/index.js

import * as t from "@babel/types";
function getObjRef(node, nodes, file, scope) {
  let ref;
  if (t.isSuper(node)) {
    // Super cannot be directly assigned so lets return it directly
    return node;
  } else if (t.isIdentifier(node)) {
    if (scope.hasBinding(node.name)) {
      // this variable is declared in scope so we can be 100% sure
      // that evaluating it multiple times wont trigger a getter
      // or something else
      return node;
    } else {
      // could possibly trigger a getter so we need to only evaluate
      // it once
      ref = node;
    }
  } else if (t.isMemberExpression(node)) {
    ref = node.object;
    if (t.isSuper(ref) || (t.isIdentifier(ref) && scope.hasBinding(ref.name))) {
      // the object reference that we need to save is locally declared
      // so as per the previous comment we can be 100% sure evaluating
      // it multiple times will be safe
      // Super cannot be directly assigned so lets return it also
      return ref;
    }
  } else {
    throw new Error(`We can't explode this node type ${node.type}`);
  }
  const temp = scope.generateUidIdentifierBasedOnNode(ref);
  scope.push({ id: temp });
  nodes.push(t.assignmentExpression("=", t.cloneNode(temp), t.cloneNode(ref)));
  return temp;
}
function getPropRef(node, nodes, file, scope) {
  const prop = node.property;
  const key = t.toComputedKey(node, prop);
  if (t.isLiteral(key) && t.isPureish(key)) return key;
  const temp = scope.generateUidIdentifierBasedOnNode(prop);
  scope.push({ id: temp });
  nodes.push(t.assignmentExpression("=", t.cloneNode(temp), t.cloneNode(prop)));
  return temp;
}
export default function(
  node: Object,
  nodes: Array<Object>,
  file,
  scope: Scope,
  allowedSingleIdent?: boolean,
): {
  uid: Object,
  ref: Object,
} {
  let obj;
  if (t.isIdentifier(node) && allowedSingleIdent) {
    obj = node;
  } else {
    obj = getObjRef(node, nodes, file, scope);
  }
  let ref, uid;
  if (t.isIdentifier(node)) {
    ref = t.cloneNode(node);
    uid = obj;
  } else {
    const prop = getPropRef(node, nodes, file, scope);
    const computed = node.computed || t.isLiteral(prop);
    uid = t.memberExpression(t.cloneNode(obj), t.cloneNode(prop), computed);
    ref = t.memberExpression(t.cloneNode(obj), t.cloneNode(prop), computed);
  }
  return {
    uid: uid,
    ref: ref,
  };
}

// </from> /home/qfox/apps/babel/packages/babel-helper-explode-assignable-expression/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-dotall-regex/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import rewritePattern from "regexpu-core";
import * as regex from "@babel/helper-regex";
export default declare(api => {
  api.assertVersion(7);
  return {
    visitor: {
      RegExpLiteral(path) {
        const node = path.node;
        if (!regex.is(node, "s")) {
          return;
        }
        node.pattern = rewritePattern(node.pattern, node.flags, {
          dotAllFlag: true,
          useUnicodeFlag: regex.is(node, "u"),
        });
        regex.pullFlag(node, "s");
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-dotall-regex/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-helper-builder-binary-assignment-operator-visitor/src/index.js

import explode from "@babel/helper-explode-assignable-expression";
import * as t from "@babel/types";
export default function(opts: { build: Function, operator: string }): Object {
  const { build, operator } = opts;
  return {
    AssignmentExpression(path) {
      const { node, scope } = path;
      if (node.operator !== operator + "=") return;
      const nodes = [];
      const exploded = explode(node.left, nodes, this, scope);
      nodes.push(
        t.assignmentExpression(
          "=",
          exploded.ref,
          build(exploded.uid, node.right),
        ),
      );
      path.replaceWith(t.sequenceExpression(nodes));
    },
    BinaryExpression(path) {
      const { node } = path;
      if (node.operator === operator) {
        path.replaceWith(build(node.left, node.right));
      }
    },
  };
}

// </from> /home/qfox/apps/babel/packages/babel-helper-builder-binary-assignment-operator-visitor/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-syntax-function-sent/src/index.js

import { declare } from "@babel/helper-plugin-utils";
export default declare(api => {
  api.assertVersion(7);
  return {
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("functionSent");
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-syntax-function-sent/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-syntax-numeric-separator/src/index.js

import { declare } from "@babel/helper-plugin-utils";
export default declare(api => {
  api.assertVersion(7);
  return {
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("numericSeparator");
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-syntax-numeric-separator/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-helpers/src/index.js

import traverse from "@babel/traverse";
import * as t from "@babel/types";
import helpers from "./helpers";
function makePath(path) {
  const parts = [];
  for (; path.parentPath; path = path.parentPath) {
    parts.push(path.key);
    if (path.inList) parts.push(path.listKey);
  }
  return parts.reverse().join(".");
}
/**
 * Given a file AST for a given helper, get a bunch of metadata about it so that Babel can quickly render
 * the helper is whatever context it is needed in.
 */
function getHelperMetadata(file) {
  const globals = new Set();
  const localBindingNames = new Set();
  // Maps imported identifier -> helper name
  const dependencies = new Map();
  let exportName;
  let exportPath;
  const exportBindingAssignments = [];
  const importPaths = [];
  const importBindingsReferences = [];
  traverse(file, {
    ImportDeclaration(child) {
      const name = child.node.source.value;
      if (!helpers[name]) {
        throw child.buildCodeFrameError(`Unknown helper ${name}`);
      }
      if (
        child.get("specifiers").length !== 1 ||
        !child.get("specifiers.0").isImportDefaultSpecifier()
      ) {
        throw child.buildCodeFrameError(
          "Helpers can only import a default value",
        );
      }
      const bindingIdentifier = child.node.specifiers[0].local;
      dependencies.set(bindingIdentifier, name);
      importPaths.push(makePath(child));
    },
    ExportDefaultDeclaration(child) {
      const decl = child.get("declaration");
      if (decl.isFunctionDeclaration()) {
        if (!decl.node.id) {
          throw decl.buildCodeFrameError(
            "Helpers should give names to their exported func declaration",
          );
        }
        exportName = decl.node.id.name;
      }
      exportPath = makePath(child);
    },
    ExportAllDeclaration(child) {
      throw child.buildCodeFrameError("Helpers can only export default");
    },
    ExportNamedDeclaration(child) {
      throw child.buildCodeFrameError("Helpers can only export default");
    },
    Statement(child) {
      if (child.isModuleDeclaration()) return;
      child.skip();
    },
  });
  traverse(file, {
    Program(path) {
      const bindings = path.scope.getAllBindings();
      Object.keys(bindings).forEach(name => {
        if (name === exportName) return;
        if (dependencies.has(bindings[name].identifier)) return;
        localBindingNames.add(name);
      });
    },
    ReferencedIdentifier(child) {
      const name = child.node.name;
      const binding = child.scope.getBinding(name, /* noGlobal */ true);
      if (!binding) {
        globals.add(name);
      } else if (dependencies.has(binding.identifier)) {
        importBindingsReferences.push(makePath(child));
      }
    },
    AssignmentExpression(child) {
      const left = child.get("left");
      if (!(exportName in left.getBindingIdentifiers())) return;
      if (!left.isIdentifier()) {
        throw left.buildCodeFrameError(
          "Only simple assignments to exports are allowed in helpers",
        );
      }
      const binding = child.scope.getBinding(exportName);
      if (binding && binding.scope.path.isProgram()) {
        exportBindingAssignments.push(makePath(child));
      }
    },
  });
  if (!exportPath) throw new Error("Helpers must default-export something.");
  // Process these in reverse so that mutating the references does not invalidate any later paths in
  // the list.
  exportBindingAssignments.reverse();
  return {
    globals: Array.from(globals),
    localBindingNames: Array.from(localBindingNames),
    dependencies,
    exportBindingAssignments,
    exportPath,
    exportName,
    importBindingsReferences,
    importPaths,
  };
}
/**
 * Given a helper AST and information about how it will be used, update the AST to match the usage.
 */
function permuteHelperAST(file, metadata, id, localBindings, getDependency) {
  if (localBindings && !id) {
    throw new Error("Unexpected local bindings for module-based helpers.");
  }
  if (!id) return;
  const {
    localBindingNames,
    dependencies,
    exportBindingAssignments,
    exportPath,
    exportName,
    importBindingsReferences,
    importPaths,
  } = metadata;
  const dependenciesRefs = {};
  dependencies.forEach((name, id) => {
    dependenciesRefs[id.name] =
      (typeof getDependency === "function" && getDependency(name)) || id;
  });
  const toRename = {};
  const bindings = new Set(localBindings || []);
  localBindingNames.forEach(name => {
    let newName = name;
    while (bindings.has(newName)) newName = "_" + newName;
    if (newName !== name) toRename[name] = newName;
  });
  if (id.type === "Identifier" && exportName !== id.name) {
    toRename[exportName] = id.name;
  }
  traverse(file, {
    Program(path) {
      // We need to compute these in advance because removing nodes would
      // invalidate the paths.
      const exp = path.get(exportPath);
      const imps = importPaths.map(p => path.get(p));
      const impsBindingRefs = importBindingsReferences.map(p => path.get(p));
      const decl = exp.get("declaration");
      if (id.type === "Identifier") {
        if (decl.isFunctionDeclaration()) {
          exp.replaceWith(decl);
        } else {
          exp.replaceWith(
            t.variableDeclaration("var", [t.variableDeclarator(id, decl.node)]),
          );
        }
      } else if (id.type === "MemberExpression") {
        if (decl.isFunctionDeclaration()) {
          exportBindingAssignments.forEach(assignPath => {
            const assign = path.get(assignPath);
            assign.replaceWith(t.assignmentExpression("=", id, assign.node));
          });
          exp.replaceWith(decl);
          path.pushContainer(
            "body",
            t.expressionStatement(
              t.assignmentExpression("=", id, t.identifier(exportName)),
            ),
          );
        } else {
          exp.replaceWith(
            t.expressionStatement(t.assignmentExpression("=", id, decl.node)),
          );
        }
      } else {
        throw new Error("Unexpected helper format.");
      }
      Object.keys(toRename).forEach(name => {
        path.scope.rename(name, toRename[name]);
      });
      for (const path of imps) path.remove();
      for (const path of impsBindingRefs) {
        const node = t.cloneNode(dependenciesRefs[path.node.name]);
        path.replaceWith(node);
      }
      // We only use "traverse" for all the handy scoping helpers, so we can stop immediately without
      // actually doing the traversal.
      path.stop();
    },
  });
}
const helperData = Object.create(null);
function loadHelper(name) {
  if (!helperData[name]) {
    const helper = helpers[name];
    if (!helper) {
      throw Object.assign(new ReferenceError(`Unknown helper ${name}`), {
        code: "BABEL_HELPER_UNKNOWN",
        helper: name,
      });
    }
    const fn = () => {
      return t.file(helper.ast());
    };
    const metadata = getHelperMetadata(fn());
    helperData[name] = {
      build(getDependency, id, localBindings) {
        const file = fn();
        permuteHelperAST(file, metadata, id, localBindings, getDependency);
        return {
          nodes: file.program.body,
          globals: metadata.globals,
        };
      },
      minVersion() {
        return helper.minVersion;
      },
      dependencies: metadata.dependencies,
    };
  }
  return helperData[name];
}
export function get(
  name,
  getDependency?: string => ?t.Expression,
  id?,
  localBindings?: string[],
) {
  return loadHelper(name).build(getDependency, id, localBindings);
}
export function minVersion(name: string) {
  return loadHelper(name).minVersion();
}
export function getDependencies(name: string): $ReadOnlyArray<string> {
  return Array.from(loadHelper(name).dependencies.values());
}
export const list = Object.keys(helpers)
  .map(name => name.replace(/^_/, ""))
  .filter(name => name !== "__esModule");
export default get;

// </from> /home/qfox/apps/babel/packages/babel-helpers/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-helpers/src/helpers.js

// @flow
import template from "@babel/template";
const helpers = Object.create(null);
export default helpers;
const helper = (minVersion: string) => tpl => ({
  minVersion,
  ast: () => template.program.ast(tpl),
});
helpers.typeof = helper("7.0.0-beta.0")`
  export default function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) { return typeof obj; };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype
          ? "symbol"
          : typeof obj;
      };
    }
    return _typeof(obj);
  }
`;
helpers.jsx = helper("7.0.0-beta.0")`
  var REACT_ELEMENT_TYPE;
  export default function _createRawReactElement(type, props, key, children) {
    if (!REACT_ELEMENT_TYPE) {
      REACT_ELEMENT_TYPE = (
        typeof Symbol === "function" && Symbol.for && Symbol.for("react.element")
      ) || 0xeac7;
    }
    var defaultProps = type && type.defaultProps;
    var childrenLength = arguments.length - 3;
    if (!props && childrenLength !== 0) {
      // If we're going to assign props.children, we create a new object now
      // to avoid mutating defaultProps.
      props = {
        children: void 0,
      };
    }
    if (props && defaultProps) {
      for (var propName in defaultProps) {
        if (props[propName] === void 0) {
          props[propName] = defaultProps[propName];
        }
      }
    } else if (!props) {
      props = defaultProps || {};
    }
    if (childrenLength === 1) {
      props.children = children;
    } else if (childrenLength > 1) {
      var childArray = new Array(childrenLength);
      for (var i = 0; i < childrenLength; i++) {
        childArray[i] = arguments[i + 3];
      }
      props.children = childArray;
    }
    return {
      $$typeof: REACT_ELEMENT_TYPE,
      type: type,
      key: key === undefined ? null : '' + key,
      ref: null,
      props: props,
      _owner: null,
    };
  }
`;
helpers.asyncIterator = helper("7.0.0-beta.0")`
  export default function _asyncIterator(iterable) {
    var method
    if (typeof Symbol === "function") {
      if (Symbol.asyncIterator) {
        method = iterable[Symbol.asyncIterator]
        if (method != null) return method.call(iterable);
      }
      if (Symbol.iterator) {
        method = iterable[Symbol.iterator]
        if (method != null) return method.call(iterable);
      }
    }
    throw new TypeError("Object is not async iterable");
  }
`;
helpers.AwaitValue = helper("7.0.0-beta.0")`
  export default function _AwaitValue(value) {
    this.wrapped = value;
  }
`;
helpers.AsyncGenerator = helper("7.0.0-beta.0")`
  import AwaitValue from "AwaitValue";
  export default function AsyncGenerator(gen) {
    var front, back;
    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null,
        };
        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }
    function resume(key, arg) {
      try {
        var result = gen[key](arg)
        var value = result.value;
        var wrappedAwait = value instanceof AwaitValue;
        Promise.resolve(wrappedAwait ? value.wrapped : value).then(
          function (arg) {
            if (wrappedAwait) {
              resume("next", arg);
              return
            }
            settle(result.done ? "return" : "normal", arg);
          },
          function (err) { resume("throw", err); });
      } catch (err) {
        settle("throw", err);
      }
    }
    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({ value: value, done: true });
          break;
        case "throw":
          front.reject(value);
          break;
        default:
          front.resolve({ value: value, done: false });
          break;
      }
      front = front.next;
      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }
    this._invoke = send;
    // Hide "return" method if generator return is not supported
    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }
  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () { return this; };
  }
  AsyncGenerator.prototype.next = function (arg) { return this._invoke("next", arg); };
  AsyncGenerator.prototype.throw = function (arg) { return this._invoke("throw", arg); };
  AsyncGenerator.prototype.return = function (arg) { return this._invoke("return", arg); };
`;
helpers.wrapAsyncGenerator = helper("7.0.0-beta.0")`
  import AsyncGenerator from "AsyncGenerator";
  export default function _wrapAsyncGenerator(fn) {
    return function () {
      return new AsyncGenerator(fn.apply(this, arguments));
    };
  }
`;
helpers.awaitAsyncGenerator = helper("7.0.0-beta.0")`
  import AwaitValue from "AwaitValue";
  export default function _awaitAsyncGenerator(value) {
    return new AwaitValue(value);
  }
`;
helpers.asyncGeneratorDelegate = helper("7.0.0-beta.0")`
  export default function _asyncGeneratorDelegate(inner, awaitWrap) {
    var iter = {}, waiting = false;
    function pump(key, value) {
      waiting = true;
      value = new Promise(function (resolve) { resolve(inner[key](value)); });
      return { done: false, value: awaitWrap(value) };
    };
    if (typeof Symbol === "function" && Symbol.iterator) {
      iter[Symbol.iterator] = function () { return this; };
    }
    iter.next = function (value) {
      if (waiting) {
        waiting = false;
        return value;
      }
      return pump("next", value);
    };
    if (typeof inner.throw === "function") {
      iter.throw = function (value) {
        if (waiting) {
          waiting = false;
          throw value;
        }
        return pump("throw", value);
      };
    }
    if (typeof inner.return === "function") {
      iter.return = function (value) {
        return pump("return", value);
      };
    }
    return iter;
  }
`;
helpers.asyncToGenerator = helper("7.0.0-beta.0")`
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  export default function _asyncToGenerator(fn) {
    return function () {
      var self = this, args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(undefined);
      });
    };
  }
`;
helpers.classCallCheck = helper("7.0.0-beta.0")`
  export default function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
`;
helpers.createClass = helper("7.0.0-beta.0")`
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i ++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  export default function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }
`;
helpers.defineEnumerableProperties = helper("7.0.0-beta.0")`
  export default function _defineEnumerableProperties(obj, descs) {
    for (var key in descs) {
      var desc = descs[key];
      desc.configurable = desc.enumerable = true;
      if ("value" in desc) desc.writable = true;
      Object.defineProperty(obj, key, desc);
    }
    // Symbols are not enumerated over by for-in loops. If native
    // Symbols are available, fetch all of the descs object's own
    // symbol properties and define them on our target object too.
    if (Object.getOwnPropertySymbols) {
      var objectSymbols = Object.getOwnPropertySymbols(descs);
      for (var i = 0; i < objectSymbols.length; i++) {
        var sym = objectSymbols[i];
        var desc = descs[sym];
        desc.configurable = desc.enumerable = true;
        if ("value" in desc) desc.writable = true;
        Object.defineProperty(obj, sym, desc);
      }
    }
    return obj;
  }
`;
helpers.defaults = helper("7.0.0-beta.0")`
  export default function _defaults(obj, defaults) {
    var keys = Object.getOwnPropertyNames(defaults);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var value = Object.getOwnPropertyDescriptor(defaults, key);
      if (value && value.configurable && obj[key] === undefined) {
        Object.defineProperty(obj, key, value);
      }
    }
    return obj;
  }
`;
helpers.defineProperty = helper("7.0.0-beta.0")`
  export default function _defineProperty(obj, key, value) {
    // Shortcircuit the slow defineProperty path when possible.
    // We are trying to avoid issues where setters defined on the
    // prototype cause side effects under the fast path of simple
    // assignment. By checking for existence of the property with
    // the in operator, we can optimize most of this overhead away.
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
`;
helpers.extends = helper("7.0.0-beta.0")`
  export default function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
`;
helpers.objectSpread = helper("7.0.0-beta.0")`
  import defineProperty from "defineProperty";
  export default function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = (arguments[i] != null) ? arguments[i] : {};
      var ownKeys = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys.forEach(function(key) {
        defineProperty(target, key, source[key]);
      });
    }
    return target;
  }
`;
helpers.inherits = helper("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";
  export default function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) setPrototypeOf(subClass, superClass);
  }
`;
helpers.inheritsLoose = helper("7.0.0-beta.0")`
  export default function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
`;
helpers.getPrototypeOf = helper("7.0.0-beta.0")`
  export default function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf
      ? Object.getPrototypeOf
      : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
    return _getPrototypeOf(o);
  }
`;
helpers.setPrototypeOf = helper("7.0.0-beta.0")`
  export default function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }
`;
helpers.construct = helper("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";
  function isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    // core-js@3
    if (Reflect.construct.sham) return false;
    // Proxy can't be polyfilled. Every browser implemented
    // proxies before or at the same time as Reflect.construct,
    // so if they support Proxy they also support Reflect.construct.
    if (typeof Proxy === "function") return true;
    // Since Reflect.construct can't be properly polyfilled, some
    // implementations (e.g. core-js@2) don't set the correct internal slots.
    // Those polyfills don't allow us to subclass built-ins, so we need to
    // use our fallback implementation.
    try {
      // If the internal slots aren't set, this throws an error similar to
      //   TypeError: this is not a Date object.
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
      return true;
    } catch (e) {
      return false;
    }
  }
  export default function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      // NOTE: If Parent !== Class, the correct __proto__ is set *after*
      //       calling the constructor.
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }
    // Avoid issues with Class being present but undefined when it wasn't
    // present in the original call.
    return _construct.apply(null, arguments);
  }
`;
helpers.isNativeFunction = helper("7.0.0-beta.0")`
  export default function _isNativeFunction(fn) {
    // Note: This function returns "true" for core-js functions.
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }
`;
// Based on https://github.com/WebReflection/babel-plugin-transform-builtin-classes
helpers.wrapNativeSuper = helper("7.0.0-beta.0")`
  import getPrototypeOf from "getPrototypeOf";
  import setPrototypeOf from "setPrototypeOf";
  import isNativeFunction from "isNativeFunction";
  import construct from "construct";
  export default function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;
    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !isNativeFunction(Class)) return Class;
      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);
        _cache.set(Class, Wrapper);
      }
      function Wrapper() {
        return construct(Class, arguments, getPrototypeOf(this).constructor)
      }
      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true,
        }
      });
      return setPrototypeOf(Wrapper, Class);
    }
    return _wrapNativeSuper(Class)
  }
`;
helpers.instanceof = helper("7.0.0-beta.0")`
  export default function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
      return right[Symbol.hasInstance](left);
    } else {
      return left instanceof right;
    }
  }
`;
helpers.interopRequireDefault = helper("7.0.0-beta.0")`
  export default function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
`;
helpers.interopRequireWildcard = helper("7.0.0-beta.0")`
  export default function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = Object.defineProperty && Object.getOwnPropertyDescriptor
              ? Object.getOwnPropertyDescriptor(obj, key)
              : {};
            if (desc.get || desc.set) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
      }
      newObj.default = obj;
      return newObj;
    }
  }
`;
helpers.newArrowCheck = helper("7.0.0-beta.0")`
  export default function _newArrowCheck(innerThis, boundThis) {
    if (innerThis !== boundThis) {
      throw new TypeError("Cannot instantiate an arrow function");
    }
  }
`;
helpers.objectDestructuringEmpty = helper("7.0.0-beta.0")`
  export default function _objectDestructuringEmpty(obj) {
    if (obj == null) throw new TypeError("Cannot destructure undefined");
  }
`;
helpers.objectWithoutPropertiesLoose = helper("7.0.0-beta.0")`
  export default function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
    return target;
  }
`;
helpers.objectWithoutProperties = helper("7.0.0-beta.0")`
  import objectWithoutPropertiesLoose from "objectWithoutPropertiesLoose";
  export default function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }
    return target;
  }
`;
helpers.assertThisInitialized = helper("7.0.0-beta.0")`
  export default function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }
`;
helpers.possibleConstructorReturn = helper("7.0.0-beta.0")`
  import assertThisInitialized from "assertThisInitialized";
  export default function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }
    return assertThisInitialized(self);
  }
`;
helpers.superPropBase = helper("7.0.0-beta.0")`
  import getPrototypeOf from "getPrototypeOf";
  export default function _superPropBase(object, property) {
    // Yes, this throws if object is null to being with, that's on purpose.
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = getPrototypeOf(object);
      if (object === null) break;
    }
    return object;
  }
`;
helpers.get = helper("7.0.0-beta.0")`
  import getPrototypeOf from "getPrototypeOf";
  import superPropBase from "superPropBase";
  export default function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = superPropBase(target, property);
        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);
        if (desc.get) {
          return desc.get.call(receiver);
        }
        return desc.value;
      };
    }
    return _get(target, property, receiver || target);
  }
`;
helpers.set = helper("7.0.0-beta.0")`
  import getPrototypeOf from "getPrototypeOf";
  import superPropBase from "superPropBase";
  import defineProperty from "defineProperty";
  function set(target, property, value, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.set) {
      set = Reflect.set;
    } else {
      set = function set(target, property, value, receiver) {
        var base = superPropBase(target, property);
        var desc;
        if (base) {
          desc = Object.getOwnPropertyDescriptor(base, property);
          if (desc.set) {
            desc.set.call(receiver, value);
            return true;
          } else if (!desc.writable) {
            // Both getter and non-writable fall into this.
            return false;
          }
        }
        // Without a super that defines the property, spec boils down to
        // "define on receiver" for some reason.
        desc = Object.getOwnPropertyDescriptor(receiver, property);
        if (desc) {
          if (!desc.writable) {
            // Setter, getter, and non-writable fall into this.
            return false;
          }
          desc.value = value;
          Object.defineProperty(receiver, property, desc);
        } else {
          // Avoid setters that may be defined on Sub's prototype, but not on
          // the instance.
          defineProperty(receiver, property, value);
        }
        return true;
      };
    }
    return set(target, property, value, receiver);
  }
  export default function _set(target, property, value, receiver, isStrict) {
    var s = set(target, property, value, receiver || target);
    if (!s && isStrict) {
      throw new Error('failed to set property');
    }
    return value;
  }
`;
helpers.taggedTemplateLiteral = helper("7.0.0-beta.0")`
  export default function _taggedTemplateLiteral(strings, raw) {
    if (!raw) { raw = strings.slice(0); }
    return Object.freeze(Object.defineProperties(strings, {
        raw: { value: Object.freeze(raw) }
    }));
  }
`;
helpers.taggedTemplateLiteralLoose = helper("7.0.0-beta.0")`
  export default function _taggedTemplateLiteralLoose(strings, raw) {
    if (!raw) { raw = strings.slice(0); }
    strings.raw = raw;
    return strings;
  }
`;
helpers.temporalRef = helper("7.0.0-beta.0")`
  import undef from "temporalUndefined";
  export default function _temporalRef(val, name) {
    if (val === undef) {
      throw new ReferenceError(name + " is not defined - temporal dead zone");
    } else {
      return val;
    }
  }
`;
helpers.readOnlyError = helper("7.0.0-beta.0")`
  export default function _readOnlyError(name) {
    throw new Error("\\"" + name + "\\" is read-only");
  }
`;
helpers.classNameTDZError = helper("7.0.0-beta.0")`
  export default function _classNameTDZError(name) {
    throw new Error("Class \\"" + name + "\\" cannot be referenced in computed property keys.");
  }
`;
helpers.temporalUndefined = helper("7.0.0-beta.0")`
  export default {};
`;
helpers.slicedToArray = helper("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArrayLimit from "iterableToArrayLimit";
  import nonIterableRest from "nonIterableRest";
  export default function _slicedToArray(arr, i) {
    return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();
  }
`;
helpers.slicedToArrayLoose = helper("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArrayLimitLoose from "iterableToArrayLimitLoose";
  import nonIterableRest from "nonIterableRest";
  export default function _slicedToArrayLoose(arr, i) {
    return arrayWithHoles(arr) || iterableToArrayLimitLoose(arr, i) || nonIterableRest();
  }
`;
helpers.toArray = helper("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArray from "iterableToArray";
  import nonIterableRest from "nonIterableRest";
  export default function _toArray(arr) {
    return arrayWithHoles(arr) || iterableToArray(arr) || nonIterableRest();
  }
`;
helpers.toConsumableArray = helper("7.0.0-beta.0")`
  import arrayWithoutHoles from "arrayWithoutHoles";
  import iterableToArray from "iterableToArray";
  import nonIterableSpread from "nonIterableSpread";
  export default function _toConsumableArray(arr) {
    return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();
  }
`;
helpers.arrayWithoutHoles = helper("7.0.0-beta.0")`
  export default function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
      return arr2;
    }
  }
`;
helpers.arrayWithHoles = helper("7.0.0-beta.0")`
  export default function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
`;
helpers.iterableToArray = helper("7.0.0-beta.0")`
  export default function _iterableToArray(iter) {
    if (
      Symbol.iterator in Object(iter) ||
      Object.prototype.toString.call(iter) === "[object Arguments]"
    ) return Array.from(iter);
  }
`;
helpers.iterableToArrayLimit = helper("7.0.0-beta.0")`
  export default function _iterableToArrayLimit(arr, i) {
    // this is an expanded form of \`for...of\` that properly supports abrupt completions of
    // iterators etc. variable names have been minimised to reduce the size of this massive
    // helper. sometimes spec compliancy is annoying :(
    //
    // _n = _iteratorNormalCompletion
    // _d = _didIteratorError
    // _e = _iteratorError
    // _i = _iterator
    // _s = _step
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
`;
helpers.iterableToArrayLimitLoose = helper("7.0.0-beta.0")`
  export default function _iterableToArrayLimitLoose(arr, i) {
    var _arr = [];
    for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
      _arr.push(_step.value);
      if (i && _arr.length === i) break;
    }
    return _arr;
  }
`;
helpers.nonIterableSpread = helper("7.0.0-beta.0")`
  export default function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }
`;
helpers.nonIterableRest = helper("7.0.0-beta.0")`
  export default function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }
`;
helpers.skipFirstGeneratorNext = helper("7.0.0-beta.0")`
  export default function _skipFirstGeneratorNext(fn) {
    return function () {
      var it = fn.apply(this, arguments);
      it.next();
      return it;
    }
  }
`;
helpers.toPropertyKey = helper("7.0.0-beta.0")`
  export default function _toPropertyKey(key) {
    if (typeof key === "symbol") {
      return key;
    } else {
      return String(key);
    }
  }
`;
/**
 * Add a helper that will throw a useful error if the transform fails to detect the class
 * property assignment, so users know something failed.
 */
helpers.initializerWarningHelper = helper("7.0.0-beta.0")`
    export default function _initializerWarningHelper(descriptor, context){
        throw new Error(
          'Decorating class property failed. Please ensure that ' +
          'proposal-class-properties is enabled and set to use loose mode. ' +
          'To use proposal-class-properties in spec mode with decorators, wait for ' +
          'the next major version of decorators in stage 2.'
        );
    }
`;
/**
 * Add a helper to call as a replacement for class property definition.
 */
helpers.initializerDefineProperty = helper("7.0.0-beta.0")`
    export default function _initializerDefineProperty(target, property, descriptor, context){
        if (!descriptor) return;
        Object.defineProperty(target, property, {
            enumerable: descriptor.enumerable,
            configurable: descriptor.configurable,
            writable: descriptor.writable,
            value: descriptor.initializer ? descriptor.initializer.call(context) : void 0,
        });
    }
`;
/**
 * Add a helper to take an initial descriptor, apply some decorators to it, and optionally
 * define the property.
 */
helpers.applyDecoratedDescriptor = helper("7.0.0-beta.0")`
    export default function _applyDecoratedDescriptor(target, property, decorators, descriptor, context){
        var desc = {};
        Object['ke' + 'ys'](descriptor).forEach(function(key){
            desc[key] = descriptor[key];
        });
        desc.enumerable = !!desc.enumerable;
        desc.configurable = !!desc.configurable;
        if ('value' in desc || desc.initializer){
            desc.writable = true;
        }
        desc = decorators.slice().reverse().reduce(function(desc, decorator){
            return decorator(target, property, desc) || desc;
        }, desc);
        if (context && desc.initializer !== void 0){
            desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
            desc.initializer = undefined;
        }
        if (desc.initializer === void 0){
            // This is a hack to avoid this being processed by 'transform-runtime'.
            // See issue #9.
            Object['define' + 'Property'](target, property, desc);
            desc = null;
        }
        return desc;
    }
`;
helpers.classPrivateFieldLooseKey = helper("7.0.0-beta.0")`
  var id = 0;
  export default function _classPrivateFieldKey(name) {
    return "__private_" + (id++) + "_" + name;
  }
`;
helpers.classPrivateFieldLooseBase = helper("7.0.0-beta.0")`
  export default function _classPrivateFieldBase(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
      throw new TypeError("attempted to use private field on non-instance");
    }
    return receiver;
  }
`;
helpers.classPrivateFieldGet = helper("7.0.0-beta.0")`
  export default function _classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver).value;
  }
`;
helpers.classPrivateFieldSet = helper("7.0.0-beta.0")`
  export default function _classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to set private field on non-instance");
    }
    var descriptor = privateMap.get(receiver);
    if (!descriptor.writable) {
      // This should only throw in strict mode, but class bodies are
      // always strict and private fields can only be used inside
      // class bodies.
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
    return value;
  }
`;
helpers.classStaticPrivateFieldSpecGet = helper("7.0.2")`
  export default function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {
    if (receiver !== classConstructor) {
      throw new TypeError("Private static access of wrong provenance");
    }
    return descriptor.value;
  }
`;
helpers.classStaticPrivateFieldSpecSet = helper("7.0.2")`
  export default function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {
    if (receiver !== classConstructor) {
      throw new TypeError("Private static access of wrong provenance");
    }
    if (!descriptor.writable) {
      // This should only throw in strict mode, but class bodies are
      // always strict and private fields can only be used inside
      // class bodies.
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
    return value;
  }
`;
helpers.decorate = helper("7.0.2")`
  import toArray from "toArray";
  // These comments are stripped by @babel/template
  /*::
  type PropertyDescriptor =
    | {
        value: any,
        writable: boolean,
        configurable: boolean,
        enumerable: boolean,
      }
    | {
        get?: () => any,
        set?: (v: any) => void,
        configurable: boolean,
        enumerable: boolean,
      };
  type FieldDescriptor ={
    writable: boolean,
    configurable: boolean,
    enumerable: boolean,
  };
  type Placement = "static" | "prototype" | "own";
  type Key = string | symbol; // PrivateName is not supported yet.
  type ElementDescriptor =
    | {
        kind: "method",
        key: Key,
        placement: Placement,
        descriptor: PropertyDescriptor
      }
    | {
        kind: "field",
        key: Key,
        placement: Placement,
        descriptor: FieldDescriptor,
        initializer?: () => any,
      };
  // This is exposed to the user code
  type ElementObjectInput = ElementDescriptor & {
    [@@toStringTag]?: "Descriptor"
  };
  // This is exposed to the user code
  type ElementObjectOutput = ElementDescriptor & {
    [@@toStringTag]?: "Descriptor"
    extras?: ElementDescriptor[],
    finisher?: ClassFinisher,
  };
  // This is exposed to the user code
  type ClassObject = {
    [@@toStringTag]?: "Descriptor",
    kind: "class",
    elements: ElementDescriptor[],
  };
  type ElementDecorator = (descriptor: ElementObjectInput) => ?ElementObjectOutput;
  type ClassDecorator = (descriptor: ClassObject) => ?ClassObject;
  type ClassFinisher = <A, B>(cl: Class<A>) => Class<B>;
  // Only used by Babel in the transform output, not part of the spec.
  type ElementDefinition =
    | {
        kind: "method",
        value: any,
        key: Key,
        static?: boolean,
        decorators?: ElementDecorator[],
      }
    | {
        kind: "field",
        value: () => any,
        key: Key,
        static?: boolean,
        decorators?: ElementDecorator[],
    };
  declare function ClassFactory<C>(initialize: (instance: C) => void): {
    F: Class<C>,
    d: ElementDefinition[]
  }
  */
  /*::
  // Various combinations with/without extras and with one or many finishers
  type ElementFinisherExtras = {
    element: ElementDescriptor,
    finisher?: ClassFinisher,
    extras?: ElementDescriptor[],
  };
  type ElementFinishersExtras = {
    element: ElementDescriptor,
    finishers: ClassFinisher[],
    extras: ElementDescriptor[],
  };
  type ElementsFinisher = {
    elements: ElementDescriptor[],
    finisher?: ClassFinisher,
  };
  type ElementsFinishers = {
    elements: ElementDescriptor[],
    finishers: ClassFinisher[],
  };
  */
  // ClassDefinitionEvaluation (Steps 26-*)
  export default function _decorate(
    decorators /*: ClassDecorator[] */,
    factory /*: ClassFactory */,
    superClass /*: ?Class<*> */,
  ) /*: Class<*> */ {
    var r = factory(function initialize(O) {
      _initializeInstanceElements(O, decorated.elements);
    }, superClass);
    var decorated = _decorateClass(
      _coalesceClassElements(r.d.map(_createElementDescriptor)),
      decorators,
    );
    _initializeClassElements(r.F, decorated.elements);
    return _runClassFinishers(r.F, decorated.finishers);
  }
  // ClassElementEvaluation
  function _createElementDescriptor(
    def /*: ElementDefinition */,
  ) /*: ElementDescriptor */ {
    var descriptor /*: PropertyDescriptor */;
    if (def.kind === "method") {
      descriptor = {
        value: def.value,
        writable: true,
        configurable: true,
        enumerable: false,
      };
    } else if (def.kind === "get") {
      descriptor = { get: def.value, configurable: true, enumerable: false };
    } else if (def.kind === "set") {
      descriptor = { set: def.value, configurable: true, enumerable: false };
    } else if (def.kind === "field") {
      descriptor = { configurable: true, writable: true, enumerable: true };
    }
    var element /*: ElementDescriptor */ = {
      kind: def.kind === "field" ? "field" : "method",
      key: def.key,
      placement: def.static
        ? "static"
        : def.kind === "field"
          ? "own"
          : "prototype",
      descriptor: descriptor,
    };
    if (def.decorators) element.decorators = def.decorators;
    if (def.kind === "field") element.initializer = def.value;
    return element;
  }
  // CoalesceGetterSetter
  function _coalesceGetterSetter(
    element /*: ElementDescriptor */,
    other /*: ElementDescriptor */,
  ) {
    if (element.descriptor.get !== undefined) {
      other.descriptor.get = element.descriptor.get;
    } else {
      other.descriptor.set = element.descriptor.set;
    }
  }
  // CoalesceClassElements
  function _coalesceClassElements(
    elements /*: ElementDescriptor[] */,
  ) /*: ElementDescriptor[] */ {
    var newElements /*: ElementDescriptor[] */ = [];
    var isSameElement = function(other /*: ElementDescriptor */) /*: boolean */ {
      return (
        other.kind === "method" &&
        other.key === element.key &&
        other.placement === element.placement
      );
    };
    for (var i = 0; i < elements.length; i++) {
      var element /*: ElementDescriptor */ = elements[i];
      var other /*: ElementDescriptor */;
      if (
        element.kind === "method" &&
        (other = newElements.find(isSameElement))
      ) {
        if (
          _isDataDescriptor(element.descriptor) ||
          _isDataDescriptor(other.descriptor)
        ) {
          if (_hasDecorators(element) || _hasDecorators(other)) {
            throw new ReferenceError(
              "Duplicated methods (" + element.key + ") can't be decorated.",
            );
          }
          other.descriptor = element.descriptor;
        } else {
          if (_hasDecorators(element)) {
            if (_hasDecorators(other)) {
              throw new ReferenceError(
                "Decorators can't be placed on different accessors with for " +
                  "the same property (" +
                  element.key +
                  ").",
              );
            }
            other.decorators = element.decorators;
          }
          _coalesceGetterSetter(element, other);
        }
      } else {
        newElements.push(element);
      }
    }
    return newElements;
  }
  function _hasDecorators(element /*: ElementDescriptor */) /*: boolean */ {
    return element.decorators && element.decorators.length;
  }
  function _isDataDescriptor(desc /*: PropertyDescriptor */) /*: boolean */ {
    return (
      desc !== undefined &&
      !(desc.value === undefined && desc.writable === undefined)
    );
  }
  // InitializeClassElements
  function _initializeClassElements /*::<C>*/(
    F /*: Class<C> */,
    elements /*: ElementDescriptor[] */,
  ) {
    var proto = F.prototype;
    ["method", "field"].forEach(function(kind) {
      elements.forEach(function(element /*: ElementDescriptor */) {
        var placement = element.placement;
        if (
          element.kind === kind &&
          (placement === "static" || placement === "prototype")
        ) {
          var receiver = placement === "static" ? F : proto;
          _defineClassElement(receiver, element);
        }
      });
    });
  }
  // InitializeInstanceElements
  function _initializeInstanceElements /*::<C>*/(
    O /*: C */,
    elements /*: ElementDescriptor[] */,
  ) {
    ["method", "field"].forEach(function(kind) {
      elements.forEach(function(element /*: ElementDescriptor */) {
        if (element.kind === kind && element.placement === "own") {
          _defineClassElement(O, element);
        }
      });
    });
  }
  // DefineClassElement
  function _defineClassElement /*::<C>*/(
    receiver /*: C | Class<C> */,
    element /*: ElementDescriptor */,
  ) {
    var descriptor /*: PropertyDescriptor */ = element.descriptor;
    if (element.kind === "field") {
      var initializer = element.initializer;
      descriptor = {
        enumerable: descriptor.enumerable,
        writable: descriptor.writable,
        configurable: descriptor.configurable,
        value: initializer === void 0 ? void 0 : initializer.call(receiver),
      };
    }
    Object.defineProperty(receiver, element.key, descriptor);
  }
  /*::
  type Placements = {
    static: Key[],
    prototype: Key[],
    own: Key[],
  };
  */
  // DecorateClass
  function _decorateClass(
    elements /*: ElementDescriptor[] */,
    decorators /*: ClassDecorator[] */,
  ) /*: ElementsFinishers */ {
    var newElements /*: ElementDescriptor[] */ = [];
    var finishers /*: ClassFinisher[] */ = [];
    var placements /*: Placements */ = { static: [], prototype: [], own: [] };
    elements.forEach(function(element /*: ElementDescriptor */) {
      _addElementPlacement(element, placements);
    });
    elements.forEach(function(element /*: ElementDescriptor */) {
      if (!_hasDecorators(element)) return newElements.push(element);
      var elementFinishersExtras /*: ElementFinishersExtras */ = _decorateElement(
        element,
        placements,
      );
      newElements.push(elementFinishersExtras.element);
      newElements.push.apply(newElements, elementFinishersExtras.extras);
      finishers.push.apply(finishers, elementFinishersExtras.finishers);
    });
    if (!decorators) {
      return { elements: newElements, finishers: finishers };
    }
    var result /*: ElementsFinishers */ = _decorateConstructor(
      newElements,
      decorators,
    );
    finishers.push.apply(finishers, result.finishers);
    result.finishers = finishers;
    return result;
  }
  // AddElementPlacement
  function _addElementPlacement(
    element /*: ElementDescriptor */,
    placements /*: Placements */,
    silent /*: boolean */,
  ) {
    var keys = placements[element.placement];
    if (!silent && keys.indexOf(element.key) !== -1) {
      throw new TypeError("Duplicated element (" + element.key + ")");
    }
    keys.push(element.key);
  }
  // DecorateElement
  function _decorateElement(
    element /*: ElementDescriptor */,
    placements /*: Placements */,
  ) /*: ElementFinishersExtras */ {
    var extras /*: ElementDescriptor[] */ = [];
    var finishers /*: ClassFinisher[] */ = [];
    for (
      var decorators = element.decorators, i = decorators.length - 1;
      i >= 0;
      i--
    ) {
      // (inlined) RemoveElementPlacement
      var keys = placements[element.placement];
      keys.splice(keys.indexOf(element.key), 1);
      var elementObject /*: ElementObjectInput */ = _fromElementDescriptor(
        element,
      );
      var elementFinisherExtras /*: ElementFinisherExtras */ = _toElementFinisherExtras(
        (0, decorators[i])(elementObject) /*: ElementObjectOutput */ ||
          elementObject,
      );
      element = elementFinisherExtras.element;
      _addElementPlacement(element, placements);
      if (elementFinisherExtras.finisher) {
        finishers.push(elementFinisherExtras.finisher);
      }
      var newExtras /*: ElementDescriptor[] | void */ =
        elementFinisherExtras.extras;
      if (newExtras) {
        for (var j = 0; j < newExtras.length; j++) {
          _addElementPlacement(newExtras[j], placements);
        }
        extras.push.apply(extras, newExtras);
      }
    }
    return { element: element, finishers: finishers, extras: extras };
  }
  // DecorateConstructor
  function _decorateConstructor(
    elements /*: ElementDescriptor[] */,
    decorators /*: ClassDecorator[] */,
  ) /*: ElementsFinishers */ {
    var finishers /*: ClassFinisher[] */ = [];
    for (var i = decorators.length - 1; i >= 0; i--) {
      var obj /*: ClassObject */ = _fromClassDescriptor(elements);
      var elementsAndFinisher /*: ElementsFinisher */ = _toClassDescriptor(
        (0, decorators[i])(obj) /*: ClassObject */ || obj,
      );
      if (elementsAndFinisher.finisher !== undefined) {
        finishers.push(elementsAndFinisher.finisher);
      }
      if (elementsAndFinisher.elements !== undefined) {
        elements = elementsAndFinisher.elements;
        for (var j = 0; j < elements.length - 1; j++) {
          for (var k = j + 1; k < elements.length; k++) {
            if (
              elements[j].key === elements[k].key &&
              elements[j].placement === elements[k].placement
            ) {
              throw new TypeError("Duplicated element (" + elements[j].key + ")");
            }
          }
        }
      }
    }
    return { elements: elements, finishers: finishers };
  }
  // FromElementDescriptor
  function _fromElementDescriptor(
    element /*: ElementDescriptor */,
  ) /*: ElementObject */ {
    var obj /*: ElementObject */ = {
      kind: element.kind,
      key: element.key,
      placement: element.placement,
      descriptor: element.descriptor,
    };
    var desc = {
      value: "Descriptor",
      configurable: true,
    };
    Object.defineProperty(obj, Symbol.toStringTag, desc);
    if (element.kind === "field") obj.initializer = element.initializer;
    return obj;
  }
  // ToElementDescriptors
  function _toElementDescriptors(
    elementObjects /*: ElementObject[] */,
  ) /*: ElementDescriptor[] */ {
    if (elementObjects === undefined) return;
    return toArray(elementObjects).map(function(elementObject) {
      var element = _toElementDescriptor(elementObject);
      _disallowProperty(elementObject, "finisher", "An element descriptor");
      _disallowProperty(elementObject, "extras", "An element descriptor");
      return element;
    });
  }
  // ToElementDescriptor
  function _toElementDescriptor(
    elementObject /*: ElementObject */,
  ) /*: ElementDescriptor */ {
    var kind = String(elementObject.kind);
    if (kind !== "method" && kind !== "field") {
      throw new TypeError(
        'An element descriptor\\'s .kind property must be either "method" or' +
          ' "field", but a decorator created an element descriptor with' +
          ' .kind "' +
          kind +
          '"',
      );
    }
    var key = elementObject.key;
    if (typeof key !== "string" && typeof key !== "symbol") key = String(key);
    var placement = String(elementObject.placement);
    if (
      placement !== "static" &&
      placement !== "prototype" &&
      placement !== "own"
    ) {
      throw new TypeError(
        'An element descriptor\\'s .placement property must be one of "static",' +
          ' "prototype" or "own", but a decorator created an element descriptor' +
          ' with .placement "' +
          placement +
          '"',
      );
    }
    var descriptor /*: PropertyDescriptor */ = elementObject.descriptor;
    _disallowProperty(elementObject, "elements", "An element descriptor");
    var element /*: ElementDescriptor */ = {
      kind: kind,
      key: key,
      placement: placement,
      descriptor: Object.assign({}, descriptor),
    };
    if (kind !== "field") {
      _disallowProperty(elementObject, "initializer", "A method descriptor");
    } else {
      _disallowProperty(
        descriptor,
        "get",
        "The property descriptor of a field descriptor",
      );
      _disallowProperty(
        descriptor,
        "set",
        "The property descriptor of a field descriptor",
      );
      _disallowProperty(
        descriptor,
        "value",
        "The property descriptor of a field descriptor",
      );
      element.initializer = elementObject.initializer;
    }
    return element;
  }
  function _toElementFinisherExtras(
    elementObject /*: ElementObject */,
  ) /*: ElementFinisherExtras */ {
    var element /*: ElementDescriptor */ = _toElementDescriptor(elementObject);
    var finisher /*: ClassFinisher */ = _optionalCallableProperty(
      elementObject,
      "finisher",
    );
    var extras /*: ElementDescriptors[] */ = _toElementDescriptors(
      elementObject.extras,
    );
    return { element: element, finisher: finisher, extras: extras };
  }
  // FromClassDescriptor
  function _fromClassDescriptor(
    elements /*: ElementDescriptor[] */,
  ) /*: ClassObject */ {
    var obj = {
      kind: "class",
      elements: elements.map(_fromElementDescriptor),
    };
    var desc = { value: "Descriptor", configurable: true };
    Object.defineProperty(obj, Symbol.toStringTag, desc);
    return obj;
  }
  // ToClassDescriptor
  function _toClassDescriptor(obj /*: ClassObject */) /*: ElementsFinisher */ {
    var kind = String(obj.kind);
    if (kind !== "class") {
      throw new TypeError(
        'A class descriptor\\'s .kind property must be "class", but a decorator' +
          ' created a class descriptor with .kind "' +
          kind +
          '"',
      );
    }
    _disallowProperty(obj, "key", "A class descriptor");
    _disallowProperty(obj, "placement", "A class descriptor");
    _disallowProperty(obj, "descriptor", "A class descriptor");
    _disallowProperty(obj, "initializer", "A class descriptor");
    _disallowProperty(obj, "extras", "A class descriptor");
    var finisher = _optionalCallableProperty(obj, "finisher");
    var elements = _toElementDescriptors(obj.elements);
    return { elements: elements, finisher: finisher };
  }
  function _disallowProperty(obj, name, objectType) {
    if (obj[name] !== undefined) {
      throw new TypeError(objectType + " can't have a ." + name + " property.");
    }
  }
  function _optionalCallableProperty /*::<T>*/(
    obj /*: T */,
    name /*: $Keys<T> */,
  ) /*: ?Function */ {
    var value = obj[name];
    if (value !== undefined && typeof value !== "function") {
      throw new TypeError("Expected '" + name + "' to be a function");
    }
    return value;
  }
  // RunClassFinishers
  function _runClassFinishers(
    constructor /*: Class<*> */,
    finishers /*: ClassFinisher[] */,
  ) /*: Class<*> */ {
    for (var i = 0; i < finishers.length; i++) {
      var newConstructor /*: ?Class<*> */ = (0, finishers[i])(constructor);
      if (newConstructor !== undefined) {
        // NOTE: This should check if IsConstructor(newConstructor) is false.
        if (typeof newConstructor !== "function") {
          throw new TypeError("Finishers must return a constructor.");
        }
        constructor = newConstructor;
      }
    }
    return constructor;
  }
  `;

// </from> /home/qfox/apps/babel/packages/babel-helpers/src/helpers.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-react-display-name/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import path from "path";
import { types as t } from "@babel/core";
export default declare(api => {
  api.assertVersion(7);
  function addDisplayName(id, call) {
    const props = call.arguments[0].properties;
    let safe = true;
    for (let i = 0; i < props.length; i++) {
      const prop = props[i];
      const key = t.toComputedKey(prop);
      if (t.isLiteral(key, { value: "displayName" })) {
        safe = false;
        break;
      }
    }
    if (safe) {
      props.unshift(
        t.objectProperty(t.identifier("displayName"), t.stringLiteral(id)),
      );
    }
  }
  const isCreateClassCallExpression = t.buildMatchMemberExpression(
    "React.createClass",
  );
  const isCreateClassAddon = callee => callee.name === "createReactClass";
  function isCreateClass(node) {
    if (!node || !t.isCallExpression(node)) return false;
    // not createReactClass nor React.createClass call member object
    if (
      !isCreateClassCallExpression(node.callee) &&
      !isCreateClassAddon(node.callee)
    ) {
      return false;
    }
    // no call arguments
    const args = node.arguments;
    if (args.length !== 1) return false;
    // first node arg is not an object
    const first = args[0];
    if (!t.isObjectExpression(first)) return false;
    return true;
  }
  return {
    visitor: {
      ExportDefaultDeclaration({ node }, state) {
        if (isCreateClass(node.declaration)) {
          const filename = state.filename || "unknown";
          let displayName = path.basename(filename, path.extname(filename));
          // ./{module name}/index.js
          if (displayName === "index") {
            displayName = path.basename(path.dirname(filename));
          }
          addDisplayName(displayName, node.declaration);
        }
      },
      CallExpression(path) {
        const { node } = path;
        if (!isCreateClass(node)) return;
        let id;
        // crawl up the ancestry looking for possible candidates for displayName inference
        path.find(function(path) {
          if (path.isAssignmentExpression()) {
            id = path.node.left;
          } else if (path.isObjectProperty()) {
            id = path.node.key;
          } else if (path.isVariableDeclarator()) {
            id = path.node.id;
          } else if (path.isStatement()) {
            // we've hit a statement, we should stop crawling up
            return true;
          }
          // we've got an id! no need to continue
          if (id) return true;
        });
        // ensure that we have an identifier we can inherit from
        if (!id) return;
        // foo.bar -> bar
        if (t.isMemberExpression(id)) {
          id = id.property;
        }
        // identifiers are the only thing we can reliably get a name from
        if (t.isIdentifier(id)) {
          addDisplayName(id.name, node);
        }
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-react-display-name/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-syntax-function-bind/src/index.js

import { declare } from "@babel/helper-plugin-utils";
export default declare(api => {
  api.assertVersion(7);
  return {
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("functionBind");
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-syntax-function-bind/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-jscript/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import { types as t } from "@babel/core";
export default declare(api => {
  api.assertVersion(7);
  return {
    visitor: {
      FunctionExpression: {
        exit(path) {
          const { node } = path;
          if (!node.id) return;
          path.replaceWith(
            t.callExpression(
              t.functionExpression(
                null,
                [],
                t.blockStatement([
                  t.toStatement(node),
                  t.returnStatement(t.cloneNode(node.id)),
                ]),
              ),
              [],
            ),
          );
        },
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-jscript/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-syntax-import-meta/src/index.js

import { declare } from "@babel/helper-plugin-utils";
export default declare(api => {
  api.assertVersion(7);
  return {
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("importMeta");
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-syntax-import-meta/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-template-literals/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import { template, types as t } from "@babel/core";
export default declare((api, options) => {
  api.assertVersion(7);
  const { loose } = options;
  let helperName = "taggedTemplateLiteral";
  if (loose) helperName += "Loose";
  /**
   * This function groups the objects into multiple calls to `.concat()` in
   * order to preserve execution order of the primitive conversion, e.g.
   *
   *   "".concat(obj.foo, "foo", obj2.foo, "foo2")
   *
   * would evaluate both member expressions _first_ then, `concat` will
   * convert each one to a primitive, whereas
   *
   *   "".concat(obj.foo, "foo").concat(obj2.foo, "foo2")
   *
   * would evaluate the member, then convert it to a primitive, then evaluate
   * the second member and convert that one, which reflects the spec behavior
   * of template literals.
   */
  function buildConcatCallExressions(items) {
    let avail = true;
    return items.reduce(function(left, right) {
      let canBeInserted = t.isLiteral(right);
      if (!canBeInserted && avail) {
        canBeInserted = true;
        avail = false;
      }
      if (canBeInserted && t.isCallExpression(left)) {
        left.arguments.push(right);
        return left;
      }
      return t.callExpression(
        t.memberExpression(left, t.identifier("concat")),
        [right],
      );
    });
  }
  return {
    visitor: {
      TaggedTemplateExpression(path) {
        const { node } = path;
        const { quasi } = node;
        const strings = [];
        const raws = [];
        // Flag variable to check if contents of strings and raw are equal
        let isStringsRawEqual = true;
        for (const elem of (quasi.quasis: Array)) {
          const { raw, cooked } = elem.value;
          const value =
            cooked == null
              ? path.scope.buildUndefinedNode()
              : t.stringLiteral(cooked);
          strings.push(value);
          raws.push(t.stringLiteral(raw));
          if (raw !== cooked) {
            // false even if one of raw and cooked are not equal
            isStringsRawEqual = false;
          }
        }
        const scope = path.scope.getProgramParent();
        const templateObject = scope.generateUidIdentifier("templateObject");
        const helperId = this.addHelper(helperName);
        const callExpressionInput = [t.arrayExpression(strings)];
        // only add raw arrayExpression if there is any difference between raws and strings
        if (!isStringsRawEqual) {
          callExpressionInput.push(t.arrayExpression(raws));
        }
        const lazyLoad = template.ast`
          function ${templateObject}() {
            const data = ${t.callExpression(helperId, callExpressionInput)};
            ${templateObject} = function() { return data };
            return data;
          } 
        `;
        scope.path.unshiftContainer("body", lazyLoad);
        path.replaceWith(
          t.callExpression(node.tag, [
            t.callExpression(t.cloneNode(templateObject), []),
            ...quasi.expressions,
          ]),
        );
      },
      TemplateLiteral(path) {
        const nodes = [];
        const expressions = path.get("expressions");
        let index = 0;
        for (const elem of (path.node.quasis: Array)) {
          if (elem.value.cooked) {
            nodes.push(t.stringLiteral(elem.value.cooked));
          }
          if (index < expressions.length) {
            const expr = expressions[index++];
            const node = expr.node;
            if (!t.isStringLiteral(node, { value: "" })) {
              nodes.push(node);
            }
          }
        }
        // since `+` is left-to-right associative
        // ensure the first node is a string if first/second isn't
        const considerSecondNode = !loose || !t.isStringLiteral(nodes[1]);
        if (!t.isStringLiteral(nodes[0]) && considerSecondNode) {
          nodes.unshift(t.stringLiteral(""));
        }
        let root = nodes[0];
        if (loose) {
          for (let i = 1; i < nodes.length; i++) {
            root = t.binaryExpression("+", root, nodes[i]);
          }
        } else if (nodes.length > 1) {
          root = buildConcatCallExressions(nodes);
        }
        path.replaceWith(root);
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-template-literals/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-proposal-json-strings/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import syntaxJsonStrings from "@babel/plugin-syntax-json-strings";
export default declare(api => {
  api.assertVersion(7);
  const regex = /(\\*)([\u2028\u2029])/g;
  function replace(match, escapes, separator) {
    // If there's an odd number, that means the separator itself was escaped.
    // "\X" escapes X.
    // "\\X" escapes the backslash, so X is unescaped.
    const isEscaped = escapes.length % 2 === 1;
    if (isEscaped) return match;
    return `${escapes}\\u${separator.charCodeAt(0).toString(16)}`;
  }
  return {
    inherits: syntaxJsonStrings,
    visitor: {
      "DirectiveLiteral|StringLiteral"({ node }) {
        const { extra } = node;
        if (!extra || !extra.raw) return;
        extra.raw = extra.raw.replace(regex, replace);
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-proposal-json-strings/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-syntax-export-namespace-from/src/index.js

import { declare } from "@babel/helper-plugin-utils";
export default declare(api => {
  api.assertVersion(7);
  return {
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("exportNamespaceFrom");
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-syntax-export-namespace-from/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-proposal-function-sent/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import syntaxFunctionSent from "@babel/plugin-syntax-function-sent";
import wrapFunction from "@babel/helper-wrap-function";
import { types as t } from "@babel/core";
export default declare(api => {
  api.assertVersion(7);
  const isFunctionSent = node =>
    t.isIdentifier(node.meta, { name: "function" }) &&
    t.isIdentifier(node.property, { name: "sent" });
  const hasBeenReplaced = (node, sentId) =>
    t.isAssignmentExpression(node) &&
    t.isIdentifier(node.left, { name: sentId });
  const yieldVisitor = {
    Function(path) {
      path.skip();
    },
    YieldExpression(path) {
      if (!hasBeenReplaced(path.parent, this.sentId)) {
        path.replaceWith(
          t.assignmentExpression("=", t.identifier(this.sentId), path.node),
        );
      }
    },
    MetaProperty(path) {
      if (isFunctionSent(path.node)) {
        path.replaceWith(t.identifier(this.sentId));
      }
    },
  };
  return {
    inherits: syntaxFunctionSent,
    visitor: {
      MetaProperty(path, state) {
        if (!isFunctionSent(path.node)) return;
        const fnPath = path.getFunctionParent();
        if (!fnPath.node.generator) {
          throw new Error("Parent generator function not found");
        }
        const sentId = path.scope.generateUid("function.sent");
        fnPath.traverse(yieldVisitor, { sentId });
        fnPath.node.body.body.unshift(
          t.variableDeclaration("let", [
            t.variableDeclarator(t.identifier(sentId), t.yieldExpression()),
          ]),
        );
        wrapFunction(fnPath, state.addHelper("skipFirstGeneratorNext"));
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-proposal-function-sent/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-typescript/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import syntaxTypeScript from "@babel/plugin-syntax-typescript";
import { types as t } from "@babel/core";
import transpileEnum from "./enum";
function isInType(path) {
  switch (path.parent.type) {
    case "TSTypeReference":
    case "TSQualifiedName":
    case "TSExpressionWithTypeArguments":
    case "TSTypeQuery":
      return true;
    default:
      return false;
  }
}
interface State {
  programPath: any;
}
const PARSED_PARAMS = new WeakSet();
export default declare((api, { jsxPragma = "React" }) => {
  api.assertVersion(7);
  return {
    inherits: syntaxTypeScript,
    visitor: {
      //"Pattern" alias doesn't include Identifier or RestElement.
      Pattern: visitPattern,
      Identifier: visitPattern,
      RestElement: visitPattern,
      Program(path, state: State) {
        state.programPath = path;
        // remove type imports
        for (const stmt of path.get("body")) {
          if (t.isImportDeclaration(stmt)) {
            // Note: this will allow both `import { } from "m"` and `import "m";`.
            // In TypeScript, the former would be elided.
            if (stmt.node.specifiers.length === 0) {
              continue;
            }
            let allElided = true;
            const importsToRemove: Path<Node>[] = [];
            for (const specifier of stmt.node.specifiers) {
              const binding = stmt.scope.getBinding(specifier.local.name);
              // The binding may not exist if the import node was explicitly
              // injected by another plugin. Currently core does not do a good job
              // of keeping scope bindings synchronized with the AST. For now we
              // just bail if there is no binding, since chances are good that if
              // the import statement was injected then it wasn't a typescript type
              // import anyway.
              if (binding && isImportTypeOnly(binding, state.programPath)) {
                importsToRemove.push(binding.path);
              } else {
                allElided = false;
              }
            }
            if (allElided) {
              stmt.remove();
            } else {
              for (const importPath of importsToRemove) {
                importPath.remove();
              }
            }
          }
        }
      },
      TSDeclareFunction(path) {
        path.remove();
      },
      TSDeclareMethod(path) {
        path.remove();
      },
      VariableDeclaration(path) {
        if (path.node.declare) path.remove();
      },
      VariableDeclarator({ node }) {
        if (node.definite) node.definite = null;
      },
      ClassMethod(path) {
        const { node } = path;
        if (node.accessibility) node.accessibility = null;
        if (node.abstract) node.abstract = null;
        if (node.optional) node.optional = null;
        // Rest handled by Function visitor
      },
      ClassProperty(path) {
        const { node } = path;
        if (node.accessibility) node.accessibility = null;
        if (node.abstract) node.abstract = null;
        if (node.readonly) node.readonly = null;
        if (node.optional) node.optional = null;
        if (node.definite) node.definite = null;
        if (node.typeAnnotation) node.typeAnnotation = null;
      },
      TSIndexSignature(path) {
        path.remove();
      },
      ClassDeclaration(path) {
        const { node } = path;
        if (node.declare) {
          path.remove();
          return;
        }
        if (node.abstract) node.abstract = null;
      },
      Class(path) {
        const { node } = path;
        if (node.typeParameters) node.typeParameters = null;
        if (node.superTypeParameters) node.superTypeParameters = null;
        if (node.implements) node.implements = null;
        // Similar to the logic in `transform-flow-strip-types`, we need to
        // handle `TSParameterProperty` and `ClassProperty` here because the
        // class transform would transform the class, causing more specific
        // visitors to not run.
        path.get("body.body").forEach(child => {
          const childNode = child.node;
          if (t.isClassMethod(childNode, { kind: "constructor" })) {
            // Collects parameter properties so that we can add an assignment
            // for each of them in the constructor body
            //
            // We use a WeakSet to ensure an assignment for a parameter
            // property is only added once. This is necessary for cases like
            // using `transform-classes`, which causes this visitor to run
            // twice.
            const parameterProperties = [];
            for (const param of childNode.params) {
              if (
                param.type === "TSParameterProperty" &&
                !PARSED_PARAMS.has(param.parameter)
              ) {
                PARSED_PARAMS.add(param.parameter);
                parameterProperties.push(param.parameter);
              }
            }
            if (parameterProperties.length) {
              const assigns = parameterProperties.map(p => {
                let name;
                if (t.isIdentifier(p)) {
                  name = p.name;
                } else if (t.isAssignmentPattern(p) && t.isIdentifier(p.left)) {
                  name = p.left.name;
                } else {
                  throw path.buildCodeFrameError(
                    "Parameter properties can not be destructuring patterns.",
                  );
                }
                const assign = t.assignmentExpression(
                  "=",
                  t.memberExpression(t.thisExpression(), t.identifier(name)),
                  t.identifier(name),
                );
                return t.expressionStatement(assign);
              });
              const statements = childNode.body.body;
              const first = statements[0];
              const startsWithSuperCall =
                first !== undefined &&
                t.isExpressionStatement(first) &&
                t.isCallExpression(first.expression) &&
                t.isSuper(first.expression.callee);
              // Make sure to put parameter properties *after* the `super`
              // call. TypeScript will enforce that a 'super()' call is the
              // first statement when there are parameter properties.
              childNode.body.body = startsWithSuperCall
                ? [first, ...assigns, ...statements.slice(1)]
                : [...assigns, ...statements];
            }
          } else if (child.isClassProperty()) {
            childNode.typeAnnotation = null;
            if (!childNode.value && !childNode.decorators) {
              child.remove();
            }
          }
        });
      },
      Function({ node }) {
        if (node.typeParameters) node.typeParameters = null;
        if (node.returnType) node.returnType = null;
        const p0 = node.params[0];
        if (p0 && t.isIdentifier(p0) && p0.name === "this") {
          node.params.shift();
        }
        // We replace `TSParameterProperty` here so that transforms that
        // rely on a `Function` visitor to deal with arguments, like
        // `transform-parameters`, work properly.
        node.params = node.params.map(p => {
          return p.type === "TSParameterProperty" ? p.parameter : p;
        });
      },
      TSModuleDeclaration(path) {
        if (!path.node.declare && path.node.id.type !== "StringLiteral") {
          throw path.buildCodeFrameError("Namespaces are not supported.");
        }
        path.remove();
      },
      TSInterfaceDeclaration(path) {
        path.remove();
      },
      TSTypeAliasDeclaration(path) {
        path.remove();
      },
      TSEnumDeclaration(path) {
        transpileEnum(path, t);
      },
      TSImportEqualsDeclaration(path) {
        throw path.buildCodeFrameError(
          "`import =` is not supported by @babel/plugin-transform-typescript\n" +
            "Please consider using " +
            "`import <moduleName> from '<moduleName>';` alongside " +
            "Typescript's --allowSyntheticDefaultImports option.",
        );
      },
      TSExportAssignment(path) {
        throw path.buildCodeFrameError(
          "`export =` is not supported by @babel/plugin-transform-typescript\n" +
            "Please consider using `export <value>;`.",
        );
      },
      TSTypeAssertion(path) {
        path.replaceWith(path.node.expression);
      },
      TSAsExpression(path) {
        let { node } = path;
        do {
          node = node.expression;
        } while (t.isTSAsExpression(node));
        path.replaceWith(node);
      },
      TSNonNullExpression(path) {
        path.replaceWith(path.node.expression);
      },
      CallExpression(path) {
        path.node.typeParameters = null;
      },
      NewExpression(path) {
        path.node.typeParameters = null;
      },
      JSXOpeningElement(path) {
        path.node.typeParameters = null;
      },
      TaggedTemplateExpression(path) {
        path.node.typeParameters = null;
      },
    },
  };
  function visitPattern({ node }) {
    if (node.typeAnnotation) node.typeAnnotation = null;
    if (t.isIdentifier(node) && node.optional) node.optional = null;
    // 'access' and 'readonly' are only for parameter properties, so constructor visitor will handle them.
  }
  function isImportTypeOnly(binding, programPath) {
    for (const path of binding.referencePaths) {
      if (!isInType(path)) {
        return false;
      }
    }
    if (binding.identifier.name !== jsxPragma) {
      return true;
    }
    // "React" or the JSX pragma is referenced as a value if there are any JSX elements in the code.
    let sourceFileHasJsx = false;
    programPath.traverse({
      JSXElement() {
        sourceFileHasJsx = true;
      },
      JSXFragment() {
        sourceFileHasJsx = true;
      },
    });
    return !sourceFileHasJsx;
  }
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-typescript/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-typescript/src/enum.js

import assert from "assert";
import { template } from "@babel/core";
export default function transpileEnum(path, t) {
  const { node } = path;
  if (node.declare) {
    path.remove();
    return;
  }
  if (node.const) {
    throw path.buildCodeFrameError("'const' enums are not supported.");
  }
  const name = node.id.name;
  const fill = enumFill(path, t, node.id);
  switch (path.parent.type) {
    case "BlockStatement":
    case "ExportNamedDeclaration":
    case "Program": {
      path.insertAfter(fill);
      if (seen(path.parentPath)) {
        path.remove();
      } else {
        const isGlobal = t.isProgram(path.parent); // && !path.parent.body.some(t.isModuleDeclaration);
        path.replaceWith(makeVar(node.id, t, isGlobal ? "var" : "let"));
      }
      break;
    }
    default:
      throw new Error(`Unexpected enum parent '${path.parent.type}`);
  }
  function seen(parentPath: Path<Node>) {
    if (parentPath.isExportDeclaration()) {
      return seen(parentPath.parentPath);
    }
    if (parentPath.getData(name)) {
      return true;
    } else {
      parentPath.setData(name, true);
      return false;
    }
  }
}
function makeVar(id, t, kind): VariableDeclaration {
  return t.variableDeclaration(kind, [t.variableDeclarator(id)]);
}
const buildEnumWrapper = template(`
  (function (ID) {
    ASSIGNMENTS;
  })(ID || (ID = {}));
`);
const buildStringAssignment = template(`
  ENUM["NAME"] = VALUE;
`);
const buildNumericAssignment = template(`
  ENUM[ENUM["NAME"] = VALUE] = "NAME";
`);
const buildEnumMember = (isString, options) =>
  (isString ? buildStringAssignment : buildNumericAssignment)(options);
/**
 * Generates the statement that fills in the variable declared by the enum.
 * `(function (E) { ... assignments ... })(E || (E = {}));`
 */
function enumFill(path, t, id) {
  const x = translateEnumValues(path, t);
  const assignments = x.map(([memberName, memberValue]) =>
    buildEnumMember(t.isStringLiteral(memberValue), {
      ENUM: t.cloneNode(id),
      NAME: memberName,
      VALUE: memberValue,
    }),
  );
  return buildEnumWrapper({
    ID: t.cloneNode(id),
    ASSIGNMENTS: assignments,
  });
}
/**
 * Maps the name of an enum member to its value.
 * We keep track of the previous enum members so you can write code like:
 *   enum E {
 *     X = 1 << 0,
 *     Y = 1 << 1,
 *     Z = X | Y,
 *   }
 */
type PreviousEnumMembers = { [name: string]: number | string };
function translateEnumValues(path, t) {
  const seen: PreviousEnumMembers = Object.create(null);
  // Start at -1 so the first enum member is its increment, 0.
  let prev: number | typeof undefined = -1;
  return path.node.members.map(member => {
    const name = t.isIdentifier(member.id) ? member.id.name : member.id.value;
    const initializer = member.initializer;
    let value: Expression;
    if (initializer) {
      const constValue = evaluate(initializer, seen);
      if (constValue !== undefined) {
        seen[name] = constValue;
        if (typeof constValue === "number") {
          value = t.numericLiteral(constValue);
          prev = constValue;
        } else {
          assert(typeof constValue === "string");
          value = t.stringLiteral(constValue);
          prev = undefined;
        }
      } else {
        value = initializer;
        prev = undefined;
      }
    } else {
      if (prev !== undefined) {
        prev++;
        value = t.numericLiteral(prev);
        seen[name] = prev;
      } else {
        throw path.buildCodeFrameError("Enum member must have initializer.");
      }
    }
    return [name, value];
  });
}
// Based on the TypeScript repository's `evalConstant` in `checker.ts`.
function evaluate(
  expr,
  seen: PreviousEnumMembers,
): number | string | typeof undefined {
  if (expr.type === "StringLiteral") {
    return expr.value;
  }
  return evalConstant(expr);
  function evalConstant(expr): number | typeof undefined {
    switch (expr.type) {
      case "UnaryExpression":
        return evalUnaryExpression(expr);
      case "BinaryExpression":
        return evalBinaryExpression(expr);
      case "NumericLiteral":
        return expr.value;
      case "ParenthesizedExpression":
        return evalConstant(expr.expression);
      case "Identifier":
        return seen[expr.name];
      default:
        return undefined;
    }
  }
  function evalUnaryExpression({
    argument,
    operator,
  }): number | typeof undefined {
    const value = evalConstant(argument);
    if (value === undefined) {
      return undefined;
    }
    switch (operator) {
      case "+":
        return value;
      case "-":
        return -value;
      case "~":
        return ~value;
      default:
        return undefined;
    }
  }
  function evalBinaryExpression(expr): number | typeof undefined {
    const left = evalConstant(expr.left);
    if (left === undefined) {
      return undefined;
    }
    const right = evalConstant(expr.right);
    if (right === undefined) {
      return undefined;
    }
    switch (expr.operator) {
      case "|":
        return left | right;
      case "&":
        return left & right;
      case ">>":
        return left >> right;
      case ">>>":
        return left >>> right;
      case "<<":
        return left << right;
      case "^":
        return left ^ right;
      case "*":
        return left * right;
      case "/":
        return left / right;
      case "+":
        return left + right;
      case "-":
        return left - right;
      case "%":
        return left % right;
      default:
        return undefined;
    }
  }
}

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-typescript/src/enum.js

// <from> /home/qfox/apps/babel/packages/babel-traverse/src/scope/index.js

import includes from "lodash/includes";
import repeat from "lodash/repeat";
import Renamer from "./lib/renamer";
import traverse from "../index";
import defaults from "lodash/defaults";
import Binding from "./binding";
import globals from "globals";
import * as t from "@babel/types";
import { scope as scopeCache } from "../cache";
// Recursively gathers the identifying names of a node.
function gatherNodeParts(node: Object, parts: Array) {
  if (t.isModuleDeclaration(node)) {
    if (node.source) {
      gatherNodeParts(node.source, parts);
    } else if (node.specifiers && node.specifiers.length) {
      for (const specifier of (node.specifiers: Array)) {
        gatherNodeParts(specifier, parts);
      }
    } else if (node.declaration) {
      gatherNodeParts(node.declaration, parts);
    }
  } else if (t.isModuleSpecifier(node)) {
    gatherNodeParts(node.local, parts);
  } else if (t.isMemberExpression(node)) {
    gatherNodeParts(node.object, parts);
    gatherNodeParts(node.property, parts);
  } else if (t.isIdentifier(node)) {
    parts.push(node.name);
  } else if (t.isLiteral(node)) {
    parts.push(node.value);
  } else if (t.isCallExpression(node)) {
    gatherNodeParts(node.callee, parts);
  } else if (t.isObjectExpression(node) || t.isObjectPattern(node)) {
    for (const prop of (node.properties: Array)) {
      gatherNodeParts(prop.key || prop.argument, parts);
    }
  } else if (t.isPrivateName(node)) {
    gatherNodeParts(node.id, parts);
  } else if (t.isThisExpression(node)) {
    parts.push("this");
  } else if (t.isSuper(node)) {
    parts.push("super");
  }
}
//
const collectorVisitor = {
  For(path) {
    for (const key of (t.FOR_INIT_KEYS: Array)) {
      const declar = path.get(key);
      if (declar.isVar()) {
        const parentScope =
          path.scope.getFunctionParent() || path.scope.getProgramParent();
        parentScope.registerBinding("var", declar);
      }
    }
  },
  Declaration(path) {
    // delegate block scope handling to the `BlockScoped` method
    if (path.isBlockScoped()) return;
    // this will be hit again once we traverse into it after this iteration
    if (path.isExportDeclaration() && path.get("declaration").isDeclaration()) {
      return;
    }
    // we've ran into a declaration!
    const parent =
      path.scope.getFunctionParent() || path.scope.getProgramParent();
    parent.registerDeclaration(path);
  },
  ReferencedIdentifier(path, state) {
    state.references.push(path);
  },
  ForXStatement(path, state) {
    const left = path.get("left");
    if (left.isPattern() || left.isIdentifier()) {
      state.constantViolations.push(path);
    }
  },
  ExportDeclaration: {
    exit(path) {
      const { node, scope } = path;
      const declar = node.declaration;
      if (t.isClassDeclaration(declar) || t.isFunctionDeclaration(declar)) {
        const id = declar.id;
        if (!id) return;
        const binding = scope.getBinding(id.name);
        if (binding) binding.reference(path);
      } else if (t.isVariableDeclaration(declar)) {
        for (const decl of (declar.declarations: Array<Object>)) {
          const ids = t.getBindingIdentifiers(decl);
          for (const name in ids) {
            const binding = scope.getBinding(name);
            if (binding) binding.reference(path);
          }
        }
      }
    },
  },
  LabeledStatement(path) {
    path.scope.getProgramParent().addGlobal(path.node);
    path.scope.getBlockParent().registerDeclaration(path);
  },
  AssignmentExpression(path, state) {
    state.assignments.push(path);
  },
  UpdateExpression(path, state) {
    state.constantViolations.push(path);
  },
  UnaryExpression(path, state) {
    if (path.node.operator === "delete") {
      state.constantViolations.push(path);
    }
  },
  BlockScoped(path) {
    let scope = path.scope;
    if (scope.path === path) scope = scope.parent;
    scope.getBlockParent().registerDeclaration(path);
  },
  ClassDeclaration(path) {
    const id = path.node.id;
    if (!id) return;
    const name = id.name;
    path.scope.bindings[name] = path.scope.getBinding(name);
  },
  Block(path) {
    const paths = path.get("body");
    for (const bodyPath of (paths: Array)) {
      if (bodyPath.isFunctionDeclaration()) {
        path.scope.getBlockParent().registerDeclaration(bodyPath);
      }
    }
  },
};
let uid = 0;
export default class Scope {
  /**
   * This searches the current "scope" and collects all references/bindings
   * within.
   */
  constructor(path: NodePath) {
    const { node } = path;
    const cached = scopeCache.get(node);
    // Sometimes, a scopable path is placed higher in the AST tree.
    // In these cases, have to create a new Scope.
    if (cached && cached.path === path) {
      return cached;
    }
    scopeCache.set(node, this);
    this.uid = uid++;
    this.block = node;
    this.path = path;
    this.labels = new Map();
  }
  /**
   * Globals.
   */
  static globals = Object.keys(globals.builtin);
  /**
   * Variables available in current context.
   */
  static contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
  get parent() {
    const parent = this.path.findParent(p => p.isScope());
    return parent && parent.scope;
  }
  get parentBlock() {
    return this.path.parent;
  }
  get hub() {
    return this.path.hub;
  }
  /**
   * Traverse node with current scope and path.
   */
  traverse(node: Object, opts: Object, state?) {
    traverse(node, opts, this, state, this.path);
  }
  /**
   * Generate a unique identifier and add it to the current scope.
   */
  generateDeclaredUidIdentifier(name?: string) {
    const id = this.generateUidIdentifier(name);
    this.push({ id });
    return t.cloneNode(id);
  }
  /**
   * Generate a unique identifier.
   */
  generateUidIdentifier(name?: string) {
    return t.identifier(this.generateUid(name));
  }
  /**
   * Generate a unique `_id1` binding.
   */
  generateUid(name: string = "temp") {
    name = t
      .toIdentifier(name)
      .replace(/^_+/, "")
      .replace(/[0-9]+$/g, "");
    let uid;
    let i = 0;
    do {
      uid = this._generateUid(name, i);
      i++;
    } while (
      this.hasLabel(uid) ||
      this.hasBinding(uid) ||
      this.hasGlobal(uid) ||
      this.hasReference(uid)
    );
    const program = this.getProgramParent();
    program.references[uid] = true;
    program.uids[uid] = true;
    return uid;
  }
  /**
   * Generate an `_id1`.
   */
  _generateUid(name, i) {
    let id = name;
    if (i > 1) id += i;
    return `_${id}`;
  }
  generateUidBasedOnNode(parent: Object, defaultName?: String) {
    let node = parent;
    if (t.isAssignmentExpression(parent)) {
      node = parent.left;
    } else if (t.isVariableDeclarator(parent)) {
      node = parent.id;
    } else if (t.isObjectProperty(node) || t.isObjectMethod(node)) {
      node = node.key;
    }
    const parts = [];
    gatherNodeParts(node, parts);
    let id = parts.join("$");
    id = id.replace(/^_/, "") || defaultName || "ref";
    return this.generateUid(id.slice(0, 20));
  }
  /**
   * Generate a unique identifier based on a node.
   */
  generateUidIdentifierBasedOnNode(
    parent: Object,
    defaultName?: String,
  ): Object {
    return t.identifier(this.generateUidBasedOnNode(parent, defaultName));
  }
  /**
   * Determine whether evaluating the specific input `node` is a consequenceless reference. ie.
   * evaluating it wont result in potentially arbitrary code from being ran. The following are
   * whitelisted and determined not to cause side effects:
   *
   *  - `this` expressions
   *  - `super` expressions
   *  - Bound identifiers
   */
  isStatic(node: Object): boolean {
    if (t.isThisExpression(node) || t.isSuper(node)) {
      return true;
    }
    if (t.isIdentifier(node)) {
      const binding = this.getBinding(node.name);
      if (binding) {
        return binding.constant;
      } else {
        return this.hasBinding(node.name);
      }
    }
    return false;
  }
  /**
   * Possibly generate a memoised identifier if it is not static and has consequences.
   */
  maybeGenerateMemoised(node: Object, dontPush?: boolean): ?Object {
    if (this.isStatic(node)) {
      return null;
    } else {
      const id = this.generateUidIdentifierBasedOnNode(node);
      if (!dontPush) {
        this.push({ id });
        return t.cloneNode(id);
      }
      return id;
    }
  }
  checkBlockScopedCollisions(local, kind: string, name: string, id: Object) {
    // ignore parameters
    if (kind === "param") return;
    // Ignore existing binding if it's the name of the current function or
    // class expression
    if (local.kind === "local") return;
    // ignore hoisted functions if there's also a local let
    if (kind === "hoisted" && local.kind === "let") return;
    const duplicate =
      // don't allow duplicate bindings to exist alongside
      kind === "let" ||
      local.kind === "let" ||
      local.kind === "const" ||
      local.kind === "module" ||
      // don't allow a local of param with a kind of let
      (local.kind === "param" && (kind === "let" || kind === "const"));
    if (duplicate) {
      throw this.hub.buildError(
        id,
        `Duplicate declaration "${name}"`,
        TypeError,
      );
    }
  }
  rename(oldName: string, newName: string, block?) {
    const binding = this.getBinding(oldName);
    if (binding) {
      newName = newName || this.generateUidIdentifier(oldName).name;
      return new Renamer(binding, oldName, newName).rename(block);
    }
  }
  _renameFromMap(map, oldName, newName, value) {
    if (map[oldName]) {
      map[newName] = value;
      map[oldName] = null;
    }
  }
  dump() {
    const sep = repeat("-", 60);
    console.log(sep);
    let scope = this;
    do {
      console.log("#", scope.block.type);
      for (const name in scope.bindings) {
        const binding = scope.bindings[name];
        console.log(" -", name, {
          constant: binding.constant,
          references: binding.references,
          violations: binding.constantViolations.length,
          kind: binding.kind,
        });
      }
    } while ((scope = scope.parent));
    console.log(sep);
  }
  toArray(node: Object, i?: number) {
    if (t.isIdentifier(node)) {
      const binding = this.getBinding(node.name);
      if (binding && binding.constant && binding.path.isGenericType("Array")) {
        return node;
      }
    }
    if (t.isArrayExpression(node)) {
      return node;
    }
    if (t.isIdentifier(node, { name: "arguments" })) {
      return t.callExpression(
        t.memberExpression(
          t.memberExpression(
            t.memberExpression(
              t.identifier("Array"),
              t.identifier("prototype"),
            ),
            t.identifier("slice"),
          ),
          t.identifier("call"),
        ),
        [node],
      );
    }
    let helperName;
    const args = [node];
    if (i === true) {
      // Used in array-spread to create an array.
      helperName = "toConsumableArray";
    } else if (i) {
      args.push(t.numericLiteral(i));
      // Used in array-rest to create an array from a subset of an iterable.
      helperName = "slicedToArray";
      // TODO if (this.hub.isLoose("es6.forOf")) helperName += "-loose";
    } else {
      // Used in array-rest to create an array
      helperName = "toArray";
    }
    return t.callExpression(this.hub.addHelper(helperName), args);
  }
  hasLabel(name: string) {
    return !!this.getLabel(name);
  }
  getLabel(name: string) {
    return this.labels.get(name);
  }
  registerLabel(path: NodePath) {
    this.labels.set(path.node.label.name, path);
  }
  registerDeclaration(path: NodePath) {
    if (path.isLabeledStatement()) {
      this.registerLabel(path);
    } else if (path.isFunctionDeclaration()) {
      this.registerBinding("hoisted", path.get("id"), path);
    } else if (path.isVariableDeclaration()) {
      const declarations = path.get("declarations");
      for (const declar of (declarations: Array)) {
        this.registerBinding(path.node.kind, declar);
      }
    } else if (path.isClassDeclaration()) {
      this.registerBinding("let", path);
    } else if (path.isImportDeclaration()) {
      const specifiers = path.get("specifiers");
      for (const specifier of (specifiers: Array)) {
        this.registerBinding("module", specifier);
      }
    } else if (path.isExportDeclaration()) {
      const declar = path.get("declaration");
      if (
        declar.isClassDeclaration() ||
        declar.isFunctionDeclaration() ||
        declar.isVariableDeclaration()
      ) {
        this.registerDeclaration(declar);
      }
    } else {
      this.registerBinding("unknown", path);
    }
  }
  buildUndefinedNode() {
    if (this.hasBinding("undefined")) {
      return t.unaryExpression("void", t.numericLiteral(0), true);
    } else {
      return t.identifier("undefined");
    }
  }
  registerConstantViolation(path: NodePath) {
    const ids = path.getBindingIdentifiers();
    for (const name in ids) {
      const binding = this.getBinding(name);
      if (binding) binding.reassign(path);
    }
  }
  registerBinding(kind: string, path: NodePath, bindingPath = path) {
    if (!kind) throw new ReferenceError("no `kind`");
    if (path.isVariableDeclaration()) {
      const declarators: Array<NodePath> = path.get("declarations");
      for (const declar of declarators) {
        this.registerBinding(kind, declar);
      }
      return;
    }
    const parent = this.getProgramParent();
    const ids = path.getBindingIdentifiers(true);
    for (const name in ids) {
      for (const id of (ids[name]: Array<Object>)) {
        const local = this.getOwnBinding(name);
        if (local) {
          // same identifier so continue safely as we're likely trying to register it
          // multiple times
          if (local.identifier === id) continue;
          this.checkBlockScopedCollisions(local, kind, name, id);
        }
        parent.references[name] = true;
        // A redeclaration of an existing variable is a modification
        if (local) {
          this.registerConstantViolation(bindingPath);
        } else {
          this.bindings[name] = new Binding({
            identifier: id,
            scope: this,
            path: bindingPath,
            kind: kind,
          });
        }
      }
    }
  }
  addGlobal(node: Object) {
    this.globals[node.name] = node;
  }
  hasUid(name): boolean {
    let scope = this;
    do {
      if (scope.uids[name]) return true;
    } while ((scope = scope.parent));
    return false;
  }
  hasGlobal(name: string): boolean {
    let scope = this;
    do {
      if (scope.globals[name]) return true;
    } while ((scope = scope.parent));
    return false;
  }
  hasReference(name: string): boolean {
    let scope = this;
    do {
      if (scope.references[name]) return true;
    } while ((scope = scope.parent));
    return false;
  }
  isPure(node, constantsOnly?: boolean) {
    if (t.isIdentifier(node)) {
      const binding = this.getBinding(node.name);
      if (!binding) return false;
      if (constantsOnly) return binding.constant;
      return true;
    } else if (t.isClass(node)) {
      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {
        return false;
      }
      return this.isPure(node.body, constantsOnly);
    } else if (t.isClassBody(node)) {
      for (const method of node.body) {
        if (!this.isPure(method, constantsOnly)) return false;
      }
      return true;
    } else if (t.isBinary(node)) {
      return (
        this.isPure(node.left, constantsOnly) &&
        this.isPure(node.right, constantsOnly)
      );
    } else if (t.isArrayExpression(node)) {
      for (const elem of (node.elements: Array<Object>)) {
        if (!this.isPure(elem, constantsOnly)) return false;
      }
      return true;
    } else if (t.isObjectExpression(node)) {
      for (const prop of (node.properties: Array<Object>)) {
        if (!this.isPure(prop, constantsOnly)) return false;
      }
      return true;
    } else if (t.isClassMethod(node)) {
      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;
      if (node.kind === "get" || node.kind === "set") return false;
      return true;
    } else if (t.isProperty(node)) {
      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;
      return this.isPure(node.value, constantsOnly);
    } else if (t.isUnaryExpression(node)) {
      return this.isPure(node.argument, constantsOnly);
    } else if (t.isTaggedTemplateExpression(node)) {
      return (
        t.matchesPattern(node.tag, "String.raw") &&
        !this.hasBinding("String", true) &&
        this.isPure(node.quasi, constantsOnly)
      );
    } else if (t.isTemplateLiteral(node)) {
      for (const expression of (node.expressions: Array<Object>)) {
        if (!this.isPure(expression, constantsOnly)) return false;
      }
      return true;
    } else {
      return t.isPureish(node);
    }
  }
  /**
   * Set some arbitrary data on the current scope.
   */
  setData(key, val) {
    return (this.data[key] = val);
  }
  /**
   * Recursively walk up scope tree looking for the data `key`.
   */
  getData(key) {
    let scope = this;
    do {
      const data = scope.data[key];
      if (data != null) return data;
    } while ((scope = scope.parent));
  }
  /**
   * Recursively walk up scope tree looking for the data `key` and if it exists,
   * remove it.
   */
  removeData(key) {
    let scope = this;
    do {
      const data = scope.data[key];
      if (data != null) scope.data[key] = null;
    } while ((scope = scope.parent));
  }
  init() {
    if (!this.references) this.crawl();
  }
  crawl() {
    const path = this.path;
    this.references = Object.create(null);
    this.bindings = Object.create(null);
    this.globals = Object.create(null);
    this.uids = Object.create(null);
    this.data = Object.create(null);
    // ForStatement - left, init
    if (path.isLoop()) {
      for (const key of (t.FOR_INIT_KEYS: Array<string>)) {
        const node = path.get(key);
        if (node.isBlockScoped()) this.registerBinding(node.node.kind, node);
      }
    }
    // FunctionExpression - id
    if (path.isFunctionExpression() && path.has("id")) {
      if (!path.get("id").node[t.NOT_LOCAL_BINDING]) {
        this.registerBinding("local", path.get("id"), path);
      }
    }
    // Class
    if (path.isClassExpression() && path.has("id")) {
      if (!path.get("id").node[t.NOT_LOCAL_BINDING]) {
        this.registerBinding("local", path);
      }
    }
    // Function - params, rest
    if (path.isFunction()) {
      const params: Array<NodePath> = path.get("params");
      for (const param of params) {
        this.registerBinding("param", param);
      }
    }
    // CatchClause - param
    if (path.isCatchClause()) {
      this.registerBinding("let", path);
    }
    // Program
    const parent = this.getProgramParent();
    if (parent.crawling) return;
    const state = {
      references: [],
      constantViolations: [],
      assignments: [],
    };
    this.crawling = true;
    path.traverse(collectorVisitor, state);
    this.crawling = false;
    // register assignments
    for (const path of state.assignments) {
      // register undeclared bindings as globals
      const ids = path.getBindingIdentifiers();
      let programParent;
      for (const name in ids) {
        if (path.scope.getBinding(name)) continue;
        programParent = programParent || path.scope.getProgramParent();
        programParent.addGlobal(ids[name]);
      }
      // register as constant violation
      path.scope.registerConstantViolation(path);
    }
    // register references
    for (const ref of state.references) {
      const binding = ref.scope.getBinding(ref.node.name);
      if (binding) {
        binding.reference(ref);
      } else {
        ref.scope.getProgramParent().addGlobal(ref.node);
      }
    }
    // register constant violations
    for (const path of state.constantViolations) {
      path.scope.registerConstantViolation(path);
    }
  }
  push(opts: {
    id: Object,
    init: ?Object,
    unique: ?boolean,
    _blockHoist: ?number,
    kind: "var" | "let",
  }) {
    let path = this.path;
    if (!path.isBlockStatement() && !path.isProgram()) {
      path = this.getBlockParent().path;
    }
    if (path.isSwitchStatement()) {
      path = (this.getFunctionParent() || this.getProgramParent()).path;
    }
    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {
      path.ensureBlock();
      path = path.get("body");
    }
    const unique = opts.unique;
    const kind = opts.kind || "var";
    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;
    const dataKey = `declaration:${kind}:${blockHoist}`;
    let declarPath = !unique && path.getData(dataKey);
    if (!declarPath) {
      const declar = t.variableDeclaration(kind, []);
      declar._blockHoist = blockHoist;
      [declarPath] = path.unshiftContainer("body", [declar]);
      if (!unique) path.setData(dataKey, declarPath);
    }
    const declarator = t.variableDeclarator(opts.id, opts.init);
    declarPath.node.declarations.push(declarator);
    this.registerBinding(kind, declarPath.get("declarations").pop());
  }
  /**
   * Walk up to the top of the scope tree and get the `Program`.
   */
  getProgramParent() {
    let scope = this;
    do {
      if (scope.path.isProgram()) {
        return scope;
      }
    } while ((scope = scope.parent));
    throw new Error("Couldn't find a Program");
  }
  /**
   * Walk up the scope tree until we hit either a Function or return null.
   */
  getFunctionParent() {
    let scope = this;
    do {
      if (scope.path.isFunctionParent()) {
        return scope;
      }
    } while ((scope = scope.parent));
    return null;
  }
  /**
   * Walk up the scope tree until we hit either a BlockStatement/Loop/Program/Function/Switch or reach the
   * very top and hit Program.
   */
  getBlockParent() {
    let scope = this;
    do {
      if (scope.path.isBlockParent()) {
        return scope;
      }
    } while ((scope = scope.parent));
    throw new Error(
      "We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...",
    );
  }
  /**
   * Walks the scope tree and gathers **all** bindings.
   */
  getAllBindings(): Object {
    const ids = Object.create(null);
    let scope = this;
    do {
      defaults(ids, scope.bindings);
      scope = scope.parent;
    } while (scope);
    return ids;
  }
  /**
   * Walks the scope tree and gathers all declarations of `kind`.
   */
  getAllBindingsOfKind(): Object {
    const ids = Object.create(null);
    for (const kind of (arguments: Array)) {
      let scope = this;
      do {
        for (const name in scope.bindings) {
          const binding = scope.bindings[name];
          if (binding.kind === kind) ids[name] = binding;
        }
        scope = scope.parent;
      } while (scope);
    }
    return ids;
  }
  bindingIdentifierEquals(name: string, node: Object): boolean {
    return this.getBindingIdentifier(name) === node;
  }
  getBinding(name: string) {
    let scope = this;
    do {
      const binding = scope.getOwnBinding(name);
      if (binding) return binding;
    } while ((scope = scope.parent));
  }
  getOwnBinding(name: string) {
    return this.bindings[name];
  }
  getBindingIdentifier(name: string) {
    const info = this.getBinding(name);
    return info && info.identifier;
  }
  getOwnBindingIdentifier(name: string) {
    const binding = this.bindings[name];
    return binding && binding.identifier;
  }
  hasOwnBinding(name: string) {
    return !!this.getOwnBinding(name);
  }
  hasBinding(name: string, noGlobals?) {
    if (!name) return false;
    if (this.hasOwnBinding(name)) return true;
    if (this.parentHasBinding(name, noGlobals)) return true;
    if (this.hasUid(name)) return true;
    if (!noGlobals && includes(Scope.globals, name)) return true;
    if (!noGlobals && includes(Scope.contextVariables, name)) return true;
    return false;
  }
  parentHasBinding(name: string, noGlobals?) {
    return this.parent && this.parent.hasBinding(name, noGlobals);
  }
  /**
   * Move a binding of `name` to another `scope`.
   */
  moveBindingTo(name, scope) {
    const info = this.getBinding(name);
    if (info) {
      info.scope.removeOwnBinding(name);
      info.scope = scope;
      scope.bindings[name] = info;
    }
  }
  removeOwnBinding(name: string) {
    delete this.bindings[name];
  }
  removeBinding(name: string) {
    // clear literal binding
    const info = this.getBinding(name);
    if (info) {
      info.scope.removeOwnBinding(name);
    }
    // clear uids with this name - https://github.com/babel/babel/issues/2101
    let scope = this;
    do {
      if (scope.uids[name]) {
        scope.uids[name] = false;
      }
    } while ((scope = scope.parent));
  }
}

// </from> /home/qfox/apps/babel/packages/babel-traverse/src/scope/index.js

// <from> /home/qfox/apps/babel/packages/babel-traverse/src/scope/binding.js

/**
 * This class is responsible for a binding inside of a scope.
 *
 * It tracks the following:
 *
 *  * Node path.
 *  * Amount of times referenced by other nodes.
 *  * Paths to nodes that reassign or modify this binding.
 *  * The kind of binding. (Is it a parameter, declaration etc)
 */
export default class Binding {
  constructor({ identifier, scope, path, kind }) {
    this.identifier = identifier;
    this.scope = scope;
    this.path = path;
    this.kind = kind;
    this.constantViolations = [];
    this.constant = true;
    this.referencePaths = [];
    this.referenced = false;
    this.references = 0;
    this.clearValue();
  }
  constantViolations: Array<NodePath>;
  constant: boolean;
  referencePaths: Array<NodePath>;
  referenced: boolean;
  references: number;
  hasDeoptedValue: boolean;
  hasValue: boolean;
  value: any;
  deoptValue() {
    this.clearValue();
    this.hasDeoptedValue = true;
  }
  setValue(value: any) {
    if (this.hasDeoptedValue) return;
    this.hasValue = true;
    this.value = value;
  }
  clearValue() {
    this.hasDeoptedValue = false;
    this.hasValue = false;
    this.value = null;
  }
  /**
   * Register a constant violation with the provided `path`.
   */
  reassign(path: Object) {
    this.constant = false;
    if (this.constantViolations.indexOf(path) !== -1) {
      return;
    }
    this.constantViolations.push(path);
  }
  /**
   * Increment the amount of references to this binding.
   */
  reference(path: NodePath) {
    if (this.referencePaths.indexOf(path) !== -1) {
      return;
    }
    this.referenced = true;
    this.references++;
    this.referencePaths.push(path);
  }
  /**
   * Decrement the amount of references to this binding.
   */
  dereference() {
    this.references--;
    this.referenced = !!this.references;
  }
}

// </from> /home/qfox/apps/babel/packages/babel-traverse/src/scope/binding.js

// <from> /home/qfox/apps/babel/packages/babel-traverse/src/scope/lib/renamer.js

import Binding from "../binding";
import splitExportDeclaration from "@babel/helper-split-export-declaration";
import * as t from "@babel/types";
const renameVisitor = {
  ReferencedIdentifier({ node }, state) {
    if (node.name === state.oldName) {
      node.name = state.newName;
    }
  },
  Scope(path, state) {
    if (
      !path.scope.bindingIdentifierEquals(
        state.oldName,
        state.binding.identifier,
      )
    ) {
      path.skip();
    }
  },
  "AssignmentExpression|Declaration"(path, state) {
    const ids = path.getOuterBindingIdentifiers();
    for (const name in ids) {
      if (name === state.oldName) ids[name].name = state.newName;
    }
  },
};
export default class Renamer {
  constructor(binding: Binding, oldName: string, newName: string) {
    this.newName = newName;
    this.oldName = oldName;
    this.binding = binding;
  }
  oldName: string;
  newName: string;
  binding: Binding;
  maybeConvertFromExportDeclaration(parentDeclar) {
    const maybeExportDeclar = parentDeclar.parentPath;
    if (!maybeExportDeclar.isExportDeclaration()) {
      return;
    }
    if (
      maybeExportDeclar.isExportDefaultDeclaration() &&
      !maybeExportDeclar.get("declaration").node.id
    ) {
      return;
    }
    splitExportDeclaration(maybeExportDeclar);
  }
  maybeConvertFromClassFunctionDeclaration(path) {
    return; // TODO
    // retain the `name` of a class/function declaration
    if (!path.isFunctionDeclaration() && !path.isClassDeclaration()) return;
    if (this.binding.kind !== "hoisted") return;
    path.node.id = t.identifier(this.oldName);
    path.node._blockHoist = 3;
    path.replaceWith(
      t.variableDeclaration("let", [
        t.variableDeclarator(
          t.identifier(this.newName),
          t.toExpression(path.node),
        ),
      ]),
    );
  }
  maybeConvertFromClassFunctionExpression(path) {
    return; // TODO
    // retain the `name` of a class/function expression
    if (!path.isFunctionExpression() && !path.isClassExpression()) return;
    if (this.binding.kind !== "local") return;
    path.node.id = t.identifier(this.oldName);
    this.binding.scope.parent.push({
      id: t.identifier(this.newName),
    });
    path.replaceWith(
      t.assignmentExpression("=", t.identifier(this.newName), path.node),
    );
  }
  rename(block?) {
    const { binding, oldName, newName } = this;
    const { scope, path } = binding;
    const parentDeclar = path.find(
      path =>
        path.isDeclaration() ||
        path.isFunctionExpression() ||
        path.isClassExpression(),
    );
    if (parentDeclar) {
      const bindingIds = parentDeclar.getOuterBindingIdentifiers();
      if (bindingIds[oldName] === binding.identifier) {
        // When we are renaming an exported identifier, we need to ensure that
        // the exported binding keeps the old name.
        this.maybeConvertFromExportDeclaration(parentDeclar);
      }
    }
    scope.traverse(block || scope.block, renameVisitor, this);
    if (!block) {
      scope.removeOwnBinding(oldName);
      scope.bindings[newName] = binding;
      this.binding.identifier.name = newName;
    }
    if (binding.type === "hoisted") {
      // https://github.com/babel/babel/issues/2435
      // todo: hoist and convert function to a let
    }
    if (parentDeclar) {
      this.maybeConvertFromClassFunctionDeclaration(parentDeclar);
      this.maybeConvertFromClassFunctionExpression(parentDeclar);
    }
  }
}

// </from> /home/qfox/apps/babel/packages/babel-traverse/src/scope/lib/renamer.js

// <from> /home/qfox/apps/babel/packages/babel-traverse/src/index.js

import TraversalContext from "./context";
import * as visitors from "./visitors";
import includes from "lodash/includes";
import * as t from "@babel/types";
import * as cache from "./cache";
export { default as NodePath } from "./path";
export { default as Scope } from "./scope";
export { default as Hub } from "./hub";
export type { HubInterface } from "./hub";
export { visitors };
export default function traverse(
  parent: Object | Array<Object>,
  opts?: Object,
  scope?: Object,
  state: Object,
  parentPath: Object,
) {
  if (!parent) return;
  if (!opts) opts = {};
  if (!opts.noScope && !scope) {
    if (parent.type !== "Program" && parent.type !== "File") {
      throw new Error(
        "You must pass a scope and parentPath unless traversing a Program/File. " +
          `Instead of that you tried to traverse a ${
            parent.type
          } node without ` +
          "passing scope and parentPath.",
      );
    }
  }
  visitors.explode(opts);
  traverse.node(parent, opts, scope, state, parentPath);
}
traverse.visitors = visitors;
traverse.verify = visitors.verify;
traverse.explode = visitors.explode;
traverse.cheap = function(node, enter) {
  return t.traverseFast(node, enter);
};
traverse.node = function(
  node: Object,
  opts: Object,
  scope: Object,
  state: Object,
  parentPath: Object,
  skipKeys?,
) {
  const keys: Array = t.VISITOR_KEYS[node.type];
  if (!keys) return;
  const context = new TraversalContext(scope, opts, state, parentPath);
  for (const key of keys) {
    if (skipKeys && skipKeys[key]) continue;
    if (context.visit(node, key)) return;
  }
};
traverse.clearNode = function(node, opts) {
  t.removeProperties(node, opts);
  cache.path.delete(node);
};
traverse.removeProperties = function(tree, opts) {
  t.traverseFast(tree, traverse.clearNode, opts);
  return tree;
};
function hasBlacklistedType(path, state) {
  if (path.node.type === state.type) {
    state.has = true;
    path.stop();
  }
}
traverse.hasType = function(
  tree: Object,
  type: Object,
  blacklistTypes: Array<string>,
): boolean {
  // the node we're searching in is blacklisted
  if (includes(blacklistTypes, tree.type)) return false;
  // the type we're looking for is the same as the passed node
  if (tree.type === type) return true;
  const state = {
    has: false,
    type: type,
  };
  traverse(
    tree,
    {
      noScope: true,
      blacklist: blacklistTypes,
      enter: hasBlacklistedType,
    },
    null,
    state,
  );
  return state.has;
};
traverse.cache = cache;

// </from> /home/qfox/apps/babel/packages/babel-traverse/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-traverse/src/hub.js

export interface HubInterface {
  getCode(): ?string;
  getScope(): ?Scope;
  addHelper(name: string): Object;
  buildError(node: Object, msg: string, Error: Class<Error>): Error;
}
export default class Hub implements HubInterface {
  getCode() {}
  getScope() {}
  addHelper() {
    throw new Error("Helpers are not supported by the default hub.");
  }
  buildError(node, msg, Error = TypeError): Error {
    return new Error(msg);
  }
}

// </from> /home/qfox/apps/babel/packages/babel-traverse/src/hub.js

// <from> /home/qfox/apps/babel/packages/babel-traverse/src/context.js

import NodePath from "./path";
import * as t from "@babel/types";
const testing = process.env.NODE_ENV === "test";
export default class TraversalContext {
  constructor(scope, opts, state, parentPath) {
    this.parentPath = parentPath;
    this.scope = scope;
    this.state = state;
    this.opts = opts;
  }
  parentPath: NodePath;
  scope;
  state;
  opts;
  queue: ?Array<NodePath> = null;
  /**
   * This method does a simple check to determine whether or not we really need to attempt
   * visit a node. This will prevent us from constructing a NodePath.
   */
  shouldVisit(node): boolean {
    const opts = this.opts;
    if (opts.enter || opts.exit) return true;
    // check if we have a visitor for this node
    if (opts[node.type]) return true;
    // check if we're going to traverse into this node
    const keys: ?Array<string> = t.VISITOR_KEYS[node.type];
    if (!keys || !keys.length) return false;
    // we need to traverse into this node so ensure that it has children to traverse into!
    for (const key of keys) {
      if (node[key]) return true;
    }
    return false;
  }
  create(node, obj, key, listKey): NodePath {
    return NodePath.get({
      parentPath: this.parentPath,
      parent: node,
      container: obj,
      key: key,
      listKey,
    });
  }
  maybeQueue(path, notPriority?: boolean) {
    if (this.trap) {
      throw new Error("Infinite cycle detected");
    }
    if (this.queue) {
      if (notPriority) {
        this.queue.push(path);
      } else {
        this.priorityQueue.push(path);
      }
    }
  }
  visitMultiple(container, parent, listKey) {
    // nothing to traverse!
    if (container.length === 0) return false;
    const queue = [];
    // build up initial queue
    for (let key = 0; key < container.length; key++) {
      const node = container[key];
      if (node && this.shouldVisit(node)) {
        queue.push(this.create(parent, container, key, listKey));
      }
    }
    return this.visitQueue(queue);
  }
  visitSingle(node, key): boolean {
    if (this.shouldVisit(node[key])) {
      return this.visitQueue([this.create(node, node, key)]);
    } else {
      return false;
    }
  }
  visitQueue(queue: Array<NodePath>) {
    // set queue
    this.queue = queue;
    this.priorityQueue = [];
    const visited = [];
    let stop = false;
    // visit the queue
    for (const path of queue) {
      path.resync();
      if (
        path.contexts.length === 0 ||
        path.contexts[path.contexts.length - 1] !== this
      ) {
        // The context might already have been pushed when this path was inserted and queued.
        // If we always re-pushed here, we could get duplicates and risk leaving contexts
        // on the stack after the traversal has completed, which could break things.
        path.pushContext(this);
      }
      // this path no longer belongs to the tree
      if (path.key === null) continue;
      if (testing && queue.length >= 10_000) {
        this.trap = true;
      }
      // ensure we don't visit the same node twice
      if (visited.indexOf(path.node) >= 0) continue;
      visited.push(path.node);
      if (path.visit()) {
        stop = true;
        break;
      }
      if (this.priorityQueue.length) {
        stop = this.visitQueue(this.priorityQueue);
        this.priorityQueue = [];
        this.queue = queue;
        if (stop) break;
      }
    }
    // clear queue
    for (const path of queue) {
      path.popContext();
    }
    // clear queue
    this.queue = null;
    return stop;
  }
  visit(node, key) {
    const nodes = node[key];
    if (!nodes) return false;
    if (Array.isArray(nodes)) {
      return this.visitMultiple(nodes, node, key);
    } else {
      return this.visitSingle(node, key);
    }
  }
}

// </from> /home/qfox/apps/babel/packages/babel-traverse/src/context.js

// <from> /home/qfox/apps/babel/packages/babel-traverse/src/visitors.js

import * as virtualTypes from "./path/lib/virtual-types";
import * as t from "@babel/types";
import clone from "lodash/clone";
/**
 * explode() will take a visitor object with all of the various shorthands
 * that we support, and validates & normalizes it into a common format, ready
 * to be used in traversal
 *
 * The various shorthands are:
 * * `Identifier() { ... }` -> `Identifier: { enter() { ... } }`
 * * `"Identifier|NumericLiteral": { ... }` -> `Identifier: { ... }, NumericLiteral: { ... }`
 * * Aliases in `@babel/types`: e.g. `Property: { ... }` -> `ObjectProperty: { ... }, ClassProperty: { ... }`
 *
 * Other normalizations are:
 * * Visitors of virtual types are wrapped, so that they are only visited when
 *   their dynamic check passes
 * * `enter` and `exit` functions are wrapped in arrays, to ease merging of
 *   visitors
 */
export function explode(visitor) {
  if (visitor._exploded) return visitor;
  visitor._exploded = true;
  // normalise pipes
  for (const nodeType in visitor) {
    if (shouldIgnoreKey(nodeType)) continue;
    const parts: Array<string> = nodeType.split("|");
    if (parts.length === 1) continue;
    const fns = visitor[nodeType];
    delete visitor[nodeType];
    for (const part of parts) {
      visitor[part] = fns;
    }
  }
  // verify data structure
  verify(visitor);
  // make sure there's no __esModule type since this is because we're using loose mode
  // and it sets __esModule to be enumerable on all modules :(
  delete visitor.__esModule;
  // ensure visitors are objects
  ensureEntranceObjects(visitor);
  // ensure enter/exit callbacks are arrays
  ensureCallbackArrays(visitor);
  // add type wrappers
  for (const nodeType of (Object.keys(visitor): Array)) {
    if (shouldIgnoreKey(nodeType)) continue;
    const wrapper = virtualTypes[nodeType];
    if (!wrapper) continue;
    // wrap all the functions
    const fns = visitor[nodeType];
    for (const type in fns) {
      fns[type] = wrapCheck(wrapper, fns[type]);
    }
    // clear it from the visitor
    delete visitor[nodeType];
    if (wrapper.types) {
      for (const type of (wrapper.types: Array<string>)) {
        // merge the visitor if necessary or just put it back in
        if (visitor[type]) {
          mergePair(visitor[type], fns);
        } else {
          visitor[type] = fns;
        }
      }
    } else {
      mergePair(visitor, fns);
    }
  }
  // add aliases
  for (const nodeType in visitor) {
    if (shouldIgnoreKey(nodeType)) continue;
    const fns = visitor[nodeType];
    let aliases: ?Array<string> = t.FLIPPED_ALIAS_KEYS[nodeType];
    const deprecratedKey = t.DEPRECATED_KEYS[nodeType];
    if (deprecratedKey) {
      console.trace(
        `Visitor defined for ${nodeType} but it has been renamed to ${deprecratedKey}`,
      );
      aliases = [deprecratedKey];
    }
    if (!aliases) continue;
    // clear it from the visitor
    delete visitor[nodeType];
    for (const alias of aliases) {
      const existing = visitor[alias];
      if (existing) {
        mergePair(existing, fns);
      } else {
        visitor[alias] = clone(fns);
      }
    }
  }
  for (const nodeType in visitor) {
    if (shouldIgnoreKey(nodeType)) continue;
    ensureCallbackArrays(visitor[nodeType]);
  }
  return visitor;
}
export function verify(visitor) {
  if (visitor._verified) return;
  if (typeof visitor === "function") {
    throw new Error(
      "You passed `traverse()` a function when it expected a visitor object, " +
        "are you sure you didn't mean `{ enter: Function }`?",
    );
  }
  for (const nodeType in visitor) {
    if (nodeType === "enter" || nodeType === "exit") {
      validateVisitorMethods(nodeType, visitor[nodeType]);
    }
    if (shouldIgnoreKey(nodeType)) continue;
    if (t.TYPES.indexOf(nodeType) < 0) {
      throw new Error(
        `You gave us a visitor for the node type ${nodeType} but it's not a valid type`,
      );
    }
    const visitors = visitor[nodeType];
    if (typeof visitors === "object") {
      for (const visitorKey in visitors) {
        if (visitorKey === "enter" || visitorKey === "exit") {
          // verify that it just contains functions
          validateVisitorMethods(
            `${nodeType}.${visitorKey}`,
            visitors[visitorKey],
          );
        } else {
          throw new Error(
            "You passed `traverse()` a visitor object with the property " +
              `${nodeType} that has the invalid property ${visitorKey}`,
          );
        }
      }
    }
  }
  visitor._verified = true;
}
function validateVisitorMethods(path, val) {
  const fns = [].concat(val);
  for (const fn of fns) {
    if (typeof fn !== "function") {
      throw new TypeError(
        `Non-function found defined in ${path} with type ${typeof fn}`,
      );
    }
  }
}
export function merge(
  visitors: Array,
  states: Array = [],
  wrapper?: ?Function,
) {
  const rootVisitor = {};
  for (let i = 0; i < visitors.length; i++) {
    const visitor = visitors[i];
    const state = states[i];
    explode(visitor);
    for (const type in visitor) {
      let visitorType = visitor[type];
      // if we have state or wrapper then overload the callbacks to take it
      if (state || wrapper) {
        visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);
      }
      const nodeVisitor = (rootVisitor[type] = rootVisitor[type] || {});
      mergePair(nodeVisitor, visitorType);
    }
  }
  return rootVisitor;
}
function wrapWithStateOrWrapper(oldVisitor, state, wrapper: ?Function) {
  const newVisitor = {};
  for (const key in oldVisitor) {
    let fns = oldVisitor[key];
    // not an enter/exit array of callbacks
    if (!Array.isArray(fns)) continue;
    fns = fns.map(function(fn) {
      let newFn = fn;
      if (state) {
        newFn = function(path) {
          return fn.call(state, path, state);
        };
      }
      if (wrapper) {
        newFn = wrapper(state.key, key, newFn);
      }
      return newFn;
    });
    newVisitor[key] = fns;
  }
  return newVisitor;
}
function ensureEntranceObjects(obj) {
  for (const key in obj) {
    if (shouldIgnoreKey(key)) continue;
    const fns = obj[key];
    if (typeof fns === "function") {
      obj[key] = { enter: fns };
    }
  }
}
function ensureCallbackArrays(obj) {
  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];
  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];
}
function wrapCheck(wrapper, fn) {
  const newFn = function(path) {
    if (wrapper.checkPath(path)) {
      return fn.apply(this, arguments);
    }
  };
  newFn.toString = () => fn.toString();
  return newFn;
}
function shouldIgnoreKey(key) {
  // internal/hidden key
  if (key[0] === "_") return true;
  // ignore function keys
  if (key === "enter" || key === "exit" || key === "shouldSkip") return true;
  // ignore other options
  if (key === "blacklist" || key === "noScope" || key === "skipKeys") {
    return true;
  }
  return false;
}
function mergePair(dest, src) {
  for (const key in src) {
    dest[key] = [].concat(dest[key] || [], src[key]);
  }
}

// </from> /home/qfox/apps/babel/packages/babel-traverse/src/visitors.js

// <from> /home/qfox/apps/babel/packages/babel-traverse/src/path/evaluation.js

// This file contains Babels metainterpreter that can evaluate static code.
const VALID_CALLEES = ["String", "Number", "Math"];
const INVALID_METHODS = ["random"];
/**
 * Walk the input `node` and statically evaluate if it's truthy.
 *
 * Returning `true` when we're sure that the expression will evaluate to a
 * truthy value, `false` if we're sure that it will evaluate to a falsy
 * value and `undefined` if we aren't sure. Because of this please do not
 * rely on coercion when using this method and check with === if it's false.
 *
 * For example do:
 *
 *   if (t.evaluateTruthy(node) === false) falsyLogic();
 *
 * **AND NOT**
 *
 *   if (!t.evaluateTruthy(node)) falsyLogic();
 *
 */
export function evaluateTruthy(): boolean {
  const res = this.evaluate();
  if (res.confident) return !!res.value;
}
/**
 * Deopts the evaluation
 */
function deopt(path, state) {
  if (!state.confident) return;
  state.deoptPath = path;
  state.confident = false;
}
/**
 * We wrap the _evaluate method so we can track `seen` nodes, we push an item
 * to the map before we actually evaluate it so we can deopt on self recursive
 * nodes such as:
 *
 *   var g = a ? 1 : 2,
 *       a = g * this.foo
 */
function evaluateCached(path, state) {
  const { node } = path;
  const { seen } = state;
  if (seen.has(node)) {
    const existing = seen.get(node);
    if (existing.resolved) {
      return existing.value;
    } else {
      deopt(path, state);
      return;
    }
  } else {
    const item = { resolved: false };
    seen.set(node, item);
    const val = _evaluate(path, state);
    if (state.confident) {
      item.resolved = true;
      item.value = val;
    }
    return val;
  }
}
function _evaluate(path, state) {
  if (!state.confident) return;
  const { node } = path;
  if (path.isSequenceExpression()) {
    const exprs = path.get("expressions");
    return evaluateCached(exprs[exprs.length - 1], state);
  }
  if (
    path.isStringLiteral() ||
    path.isNumericLiteral() ||
    path.isBooleanLiteral()
  ) {
    return node.value;
  }
  if (path.isNullLiteral()) {
    return null;
  }
  if (path.isTemplateLiteral()) {
    return evaluateQuasis(path, node.quasis, state);
  }
  if (
    path.isTaggedTemplateExpression() &&
    path.get("tag").isMemberExpression()
  ) {
    const object = path.get("tag.object");
    const {
      node: { name },
    } = object;
    const property = path.get("tag.property");
    if (
      object.isIdentifier() &&
      name === "String" &&
      !path.scope.getBinding(name, true) &&
      property.isIdentifier &&
      property.node.name === "raw"
    ) {
      return evaluateQuasis(path, node.quasi.quasis, state, true);
    }
  }
  if (path.isConditionalExpression()) {
    const testResult = evaluateCached(path.get("test"), state);
    if (!state.confident) return;
    if (testResult) {
      return evaluateCached(path.get("consequent"), state);
    } else {
      return evaluateCached(path.get("alternate"), state);
    }
  }
  if (path.isExpressionWrapper()) {
    // TypeCastExpression, ExpressionStatement etc
    return evaluateCached(path.get("expression"), state);
  }
  // "foo".length
  if (
    path.isMemberExpression() &&
    !path.parentPath.isCallExpression({ callee: node })
  ) {
    const property = path.get("property");
    const object = path.get("object");
    if (object.isLiteral() && property.isIdentifier()) {
      const value = object.node.value;
      const type = typeof value;
      if (type === "number" || type === "string") {
        return value[property.node.name];
      }
    }
  }
  if (path.isReferencedIdentifier()) {
    const binding = path.scope.getBinding(node.name);
    if (binding && binding.constantViolations.length > 0) {
      return deopt(binding.path, state);
    }
    if (binding && path.node.start < binding.path.node.end) {
      return deopt(binding.path, state);
    }
    if (binding && binding.hasValue) {
      return binding.value;
    } else {
      if (node.name === "undefined") {
        return binding ? deopt(binding.path, state) : undefined;
      } else if (node.name === "Infinity") {
        return binding ? deopt(binding.path, state) : Infinity;
      } else if (node.name === "NaN") {
        return binding ? deopt(binding.path, state) : NaN;
      }
      const resolved = path.resolve();
      if (resolved === path) {
        return deopt(path, state);
      } else {
        return evaluateCached(resolved, state);
      }
    }
  }
  if (path.isUnaryExpression({ prefix: true })) {
    if (node.operator === "void") {
      // we don't need to evaluate the argument to know what this will return
      return undefined;
    }
    const argument = path.get("argument");
    if (
      node.operator === "typeof" &&
      (argument.isFunction() || argument.isClass())
    ) {
      return "function";
    }
    const arg = evaluateCached(argument, state);
    if (!state.confident) return;
    switch (node.operator) {
      case "!":
        return !arg;
      case "+":
        return +arg;
      case "-":
        return -arg;
      case "~":
        return ~arg;
      case "typeof":
        return typeof arg;
    }
  }
  if (path.isArrayExpression()) {
    const arr = [];
    const elems: Array<NodePath> = path.get("elements");
    for (const elem of elems) {
      const elemValue = elem.evaluate();
      if (elemValue.confident) {
        arr.push(elemValue.value);
      } else {
        return deopt(elem, state);
      }
    }
    return arr;
  }
  if (path.isObjectExpression()) {
    const obj = {};
    const props: Array<NodePath> = path.get("properties");
    for (const prop of props) {
      if (prop.isObjectMethod() || prop.isSpreadElement()) {
        return deopt(prop, state);
      }
      const keyPath = prop.get("key");
      let key = keyPath;
      if (prop.node.computed) {
        key = key.evaluate();
        if (!key.confident) {
          return deopt(keyPath, state);
        }
        key = key.value;
      } else if (key.isIdentifier()) {
        key = key.node.name;
      } else {
        key = key.node.value;
      }
      const valuePath = prop.get("value");
      let value = valuePath.evaluate();
      if (!value.confident) {
        return deopt(valuePath, state);
      }
      value = value.value;
      obj[key] = value;
    }
    return obj;
  }
  if (path.isLogicalExpression()) {
    // If we are confident that one side of an && is false, or the left
    // side of an || is true, we can be confident about the entire expression
    const wasConfident = state.confident;
    const left = evaluateCached(path.get("left"), state);
    const leftConfident = state.confident;
    state.confident = wasConfident;
    const right = evaluateCached(path.get("right"), state);
    const rightConfident = state.confident;
    state.confident = leftConfident && rightConfident;
    switch (node.operator) {
      case "||":
        // TODO consider having a "truthy type" that doesn't bail on
        // left uncertainty but can still evaluate to truthy.
        if (left && leftConfident) {
          state.confident = true;
          return left;
        }
        if (!state.confident) return;
        return left || right;
      case "&&":
        if ((!left && leftConfident) || (!right && rightConfident)) {
          state.confident = true;
        }
        if (!state.confident) return;
        return left && right;
    }
  }
  if (path.isBinaryExpression()) {
    const left = evaluateCached(path.get("left"), state);
    if (!state.confident) return;
    const right = evaluateCached(path.get("right"), state);
    if (!state.confident) return;
    switch (node.operator) {
      case "-":
        return left - right;
      case "+":
        return left + right;
      case "/":
        return left / right;
      case "*":
        return left * right;
      case "%":
        return left % right;
      case "**":
        return left ** right;
      case "<":
        return left < right;
      case ">":
        return left > right;
      case "<=":
        return left <= right;
      case ">=":
        return left >= right;
      case "==":
        return left == right; // eslint-disable-line eqeqeq
      case "!=":
        return left != right;
      case "===":
        return left === right;
      case "!==":
        return left !== right;
      case "|":
        return left | right;
      case "&":
        return left & right;
      case "^":
        return left ^ right;
      case "<<":
        return left << right;
      case ">>":
        return left >> right;
      case ">>>":
        return left >>> right;
    }
  }
  if (path.isCallExpression()) {
    const callee = path.get("callee");
    let context;
    let func;
    // Number(1);
    if (
      callee.isIdentifier() &&
      !path.scope.getBinding(callee.node.name, true) &&
      VALID_CALLEES.indexOf(callee.node.name) >= 0
    ) {
      func = global[node.callee.name];
    }
    if (callee.isMemberExpression()) {
      const object = callee.get("object");
      const property = callee.get("property");
      // Math.min(1, 2)
      if (
        object.isIdentifier() &&
        property.isIdentifier() &&
        VALID_CALLEES.indexOf(object.node.name) >= 0 &&
        INVALID_METHODS.indexOf(property.node.name) < 0
      ) {
        context = global[object.node.name];
        func = context[property.node.name];
      }
      // "abc".charCodeAt(4)
      if (object.isLiteral() && property.isIdentifier()) {
        const type = typeof object.node.value;
        if (type === "string" || type === "number") {
          context = object.node.value;
          func = context[property.node.name];
        }
      }
    }
    if (func) {
      const args = path.get("arguments").map(arg => evaluateCached(arg, state));
      if (!state.confident) return;
      return func.apply(context, args);
    }
  }
  deopt(path, state);
}
function evaluateQuasis(path, quasis: Array<Object>, state, raw = false) {
  let str = "";
  let i = 0;
  const exprs = path.get("expressions");
  for (const elem of quasis) {
    // not confident, evaluated an expression we don't like
    if (!state.confident) break;
    // add on element
    str += raw ? elem.value.raw : elem.value.cooked;
    // add on interpolated expression if it's present
    const expr = exprs[i++];
    if (expr) str += String(evaluateCached(expr, state));
  }
  if (!state.confident) return;
  return str;
}
/**
 * Walk the input `node` and statically evaluate it.
 *
 * Returns an object in the form `{ confident, value }`. `confident` indicates
 * whether or not we had to drop out of evaluating the expression because of
 * hitting an unknown node that we couldn't confidently find the value of.
 *
 * Example:
 *
 *   t.evaluate(parse("5 + 5")) // { confident: true, value: 10 }
 *   t.evaluate(parse("!true")) // { confident: true, value: false }
 *   t.evaluate(parse("foo + foo")) // { confident: false, value: undefined }
 *
 */
export function evaluate(): { confident: boolean, value: any } {
  const state = {
    confident: true,
    deoptPath: null,
    seen: new Map(),
  };
  let value = evaluateCached(this, state);
  if (!state.confident) value = undefined;
  return {
    confident: state.confident,
    deopt: state.deoptPath,
    value: value,
  };
}

// </from> /home/qfox/apps/babel/packages/babel-traverse/src/path/evaluation.js

// <from> /home/qfox/apps/babel/packages/babel-traverse/src/path/index.js

import * as virtualTypes from "./lib/virtual-types";
import buildDebug from "debug";
import traverse from "../index";
import Scope from "../scope";
import * as t from "@babel/types";
import { path as pathCache } from "../cache";
import generator from "@babel/generator";
// NodePath is split across many files.
import * as NodePath_ancestry from "./ancestry";
import * as NodePath_inference from "./inference";
import * as NodePath_replacement from "./replacement";
import * as NodePath_evaluation from "./evaluation";
import * as NodePath_conversion from "./conversion";
import * as NodePath_introspection from "./introspection";
import * as NodePath_context from "./context";
import * as NodePath_removal from "./removal";
import * as NodePath_modification from "./modification";
import * as NodePath_family from "./family";
import * as NodePath_comments from "./comments";
const debug = buildDebug("babel");
export default class NodePath {
  constructor(hub: HubInterface, parent: Object) {
    this.parent = parent;
    this.hub = hub;
    this.contexts = [];
    this.data = {};
    this.shouldSkip = false;
    this.shouldStop = false;
    this.removed = false;
    this.state = null;
    this.opts = null;
    this.skipKeys = null;
    this.parentPath = null;
    this.context = null;
    this.container = null;
    this.listKey = null;
    this.inList = false;
    this.parentKey = null;
    this.key = null;
    this.node = null;
    this.scope = null;
    this.type = null;
    this.typeAnnotation = null;
  }
  parent: Object;
  hub: HubInterface;
  contexts: Array<TraversalContext>;
  data: Object;
  shouldSkip: boolean;
  shouldStop: boolean;
  removed: boolean;
  state: any;
  opts: ?Object;
  skipKeys: ?Object;
  parentPath: ?NodePath;
  context: TraversalContext;
  container: ?Object | Array<Object>;
  listKey: ?string;
  inList: boolean;
  parentKey: ?string;
  key: ?string;
  node: ?Object;
  scope: Scope;
  type: ?string;
  typeAnnotation: ?Object;
  static get({ hub, parentPath, parent, container, listKey, key }): NodePath {
    if (!hub && parentPath) {
      hub = parentPath.hub;
    }
    if (!parent) {
      throw new Error("To get a node path the parent needs to exist");
    }
    const targetNode = container[key];
    const paths = pathCache.get(parent) || [];
    if (!pathCache.has(parent)) {
      pathCache.set(parent, paths);
    }
    let path;
    for (let i = 0; i < paths.length; i++) {
      const pathCheck = paths[i];
      if (pathCheck.node === targetNode) {
        path = pathCheck;
        break;
      }
    }
    if (!path) {
      path = new NodePath(hub, parent);
      paths.push(path);
    }
    path.setup(parentPath, container, listKey, key);
    return path;
  }
  getScope(scope: Scope) {
    return this.isScope() ? new Scope(this) : scope;
  }
  setData(key: string, val: any): any {
    return (this.data[key] = val);
  }
  getData(key: string, def?: any): any {
    let val = this.data[key];
    if (!val && def) val = this.data[key] = def;
    return val;
  }
  buildCodeFrameError(msg: string, Error: typeof Error = SyntaxError): Error {
    return this.hub.buildError(this.node, msg, Error);
  }
  traverse(visitor: Object, state?: any) {
    traverse(this.node, visitor, this.scope, state, this);
  }
  set(key: string, node: Object) {
    t.validate(this.node, key, node);
    this.node[key] = node;
  }
  getPathLocation(): string {
    const parts = [];
    let path = this;
    do {
      let key = path.key;
      if (path.inList) key = `${path.listKey}[${key}]`;
      parts.unshift(key);
    } while ((path = path.parentPath));
    return parts.join(".");
  }
  debug(message) {
    if (!debug.enabled) return;
    debug(`${this.getPathLocation()} ${this.type}: ${message}`);
  }
  toString() {
    return generator(this.node).code;
  }
}
Object.assign(
  NodePath.prototype,
  NodePath_ancestry,
  NodePath_inference,
  NodePath_replacement,
  NodePath_evaluation,
  NodePath_conversion,
  NodePath_introspection,
  NodePath_context,
  NodePath_removal,
  NodePath_modification,
  NodePath_family,
  NodePath_comments,
);
for (const type of (t.TYPES: Array<string>)) {
  const typeKey = `is${type}`;
  const fn = t[typeKey];
  NodePath.prototype[typeKey] = function(opts) {
    return fn(this.node, opts);
  };
  NodePath.prototype[`assert${type}`] = function(opts) {
    if (!fn(this.node, opts)) {
      throw new TypeError(`Expected node path of type ${type}`);
    }
  };
}
for (const type in virtualTypes) {
  if (type[0] === "_") continue;
  if (t.TYPES.indexOf(type) < 0) t.TYPES.push(type);
  const virtualType = virtualTypes[type];
  NodePath.prototype[`is${type}`] = function(opts) {
    return virtualType.checkPath(this, opts);
  };
}

// </from> /home/qfox/apps/babel/packages/babel-traverse/src/path/index.js

// <from> /home/qfox/apps/babel/packages/babel-traverse/src/path/family.js

// This file contains methods responsible for dealing with/retrieving children or siblings.
import NodePath from "./index";
import * as t from "@babel/types";
export function getOpposite(): ?NodePath {
  if (this.key === "left") {
    return this.getSibling("right");
  } else if (this.key === "right") {
    return this.getSibling("left");
  }
}
function addCompletionRecords(path, paths) {
  if (path) return paths.concat(path.getCompletionRecords());
  return paths;
}
export function getCompletionRecords(): Array {
  let paths = [];
  if (this.isIfStatement()) {
    paths = addCompletionRecords(this.get("consequent"), paths);
    paths = addCompletionRecords(this.get("alternate"), paths);
  } else if (this.isDoExpression() || this.isFor() || this.isWhile()) {
    paths = addCompletionRecords(this.get("body"), paths);
  } else if (this.isProgram() || this.isBlockStatement()) {
    paths = addCompletionRecords(this.get("body").pop(), paths);
  } else if (this.isFunction()) {
    return this.get("body").getCompletionRecords();
  } else if (this.isTryStatement()) {
    paths = addCompletionRecords(this.get("block"), paths);
    paths = addCompletionRecords(this.get("handler"), paths);
    paths = addCompletionRecords(this.get("finalizer"), paths);
  } else if (this.isCatchClause()) {
    paths = addCompletionRecords(this.get("body"), paths);
  } else {
    paths.push(this);
  }
  return paths;
}
export function getSibling(key): NodePath {
  return NodePath.get({
    parentPath: this.parentPath,
    parent: this.parent,
    container: this.container,
    listKey: this.listKey,
    key: key,
  });
}
export function getPrevSibling(): NodePath {
  return this.getSibling(this.key - 1);
}
export function getNextSibling(): NodePath {
  return this.getSibling(this.key + 1);
}
export function getAllNextSiblings(): Array<NodePath> {
  let _key = this.key;
  let sibling: NodePath = this.getSibling(++_key);
  const siblings: Array<NodePath> = [];
  while (sibling.node) {
    siblings.push(sibling);
    sibling = this.getSibling(++_key);
  }
  return siblings;
}
export function getAllPrevSiblings(): Array<NodePath> {
  let _key = this.key;
  let sibling: NodePath = this.getSibling(--_key);
  const siblings: Array<NodePath> = [];
  while (sibling.node) {
    siblings.push(sibling);
    sibling = this.getSibling(--_key);
  }
  return siblings;
}
export function get(
  key: string,
  context?: boolean | TraversalContext,
): NodePath {
  if (context === true) context = this.context;
  const parts = key.split(".");
  if (parts.length === 1) {
    // "foo"
    return this._getKey(key, context);
  } else {
    // "foo.bar"
    return this._getPattern(parts, context);
  }
}
export function _getKey(key, context?) {
  const node = this.node;
  const container = node[key];
  if (Array.isArray(container)) {
    // requested a container so give them all the paths
    return container.map((_, i) => {
      return NodePath.get({
        listKey: key,
        parentPath: this,
        parent: node,
        container: container,
        key: i,
      }).setContext(context);
    });
  } else {
    return NodePath.get({
      parentPath: this,
      parent: node,
      container: node,
      key: key,
    }).setContext(context);
  }
}
export function _getPattern(parts, context) {
  let path = this;
  for (const part of (parts: Array)) {
    if (part === ".") {
      path = path.parentPath;
    } else {
      if (Array.isArray(path)) {
        path = path[part];
      } else {
        path = path.get(part, context);
      }
    }
  }
  return path;
}
export function getBindingIdentifiers(duplicates?): Object {
  return t.getBindingIdentifiers(this.node, duplicates);
}
export function getOuterBindingIdentifiers(duplicates?): Object {
  return t.getOuterBindingIdentifiers(this.node, duplicates);
}
// original source - https://github.com/babel/babel/blob/master/packages/babel-types/src/retrievers.js
// path.getBindingIdentifiers returns nodes where the following re-implementation
// returns paths
export function getBindingIdentifierPaths(
  duplicates = false,
  outerOnly = false,
) {
  const path = this;
  let search = [].concat(path);
  const ids = Object.create(null);
  while (search.length) {
    const id = search.shift();
    if (!id) continue;
    if (!id.node) continue;
    const keys = t.getBindingIdentifiers.keys[id.node.type];
    if (id.isIdentifier()) {
      if (duplicates) {
        const _ids = (ids[id.node.name] = ids[id.node.name] || []);
        _ids.push(id);
      } else {
        ids[id.node.name] = id;
      }
      continue;
    }
    if (id.isExportDeclaration()) {
      const declaration = id.get("declaration");
      if (declaration.isDeclaration()) {
        search.push(declaration);
      }
      continue;
    }
    if (outerOnly) {
      if (id.isFunctionDeclaration()) {
        search.push(id.get("id"));
        continue;
      }
      if (id.isFunctionExpression()) {
        continue;
      }
    }
    if (keys) {
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const child = id.get(key);
        if (Array.isArray(child) || child.node) {
          search = search.concat(child);
        }
      }
    }
  }
  return ids;
}
export function getOuterBindingIdentifierPaths(duplicates?) {
  return this.getBindingIdentifierPaths(duplicates, true);
}

// </from> /home/qfox/apps/babel/packages/babel-traverse/src/path/family.js

// <from> /home/qfox/apps/babel/packages/babel-traverse/src/path/modification.js

// This file contains methods that modify the path/node in some ways.
import { path as pathCache } from "../cache";
import PathHoister from "./lib/hoister";
import NodePath from "./index";
import * as t from "@babel/types";
/**
 * Insert the provided nodes before the current one.
 */
export function insertBefore(nodes) {
  this._assertUnremoved();
  nodes = this._verifyNodeList(nodes);
  const { parentPath } = this;
  if (
    parentPath.isExpressionStatement() ||
    parentPath.isLabeledStatement() ||
    parentPath.isExportNamedDeclaration() ||
    (parentPath.isExportDefaultDeclaration() && this.isDeclaration())
  ) {
    return parentPath.insertBefore(nodes);
  } else if (
    (this.isNodeType("Expression") &&
      this.listKey !== "params" &&
      this.listKey !== "arguments") ||
    (parentPath.isForStatement() && this.key === "init")
  ) {
    if (this.node) nodes.push(this.node);
    return this.replaceExpressionWithStatements(nodes);
  } else if (Array.isArray(this.container)) {
    return this._containerInsertBefore(nodes);
  } else if (this.isStatementOrBlock()) {
    const shouldInsertCurrentNode =
      this.node &&
      (!this.isExpressionStatement() || this.node.expression != null);
    this.replaceWith(
      t.blockStatement(shouldInsertCurrentNode ? [this.node] : []),
    );
    return this.unshiftContainer("body", nodes);
  } else {
    throw new Error(
      "We don't know what to do with this node type. " +
        "We were previously a Statement but we can't fit in here?",
    );
  }
}
export function _containerInsert(from, nodes) {
  this.updateSiblingKeys(from, nodes.length);
  const paths = [];
  this.container.splice(from, 0, ...nodes);
  for (let i = 0; i < nodes.length; i++) {
    const to = from + i;
    const path = this.getSibling(to);
    paths.push(path);
    if (this.context && this.context.queue) {
      path.pushContext(this.context);
    }
  }
  const contexts = this._getQueueContexts();
  for (const path of paths) {
    path.setScope();
    path.debug("Inserted.");
    for (const context of contexts) {
      context.maybeQueue(path, true);
    }
  }
  return paths;
}
export function _containerInsertBefore(nodes) {
  return this._containerInsert(this.key, nodes);
}
export function _containerInsertAfter(nodes) {
  return this._containerInsert(this.key + 1, nodes);
}
/**
 * Insert the provided nodes after the current one. When inserting nodes after an
 * expression, ensure that the completion record is correct by pushing the current node.
 */
export function insertAfter(nodes) {
  this._assertUnremoved();
  nodes = this._verifyNodeList(nodes);
  const { parentPath } = this;
  if (
    parentPath.isExpressionStatement() ||
    parentPath.isLabeledStatement() ||
    parentPath.isExportNamedDeclaration() ||
    (parentPath.isExportDefaultDeclaration() && this.isDeclaration())
  ) {
    return parentPath.insertAfter(nodes);
  } else if (
    this.isNodeType("Expression") ||
    (parentPath.isForStatement() && this.key === "init")
  ) {
    if (this.node) {
      let { scope } = this;
      // Inserting after the computed key of a method should insert the
      // temporary binding in the method's parent's scope.
      if (parentPath.isMethod({ computed: true, key: this.node })) {
        scope = scope.parent;
      }
      const temp = scope.generateDeclaredUidIdentifier();
      nodes.unshift(
        t.expressionStatement(
          t.assignmentExpression("=", t.cloneNode(temp), this.node),
        ),
      );
      nodes.push(t.expressionStatement(t.cloneNode(temp)));
    }
    return this.replaceExpressionWithStatements(nodes);
  } else if (Array.isArray(this.container)) {
    return this._containerInsertAfter(nodes);
  } else if (this.isStatementOrBlock()) {
    const shouldInsertCurrentNode =
      this.node &&
      (!this.isExpressionStatement() || this.node.expression != null);
    this.replaceWith(
      t.blockStatement(shouldInsertCurrentNode ? [this.node] : []),
    );
    return this.pushContainer("body", nodes);
  } else {
    throw new Error(
      "We don't know what to do with this node type. " +
        "We were previously a Statement but we can't fit in here?",
    );
  }
}
/**
 * Update all sibling node paths after `fromIndex` by `incrementBy`.
 */
export function updateSiblingKeys(fromIndex, incrementBy) {
  if (!this.parent) return;
  const paths = pathCache.get(this.parent);
  for (let i = 0; i < paths.length; i++) {
    const path = paths[i];
    if (path.key >= fromIndex) {
      path.key += incrementBy;
    }
  }
}
export function _verifyNodeList(nodes) {
  if (!nodes) {
    return [];
  }
  if (nodes.constructor !== Array) {
    nodes = [nodes];
  }
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    let msg;
    if (!node) {
      msg = "has falsy node";
    } else if (typeof node !== "object") {
      msg = "contains a non-object node";
    } else if (!node.type) {
      msg = "without a type";
    } else if (node instanceof NodePath) {
      msg = "has a NodePath when it expected a raw object";
    }
    if (msg) {
      const type = Array.isArray(node) ? "array" : typeof node;
      throw new Error(
        `Node list ${msg} with the index of ${i} and type of ${type}`,
      );
    }
  }
  return nodes;
}
export function unshiftContainer(listKey, nodes) {
  this._assertUnremoved();
  nodes = this._verifyNodeList(nodes);
  // get the first path and insert our nodes before it, if it doesn't exist then it
  // doesn't matter, our nodes will be inserted anyway
  const path = NodePath.get({
    parentPath: this,
    parent: this.node,
    container: this.node[listKey],
    listKey,
    key: 0,
  });
  return path.insertBefore(nodes);
}
export function pushContainer(listKey, nodes) {
  this._assertUnremoved();
  nodes = this._verifyNodeList(nodes);
  // get an invisible path that represents the last node + 1 and replace it with our
  // nodes, effectively inlining it
  const container = this.node[listKey];
  const path = NodePath.get({
    parentPath: this,
    parent: this.node,
    container: container,
    listKey,
    key: container.length,
  });
  return path.replaceWithMultiple(nodes);
}
/**
 * Hoist the current node to the highest scope possible and return a UID
 * referencing it.
 */
export function hoist(scope = this.scope) {
  const hoister = new PathHoister(this, scope);
  return hoister.run();
}

// </from> /home/qfox/apps/babel/packages/babel-traverse/src/path/modification.js

// <from> /home/qfox/apps/babel/packages/babel-traverse/src/path/introspection.js

// This file contains methods responsible for introspecting the current path for certain values.
import includes from "lodash/includes";
import * as t from "@babel/types";
/**
 * Match the current node if it matches the provided `pattern`.
 *
 * For example, given the match `React.createClass` it would match the
 * parsed nodes of `React.createClass` and `React["createClass"]`.
 */
export function matchesPattern(
  pattern: string,
  allowPartial?: boolean,
): boolean {
  return t.matchesPattern(this.node, pattern, allowPartial);
}
/**
 * Check whether we have the input `key`. If the `key` references an array then we check
 * if the array has any items, otherwise we just check if it's falsy.
 */
export function has(key): boolean {
  const val = this.node && this.node[key];
  if (val && Array.isArray(val)) {
    return !!val.length;
  } else {
    return !!val;
  }
}
/**
 * Description
 */
export function isStatic() {
  return this.scope.isStatic(this.node);
}
/**
 * Alias of `has`.
 */
export const is = has;
/**
 * Opposite of `has`.
 */
export function isnt(key): boolean {
  return !this.has(key);
}
/**
 * Check whether the path node `key` strict equals `value`.
 */
export function equals(key, value): boolean {
  return this.node[key] === value;
}
/**
 * Check the type against our stored internal type of the node. This is handy when a node has
 * been removed yet we still internally know the type and need it to calculate node replacement.
 */
export function isNodeType(type: string): boolean {
  return t.isType(this.type, type);
}
/**
 * This checks whether or not we're in one of the following positions:
 *
 *   for (KEY in right);
 *   for (KEY;;);
 *
 * This is because these spots allow VariableDeclarations AND normal expressions so we need
 * to tell the path replacement that it's ok to replace this with an expression.
 */
export function canHaveVariableDeclarationOrExpression() {
  return (
    (this.key === "init" || this.key === "left") && this.parentPath.isFor()
  );
}
/**
 * This checks whether we are swapping an arrow function's body between an
 * expression and a block statement (or vice versa).
 *
 * This is because arrow functions may implicitly return an expression, which
 * is the same as containing a block statement.
 */
export function canSwapBetweenExpressionAndStatement(replacement) {
  if (this.key !== "body" || !this.parentPath.isArrowFunctionExpression()) {
    return false;
  }
  if (this.isExpression()) {
    return t.isBlockStatement(replacement);
  } else if (this.isBlockStatement()) {
    return t.isExpression(replacement);
  }
  return false;
}
/**
 * Check whether the current path references a completion record
 */
export function isCompletionRecord(allowInsideFunction?) {
  let path = this;
  let first = true;
  do {
    const container = path.container;
    // we're in a function so can't be a completion record
    if (path.isFunction() && !first) {
      return !!allowInsideFunction;
    }
    first = false;
    // check to see if we're the last item in the container and if we are
    // we're a completion record!
    if (Array.isArray(container) && path.key !== container.length - 1) {
      return false;
    }
  } while ((path = path.parentPath) && !path.isProgram());
  return true;
}
/**
 * Check whether or not the current `key` allows either a single statement or block statement
 * so we can explode it if necessary.
 */
export function isStatementOrBlock() {
  if (
    this.parentPath.isLabeledStatement() ||
    t.isBlockStatement(this.container)
  ) {
    return false;
  } else {
    return includes(t.STATEMENT_OR_BLOCK_KEYS, this.key);
  }
}
/**
 * Check if the currently assigned path references the `importName` of `moduleSource`.
 */
export function referencesImport(moduleSource, importName) {
  if (!this.isReferencedIdentifier()) return false;
  const binding = this.scope.getBinding(this.node.name);
  if (!binding || binding.kind !== "module") return false;
  const path = binding.path;
  const parent = path.parentPath;
  if (!parent.isImportDeclaration()) return false;
  // check moduleSource
  if (parent.node.source.value === moduleSource) {
    if (!importName) return true;
  } else {
    return false;
  }
  if (path.isImportDefaultSpecifier() && importName === "default") {
    return true;
  }
  if (path.isImportNamespaceSpecifier() && importName === "*") {
    return true;
  }
  if (path.isImportSpecifier() && path.node.imported.name === importName) {
    return true;
  }
  return false;
}
/**
 * Get the source code associated with this node.
 */
export function getSource() {
  const node = this.node;
  if (node.end) {
    const code = this.hub.getCode();
    if (code) return code.slice(node.start, node.end);
  }
  return "";
}
export function willIMaybeExecuteBefore(target) {
  return this._guessExecutionStatusRelativeTo(target) !== "after";
}
/**
 * Given a `target` check the execution status of it relative to the current path.
 *
 * "Execution status" simply refers to where or not we **think** this will execuete
 * before or after the input `target` element.
 */
export function _guessExecutionStatusRelativeTo(target) {
  // check if the two paths are in different functions, we can't track execution of these
  const targetFuncParent =
    target.scope.getFunctionParent() || target.scope.getProgramParent();
  const selfFuncParent =
    this.scope.getFunctionParent() || target.scope.getProgramParent();
  // here we check the `node` equality as sometimes we may have different paths for the
  // same node due to path thrashing
  if (targetFuncParent.node !== selfFuncParent.node) {
    const status = this._guessExecutionStatusRelativeToDifferentFunctions(
      targetFuncParent,
    );
    if (status) {
      return status;
    } else {
      target = targetFuncParent.path;
    }
  }
  const targetPaths = target.getAncestry();
  if (targetPaths.indexOf(this) >= 0) return "after";
  const selfPaths = this.getAncestry();
  // get ancestor where the branches intersect
  let commonPath;
  let targetIndex;
  let selfIndex;
  for (selfIndex = 0; selfIndex < selfPaths.length; selfIndex++) {
    const selfPath = selfPaths[selfIndex];
    targetIndex = targetPaths.indexOf(selfPath);
    if (targetIndex >= 0) {
      commonPath = selfPath;
      break;
    }
  }
  if (!commonPath) {
    return "before";
  }
  // get the relationship paths that associate these nodes to their common ancestor
  const targetRelationship = targetPaths[targetIndex - 1];
  const selfRelationship = selfPaths[selfIndex - 1];
  if (!targetRelationship || !selfRelationship) {
    return "before";
  }
  // container list so let's see which one is after the other
  if (
    targetRelationship.listKey &&
    targetRelationship.container === selfRelationship.container
  ) {
    return targetRelationship.key > selfRelationship.key ? "before" : "after";
  }
  // otherwise we're associated by a parent node, check which key comes before the other
  const keys = t.VISITOR_KEYS[commonPath.type];
  const targetKeyPosition = keys.indexOf(targetRelationship.key);
  const selfKeyPosition = keys.indexOf(selfRelationship.key);
  return targetKeyPosition > selfKeyPosition ? "before" : "after";
}
export function _guessExecutionStatusRelativeToDifferentFunctions(
  targetFuncParent,
) {
  const targetFuncPath = targetFuncParent.path;
  if (!targetFuncPath.isFunctionDeclaration()) return;
  // so we're in a completely different function, if this is a function declaration
  // then we can be a bit smarter and handle cases where the function is either
  // a. not called at all (part of an export)
  // b. called directly
  const binding = targetFuncPath.scope.getBinding(targetFuncPath.node.id.name);
  // no references!
  if (!binding.references) return "before";
  const referencePaths: Array<NodePath> = binding.referencePaths;
  // verify that all of the references are calls
  for (const path of referencePaths) {
    if (path.key !== "callee" || !path.parentPath.isCallExpression()) {
      return;
    }
  }
  let allStatus;
  // verify that all the calls have the same execution status
  for (const path of referencePaths) {
    // if a reference is a child of the function we're checking against then we can
    // safelty ignore it
    const childOfFunction = !!path.find(
      path => path.node === targetFuncPath.node,
    );
    if (childOfFunction) continue;
    const status = this._guessExecutionStatusRelativeTo(path);
    if (allStatus) {
      if (allStatus !== status) return;
    } else {
      allStatus = status;
    }
  }
  return allStatus;
}
/**
 * Resolve a "pointer" `NodePath` to it's absolute path.
 */
export function resolve(dangerous, resolved) {
  return this._resolve(dangerous, resolved) || this;
}
export function _resolve(dangerous?, resolved?): ?NodePath {
  // detect infinite recursion
  // todo: possibly have a max length on this just to be safe
  if (resolved && resolved.indexOf(this) >= 0) return;
  // we store all the paths we've "resolved" in this array to prevent infinite recursion
  resolved = resolved || [];
  resolved.push(this);
  if (this.isVariableDeclarator()) {
    if (this.get("id").isIdentifier()) {
      return this.get("init").resolve(dangerous, resolved);
    } else {
      // otherwise it's a request for a pattern and that's a bit more tricky
    }
  } else if (this.isReferencedIdentifier()) {
    const binding = this.scope.getBinding(this.node.name);
    if (!binding) return;
    // reassigned so we can't really resolve it
    if (!binding.constant) return;
    // todo - lookup module in dependency graph
    if (binding.kind === "module") return;
    if (binding.path !== this) {
      const ret = binding.path.resolve(dangerous, resolved);
      // If the identifier resolves to parent node then we can't really resolve it.
      if (this.find(parent => parent.node === ret.node)) return;
      return ret;
    }
  } else if (this.isTypeCastExpression()) {
    return this.get("expression").resolve(dangerous, resolved);
  } else if (dangerous && this.isMemberExpression()) {
    // this is dangerous, as non-direct target assignments will mutate it's state
    // making this resolution inaccurate
    const targetKey = this.toComputedKey();
    if (!t.isLiteral(targetKey)) return;
    const targetName = targetKey.value;
    const target = this.get("object").resolve(dangerous, resolved);
    if (target.isObjectExpression()) {
      const props = target.get("properties");
      for (const prop of (props: Array)) {
        if (!prop.isProperty()) continue;
        const key = prop.get("key");
        // { foo: obj }
        let match =
          prop.isnt("computed") && key.isIdentifier({ name: targetName });
        // { "foo": "obj" } or { ["foo"]: "obj" }
        match = match || key.isLiteral({ value: targetName });
        if (match) return prop.get("value").resolve(dangerous, resolved);
      }
    } else if (target.isArrayExpression() && !isNaN(+targetName)) {
      const elems = target.get("elements");
      const elem = elems[targetName];
      if (elem) return elem.resolve(dangerous, resolved);
    }
  }
}
export function isConstantExpression() {
  if (this.isIdentifier()) {
    const binding = this.scope.getBinding(this.node.name);
    if (!binding) return false;
    return binding.constant;
  }
  if (this.isLiteral()) {
    if (this.isRegExpLiteral()) {
      return false;
    }
    if (this.isTemplateLiteral()) {
      return this.get("expressions").every(expression =>
        expression.isConstantExpression(),
      );
    }
    return true;
  }
  if (this.isUnaryExpression()) {
    if (this.get("operator").node !== "void") {
      return false;
    }
    return this.get("argument").isConstantExpression();
  }
  if (this.isBinaryExpression()) {
    return (
      this.get("left").isConstantExpression() &&
      this.get("right").isConstantExpression()
    );
  }
  return false;
}
export function isInStrictMode() {
  const start = this.isProgram() ? this : this.parentPath;
  const strictParent = start.find(path => {
    if (path.isProgram({ sourceType: "module" })) return true;
    if (path.isClass()) return true;
    if (!path.isProgram() && !path.isFunction()) return false;
    if (
      path.isArrowFunctionExpression() &&
      !path.get("body").isBlockStatement()
    ) {
      return false;
    }
    let { node } = path;
    if (path.isFunction()) node = node.body;
    for (const directive of node.directives) {
      if (directive.value.value === "use strict") {
        return true;
      }
    }
  });
  return !!strictParent;
}

// </from> /home/qfox/apps/babel/packages/babel-traverse/src/path/introspection.js

// <from> /home/qfox/apps/babel/packages/babel-traverse/src/path/conversion.js

// This file contains methods that convert the path node into another node or some other type of data.
import * as t from "@babel/types";
import nameFunction from "@babel/helper-function-name";
export function toComputedKey(): Object {
  const node = this.node;
  let key;
  if (this.isMemberExpression()) {
    key = node.property;
  } else if (this.isProperty() || this.isMethod()) {
    key = node.key;
  } else {
    throw new ReferenceError("todo");
  }
  if (!node.computed) {
    if (t.isIdentifier(key)) key = t.stringLiteral(key.name);
  }
  return key;
}
export function ensureBlock() {
  const body = this.get("body");
  const bodyNode = body.node;
  if (Array.isArray(body)) {
    throw new Error("Can't convert array path to a block statement");
  }
  if (!bodyNode) {
    throw new Error("Can't convert node without a body");
  }
  if (body.isBlockStatement()) {
    return bodyNode;
  }
  const statements = [];
  let stringPath = "body";
  let key;
  let listKey;
  if (body.isStatement()) {
    listKey = "body";
    key = 0;
    statements.push(body.node);
  } else {
    stringPath += ".body.0";
    if (this.isFunction()) {
      key = "argument";
      statements.push(t.returnStatement(body.node));
    } else {
      key = "expression";
      statements.push(t.expressionStatement(body.node));
    }
  }
  this.node.body = t.blockStatement(statements);
  const parentPath = this.get(stringPath);
  body.setup(
    parentPath,
    listKey ? parentPath.node[listKey] : parentPath.node,
    listKey,
    key,
  );
  return this.node;
}
/**
 * Keeping this for backward-compatibility. You should use arrowFunctionToExpression() for >=7.x.
 */
export function arrowFunctionToShadowed() {
  if (!this.isArrowFunctionExpression()) return;
  this.arrowFunctionToExpression();
}
/**
 * Given an arbitrary function, process its content as if it were an arrow function, moving references
 * to "this", "arguments", "super", and such into the function's parent scope. This method is useful if
 * you have wrapped some set of items in an IIFE or other function, but want "this", "arguments", and super"
 * to continue behaving as expected.
 */
export function unwrapFunctionEnvironment() {
  if (
    !this.isArrowFunctionExpression() &&
    !this.isFunctionExpression() &&
    !this.isFunctionDeclaration()
  ) {
    throw this.buildCodeFrameError(
      "Can only unwrap the environment of a function.",
    );
  }
  hoistFunctionEnvironment(this);
}
/**
 * Convert a given arrow function into a normal ES5 function expression.
 */
export function arrowFunctionToExpression({
  allowInsertArrow = true,
  specCompliant = false,
} = {}) {
  if (!this.isArrowFunctionExpression()) {
    throw this.buildCodeFrameError(
      "Cannot convert non-arrow function to a function expression.",
    );
  }
  const thisBinding = hoistFunctionEnvironment(
    this,
    specCompliant,
    allowInsertArrow,
  );
  this.ensureBlock();
  this.node.type = "FunctionExpression";
  if (specCompliant) {
    const checkBinding = thisBinding
      ? null
      : this.parentPath.scope.generateUidIdentifier("arrowCheckId");
    if (checkBinding) {
      this.parentPath.scope.push({
        id: checkBinding,
        init: t.objectExpression([]),
      });
    }
    this.get("body").unshiftContainer(
      "body",
      t.expressionStatement(
        t.callExpression(this.hub.addHelper("newArrowCheck"), [
          t.thisExpression(),
          checkBinding
            ? t.identifier(checkBinding.name)
            : t.identifier(thisBinding),
        ]),
      ),
    );
    this.replaceWith(
      t.callExpression(
        t.memberExpression(
          nameFunction(this, true) || this.node,
          t.identifier("bind"),
        ),
        [checkBinding ? t.identifier(checkBinding.name) : t.thisExpression()],
      ),
    );
  }
}
/**
 * Given a function, traverse its contents, and if there are references to "this", "arguments", "super",
 * or "new.target", ensure that these references reference the parent environment around this function.
 */
function hoistFunctionEnvironment(
  fnPath,
  specCompliant = false,
  allowInsertArrow = true,
) {
  const thisEnvFn = fnPath.findParent(p => {
    return (
      (p.isFunction() && !p.isArrowFunctionExpression()) ||
      p.isProgram() ||
      p.isClassProperty({ static: false })
    );
  });
  const inConstructor = thisEnvFn && thisEnvFn.node.kind === "constructor";
  if (thisEnvFn.isClassProperty()) {
    throw fnPath.buildCodeFrameError(
      "Unable to transform arrow inside class property",
    );
  }
  const {
    thisPaths,
    argumentsPaths,
    newTargetPaths,
    superProps,
    superCalls,
  } = getScopeInformation(fnPath);
  // Convert all super() calls in the constructor, if super is used in an arrow.
  if (inConstructor && superCalls.length > 0) {
    if (!allowInsertArrow) {
      throw superCalls[0].buildCodeFrameError(
        "Unable to handle nested super() usage in arrow",
      );
    }
    const allSuperCalls = [];
    thisEnvFn.traverse({
      Function(child) {
        if (child.isArrowFunctionExpression()) return;
        child.skip();
      },
      ClassProperty(child) {
        if (child.node.static) return;
        child.skip();
      },
      CallExpression(child) {
        if (!child.get("callee").isSuper()) return;
        allSuperCalls.push(child);
      },
    });
    const superBinding = getSuperBinding(thisEnvFn);
    allSuperCalls.forEach(superCall => {
      const callee = t.identifier(superBinding);
      callee.loc = superCall.node.callee.loc;
      superCall.get("callee").replaceWith(callee);
    });
  }
  // Convert all "this" references in the arrow to point at the alias.
  let thisBinding;
  if (thisPaths.length > 0 || specCompliant) {
    thisBinding = getThisBinding(thisEnvFn, inConstructor);
    if (
      !specCompliant ||
      // In subclass constructors, still need to rewrite because "this" can't be bound in spec mode
      // because it might not have been initialized yet.
      (inConstructor && hasSuperClass(thisEnvFn))
    ) {
      thisPaths.forEach(thisChild => {
        const thisRef = thisChild.isJSX()
          ? t.jsxIdentifier(thisBinding)
          : t.identifier(thisBinding);
        thisRef.loc = thisChild.node.loc;
        thisChild.replaceWith(thisRef);
      });
      if (specCompliant) thisBinding = null;
    }
  }
  // Convert all "arguments" references in the arrow to point at the alias.
  if (argumentsPaths.length > 0) {
    const argumentsBinding = getBinding(thisEnvFn, "arguments", () =>
      t.identifier("arguments"),
    );
    argumentsPaths.forEach(argumentsChild => {
      const argsRef = t.identifier(argumentsBinding);
      argsRef.loc = argumentsChild.node.loc;
      argumentsChild.replaceWith(argsRef);
    });
  }
  // Convert all "new.target" references in the arrow to point at the alias.
  if (newTargetPaths.length > 0) {
    const newTargetBinding = getBinding(thisEnvFn, "newtarget", () =>
      t.metaProperty(t.identifier("new"), t.identifier("target")),
    );
    newTargetPaths.forEach(targetChild => {
      const targetRef = t.identifier(newTargetBinding);
      targetRef.loc = targetChild.node.loc;
      targetChild.replaceWith(targetRef);
    });
  }
  // Convert all "super.prop" references to point at aliases.
  if (superProps.length > 0) {
    if (!allowInsertArrow) {
      throw superProps[0].buildCodeFrameError(
        "Unable to handle nested super.prop usage",
      );
    }
    const flatSuperProps = superProps.reduce(
      (acc, superProp) => acc.concat(standardizeSuperProperty(superProp)),
      [],
    );
    flatSuperProps.forEach(superProp => {
      const key = superProp.node.computed
        ? ""
        : superProp.get("property").node.name;
      if (superProp.parentPath.isCallExpression({ callee: superProp.node })) {
        const superBinding = getSuperPropCallBinding(thisEnvFn, key);
        if (superProp.node.computed) {
          const prop = superProp.get("property").node;
          superProp.replaceWith(t.identifier(superBinding));
          superProp.parentPath.node.arguments.unshift(prop);
        } else {
          superProp.replaceWith(t.identifier(superBinding));
        }
      } else {
        const isAssignment = superProp.parentPath.isAssignmentExpression({
          left: superProp.node,
        });
        const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);
        const args = [];
        if (superProp.node.computed) {
          args.push(superProp.get("property").node);
        }
        if (isAssignment) {
          const value = superProp.parentPath.node.right;
          args.push(value);
          superProp.parentPath.replaceWith(
            t.callExpression(t.identifier(superBinding), args),
          );
        } else {
          superProp.replaceWith(
            t.callExpression(t.identifier(superBinding), args),
          );
        }
      }
    });
  }
  return thisBinding;
}
function standardizeSuperProperty(superProp) {
  if (
    superProp.parentPath.isAssignmentExpression() &&
    superProp.parentPath.node.operator !== "="
  ) {
    const assignmentPath = superProp.parentPath;
    const op = assignmentPath.node.operator.slice(0, -1);
    const value = assignmentPath.node.right;
    assignmentPath.node.operator = "=";
    if (superProp.node.computed) {
      const tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
      assignmentPath
        .get("left")
        .replaceWith(
          t.memberExpression(
            superProp.node.object,
            t.assignmentExpression("=", tmp, superProp.node.property),
            true /* computed */,
          ),
        );
      assignmentPath
        .get("right")
        .replaceWith(
          t.binaryExpression(
            op,
            t.memberExpression(
              superProp.node.object,
              t.identifier(tmp.name),
              true /* computed */,
            ),
            value,
          ),
        );
    } else {
      assignmentPath
        .get("left")
        .replaceWith(
          t.memberExpression(superProp.node.object, superProp.node.property),
        );
      assignmentPath
        .get("right")
        .replaceWith(
          t.binaryExpression(
            op,
            t.memberExpression(
              superProp.node.object,
              t.identifier(superProp.node.property.name),
            ),
            value,
          ),
        );
    }
    return [
      assignmentPath.get("left"),
      assignmentPath.get("right").get("left"),
    ];
  } else if (superProp.parentPath.isUpdateExpression()) {
    const updateExpr = superProp.parentPath;
    const tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
    const computedKey = superProp.node.computed
      ? superProp.scope.generateDeclaredUidIdentifier("prop")
      : null;
    const parts = [
      t.assignmentExpression(
        "=",
        tmp,
        t.memberExpression(
          superProp.node.object,
          computedKey
            ? t.assignmentExpression("=", computedKey, superProp.node.property)
            : superProp.node.property,
          superProp.node.computed,
        ),
      ),
      t.assignmentExpression(
        "=",
        t.memberExpression(
          superProp.node.object,
          computedKey
            ? t.identifier(computedKey.name)
            : superProp.node.property,
          superProp.node.computed,
        ),
        t.binaryExpression("+", t.identifier(tmp.name), t.numericLiteral(1)),
      ),
    ];
    if (!superProp.parentPath.node.prefix) {
      parts.push(t.identifier(tmp.name));
    }
    updateExpr.replaceWith(t.sequenceExpression(parts));
    const left = updateExpr.get("expressions.0.right");
    const right = updateExpr.get("expressions.1.left");
    return [left, right];
  }
  return [superProp];
}
function hasSuperClass(thisEnvFn) {
  return (
    thisEnvFn.isClassMethod() &&
    !!thisEnvFn.parentPath.parentPath.node.superClass
  );
}
// Create a binding that evaluates to the "this" of the given function.
function getThisBinding(thisEnvFn, inConstructor) {
  return getBinding(thisEnvFn, "this", thisBinding => {
    if (!inConstructor || !hasSuperClass(thisEnvFn)) return t.thisExpression();
    const supers = new WeakSet();
    thisEnvFn.traverse({
      Function(child) {
        if (child.isArrowFunctionExpression()) return;
        child.skip();
      },
      ClassProperty(child) {
        if (child.node.static) return;
        child.skip();
      },
      CallExpression(child) {
        if (!child.get("callee").isSuper()) return;
        if (supers.has(child.node)) return;
        supers.add(child.node);
        child.replaceWith(
          t.assignmentExpression("=", t.identifier(thisBinding), child.node),
        );
      },
    });
  });
}
// Create a binding for a function that will call "super()" with arguments passed through.
function getSuperBinding(thisEnvFn) {
  return getBinding(thisEnvFn, "supercall", () => {
    const argsBinding = thisEnvFn.scope.generateUidIdentifier("args");
    return t.arrowFunctionExpression(
      [t.restElement(argsBinding)],
      t.callExpression(t.super(), [
        t.spreadElement(t.identifier(argsBinding.name)),
      ]),
    );
  });
}
// Create a binding for a function that will call "super.foo()" or "super[foo]()".
function getSuperPropCallBinding(thisEnvFn, propName) {
  return getBinding(thisEnvFn, `superprop_call:${propName || ""}`, () => {
    const argsBinding = thisEnvFn.scope.generateUidIdentifier("args");
    const argsList = [t.restElement(argsBinding)];
    let fnBody;
    if (propName) {
      // (...args) => super.foo(...args)
      fnBody = t.callExpression(
        t.memberExpression(t.super(), t.identifier(propName)),
        [t.spreadElement(t.identifier(argsBinding.name))],
      );
    } else {
      const method = thisEnvFn.scope.generateUidIdentifier("prop");
      // (method, ...args) => super[method](...args)
      argsList.unshift(method);
      fnBody = t.callExpression(
        t.memberExpression(
          t.super(),
          t.identifier(method.name),
          true /* computed */,
        ),
        [t.spreadElement(t.identifier(argsBinding.name))],
      );
    }
    return t.arrowFunctionExpression(argsList, fnBody);
  });
}
// Create a binding for a function that will call "super.foo" or "super[foo]".
function getSuperPropBinding(thisEnvFn, isAssignment, propName) {
  const op = isAssignment ? "set" : "get";
  return getBinding(thisEnvFn, `superprop_${op}:${propName || ""}`, () => {
    const argsList = [];
    let fnBody;
    if (propName) {
      // () => super.foo
      fnBody = t.memberExpression(t.super(), t.identifier(propName));
    } else {
      const method = thisEnvFn.scope.generateUidIdentifier("prop");
      // (method) => super[method]
      argsList.unshift(method);
      fnBody = t.memberExpression(
        t.super(),
        t.identifier(method.name),
        true /* computed */,
      );
    }
    if (isAssignment) {
      const valueIdent = thisEnvFn.scope.generateUidIdentifier("value");
      argsList.push(valueIdent);
      fnBody = t.assignmentExpression(
        "=",
        fnBody,
        t.identifier(valueIdent.name),
      );
    }
    return t.arrowFunctionExpression(argsList, fnBody);
  });
}
function getBinding(thisEnvFn, key, init) {
  const cacheKey = "binding:" + key;
  let data = thisEnvFn.getData(cacheKey);
  if (!data) {
    const id = thisEnvFn.scope.generateUidIdentifier(key);
    data = id.name;
    thisEnvFn.setData(cacheKey, data);
    thisEnvFn.scope.push({
      id: id,
      init: init(data),
    });
  }
  return data;
}
function getScopeInformation(fnPath) {
  const thisPaths = [];
  const argumentsPaths = [];
  const newTargetPaths = [];
  const superProps = [];
  const superCalls = [];
  fnPath.traverse({
    ClassProperty(child) {
      if (child.node.static) return;
      child.skip();
    },
    Function(child) {
      if (child.isArrowFunctionExpression()) return;
      child.skip();
    },
    ThisExpression(child) {
      thisPaths.push(child);
    },
    JSXIdentifier(child) {
      if (child.node.name !== "this") return;
      if (
        !child.parentPath.isJSXMemberExpression({ object: child.node }) &&
        !child.parentPath.isJSXOpeningElement({ name: child.node })
      ) {
        return;
      }
      thisPaths.push(child);
    },
    CallExpression(child) {
      if (child.get("callee").isSuper()) superCalls.push(child);
    },
    MemberExpression(child) {
      if (child.get("object").isSuper()) superProps.push(child);
    },
    ReferencedIdentifier(child) {
      if (child.node.name !== "arguments") return;
      argumentsPaths.push(child);
    },
    MetaProperty(child) {
      if (!child.get("meta").isIdentifier({ name: "new" })) return;
      if (!child.get("property").isIdentifier({ name: "target" })) return;
      newTargetPaths.push(child);
    },
  });
  return {
    thisPaths,
    argumentsPaths,
    newTargetPaths,
    superProps,
    superCalls,
  };
}

// </from> /home/qfox/apps/babel/packages/babel-traverse/src/path/conversion.js

// <from> /home/qfox/apps/babel/packages/babel-traverse/src/path/context.js

// This file contains methods responsible for maintaining a TraversalContext.
import traverse from "../index";
export function call(key): boolean {
  const opts = this.opts;
  this.debug(key);
  if (this.node) {
    if (this._call(opts[key])) return true;
  }
  if (this.node) {
    return this._call(opts[this.node.type] && opts[this.node.type][key]);
  }
  return false;
}
export function _call(fns?: Array<Function>): boolean {
  if (!fns) return false;
  for (const fn of fns) {
    if (!fn) continue;
    const node = this.node;
    if (!node) return true;
    const ret = fn.call(this.state, this, this.state);
    if (ret && typeof ret === "object" && typeof ret.then === "function") {
      throw new Error(
        `You appear to be using a plugin with an async traversal visitor, ` +
          `which your current version of Babel does not support.` +
          `If you're using a published plugin, you may need to upgrade ` +
          `your @babel/core version.`,
      );
    }
    if (ret) {
      throw new Error(`Unexpected return value from visitor method ${fn}`);
    }
    // node has been replaced, it will have been requeued
    if (this.node !== node) return true;
    if (this.shouldStop || this.shouldSkip || this.removed) return true;
  }
  return false;
}
export function isBlacklisted(): boolean {
  const blacklist = this.opts.blacklist;
  return blacklist && blacklist.indexOf(this.node.type) > -1;
}
export function visit(): boolean {
  if (!this.node) {
    return false;
  }
  if (this.isBlacklisted()) {
    return false;
  }
  if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {
    return false;
  }
  if (this.call("enter") || this.shouldSkip) {
    this.debug("Skip...");
    return this.shouldStop;
  }
  this.debug("Recursing into...");
  traverse.node(
    this.node,
    this.opts,
    this.scope,
    this.state,
    this,
    this.skipKeys,
  );
  this.call("exit");
  return this.shouldStop;
}
export function skip() {
  this.shouldSkip = true;
}
export function skipKey(key) {
  this.skipKeys[key] = true;
}
export function stop() {
  this.shouldStop = true;
  this.shouldSkip = true;
}
export function setScope() {
  if (this.opts && this.opts.noScope) return;
  let path = this.parentPath;
  let target;
  while (path && !target) {
    if (path.opts && path.opts.noScope) return;
    target = path.scope;
    path = path.parentPath;
  }
  this.scope = this.getScope(target);
  if (this.scope) this.scope.init();
}
export function setContext(context) {
  this.shouldSkip = false;
  this.shouldStop = false;
  this.removed = false;
  this.skipKeys = {};
  if (context) {
    this.context = context;
    this.state = context.state;
    this.opts = context.opts;
  }
  this.setScope();
  return this;
}
/**
 * Here we resync the node paths `key` and `container`. If they've changed according
 * to what we have stored internally then we attempt to resync by crawling and looking
 * for the new values.
 */
export function resync() {
  if (this.removed) return;
  this._resyncParent();
  this._resyncList();
  this._resyncKey();
  //this._resyncRemoved();
}
export function _resyncParent() {
  if (this.parentPath) {
    this.parent = this.parentPath.node;
  }
}
export function _resyncKey() {
  if (!this.container) return;
  if (this.node === this.container[this.key]) return;
  // grrr, path key is out of sync. this is likely due to a modification to the AST
  // not done through our path APIs
  if (Array.isArray(this.container)) {
    for (let i = 0; i < this.container.length; i++) {
      if (this.container[i] === this.node) {
        return this.setKey(i);
      }
    }
  } else {
    for (const key in this.container) {
      if (this.container[key] === this.node) {
        return this.setKey(key);
      }
    }
  }
  // \_()_/ who knows where it's gone lol
  this.key = null;
}
export function _resyncList() {
  if (!this.parent || !this.inList) return;
  const newContainer = this.parent[this.listKey];
  if (this.container === newContainer) return;
  // container is out of sync. this is likely the result of it being reassigned
  this.container = newContainer || null;
}
export function _resyncRemoved() {
  if (
    this.key == null ||
    !this.container ||
    this.container[this.key] !== this.node
  ) {
    this._markRemoved();
  }
}
export function popContext() {
  this.contexts.pop();
  if (this.contexts.length > 0) {
    this.setContext(this.contexts[this.contexts.length - 1]);
  } else {
    this.setContext(undefined);
  }
}
export function pushContext(context) {
  this.contexts.push(context);
  this.setContext(context);
}
export function setup(parentPath, container, listKey, key) {
  this.inList = !!listKey;
  this.listKey = listKey;
  this.parentKey = listKey || key;
  this.container = container;
  this.parentPath = parentPath || this.parentPath;
  this.setKey(key);
}
export function setKey(key) {
  this.key = key;
  this.node = this.container[this.key];
  this.type = this.node && this.node.type;
}
export function requeue(pathToQueue = this) {
  if (pathToQueue.removed) return;
  // TODO(loganfsmyth): This should be switched back to queue in parent contexts
  // automatically once #2892 and #4135 have been resolved. See #4140.
  // let contexts = this._getQueueContexts();
  const contexts = this.contexts;
  for (const context of contexts) {
    context.maybeQueue(pathToQueue);
  }
}
export function _getQueueContexts() {
  let path = this;
  let contexts = this.contexts;
  while (!contexts.length) {
    path = path.parentPath;
    if (!path) break;
    contexts = path.contexts;
  }
  return contexts;
}

// </from> /home/qfox/apps/babel/packages/babel-traverse/src/path/context.js

// <from> /home/qfox/apps/babel/packages/babel-traverse/src/path/removal.js

// This file contains methods responsible for removing a node.
import { hooks } from "./lib/removal-hooks";
export function remove() {
  this._assertUnremoved();
  this.resync();
  this._removeFromScope();
  if (this._callRemovalHooks()) {
    this._markRemoved();
    return;
  }
  this.shareCommentsWithSiblings();
  this._remove();
  this._markRemoved();
}
export function _removeFromScope() {
  const bindings = this.getBindingIdentifiers();
  Object.keys(bindings).forEach(name => this.scope.removeBinding(name));
}
export function _callRemovalHooks() {
  for (const fn of (hooks: Array<Function>)) {
    if (fn(this, this.parentPath)) return true;
  }
}
export function _remove() {
  if (Array.isArray(this.container)) {
    this.container.splice(this.key, 1);
    this.updateSiblingKeys(this.key, -1);
  } else {
    this._replaceWith(null);
  }
}
export function _markRemoved() {
  this.shouldSkip = true;
  this.removed = true;
  this.node = null;
}
export function _assertUnremoved() {
  if (this.removed) {
    throw this.buildCodeFrameError(
      "NodePath has been removed so is read-only.",
    );
  }
}

// </from> /home/qfox/apps/babel/packages/babel-traverse/src/path/removal.js

// <from> /home/qfox/apps/babel/packages/babel-traverse/src/path/ancestry.js

// This file contains that retrieve or validate anything related to the current paths ancestry.
import * as t from "@babel/types";
import NodePath from "./index";
/**
 * Call the provided `callback` with the `NodePath`s of all the parents.
 * When the `callback` returns a truthy value, we return that node path.
 */
export function findParent(callback): ?NodePath {
  let path = this;
  while ((path = path.parentPath)) {
    if (callback(path)) return path;
  }
  return null;
}
/**
 * Starting at current `NodePath` and going up the tree, return the first
 * `NodePath` that causes the provided `callback` to return a truthy value.
 */
export function find(callback): ?NodePath {
  let path = this;
  do {
    if (callback(path)) return path;
  } while ((path = path.parentPath));
  return null;
}
/**
 * Get the parent function of the current path.
 */
export function getFunctionParent(): ?NodePath {
  return this.findParent(p => p.isFunction());
}
/**
 * Walk up the tree until we hit a parent node path in a list.
 */
export function getStatementParent(): NodePath {
  let path = this;
  do {
    if (
      !path.parentPath ||
      (Array.isArray(path.container) && path.isStatement())
    ) {
      break;
    } else {
      path = path.parentPath;
    }
  } while (path);
  if (path && (path.isProgram() || path.isFile())) {
    throw new Error(
      "File/Program node, we can't possibly find a statement parent to this",
    );
  }
  return path;
}
/**
 * Get the deepest common ancestor and then from it, get the earliest relationship path
 * to that ancestor.
 *
 * Earliest is defined as being "before" all the other nodes in terms of list container
 * position and visiting key.
 */
export function getEarliestCommonAncestorFrom(
  paths: Array<NodePath>,
): NodePath {
  return this.getDeepestCommonAncestorFrom(paths, function(
    deepest,
    i,
    ancestries,
  ) {
    let earliest;
    const keys = t.VISITOR_KEYS[deepest.type];
    for (const ancestry of (ancestries: Array)) {
      const path = ancestry[i + 1];
      // first path
      if (!earliest) {
        earliest = path;
        continue;
      }
      // handle containers
      if (path.listKey && earliest.listKey === path.listKey) {
        // we're in the same container so check if we're earlier
        if (path.key < earliest.key) {
          earliest = path;
          continue;
        }
      }
      // handle keys
      const earliestKeyIndex = keys.indexOf(earliest.parentKey);
      const currentKeyIndex = keys.indexOf(path.parentKey);
      if (earliestKeyIndex > currentKeyIndex) {
        // key appears before so it's earlier
        earliest = path;
      }
    }
    return earliest;
  });
}
/**
 * Get the earliest path in the tree where the provided `paths` intersect.
 *
 * TODO: Possible optimisation target.
 */
export function getDeepestCommonAncestorFrom(
  paths: Array<NodePath>,
  filter?: Function,
): NodePath {
  if (!paths.length) {
    return this;
  }
  if (paths.length === 1) {
    return paths[0];
  }
  // minimum depth of the tree so we know the highest node
  let minDepth = Infinity;
  // last common ancestor
  let lastCommonIndex, lastCommon;
  // get the ancestors of the path, breaking when the parent exceeds ourselves
  const ancestries = paths.map(path => {
    const ancestry = [];
    do {
      ancestry.unshift(path);
    } while ((path = path.parentPath) && path !== this);
    // save min depth to avoid going too far in
    if (ancestry.length < minDepth) {
      minDepth = ancestry.length;
    }
    return ancestry;
  });
  // get the first ancestry so we have a seed to assess all other ancestries with
  const first = ancestries[0];
  // check ancestor equality
  depthLoop: for (let i = 0; i < minDepth; i++) {
    const shouldMatch = first[i];
    for (const ancestry of (ancestries: Array)) {
      if (ancestry[i] !== shouldMatch) {
        // we've hit a snag
        break depthLoop;
      }
    }
    // next iteration may break so store these so they can be returned
    lastCommonIndex = i;
    lastCommon = shouldMatch;
  }
  if (lastCommon) {
    if (filter) {
      return filter(lastCommon, lastCommonIndex, ancestries);
    } else {
      return lastCommon;
    }
  } else {
    throw new Error("Couldn't find intersection");
  }
}
/**
 * Build an array of node paths containing the entire ancestry of the current node path.
 *
 * NOTE: The current node path is included in this.
 */
export function getAncestry(): Array<NodePath> {
  let path = this;
  const paths = [];
  do {
    paths.push(path);
  } while ((path = path.parentPath));
  return paths;
}
/**
 * A helper to find if `this` path is an ancestor of @param maybeDescendant
 */
export function isAncestor(maybeDescendant: NodePath): boolean {
  return maybeDescendant.isDescendant(this);
}
/**
 * A helper to find if `this` path is a descendant of @param maybeAncestor
 */
export function isDescendant(maybeAncestor: NodePath): boolean {
  return !!this.findParent(parent => parent === maybeAncestor);
}
export function inType(): boolean {
  let path = this;
  while (path) {
    for (const type of (arguments: Array)) {
      if (path.node.type === type) return true;
    }
    path = path.parentPath;
  }
  return false;
}

// </from> /home/qfox/apps/babel/packages/babel-traverse/src/path/ancestry.js

// <from> /home/qfox/apps/babel/packages/babel-traverse/src/path/comments.js

// This file contains methods responsible for dealing with comments.
import * as t from "@babel/types";
/**
 * Share comments amongst siblings.
 */
export function shareCommentsWithSiblings() {
  // NOTE: this assumes numbered keys
  if (typeof this.key === "string") return;
  const node = this.node;
  if (!node) return;
  const trailing = node.trailingComments;
  const leading = node.leadingComments;
  if (!trailing && !leading) return;
  const prev = this.getSibling(this.key - 1);
  const next = this.getSibling(this.key + 1);
  const hasPrev = Boolean(prev.node);
  const hasNext = Boolean(next.node);
  if (hasPrev && hasNext) {
  } else if (hasPrev) {
    prev.addComments("trailing", trailing);
  } else if (hasNext) {
    next.addComments("leading", leading);
  }
}
export function addComment(type: string, content: string, line?: boolean) {
  t.addComment(this.node, type, content, line);
}
/**
 * Give node `comments` of the specified `type`.
 */
export function addComments(type: string, comments: Array) {
  t.addComments(this.node, type, comments);
}

// </from> /home/qfox/apps/babel/packages/babel-traverse/src/path/comments.js

// <from> /home/qfox/apps/babel/packages/babel-traverse/src/path/replacement.js

// This file contains methods responsible for replacing a node with another.
import { codeFrameColumns } from "@babel/code-frame";
import traverse from "../index";
import NodePath from "./index";
import { parse } from "@babel/parser";
import * as t from "@babel/types";
const hoistVariablesVisitor = {
  Function(path) {
    path.skip();
  },
  VariableDeclaration(path) {
    if (path.node.kind !== "var") return;
    const bindings = path.getBindingIdentifiers();
    for (const key in bindings) {
      path.scope.push({ id: bindings[key] });
    }
    const exprs = [];
    for (const declar of (path.node.declarations: Array<Object>)) {
      if (declar.init) {
        exprs.push(
          t.expressionStatement(
            t.assignmentExpression("=", declar.id, declar.init),
          ),
        );
      }
    }
    path.replaceWithMultiple(exprs);
  },
};
/**
 * Replace a node with an array of multiple. This method performs the following steps:
 *
 *  - Inherit the comments of first provided node with that of the current node.
 *  - Insert the provided nodes after the current node.
 *  - Remove the current node.
 */
export function replaceWithMultiple(nodes: Array<Object>) {
  this.resync();
  nodes = this._verifyNodeList(nodes);
  t.inheritLeadingComments(nodes[0], this.node);
  t.inheritTrailingComments(nodes[nodes.length - 1], this.node);
  this.node = this.container[this.key] = null;
  const paths = this.insertAfter(nodes);
  if (this.node) {
    this.requeue();
  } else {
    this.remove();
  }
  return paths;
}
/**
 * Parse a string as an expression and replace the current node with the result.
 *
 * NOTE: This is typically not a good idea to use. Building source strings when
 * transforming ASTs is an antipattern and SHOULD NOT be encouraged. Even if it's
 * easier to use, your transforms will be extremely brittle.
 */
export function replaceWithSourceString(replacement) {
  this.resync();
  try {
    replacement = `(${replacement})`;
    replacement = parse(replacement);
  } catch (err) {
    const loc = err.loc;
    if (loc) {
      err.message +=
        " - make sure this is an expression.\n" +
        codeFrameColumns(replacement, {
          start: {
            line: loc.line,
            column: loc.column + 1,
          },
        });
      err.code = "BABEL_REPLACE_SOURCE_ERROR";
    }
    throw err;
  }
  replacement = replacement.program.body[0].expression;
  traverse.removeProperties(replacement);
  return this.replaceWith(replacement);
}
/**
 * Replace the current node with another.
 */
export function replaceWith(replacement) {
  this.resync();
  if (this.removed) {
    throw new Error("You can't replace this node, we've already removed it");
  }
  if (replacement instanceof NodePath) {
    replacement = replacement.node;
  }
  if (!replacement) {
    throw new Error(
      "You passed `path.replaceWith()` a falsy node, use `path.remove()` instead",
    );
  }
  if (this.node === replacement) {
    return [this];
  }
  if (this.isProgram() && !t.isProgram(replacement)) {
    throw new Error(
      "You can only replace a Program root node with another Program node",
    );
  }
  if (Array.isArray(replacement)) {
    throw new Error(
      "Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`",
    );
  }
  if (typeof replacement === "string") {
    throw new Error(
      "Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`",
    );
  }
  let nodePath = "";
  if (this.isNodeType("Statement") && t.isExpression(replacement)) {
    if (
      !this.canHaveVariableDeclarationOrExpression() &&
      !this.canSwapBetweenExpressionAndStatement(replacement) &&
      !this.parentPath.isExportDefaultDeclaration()
    ) {
      // replacing a statement with an expression so wrap it in an expression statement
      replacement = t.expressionStatement(replacement);
      nodePath = "expression";
    }
  }
  if (this.isNodeType("Expression") && t.isStatement(replacement)) {
    if (
      !this.canHaveVariableDeclarationOrExpression() &&
      !this.canSwapBetweenExpressionAndStatement(replacement)
    ) {
      // replacing an expression with a statement so let's explode it
      return this.replaceExpressionWithStatements([replacement]);
    }
  }
  const oldNode = this.node;
  if (oldNode) {
    t.inheritsComments(replacement, oldNode);
    t.removeComments(oldNode);
  }
  // replace the node
  this._replaceWith(replacement);
  this.type = replacement.type;
  // potentially create new scope
  this.setScope();
  // requeue for visiting
  this.requeue();
  return [nodePath ? this.get(nodePath) : this];
}
/**
 * Description
 */
export function _replaceWith(node) {
  if (!this.container) {
    throw new ReferenceError("Container is falsy");
  }
  if (this.inList) {
    t.validate(this.parent, this.key, [node]);
  } else {
    t.validate(this.parent, this.key, node);
  }
  this.debug(`Replace with ${node && node.type}`);
  this.node = this.container[this.key] = node;
}
/**
 * This method takes an array of statements nodes and then explodes it
 * into expressions. This method retains completion records which is
 * extremely important to retain original semantics.
 */
export function replaceExpressionWithStatements(nodes: Array<Object>) {
  this.resync();
  const toSequenceExpression = t.toSequenceExpression(nodes, this.scope);
  if (toSequenceExpression) {
    return this.replaceWith(toSequenceExpression)[0].get("expressions");
  }
  const container = t.arrowFunctionExpression([], t.blockStatement(nodes));
  this.replaceWith(t.callExpression(container, []));
  this.traverse(hoistVariablesVisitor);
  // add implicit returns to all ending expression statements
  const completionRecords: Array<NodePath> = this.get(
    "callee",
  ).getCompletionRecords();
  for (const path of completionRecords) {
    if (!path.isExpressionStatement()) continue;
    const loop = path.findParent(path => path.isLoop());
    if (loop) {
      let uid = loop.getData("expressionReplacementReturnUid");
      if (!uid) {
        const callee = this.get("callee");
        uid = callee.scope.generateDeclaredUidIdentifier("ret");
        callee
          .get("body")
          .pushContainer("body", t.returnStatement(t.cloneNode(uid)));
        loop.setData("expressionReplacementReturnUid", uid);
      } else {
        uid = t.identifier(uid.name);
      }
      path
        .get("expression")
        .replaceWith(
          t.assignmentExpression("=", t.cloneNode(uid), path.node.expression),
        );
    } else {
      path.replaceWith(t.returnStatement(path.node.expression));
    }
  }
  const callee = this.get("callee");
  callee.arrowFunctionToExpression();
  return callee.get("body.body");
}
export function replaceInline(nodes: Object | Array<Object>) {
  this.resync();
  if (Array.isArray(nodes)) {
    if (Array.isArray(this.container)) {
      nodes = this._verifyNodeList(nodes);
      const paths = this._containerInsertAfter(nodes);
      this.remove();
      return paths;
    } else {
      return this.replaceWithMultiple(nodes);
    }
  } else {
    return this.replaceWith(nodes);
  }
}

// </from> /home/qfox/apps/babel/packages/babel-traverse/src/path/replacement.js

// <from> /home/qfox/apps/babel/packages/babel-traverse/src/path/lib/removal-hooks.js

// this file contains hooks that handle ancestry cleanup of parent nodes when removing children
/**
 * Pre hooks should be used for either rejecting removal or delegating removal
 */
export const hooks = [
  function(self, parent) {
    const removeParent =
      // while (NODE);
      // removing the test of a while/switch, we can either just remove it entirely *or* turn the
      // `test` into `true` unlikely that the latter will ever be what's wanted so we just remove
      // the loop to avoid infinite recursion
      (self.key === "test" && (parent.isWhile() || parent.isSwitchCase())) ||
      // export NODE;
      // just remove a declaration for an export as this is no longer valid
      (self.key === "declaration" && parent.isExportDeclaration()) ||
      // label: NODE
      // stray labeled statement with no body
      (self.key === "body" && parent.isLabeledStatement()) ||
      // let NODE;
      // remove an entire declaration if there are no declarators left
      (self.listKey === "declarations" &&
        parent.isVariableDeclaration() &&
        parent.node.declarations.length === 1) ||
      // NODE;
      // remove the entire expression statement if there's no expression
      (self.key === "expression" && parent.isExpressionStatement());
    if (removeParent) {
      parent.remove();
      return true;
    }
  },
  function(self, parent) {
    if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {
      // (node, NODE);
      // we've just removed the second element of a sequence expression so let's turn that sequence
      // expression into a regular expression
      parent.replaceWith(parent.node.expressions[0]);
      return true;
    }
  },
  function(self, parent) {
    if (parent.isBinary()) {
      // left + NODE;
      // NODE + right;
      // we're in a binary expression, better remove it and replace it with the last expression
      if (self.key === "left") {
        parent.replaceWith(parent.node.right);
      } else {
        // key === "right"
        parent.replaceWith(parent.node.left);
      }
      return true;
    }
  },
  function(self, parent) {
    if (
      (parent.isIfStatement() &&
        (self.key === "consequent" || self.key === "alternate")) ||
      (self.key === "body" &&
        (parent.isLoop() || parent.isArrowFunctionExpression()))
    ) {
      self.replaceWith({
        type: "BlockStatement",
        body: [],
      });
      return true;
    }
  },
];

// </from> /home/qfox/apps/babel/packages/babel-traverse/src/path/lib/removal-hooks.js

// <from> /home/qfox/apps/babel/packages/babel-traverse/src/path/lib/hoister.js

import { react } from "@babel/types";
import * as t from "@babel/types";
const referenceVisitor = {
  // This visitor looks for bindings to establish a topmost scope for hoisting.
  ReferencedIdentifier(path, state) {
    // Don't hoist regular JSX identifiers ('div', 'span', etc).
    // We do have to consider member expressions for hoisting (e.g. `this.component`)
    if (
      path.isJSXIdentifier() &&
      react.isCompatTag(path.node.name) &&
      !path.parentPath.isJSXMemberExpression()
    ) {
      return;
    }
    // If the identifier refers to `this`, we need to break on the closest non-arrow scope.
    if (path.node.name === "this") {
      let scope = path.scope;
      do {
        if (
          scope.path.isFunction() &&
          !scope.path.isArrowFunctionExpression()
        ) {
          break;
        }
      } while ((scope = scope.parent));
      if (scope) state.breakOnScopePaths.push(scope.path);
    }
    // direct references that we need to track to hoist this to the highest scope we can
    const binding = path.scope.getBinding(path.node.name);
    if (!binding) return;
    // this binding isn't accessible from the parent scope so we can safely ignore it
    // eg. it's in a closure etc
    if (binding !== state.scope.getBinding(path.node.name)) return;
    state.bindings[path.node.name] = binding;
  },
};
export default class PathHoister {
  constructor(path, scope) {
    // Storage for scopes we can't hoist above.
    this.breakOnScopePaths = [];
    // Storage for bindings that may affect what path we can hoist to.
    this.bindings = {};
    // Storage for eligible scopes.
    this.scopes = [];
    // Our original scope and path.
    this.scope = scope;
    this.path = path;
    // By default, we attach as far up as we can; but if we're trying
    // to avoid referencing a binding, we may have to go after.
    this.attachAfter = false;
  }
  // A scope is compatible if all required bindings are reachable.
  isCompatibleScope(scope) {
    for (const key in this.bindings) {
      const binding = this.bindings[key];
      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {
        return false;
      }
    }
    return true;
  }
  // Look through all scopes and push compatible ones.
  getCompatibleScopes() {
    let scope = this.path.scope;
    do {
      if (this.isCompatibleScope(scope)) {
        this.scopes.push(scope);
      } else {
        break;
      }
      // deopt: These scopes are set in the visitor on const violations
      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {
        break;
      }
    } while ((scope = scope.parent));
  }
  getAttachmentPath() {
    let path = this._getAttachmentPath();
    if (!path) return;
    let targetScope = path.scope;
    // don't allow paths that have their own lexical environments to pollute
    if (targetScope.path === path) {
      targetScope = path.scope.parent;
    }
    // avoid hoisting to a scope that contains bindings that are executed after our attachment path
    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {
      for (const name in this.bindings) {
        // check binding is a direct child of this paths scope
        if (!targetScope.hasOwnBinding(name)) continue;
        const binding = this.bindings[name];
        // allow parameter references and expressions in params (like destructuring rest)
        if (binding.kind === "param" || binding.path.parentKey === "params") {
          continue;
        }
        // For each binding, get its attachment parent. This gives us an idea of where we might
        // introduce conflicts.
        const bindingParentPath = this.getAttachmentParentForPath(binding.path);
        // If the binding's attachment appears at or after our attachment point, then we move after it.
        if (bindingParentPath.key >= path.key) {
          this.attachAfter = true;
          path = binding.path;
          // We also move past any constant violations.
          for (const violationPath of (binding.constantViolations: Array)) {
            if (this.getAttachmentParentForPath(violationPath).key > path.key) {
              path = violationPath;
            }
          }
        }
      }
    }
    return path;
  }
  _getAttachmentPath() {
    const scopes = this.scopes;
    const scope = scopes.pop();
    // deopt: no compatible scopes
    if (!scope) return;
    if (scope.path.isFunction()) {
      if (this.hasOwnParamBindings(scope)) {
        // deopt: should ignore this scope since it's ourselves
        if (this.scope === scope) return;
        // needs to be attached to the body
        const bodies = scope.path.get("body").get("body");
        for (let i = 0; i < bodies.length; i++) {
          // Don't attach to something that's going to get hoisted,
          // like a default parameter
          if (bodies[i].node._blockHoist) continue;
          return bodies[i];
        }
        // deopt: If here, no attachment path found
      } else {
        // doesn't need to be be attached to this scope
        return this.getNextScopeAttachmentParent();
      }
    } else if (scope.path.isProgram()) {
      return this.getNextScopeAttachmentParent();
    }
  }
  getNextScopeAttachmentParent() {
    const scope = this.scopes.pop();
    if (scope) return this.getAttachmentParentForPath(scope.path);
  }
  // Find an attachment for this path.
  getAttachmentParentForPath(path) {
    do {
      if (
        // Beginning of the scope
        !path.parentPath ||
        // Has siblings and is a statement
        (Array.isArray(path.container) && path.isStatement())
      ) {
        return path;
      }
    } while ((path = path.parentPath));
  }
  // Returns true if a scope has param bindings.
  hasOwnParamBindings(scope) {
    for (const name in this.bindings) {
      if (!scope.hasOwnBinding(name)) continue;
      const binding = this.bindings[name];
      // Ensure constant; without it we could place behind a reassignment
      if (binding.kind === "param" && binding.constant) return true;
    }
    return false;
  }
  run() {
    this.path.traverse(referenceVisitor, this);
    this.getCompatibleScopes();
    const attachTo = this.getAttachmentPath();
    if (!attachTo) return;
    // don't bother hoisting to the same function as this will cause multiple branches to be
    // evaluated more than once leading to a bad optimisation
    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;
    // generate declaration and insert it to our point
    let uid = attachTo.scope.generateUidIdentifier("ref");
    const declarator = t.variableDeclarator(uid, this.path.node);
    const insertFn = this.attachAfter ? "insertAfter" : "insertBefore";
    const [attached] = attachTo[insertFn]([
      attachTo.isVariableDeclarator()
        ? declarator
        : t.variableDeclaration("var", [declarator]),
    ]);
    const parent = this.path.parentPath;
    if (parent.isJSXElement() && this.path.container === parent.node.children) {
      // turning the `span` in `<div><span /></div>` to an expression so we need to wrap it with
      // an expression container
      uid = t.JSXExpressionContainer(uid);
    }
    this.path.replaceWith(t.cloneNode(uid));
    return attachTo.isVariableDeclarator()
      ? attached.get("init")
      : attached.get("declarations.0.init");
  }
}

// </from> /home/qfox/apps/babel/packages/babel-traverse/src/path/lib/hoister.js

// <from> /home/qfox/apps/babel/packages/babel-traverse/src/path/lib/virtual-types.js

import { react } from "@babel/types";
import * as t from "@babel/types";
export const ReferencedIdentifier = {
  types: ["Identifier", "JSXIdentifier"],
  checkPath({ node, parent }: NodePath, opts?: Object): boolean {
    if (!t.isIdentifier(node, opts) && !t.isJSXMemberExpression(parent, opts)) {
      if (t.isJSXIdentifier(node, opts)) {
        if (react.isCompatTag(node.name)) return false;
      } else {
        // not a JSXIdentifier or an Identifier
        return false;
      }
    }
    // check if node is referenced
    return t.isReferenced(node, parent);
  },
};
export const ReferencedMemberExpression = {
  types: ["MemberExpression"],
  checkPath({ node, parent }) {
    return t.isMemberExpression(node) && t.isReferenced(node, parent);
  },
};
export const BindingIdentifier = {
  types: ["Identifier"],
  checkPath({ node, parent }: NodePath): boolean {
    return t.isIdentifier(node) && t.isBinding(node, parent);
  },
};
export const Statement = {
  types: ["Statement"],
  checkPath({ node, parent }: NodePath): boolean {
    if (t.isStatement(node)) {
      if (t.isVariableDeclaration(node)) {
        if (t.isForXStatement(parent, { left: node })) return false;
        if (t.isForStatement(parent, { init: node })) return false;
      }
      return true;
    } else {
      return false;
    }
  },
};
export const Expression = {
  types: ["Expression"],
  checkPath(path: NodePath): boolean {
    if (path.isIdentifier()) {
      return path.isReferencedIdentifier();
    } else {
      return t.isExpression(path.node);
    }
  },
};
export const Scope = {
  types: ["Scopable"],
  checkPath(path) {
    return t.isScope(path.node, path.parent);
  },
};
export const Referenced = {
  checkPath(path: NodePath): boolean {
    return t.isReferenced(path.node, path.parent);
  },
};
export const BlockScoped = {
  checkPath(path: NodePath): boolean {
    return t.isBlockScoped(path.node);
  },
};
export const Var = {
  types: ["VariableDeclaration"],
  checkPath(path: NodePath): boolean {
    return t.isVar(path.node);
  },
};
export const User = {
  checkPath(path: NodePath): boolean {
    return path.node && !!path.node.loc;
  },
};
export const Generated = {
  checkPath(path: NodePath): boolean {
    return !path.isUser();
  },
};
export const Pure = {
  checkPath(path: NodePath, opts?): boolean {
    return path.scope.isPure(path.node, opts);
  },
};
export const Flow = {
  types: ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"],
  checkPath({ node }: NodePath): boolean {
    if (t.isFlow(node)) {
      return true;
    } else if (t.isImportDeclaration(node)) {
      return node.importKind === "type" || node.importKind === "typeof";
    } else if (t.isExportDeclaration(node)) {
      return node.exportKind === "type";
    } else if (t.isImportSpecifier(node)) {
      return node.importKind === "type" || node.importKind === "typeof";
    } else {
      return false;
    }
  },
};
// TODO: 7.0 Backwards Compat
export const RestProperty = {
  types: ["RestElement"],
  checkPath(path: NodePath): boolean {
    return path.parentPath && path.parentPath.isObjectPattern();
  },
};
export const SpreadProperty = {
  types: ["RestElement"],
  checkPath(path: NodePath): boolean {
    return path.parentPath && path.parentPath.isObjectExpression();
  },
};
export const ExistentialTypeParam = {
  types: ["ExistsTypeAnnotation"],
};
export const NumericLiteralTypeAnnotation = {
  types: ["NumberLiteralTypeAnnotation"],
};
export const ForAwaitStatement = {
  types: ["ForOfStatement"],
  checkPath({ node }: NodePath): boolean {
    return node.await === true;
  },
};

// </from> /home/qfox/apps/babel/packages/babel-traverse/src/path/lib/virtual-types.js

// <from> /home/qfox/apps/babel/packages/babel-traverse/src/path/inference/index.js

import * as inferers from "./inferers";
import * as t from "@babel/types";
/**
 * Infer the type of the current `NodePath`.
 */
export function getTypeAnnotation(): Object {
  if (this.typeAnnotation) return this.typeAnnotation;
  let type = this._getTypeAnnotation() || t.anyTypeAnnotation();
  if (t.isTypeAnnotation(type)) type = type.typeAnnotation;
  return (this.typeAnnotation = type);
}
/**
 * todo: split up this method
 */
export function _getTypeAnnotation(): ?Object {
  const node = this.node;
  if (!node) {
    // handle initializerless variables, add in checks for loop initializers too
    if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
      const declar = this.parentPath.parentPath;
      const declarParent = declar.parentPath;
      // for (let NODE in bar) {}
      if (declar.key === "left" && declarParent.isForInStatement()) {
        return t.stringTypeAnnotation();
      }
      // for (let NODE of bar) {}
      if (declar.key === "left" && declarParent.isForOfStatement()) {
        return t.anyTypeAnnotation();
      }
      return t.voidTypeAnnotation();
    } else {
      return;
    }
  }
  if (node.typeAnnotation) {
    return node.typeAnnotation;
  }
  let inferer = inferers[node.type];
  if (inferer) {
    return inferer.call(this, node);
  }
  inferer = inferers[this.parentPath.type];
  if (inferer && inferer.validParent) {
    return this.parentPath.getTypeAnnotation();
  }
}
export function isBaseType(baseName: string, soft?: boolean): boolean {
  return _isBaseType(baseName, this.getTypeAnnotation(), soft);
}
function _isBaseType(baseName: string, type?, soft?): boolean {
  if (baseName === "string") {
    return t.isStringTypeAnnotation(type);
  } else if (baseName === "number") {
    return t.isNumberTypeAnnotation(type);
  } else if (baseName === "boolean") {
    return t.isBooleanTypeAnnotation(type);
  } else if (baseName === "any") {
    return t.isAnyTypeAnnotation(type);
  } else if (baseName === "mixed") {
    return t.isMixedTypeAnnotation(type);
  } else if (baseName === "empty") {
    return t.isEmptyTypeAnnotation(type);
  } else if (baseName === "void") {
    return t.isVoidTypeAnnotation(type);
  } else {
    if (soft) {
      return false;
    } else {
      throw new Error(`Unknown base type ${baseName}`);
    }
  }
}
export function couldBeBaseType(name: string): boolean {
  const type = this.getTypeAnnotation();
  if (t.isAnyTypeAnnotation(type)) return true;
  if (t.isUnionTypeAnnotation(type)) {
    for (const type2 of (type.types: Array<Object>)) {
      if (t.isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {
        return true;
      }
    }
    return false;
  } else {
    return _isBaseType(name, type, true);
  }
}
export function baseTypeStrictlyMatches(right: NodePath) {
  const left = this.getTypeAnnotation();
  right = right.getTypeAnnotation();
  if (!t.isAnyTypeAnnotation(left) && t.isFlowBaseAnnotation(left)) {
    return right.type === left.type;
  }
}
export function isGenericType(genericName: string): boolean {
  const type = this.getTypeAnnotation();
  return (
    t.isGenericTypeAnnotation(type) &&
    t.isIdentifier(type.id, { name: genericName })
  );
}

// </from> /home/qfox/apps/babel/packages/babel-traverse/src/path/inference/index.js

// <from> /home/qfox/apps/babel/packages/babel-traverse/src/path/inference/inferers.js

import * as t from "@babel/types";
export { default as Identifier } from "./inferer-reference";
export function VariableDeclarator() {
  const id = this.get("id");
  if (!id.isIdentifier()) return;
  const init = this.get("init");
  let type = init.getTypeAnnotation();
  if (type && type.type === "AnyTypeAnnotation") {
    // Detect "var foo = Array()" calls so we can optimize for arrays vs iterables.
    if (
      init.isCallExpression() &&
      init.get("callee").isIdentifier({ name: "Array" }) &&
      !init.scope.hasBinding("Array", true /* noGlobals */)
    ) {
      type = ArrayExpression();
    }
  }
  return type;
}
export function TypeCastExpression(node) {
  return node.typeAnnotation;
}
TypeCastExpression.validParent = true;
export function NewExpression(node) {
  if (this.get("callee").isIdentifier()) {
    // only resolve identifier callee
    return t.genericTypeAnnotation(node.callee);
  }
}
export function TemplateLiteral() {
  return t.stringTypeAnnotation();
}
export function UnaryExpression(node) {
  const operator = node.operator;
  if (operator === "void") {
    return t.voidTypeAnnotation();
  } else if (t.NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {
    return t.numberTypeAnnotation();
  } else if (t.STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {
    return t.stringTypeAnnotation();
  } else if (t.BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {
    return t.booleanTypeAnnotation();
  }
}
export function BinaryExpression(node) {
  const operator = node.operator;
  if (t.NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
    return t.numberTypeAnnotation();
  } else if (t.BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {
    return t.booleanTypeAnnotation();
  } else if (operator === "+") {
    const right = this.get("right");
    const left = this.get("left");
    if (left.isBaseType("number") && right.isBaseType("number")) {
      // both numbers so this will be a number
      return t.numberTypeAnnotation();
    } else if (left.isBaseType("string") || right.isBaseType("string")) {
      // one is a string so the result will be a string
      return t.stringTypeAnnotation();
    }
    // unsure if left and right are strings or numbers so stay on the safe side
    return t.unionTypeAnnotation([
      t.stringTypeAnnotation(),
      t.numberTypeAnnotation(),
    ]);
  }
}
export function LogicalExpression() {
  return t.createUnionTypeAnnotation([
    this.get("left").getTypeAnnotation(),
    this.get("right").getTypeAnnotation(),
  ]);
}
export function ConditionalExpression() {
  return t.createUnionTypeAnnotation([
    this.get("consequent").getTypeAnnotation(),
    this.get("alternate").getTypeAnnotation(),
  ]);
}
export function SequenceExpression() {
  return this.get("expressions")
    .pop()
    .getTypeAnnotation();
}
export function AssignmentExpression() {
  return this.get("right").getTypeAnnotation();
}
export function UpdateExpression(node) {
  const operator = node.operator;
  if (operator === "++" || operator === "--") {
    return t.numberTypeAnnotation();
  }
}
export function StringLiteral() {
  return t.stringTypeAnnotation();
}
export function NumericLiteral() {
  return t.numberTypeAnnotation();
}
export function BooleanLiteral() {
  return t.booleanTypeAnnotation();
}
export function NullLiteral() {
  return t.nullLiteralTypeAnnotation();
}
export function RegExpLiteral() {
  return t.genericTypeAnnotation(t.identifier("RegExp"));
}
export function ObjectExpression() {
  return t.genericTypeAnnotation(t.identifier("Object"));
}
export function ArrayExpression() {
  return t.genericTypeAnnotation(t.identifier("Array"));
}
export function RestElement() {
  return ArrayExpression();
}
RestElement.validParent = true;
function Func() {
  return t.genericTypeAnnotation(t.identifier("Function"));
}
export {
  Func as FunctionExpression,
  Func as ArrowFunctionExpression,
  Func as FunctionDeclaration,
  Func as ClassExpression,
  Func as ClassDeclaration,
};
const isArrayFrom = t.buildMatchMemberExpression("Array.from");
const isObjectKeys = t.buildMatchMemberExpression("Object.keys");
const isObjectValues = t.buildMatchMemberExpression("Object.values");
const isObjectEntries = t.buildMatchMemberExpression("Object.entries");
export function CallExpression() {
  const { callee } = this.node;
  if (isObjectKeys(callee)) {
    return t.arrayTypeAnnotation(t.stringTypeAnnotation());
  } else if (isArrayFrom(callee) || isObjectValues(callee)) {
    return t.arrayTypeAnnotation(t.anyTypeAnnotation());
  } else if (isObjectEntries(callee)) {
    return t.arrayTypeAnnotation(
      t.tupleTypeAnnotation([t.stringTypeAnnotation(), t.anyTypeAnnotation()]),
    );
  }
  return resolveCall(this.get("callee"));
}
export function TaggedTemplateExpression() {
  return resolveCall(this.get("tag"));
}
function resolveCall(callee) {
  callee = callee.resolve();
  if (callee.isFunction()) {
    if (callee.is("async")) {
      if (callee.is("generator")) {
        return t.genericTypeAnnotation(t.identifier("AsyncIterator"));
      } else {
        return t.genericTypeAnnotation(t.identifier("Promise"));
      }
    } else {
      if (callee.node.returnType) {
        return callee.node.returnType;
      } else {
        // todo: get union type of all return arguments
      }
    }
  }
}

// </from> /home/qfox/apps/babel/packages/babel-traverse/src/path/inference/inferers.js

// <from> /home/qfox/apps/babel/packages/babel-traverse/src/path/inference/inferer-reference.js

import * as t from "@babel/types";
export default function(node: Object) {
  if (!this.isReferenced()) return;
  // check if a binding exists of this value and if so then return a union type of all
  // possible types that the binding could be
  const binding = this.scope.getBinding(node.name);
  if (binding) {
    if (binding.identifier.typeAnnotation) {
      return binding.identifier.typeAnnotation;
    } else {
      return getTypeAnnotationBindingConstantViolations(
        binding,
        this,
        node.name,
      );
    }
  }
  // built-in values
  if (node.name === "undefined") {
    return t.voidTypeAnnotation();
  } else if (node.name === "NaN" || node.name === "Infinity") {
    return t.numberTypeAnnotation();
  } else if (node.name === "arguments") {
    // todo
  }
}
function getTypeAnnotationBindingConstantViolations(binding, path, name) {
  const types = [];
  const functionConstantViolations = [];
  let constantViolations = getConstantViolationsBefore(
    binding,
    path,
    functionConstantViolations,
  );
  const testType = getConditionalAnnotation(binding, path, name);
  if (testType) {
    const testConstantViolations = getConstantViolationsBefore(
      binding,
      testType.ifStatement,
    );
    // remove constant violations observed before the IfStatement
    constantViolations = constantViolations.filter(
      path => testConstantViolations.indexOf(path) < 0,
    );
    // clear current types and add in observed test type
    types.push(testType.typeAnnotation);
  }
  if (constantViolations.length) {
    // pick one constant from each scope which will represent the last possible
    // control flow path that it could've taken/been
    /* This code is broken for the following problems:
     * It thinks that assignments can only happen in scopes.
     * What about conditionals, if statements without block,
     * or guarded assignments.
     * It also checks to see if one of the assignments is in the
     * same scope and uses that as the only "violation". However,
     * the binding is returned by `getConstantViolationsBefore` so we for
     * sure always going to return that as the only "violation".
    let rawConstantViolations = constantViolations.reverse();
    let visitedScopes = [];
    constantViolations = [];
    for (let violation of (rawConstantViolations: Array<NodePath>)) {
      let violationScope = violation.scope;
      if (visitedScopes.indexOf(violationScope) >= 0) continue;
      visitedScopes.push(violationScope);
      constantViolations.push(violation);
      if (violationScope === path.scope) {
        constantViolations = [violation];
        break;
      }
    }*/
    // add back on function constant violations since we can't track calls
    constantViolations = constantViolations.concat(functionConstantViolations);
    // push on inferred types of violated paths
    for (const violation of (constantViolations: Array<NodePath>)) {
      types.push(violation.getTypeAnnotation());
    }
  }
  if (types.length) {
    return t.createUnionTypeAnnotation(types);
  }
}
function getConstantViolationsBefore(binding, path, functions) {
  const violations = binding.constantViolations.slice();
  violations.unshift(binding.path);
  return violations.filter(violation => {
    violation = violation.resolve();
    const status = violation._guessExecutionStatusRelativeTo(path);
    if (functions && status === "function") functions.push(violation);
    return status === "before";
  });
}
function inferAnnotationFromBinaryExpression(name, path) {
  const operator = path.node.operator;
  const right = path.get("right").resolve();
  const left = path.get("left").resolve();
  let target;
  if (left.isIdentifier({ name })) {
    target = right;
  } else if (right.isIdentifier({ name })) {
    target = left;
  }
  if (target) {
    if (operator === "===") {
      return target.getTypeAnnotation();
    }
    if (t.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
      return t.numberTypeAnnotation();
    }
    return;
  }
  if (operator !== "===" && operator !== "==") return;
  //
  let typeofPath;
  let typePath;
  if (left.isUnaryExpression({ operator: "typeof" })) {
    typeofPath = left;
    typePath = right;
  } else if (right.isUnaryExpression({ operator: "typeof" })) {
    typeofPath = right;
    typePath = left;
  }
  if (!typeofPath) return;
  // and that the argument of the typeof path references us!
  if (!typeofPath.get("argument").isIdentifier({ name })) return;
  // ensure that the type path is a Literal
  typePath = typePath.resolve();
  if (!typePath.isLiteral()) return;
  // and that it's a string so we can infer it
  const typeValue = typePath.node.value;
  if (typeof typeValue !== "string") return;
  // turn type value into a type annotation
  return t.createTypeAnnotationBasedOnTypeof(typeValue);
}
function getParentConditionalPath(binding, path, name) {
  let parentPath;
  while ((parentPath = path.parentPath)) {
    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {
      if (path.key === "test") {
        return;
      }
      return parentPath;
    }
    if (parentPath.isFunction()) {
      if (parentPath.parentPath.scope.getBinding(name) !== binding) return;
    }
    path = parentPath;
  }
}
function getConditionalAnnotation(binding, path, name) {
  const ifStatement = getParentConditionalPath(binding, path, name);
  if (!ifStatement) return;
  const test = ifStatement.get("test");
  const paths = [test];
  const types = [];
  for (let i = 0; i < paths.length; i++) {
    const path = paths[i];
    if (path.isLogicalExpression()) {
      if (path.node.operator === "&&") {
        paths.push(path.get("left"));
        paths.push(path.get("right"));
      }
    } else if (path.isBinaryExpression()) {
      const type = inferAnnotationFromBinaryExpression(name, path);
      if (type) types.push(type);
    }
  }
  if (types.length) {
    return {
      typeAnnotation: t.createUnionTypeAnnotation(types),
      ifStatement,
    };
  }
  return getConditionalAnnotation(ifStatement, name);
}

// </from> /home/qfox/apps/babel/packages/babel-traverse/src/path/inference/inferer-reference.js

// <from> /home/qfox/apps/babel/packages/babel-traverse/src/cache.js

export let path = new WeakMap();
export let scope = new WeakMap();
export function clear() {
  clearPath();
  clearScope();
}
export function clearPath() {
  path = new WeakMap();
}
export function clearScope() {
  scope = new WeakMap();
}

// </from> /home/qfox/apps/babel/packages/babel-traverse/src/cache.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-syntax-pipeline-operator/src/index.js

import { declare } from "@babel/helper-plugin-utils";
export const proposals = ["minimal"];
export default declare((api, { proposal }) => {
  api.assertVersion(7);
  if (typeof proposal !== "string" || !proposals.includes(proposal)) {
    throw new Error(
      "The pipeline operator plugin requires a 'proposal' option." +
        "'proposal' must be one of: " +
        proposals.join(", ") +
        ". More details: https://babeljs.io/docs/en/next/babel-plugin-proposal-pipeline-operator",
    );
  }
  return {
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push(["pipelineOperator", { proposal }]);
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-syntax-pipeline-operator/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-syntax-flow/src/index.js

import { declare } from "@babel/helper-plugin-utils";
export default declare((api, options) => {
  api.assertVersion(7);
  // When enabled and plugins includes flow, all files should be parsed as if
  // the @flow pragma was provided.
  const { all } = options;
  if (typeof all !== "boolean" && typeof all !== "undefined") {
    throw new Error(".all must be a boolean, or undefined");
  }
  return {
    manipulateOptions(opts, parserOpts) {
      // If the file has already enabled TS, assume that this is not a
      // valid Flowtype file.
      if (
        parserOpts.plugins.some(
          p => (Array.isArray(p) ? p[0] : p) === "typescript",
        )
      ) {
        return;
      }
      parserOpts.plugins.push(["flow", { all }]);
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-syntax-flow/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-syntax-typescript/src/index.js

import { declare } from "@babel/helper-plugin-utils";
function removePlugin(plugins, name) {
  const indices = [];
  plugins.forEach((plugin, i) => {
    const n = Array.isArray(plugin) ? plugin[0] : plugin;
    if (n === name) {
      indices.unshift(i);
    }
  });
  for (const i of indices) {
    plugins.splice(i, 1);
  }
}
export default declare((api, { isTSX }) => {
  api.assertVersion(7);
  return {
    manipulateOptions(opts, parserOpts) {
      const { plugins } = parserOpts;
      // If the Flow syntax plugin already ran, remove it since Typescript
      // takes priority.
      removePlugin(plugins, "flow");
      // If the JSX syntax plugin already ran, remomove it because JSX handling
      // in TS depends on the extensions, and is purely dependent on 'isTSX'.
      removePlugin(plugins, "jsx");
      parserOpts.plugins.push(
        "typescript",
        "objectRestSpread",
        "classProperties",
      );
      if (isTSX) {
        parserOpts.plugins.push("jsx");
      }
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-syntax-typescript/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-instanceof/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import { types as t } from "@babel/core";
export default declare(api => {
  api.assertVersion(7);
  return {
    visitor: {
      BinaryExpression(path) {
        const { node } = path;
        if (node.operator === "instanceof") {
          const helper = this.addHelper("instanceof");
          const isUnderHelper = path.findParent(path => {
            return (
              (path.isVariableDeclarator() && path.node.id === helper) ||
              (path.isFunctionDeclaration() &&
                path.node.id &&
                path.node.id.name === helper.name)
            );
          });
          if (isUnderHelper) {
            return;
          } else {
            path.replaceWith(t.callExpression(helper, [node.left, node.right]));
          }
        }
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-instanceof/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-preset-stage-0/src/index.js

export default function() {
  throw new Error(`
As of v7.0.0-beta.55, we've removed Babel's Stage presets.
Please consider reading our blog post on this decision at
https://babeljs.io/blog/2018/07/27/removing-babels-stage-presets
for more details. TL;DR is that it's more beneficial in the
  long run to explicitly add which proposals to use.
For a more automatic migration, we have updated babel-upgrade,
https://github.com/babel/babel-upgrade to do this for you with
"npx babel-upgrade".
If you want the same configuration as before:
{
  "plugins": [
    // Stage 0
    "@babel/plugin-proposal-function-bind",
    // Stage 1
    "@babel/plugin-proposal-export-default-from",
    "@babel/plugin-proposal-logical-assignment-operators",
    ["@babel/plugin-proposal-optional-chaining", { "loose": false }],
    ["@babel/plugin-proposal-pipeline-operator", { "proposal": "minimal" }],
    ["@babel/plugin-proposal-nullish-coalescing-operator", { "loose": false }],
    "@babel/plugin-proposal-do-expressions",
    // Stage 2
    ["@babel/plugin-proposal-decorators", { "legacy": true }],
    "@babel/plugin-proposal-function-sent",
    "@babel/plugin-proposal-export-namespace-from",
    "@babel/plugin-proposal-numeric-separator",
    "@babel/plugin-proposal-throw-expressions",
    // Stage 3
    "@babel/plugin-syntax-dynamic-import",
    "@babel/plugin-syntax-import-meta",
    ["@babel/plugin-proposal-class-properties", { "loose": false }],
    "@babel/plugin-proposal-json-strings"
  ]
}
If you're using the same configuration across many separate projects,
keep in mind that you can also create your own custom presets with
whichever plugins and presets you're looking to use.
module.exports = function() {
  return {
    plugins: [
      require("@babel/plugin-syntax-dynamic-import"),
      [require("@babel/plugin-proposal-decorators"), { "legacy": true }],
      [require("@babel/plugin-proposal-class-properties"), { "loose": false }],
    ],
    presets: [
      // ...
    ],
  };
};
  `);
}

// </from> /home/qfox/apps/babel/packages/babel-preset-stage-0/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-proposal-do-expressions/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import syntaxDoExpressions from "@babel/plugin-syntax-do-expressions";
export default declare(api => {
  api.assertVersion(7);
  return {
    inherits: syntaxDoExpressions,
    visitor: {
      DoExpression: {
        exit(path) {
          const body = path.node.body.body;
          if (body.length) {
            path.replaceExpressionWithStatements(body);
          } else {
            path.replaceWith(path.scope.buildUndefinedNode());
          }
        },
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-proposal-do-expressions/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-classes/src/index.js

// @flow
import { declare } from "@babel/helper-plugin-utils";
import annotateAsPure from "@babel/helper-annotate-as-pure";
import nameFunction from "@babel/helper-function-name";
import splitExportDeclaration from "@babel/helper-split-export-declaration";
import { types as t } from "@babel/core";
import globals from "globals";
import transformClass from "./transformClass";
const getBuiltinClasses = category =>
  Object.keys(globals[category]).filter(name => /^[A-Z]/.test(name));
const builtinClasses = new Set([
  ...getBuiltinClasses("builtin"),
  ...getBuiltinClasses("browser"),
]);
export default declare((api, options) => {
  api.assertVersion(7);
  const { loose } = options;
  // todo: investigate traversal requeueing
  const VISITED = Symbol();
  return {
    visitor: {
      ExportDefaultDeclaration(path: NodePath) {
        if (!path.get("declaration").isClassDeclaration()) return;
        splitExportDeclaration(path);
      },
      ClassDeclaration(path: NodePath) {
        const { node } = path;
        const ref = node.id || path.scope.generateUidIdentifier("class");
        path.replaceWith(
          t.variableDeclaration("let", [
            t.variableDeclarator(ref, t.toExpression(node)),
          ]),
        );
      },
      ClassExpression(path: NodePath, state: any) {
        const { node } = path;
        if (node[VISITED]) return;
        const inferred = nameFunction(path);
        if (inferred && inferred !== node) {
          path.replaceWith(inferred);
          return;
        }
        node[VISITED] = true;
        path.replaceWith(
          transformClass(path, state.file, builtinClasses, loose),
        );
        if (path.isCallExpression()) {
          annotateAsPure(path);
          if (path.get("callee").isArrowFunctionExpression()) {
            path.get("callee").arrowFunctionToExpression();
          }
        }
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-classes/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-classes/src/transformClass.js

import nameFunction from "@babel/helper-function-name";
import ReplaceSupers, {
  environmentVisitor,
} from "@babel/helper-replace-supers";
import optimiseCall from "@babel/helper-optimise-call-expression";
import * as defineMap from "@babel/helper-define-map";
import { traverse, template, types as t } from "@babel/core";
type ReadonlySet<T> = Set<T> | { has(val: T): boolean };
function buildConstructor(classRef, constructorBody, node) {
  const func = t.functionDeclaration(
    t.cloneNode(classRef),
    [],
    constructorBody,
  );
  t.inherits(func, node);
  return func;
}
const verifyConstructorVisitor = traverse.visitors.merge([
  environmentVisitor,
  {
    Super(path, state) {
      if (state.isDerived) return;
      const { node, parentPath } = path;
      if (parentPath.isCallExpression({ callee: node })) {
        throw path.buildCodeFrameError(
          "super() is only allowed in a derived constructor",
        );
      }
    },
    ThisExpression(path, state) {
      if (!state.isDerived) return;
      const { node, parentPath } = path;
      if (parentPath.isMemberExpression({ object: node })) {
        // In cases like this.foo or this[foo], there is no need to add
        // assertThisInitialized, since they already throw if this is
        // undefined.
        return;
      }
      const assertion = t.callExpression(
        state.file.addHelper("assertThisInitialized"),
        [node],
      );
      path.replaceWith(assertion);
      path.skip();
    },
  },
]);
export default function transformClass(
  path: NodePath,
  file: any,
  builtinClasses: ReadonlySet<string>,
  isLoose: boolean,
) {
  const classState = {
    parent: undefined,
    scope: undefined,
    node: undefined,
    path: undefined,
    file: undefined,
    classId: undefined,
    classRef: undefined,
    superName: undefined,
    superReturns: [],
    isDerived: false,
    extendsNative: false,
    construct: undefined,
    constructorBody: undefined,
    userConstructor: undefined,
    userConstructorPath: undefined,
    hasConstructor: false,
    instancePropBody: [],
    instancePropRefs: {},
    staticPropBody: [],
    body: [],
    bareSupers: new Set(),
    superThises: [],
    pushedConstructor: false,
    pushedInherits: false,
    protoAlias: null,
    isLoose: false,
    hasInstanceDescriptors: false,
    hasStaticDescriptors: false,
    instanceMutatorMap: {},
    staticMutatorMap: {},
  };
  const setState = newState => {
    Object.assign(classState, newState);
  };
  const findThisesVisitor = traverse.visitors.merge([
    environmentVisitor,
    {
      ThisExpression(path) {
        classState.superThises.push(path);
      },
    },
  ]);
  function pushToMap(node, enumerable, kind = "value", scope?) {
    let mutatorMap;
    if (node.static) {
      setState({ hasStaticDescriptors: true });
      mutatorMap = classState.staticMutatorMap;
    } else {
      setState({ hasInstanceDescriptors: true });
      mutatorMap = classState.instanceMutatorMap;
    }
    const map = defineMap.push(mutatorMap, node, kind, classState.file, scope);
    if (enumerable) {
      map.enumerable = t.booleanLiteral(true);
    }
    return map;
  }
  /**
   * Creates a class constructor or bail out if there is none
   */
  function maybeCreateConstructor() {
    let hasConstructor = false;
    const paths = classState.path.get("body.body");
    for (const path of paths) {
      hasConstructor = path.equals("kind", "constructor");
      if (hasConstructor) break;
    }
    if (hasConstructor) return;
    let params, body;
    if (classState.isDerived) {
      const constructor = template.expression.ast`
        (function () {
          super(...arguments);
        })
      `;
      params = constructor.params;
      body = constructor.body;
    } else {
      params = [];
      body = t.blockStatement([]);
    }
    classState.path
      .get("body")
      .unshiftContainer(
        "body",
        t.classMethod("constructor", t.identifier("constructor"), params, body),
      );
  }
  function buildBody() {
    maybeCreateConstructor();
    pushBody();
    verifyConstructor();
    if (classState.userConstructor) {
      const { constructorBody, userConstructor, construct } = classState;
      constructorBody.body = constructorBody.body.concat(
        userConstructor.body.body,
      );
      t.inherits(construct, userConstructor);
      t.inherits(constructorBody, userConstructor.body);
    }
    pushDescriptors();
  }
  function pushBody() {
    const classBodyPaths: Array<Object> = classState.path.get("body.body");
    for (const path of classBodyPaths) {
      const node = path.node;
      if (path.isClassProperty()) {
        throw path.buildCodeFrameError("Missing class properties transform.");
      }
      if (node.decorators) {
        throw path.buildCodeFrameError(
          "Method has decorators, put the decorator plugin before the classes one.",
        );
      }
      if (t.isClassMethod(node)) {
        const isConstructor = node.kind === "constructor";
        if (isConstructor) {
          path.traverse(verifyConstructorVisitor, {
            isDerived: classState.isDerived,
            file: classState.file,
          });
        }
        const replaceSupers = new ReplaceSupers({
          methodPath: path,
          objectRef: classState.classRef,
          superRef: classState.superName,
          isLoose: classState.isLoose,
          file: classState.file,
        });
        replaceSupers.replace();
        // TODO this needs to be cleaned up. But, one step at a time.
        const state = {
          returns: [],
          bareSupers: new Set(),
        };
        path.traverse(
          traverse.visitors.merge([
            environmentVisitor,
            {
              ReturnStatement(path, state) {
                if (!path.getFunctionParent().isArrowFunctionExpression()) {
                  state.returns.push(path);
                }
              },
              Super(path, state) {
                const { node, parentPath } = path;
                if (parentPath.isCallExpression({ callee: node })) {
                  state.bareSupers.add(parentPath);
                }
              },
            },
          ]),
          state,
        );
        if (isConstructor) {
          pushConstructor(state, node, path);
        } else {
          pushMethod(node, path);
        }
      }
    }
  }
  function clearDescriptors() {
    setState({
      hasInstanceDescriptors: false,
      hasStaticDescriptors: false,
      instanceMutatorMap: {},
      staticMutatorMap: {},
    });
  }
  function pushDescriptors() {
    pushInheritsToBody();
    const { body } = classState;
    let instanceProps;
    let staticProps;
    if (classState.hasInstanceDescriptors) {
      instanceProps = defineMap.toClassObject(classState.instanceMutatorMap);
    }
    if (classState.hasStaticDescriptors) {
      staticProps = defineMap.toClassObject(classState.staticMutatorMap);
    }
    if (instanceProps || staticProps) {
      if (instanceProps) {
        instanceProps = defineMap.toComputedObjectFromClass(instanceProps);
      }
      if (staticProps) {
        staticProps = defineMap.toComputedObjectFromClass(staticProps);
      }
      let args = [
        t.cloneNode(classState.classRef), // Constructor
        t.nullLiteral(), // instanceDescriptors
        t.nullLiteral(), // staticDescriptors
      ];
      if (instanceProps) args[1] = instanceProps;
      if (staticProps) args[2] = staticProps;
      let lastNonNullIndex = 0;
      for (let i = 0; i < args.length; i++) {
        if (!t.isNullLiteral(args[i])) lastNonNullIndex = i;
      }
      args = args.slice(0, lastNonNullIndex + 1);
      body.push(
        t.expressionStatement(
          t.callExpression(classState.file.addHelper("createClass"), args),
        ),
      );
    }
    clearDescriptors();
  }
  function wrapSuperCall(bareSuper, superRef, thisRef, body) {
    let bareSuperNode = bareSuper.node;
    let call;
    if (classState.isLoose) {
      bareSuperNode.arguments.unshift(t.thisExpression());
      if (
        bareSuperNode.arguments.length === 2 &&
        t.isSpreadElement(bareSuperNode.arguments[1]) &&
        t.isIdentifier(bareSuperNode.arguments[1].argument, {
          name: "arguments",
        })
      ) {
        // special case single arguments spread
        bareSuperNode.arguments[1] = bareSuperNode.arguments[1].argument;
        bareSuperNode.callee = t.memberExpression(
          t.cloneNode(superRef),
          t.identifier("apply"),
        );
      } else {
        bareSuperNode.callee = t.memberExpression(
          t.cloneNode(superRef),
          t.identifier("call"),
        );
      }
      call = t.logicalExpression("||", bareSuperNode, t.thisExpression());
    } else {
      bareSuperNode = optimiseCall(
        t.callExpression(classState.file.addHelper("getPrototypeOf"), [
          t.cloneNode(classState.classRef),
        ]),
        t.thisExpression(),
        bareSuperNode.arguments,
      );
      call = t.callExpression(
        classState.file.addHelper("possibleConstructorReturn"),
        [t.thisExpression(), bareSuperNode],
      );
    }
    if (
      bareSuper.parentPath.isExpressionStatement() &&
      bareSuper.parentPath.container === body.node.body &&
      body.node.body.length - 1 === bareSuper.parentPath.key
    ) {
      // this super call is the last statement in the body so we can just straight up
      // turn it into a return
      if (classState.superThises.length) {
        call = t.assignmentExpression("=", thisRef(), call);
      }
      bareSuper.parentPath.replaceWith(t.returnStatement(call));
    } else {
      bareSuper.replaceWith(t.assignmentExpression("=", thisRef(), call));
    }
  }
  function verifyConstructor() {
    if (!classState.isDerived) return;
    const path = classState.userConstructorPath;
    const body = path.get("body");
    path.traverse(findThisesVisitor);
    let guaranteedSuperBeforeFinish = !!classState.bareSupers.size;
    let thisRef = function() {
      const ref = path.scope.generateDeclaredUidIdentifier("this");
      thisRef = () => t.cloneNode(ref);
      return ref;
    };
    for (const bareSuper of classState.bareSupers) {
      wrapSuperCall(bareSuper, classState.superName, thisRef, body);
      if (guaranteedSuperBeforeFinish) {
        bareSuper.find(function(parentPath) {
          // hit top so short circuit
          if (parentPath === path) {
            return true;
          }
          if (
            parentPath.isLoop() ||
            parentPath.isConditional() ||
            parentPath.isArrowFunctionExpression()
          ) {
            guaranteedSuperBeforeFinish = false;
            return true;
          }
        });
      }
    }
    for (const thisPath of classState.superThises) {
      const { node, parentPath } = thisPath;
      if (parentPath.isMemberExpression({ object: node })) {
        thisPath.replaceWith(thisRef());
        continue;
      }
      thisPath.replaceWith(
        t.callExpression(classState.file.addHelper("assertThisInitialized"), [
          thisRef(),
        ]),
      );
    }
    let wrapReturn;
    if (classState.isLoose) {
      wrapReturn = returnArg => {
        const thisExpr = t.callExpression(
          classState.file.addHelper("assertThisInitialized"),
          [thisRef()],
        );
        return returnArg
          ? t.logicalExpression("||", returnArg, thisExpr)
          : thisExpr;
      };
    } else {
      wrapReturn = returnArg =>
        t.callExpression(
          classState.file.addHelper("possibleConstructorReturn"),
          [thisRef()].concat(returnArg || []),
        );
    }
    // if we have a return as the last node in the body then we've already caught that
    // return
    const bodyPaths = body.get("body");
    if (!bodyPaths.length || !bodyPaths.pop().isReturnStatement()) {
      body.pushContainer(
        "body",
        t.returnStatement(
          guaranteedSuperBeforeFinish ? thisRef() : wrapReturn(),
        ),
      );
    }
    for (const returnPath of classState.superReturns) {
      returnPath
        .get("argument")
        .replaceWith(wrapReturn(returnPath.node.argument));
    }
  }
  /**
   * Push a method to its respective mutatorMap.
   */
  function pushMethod(node: { type: "ClassMethod" }, path?: NodePath) {
    const scope = path ? path.scope : classState.scope;
    if (node.kind === "method") {
      if (processMethod(node, scope)) return;
    }
    pushToMap(node, false, null, scope);
  }
  function processMethod(node, scope) {
    if (classState.isLoose && !node.decorators) {
      // use assignments instead of define properties for loose classes
      let { classRef } = classState;
      if (!node.static) {
        insertProtoAliasOnce();
        classRef = classState.protoAlias;
      }
      const methodName = t.memberExpression(
        t.cloneNode(classRef),
        node.key,
        node.computed || t.isLiteral(node.key),
      );
      let func = t.functionExpression(
        null,
        node.params,
        node.body,
        node.generator,
        node.async,
      );
      func.returnType = node.returnType;
      const key = t.toComputedKey(node, node.key);
      if (t.isStringLiteral(key)) {
        func = nameFunction({
          node: func,
          id: key,
          scope,
        });
      }
      const expr = t.expressionStatement(
        t.assignmentExpression("=", methodName, func),
      );
      t.inheritsComments(expr, node);
      classState.body.push(expr);
      return true;
    }
    return false;
  }
  function insertProtoAliasOnce() {
    if (classState.protoAlias === null) {
      setState({ protoAlias: classState.scope.generateUidIdentifier("proto") });
      const classProto = t.memberExpression(
        classState.classRef,
        t.identifier("prototype"),
      );
      const protoDeclaration = t.variableDeclaration("var", [
        t.variableDeclarator(classState.protoAlias, classProto),
      ]);
      classState.body.push(protoDeclaration);
    }
  }
  /**
   * Replace the constructor body of our class.
   */
  function pushConstructor(
    replaceSupers,
    method: { type: "ClassMethod" },
    path: NodePath,
  ) {
    // https://github.com/babel/babel/issues/1077
    if (path.scope.hasOwnBinding(classState.classRef.name)) {
      path.scope.rename(classState.classRef.name);
    }
    setState({
      userConstructorPath: path,
      userConstructor: method,
      hasConstructor: true,
      bareSupers: replaceSupers.bareSupers,
      superReturns: replaceSupers.returns,
    });
    const { construct } = classState;
    t.inheritsComments(construct, method);
    construct.params = method.params;
    t.inherits(construct.body, method.body);
    construct.body.directives = method.body.directives;
    pushConstructorToBody();
  }
  function pushConstructorToBody() {
    if (classState.pushedConstructor) return;
    classState.pushedConstructor = true;
    // we haven't pushed any descriptors yet
    if (classState.hasInstanceDescriptors || classState.hasStaticDescriptors) {
      pushDescriptors();
    }
    classState.body.push(classState.construct);
    pushInheritsToBody();
  }
  /**
   * Push inherits helper to body.
   */
  function pushInheritsToBody() {
    if (!classState.isDerived || classState.pushedInherits) return;
    setState({ pushedInherits: true });
    // Unshift to ensure that the constructor inheritance is set up before
    // any properties can be assigned to the prototype.
    classState.body.unshift(
      t.expressionStatement(
        t.callExpression(
          classState.file.addHelper(
            classState.isLoose ? "inheritsLoose" : "inherits",
          ),
          [t.cloneNode(classState.classRef), t.cloneNode(classState.superName)],
        ),
      ),
    );
  }
  function setupClosureParamsArgs() {
    const { superName } = classState;
    const closureParams = [];
    const closureArgs = [];
    if (classState.isDerived) {
      const arg = classState.extendsNative
        ? t.callExpression(classState.file.addHelper("wrapNativeSuper"), [
            t.cloneNode(superName),
          ])
        : t.cloneNode(superName);
      const param = classState.scope.generateUidIdentifierBasedOnNode(
        superName,
      );
      closureParams.push(param);
      closureArgs.push(arg);
      setState({ superName: t.cloneNode(param) });
    }
    return { closureParams, closureArgs };
  }
  function classTransformer(
    path: NodePath,
    file,
    builtinClasses: ReadonlySet<string>,
    isLoose: boolean,
  ) {
    setState({
      parent: path.parent,
      scope: path.scope,
      node: path.node,
      path,
      file,
      isLoose,
    });
    setState({
      classId: classState.node.id,
      // this is the name of the binding that will **always** reference the class we've constructed
      classRef: classState.node.id
        ? t.identifier(classState.node.id.name)
        : classState.scope.generateUidIdentifier("class"),
      superName: classState.node.superClass,
      isDerived: !!classState.node.superClass,
      constructorBody: t.blockStatement([]),
    });
    setState({
      extendsNative:
        classState.isDerived &&
        builtinClasses.has(classState.superName.name) &&
        !classState.scope.hasBinding(
          classState.superName.name,
          /* noGlobals */ true,
        ),
    });
    const { classRef, node, constructorBody } = classState;
    setState({
      construct: buildConstructor(classRef, constructorBody, node),
    });
    let { body } = classState;
    const { closureParams, closureArgs } = setupClosureParamsArgs();
    buildBody();
    // make sure this class isn't directly called (with A() instead new A())
    if (!classState.isLoose) {
      constructorBody.body.unshift(
        t.expressionStatement(
          t.callExpression(classState.file.addHelper("classCallCheck"), [
            t.thisExpression(),
            t.cloneNode(classState.classRef),
          ]),
        ),
      );
    }
    body = body.concat(
      classState.staticPropBody.map(fn => fn(t.cloneNode(classState.classRef))),
    );
    const isStrict = path.isInStrictMode();
    let constructorOnly = classState.classId && body.length === 1;
    if (constructorOnly && !isStrict) {
      for (const param of classState.construct.params) {
        // It's illegal to put a use strict directive into the body of a function
        // with non-simple parameters for some reason. So, we have to use a strict
        // wrapper function.
        if (!t.isIdentifier(param)) {
          constructorOnly = false;
          break;
        }
      }
    }
    const directives = constructorOnly ? body[0].body.directives : [];
    if (!isStrict) {
      directives.push(t.directive(t.directiveLiteral("use strict")));
    }
    if (constructorOnly) {
      // named class with only a constructor
      return t.toExpression(body[0]);
    }
    body.push(t.returnStatement(t.cloneNode(classState.classRef)));
    const container = t.arrowFunctionExpression(
      closureParams,
      t.blockStatement(body, directives),
    );
    return t.callExpression(container, closureArgs);
  }
  return classTransformer(path, file, builtinClasses, isLoose);
}

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-classes/src/transformClass.js

// <from> /home/qfox/apps/babel/packages/babel-helper-module-imports/src/index.js

import ImportInjector from "./import-injector";
export { ImportInjector };
export { default as isModule } from "./is-module";
export function addDefault(path, importedSource, opts) {
  return new ImportInjector(path).addDefault(importedSource, opts);
}
export function addNamed(path, name, importedSource, opts) {
  return new ImportInjector(path).addNamed(name, importedSource, opts);
}
export function addNamespace(path, importedSource, opts) {
  return new ImportInjector(path).addNamespace(importedSource, opts);
}
export function addSideEffect(path, importedSource, opts) {
  return new ImportInjector(path).addSideEffect(importedSource, opts);
}

// </from> /home/qfox/apps/babel/packages/babel-helper-module-imports/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-helper-module-imports/src/import-injector.js

import assert from "assert";
import * as t from "@babel/types";
import ImportBuilder from "./import-builder";
import isModule from "./is-module";
export type ImportOptions = {
  /**
   * The module being referenced.
   */
  importedSource: string | null,
  /**
   * The type of module being imported:
   *
   *  * 'es6'      - An ES6 module.
   *  * 'commonjs' - A CommonJS module. (Default)
   */
  importedType: "es6" | "commonjs",
  /**
   * The type of interop behavior for namespace/default/named when loading
   * CommonJS modules.
   *
   * ## 'babel' (Default)
   *
   * Load using Babel's interop.
   *
   * If '.__esModule' is true, treat as 'compiled', else:
   *
   * * Namespace: A copy of the module.exports with .default
   *     populated by the module.exports object.
   * * Default: The module.exports value.
   * * Named: The .named property of module.exports.
   *
   * The 'ensureLiveReference' has no effect on the liveness of these.
   *
   * ## 'compiled'
   *
   * Assume the module is ES6 compiled to CommonJS. Useful to avoid injecting
   * interop logic if you are confident that the module is a certain format.
   *
   * * Namespace: The root module.exports object.
   * * Default: The .default property of the namespace.
   * * Named: The .named property of the namespace.
   *
   * Will return erroneous results if the imported module is _not_ compiled
   * from ES6 with Babel.
   *
   * ## 'uncompiled'
   *
   * Assume the module is _not_ ES6 compiled to CommonJS. Used a simplified
   * access pattern that doesn't require additional function calls.
   *
   * Will return erroneous results if the imported module _is_ compiled
   * from ES6 with Babel.
   *
   * * Namespace: The module.exports object.
   * * Default: The module.exports object.
   * * Named: The .named property of module.exports.
   */
  importedInterop: "babel" | "node" | "compiled" | "uncompiled",
  /**
   * The type of CommonJS interop included in the environment that will be
   * loading the output code.
   *
   *  * 'babel' - CommonJS modules load with Babel's interop. (Default)
   *  * 'node'  - CommonJS modules load with Node's interop.
   *
   * See descriptions in 'importedInterop' for more details.
   */
  importingInterop: "babel" | "node",
  /**
   * Define whether we explicitly care that the import be a live reference.
   * Only applies when importing default and named imports, not the namespace.
   *
   *  * true  - Force imported values to be live references.
   *  * false - No particular requirements. Keeps the code simplest. (Default)
   */
  ensureLiveReference: boolean,
  /**
   * Define if we explicitly care that the result not be a property reference.
   *
   *  * true  - Force calls to exclude context. Useful if the value is going to
   *            be used as function callee.
   *  * false - No particular requirements for context of the access. (Default)
   */
  ensureNoContext: boolean,
};
/**
 * A general helper classes add imports via transforms. See README for usage.
 */
export default class ImportInjector {
  /**
   * The path used for manipulation.
   */
  _programPath: NodePath;
  /**
   * The scope used to generate unique variable names.
   */
  _programScope;
  /**
   * The file used to inject helpers and resolve paths.
   */
  _hub;
  /**
   * The default options to use with this instance when imports are added.
   */
  _defaultOpts: ImportOptions = {
    importedSource: null,
    importedType: "commonjs",
    importedInterop: "babel",
    importingInterop: "babel",
    ensureLiveReference: false,
    ensureNoContext: false,
  };
  constructor(path, importedSource, opts) {
    const programPath = path.find(p => p.isProgram());
    this._programPath = programPath;
    this._programScope = programPath.scope;
    this._hub = programPath.hub;
    this._defaultOpts = this._applyDefaults(importedSource, opts, true);
  }
  addDefault(importedSourceIn, opts) {
    return this.addNamed("default", importedSourceIn, opts);
  }
  addNamed(importName, importedSourceIn, opts) {
    assert(typeof importName === "string");
    return this._generateImport(
      this._applyDefaults(importedSourceIn, opts),
      importName,
    );
  }
  addNamespace(importedSourceIn, opts) {
    return this._generateImport(
      this._applyDefaults(importedSourceIn, opts),
      null,
    );
  }
  addSideEffect(importedSourceIn, opts) {
    return this._generateImport(
      this._applyDefaults(importedSourceIn, opts),
      false,
    );
  }
  _applyDefaults(importedSource, opts, isInit = false) {
    const optsList = [];
    if (typeof importedSource === "string") {
      optsList.push({ importedSource });
      optsList.push(opts);
    } else {
      assert(!opts, "Unexpected secondary arguments.");
      optsList.push(importedSource);
    }
    const newOpts = {
      ...this._defaultOpts,
    };
    for (const opts of optsList) {
      if (!opts) continue;
      Object.keys(newOpts).forEach(key => {
        if (opts[key] !== undefined) newOpts[key] = opts[key];
      });
      if (!isInit) {
        if (opts.nameHint !== undefined) newOpts.nameHint = opts.nameHint;
        if (opts.blockHoist !== undefined) newOpts.blockHoist = opts.blockHoist;
      }
    }
    return newOpts;
  }
  _generateImport(opts, importName) {
    const isDefault = importName === "default";
    const isNamed = !!importName && !isDefault;
    const isNamespace = importName === null;
    const {
      importedSource,
      importedType,
      importedInterop,
      importingInterop,
      ensureLiveReference,
      ensureNoContext,
      nameHint,
      // Not meant for public usage. Allows code that absolutely must control
      // ordering to set a specific hoist value on the import nodes.
      blockHoist,
    } = opts;
    // Provide a hint for generateUidIdentifier for the local variable name
    // to use for the import, if the code will generate a simple assignment
    // to a variable.
    let name = nameHint || importName;
    const isMod = isModule(this._programPath);
    const isModuleForNode = isMod && importingInterop === "node";
    const isModuleForBabel = isMod && importingInterop === "babel";
    const builder = new ImportBuilder(
      importedSource,
      this._programScope,
      this._hub,
    );
    if (importedType === "es6") {
      if (!isModuleForNode && !isModuleForBabel) {
        throw new Error("Cannot import an ES6 module from CommonJS");
      }
      // import * as namespace from ''; namespace
      // import def from ''; def
      // import { named } from ''; named
      builder.import();
      if (isNamespace) {
        builder.namespace(nameHint || importedSource);
      } else if (isDefault || isNamed) {
        builder.named(name, importName);
      }
    } else if (importedType !== "commonjs") {
      throw new Error(`Unexpected interopType "${importedType}"`);
    } else if (importedInterop === "babel") {
      if (isModuleForNode) {
        // import _tmp from ''; var namespace = interopRequireWildcard(_tmp); namespace
        // import _tmp from ''; var def = interopRequireDefault(_tmp).default; def
        // import _tmp from ''; _tmp.named
        name = name !== "default" ? name : importedSource;
        const es6Default = `${importedSource}$es6Default`;
        builder.import();
        if (isNamespace) {
          builder
            .default(es6Default)
            .var(name || importedSource)
            .wildcardInterop();
        } else if (isDefault) {
          if (ensureLiveReference) {
            builder
              .default(es6Default)
              .var(name || importedSource)
              .defaultInterop()
              .read("default");
          } else {
            builder
              .default(es6Default)
              .var(name)
              .defaultInterop()
              .prop(importName);
          }
        } else if (isNamed) {
          builder.default(es6Default).read(importName);
        }
      } else if (isModuleForBabel) {
        // import * as namespace from ''; namespace
        // import def from ''; def
        // import { named } from ''; named
        builder.import();
        if (isNamespace) {
          builder.namespace(name || importedSource);
        } else if (isDefault || isNamed) {
          builder.named(name, importName);
        }
      } else {
        // var namespace = interopRequireWildcard(require(''));
        // var def = interopRequireDefault(require('')).default; def
        // var named = require('').named; named
        builder.require();
        if (isNamespace) {
          builder.var(name || importedSource).wildcardInterop();
        } else if ((isDefault || isNamed) && ensureLiveReference) {
          if (isDefault) {
            name = name !== "default" ? name : importedSource;
            builder.var(name).read(importName);
            builder.defaultInterop();
          } else {
            builder.var(importedSource).read(importName);
          }
        } else if (isDefault) {
          builder
            .var(name)
            .defaultInterop()
            .prop(importName);
        } else if (isNamed) {
          builder.var(name).prop(importName);
        }
      }
    } else if (importedInterop === "compiled") {
      if (isModuleForNode) {
        // import namespace from ''; namespace
        // import namespace from ''; namespace.default
        // import namespace from ''; namespace.named
        builder.import();
        if (isNamespace) {
          builder.default(name || importedSource);
        } else if (isDefault || isNamed) {
          builder.default(importedSource).read(name);
        }
      } else if (isModuleForBabel) {
        // import * as namespace from ''; namespace
        // import def from ''; def
        // import { named } from ''; named
        // Note: These lookups will break if the module has no __esModule set,
        // hence the warning that 'compiled' will not work on standard CommonJS.
        builder.import();
        if (isNamespace) {
          builder.namespace(name || importedSource);
        } else if (isDefault || isNamed) {
          builder.named(name, importName);
        }
      } else {
        // var namespace = require(''); namespace
        // var namespace = require(''); namespace.default
        // var namespace = require(''); namespace.named
        // var named = require('').named;
        builder.require();
        if (isNamespace) {
          builder.var(name || importedSource);
        } else if (isDefault || isNamed) {
          if (ensureLiveReference) {
            builder.var(importedSource).read(name);
          } else {
            builder.prop(importName).var(name);
          }
        }
      }
    } else if (importedInterop === "uncompiled") {
      if (isDefault && ensureLiveReference) {
        throw new Error("No live reference for commonjs default");
      }
      if (isModuleForNode) {
        // import namespace from ''; namespace
        // import def from ''; def;
        // import namespace from ''; namespace.named
        builder.import();
        if (isNamespace) {
          builder.default(name || importedSource);
        } else if (isDefault) {
          builder.default(name);
        } else if (isNamed) {
          builder.default(importedSource).read(name);
        }
      } else if (isModuleForBabel) {
        // import namespace from '';
        // import def from '';
        // import { named } from ''; named;
        // Note: These lookups will break if the module has __esModule set,
        // hence the warning that 'uncompiled' will not work on ES6 transpiled
        // to CommonJS.
        builder.import();
        if (isNamespace) {
          builder.default(name || importedSource);
        } else if (isDefault) {
          builder.default(name);
        } else if (isNamed) {
          builder.named(name, importName);
        }
      } else {
        // var namespace = require(''); namespace
        // var def = require(''); def
        // var namespace = require(''); namespace.named
        // var named = require('').named;
        builder.require();
        if (isNamespace) {
          builder.var(name || importedSource);
        } else if (isDefault) {
          builder.var(name);
        } else if (isNamed) {
          if (ensureLiveReference) {
            builder.var(importedSource).read(name);
          } else {
            builder.var(name).prop(importName);
          }
        }
      }
    } else {
      throw new Error(`Unknown importedInterop "${importedInterop}".`);
    }
    const { statements, resultName } = builder.done();
    this._insertStatements(statements, blockHoist);
    if (
      (isDefault || isNamed) &&
      ensureNoContext &&
      resultName.type !== "Identifier"
    ) {
      return t.sequenceExpression([t.numericLiteral(0), resultName]);
    }
    return resultName;
  }
  _insertStatements(statements, blockHoist = 3) {
    statements.forEach(node => {
      node._blockHoist = blockHoist;
    });
    const targetPath = this._programPath.get("body").filter(p => {
      const val = p.node._blockHoist;
      return Number.isFinite(val) && val < 4;
    })[0];
    if (targetPath) {
      targetPath.insertBefore(statements);
    } else {
      this._programPath.unshiftContainer("body", statements);
    }
  }
}

// </from> /home/qfox/apps/babel/packages/babel-helper-module-imports/src/import-injector.js

// <from> /home/qfox/apps/babel/packages/babel-helper-module-imports/src/is-module.js

/**
 * A small utility to check if a file qualifies as a module.
 */
export default function isModule(path: NodePath) {
  const { sourceType } = path.node;
  if (sourceType !== "module" && sourceType !== "script") {
    throw path.buildCodeFrameError(
      `Unknown sourceType "${sourceType}", cannot transform.`,
    );
  }
  return path.node.sourceType === "module";
}

// </from> /home/qfox/apps/babel/packages/babel-helper-module-imports/src/is-module.js

// <from> /home/qfox/apps/babel/packages/babel-helper-module-imports/src/import-builder.js

import assert from "assert";
import * as t from "@babel/types";
/**
 * A class to track and accumulate mutations to the AST that will eventually
 * output a new require/import statement list.
 */
export default class ImportBuilder {
  _statements = [];
  _resultName = null;
  _scope = null;
  _hub = null;
  constructor(importedSource, scope, hub) {
    this._scope = scope;
    this._hub = hub;
    this._importedSource = importedSource;
  }
  done() {
    return {
      statements: this._statements,
      resultName: this._resultName,
    };
  }
  import() {
    this._statements.push(
      t.importDeclaration([], t.stringLiteral(this._importedSource)),
    );
    return this;
  }
  require() {
    this._statements.push(
      t.expressionStatement(
        t.callExpression(t.identifier("require"), [
          t.stringLiteral(this._importedSource),
        ]),
      ),
    );
    return this;
  }
  namespace(name = "namespace") {
    name = this._scope.generateUidIdentifier(name);
    const statement = this._statements[this._statements.length - 1];
    assert(statement.type === "ImportDeclaration");
    assert(statement.specifiers.length === 0);
    statement.specifiers = [t.importNamespaceSpecifier(name)];
    this._resultName = t.cloneNode(name);
    return this;
  }
  default(name) {
    name = this._scope.generateUidIdentifier(name);
    const statement = this._statements[this._statements.length - 1];
    assert(statement.type === "ImportDeclaration");
    assert(statement.specifiers.length === 0);
    statement.specifiers = [t.importDefaultSpecifier(name)];
    this._resultName = t.cloneNode(name);
    return this;
  }
  named(name, importName) {
    if (importName === "default") return this.default(name);
    name = this._scope.generateUidIdentifier(name);
    const statement = this._statements[this._statements.length - 1];
    assert(statement.type === "ImportDeclaration");
    assert(statement.specifiers.length === 0);
    statement.specifiers = [t.importSpecifier(name, t.identifier(importName))];
    this._resultName = t.cloneNode(name);
    return this;
  }
  var(name) {
    name = this._scope.generateUidIdentifier(name);
    let statement = this._statements[this._statements.length - 1];
    if (statement.type !== "ExpressionStatement") {
      assert(this._resultName);
      statement = t.expressionStatement(this._resultName);
      this._statements.push(statement);
    }
    this._statements[this._statements.length - 1] = t.variableDeclaration(
      "var",
      [t.variableDeclarator(name, statement.expression)],
    );
    this._resultName = t.cloneNode(name);
    return this;
  }
  defaultInterop() {
    return this._interop(this._hub.addHelper("interopRequireDefault"));
  }
  wildcardInterop() {
    return this._interop(this._hub.addHelper("interopRequireWildcard"));
  }
  _interop(callee) {
    const statement = this._statements[this._statements.length - 1];
    if (statement.type === "ExpressionStatement") {
      statement.expression = t.callExpression(callee, [statement.expression]);
    } else if (statement.type === "VariableDeclaration") {
      assert(statement.declarations.length === 1);
      statement.declarations[0].init = t.callExpression(callee, [
        statement.declarations[0].init,
      ]);
    } else {
      assert.fail("Unexpected type.");
    }
    return this;
  }
  prop(name) {
    const statement = this._statements[this._statements.length - 1];
    if (statement.type === "ExpressionStatement") {
      statement.expression = t.memberExpression(
        statement.expression,
        t.identifier(name),
      );
    } else if (statement.type === "VariableDeclaration") {
      assert(statement.declarations.length === 1);
      statement.declarations[0].init = t.memberExpression(
        statement.declarations[0].init,
        t.identifier(name),
      );
    } else {
      assert.fail("Unexpected type:" + statement.type);
    }
    return this;
  }
  read(name) {
    this._resultName = t.memberExpression(this._resultName, t.identifier(name));
  }
}

// </from> /home/qfox/apps/babel/packages/babel-helper-module-imports/src/import-builder.js

// <from> /home/qfox/apps/babel/packages/babel-helper-get-function-arity/src/index.js

import * as t from "@babel/types";
export default function(node): number {
  const params: Array<Object> = node.params;
  for (let i = 0; i < params.length; i++) {
    const param = params[i];
    if (t.isAssignmentPattern(param) || t.isRestElement(param)) {
      return i;
    }
  }
  return params.length;
}

// </from> /home/qfox/apps/babel/packages/babel-helper-get-function-arity/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-proposal-decorators/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import syntaxDecorators from "@babel/plugin-syntax-decorators";
import visitor from "./transformer";
import legacyVisitor from "./transformer-legacy";
export default declare((api, options) => {
  api.assertVersion(7);
  const { legacy = false } = options;
  if (typeof legacy !== "boolean") {
    throw new Error("'legacy' must be a boolean.");
  }
  const { decoratorsBeforeExport } = options;
  if (decoratorsBeforeExport === undefined) {
    if (!legacy) {
      throw new Error(
        "The decorators plugin requires a 'decoratorsBeforeExport' option," +
          " whose value must be a boolean. If you want to use the legacy" +
          " decorators semantics, you can set the 'legacy: true' option.",
      );
    }
  } else {
    if (legacy) {
      throw new Error(
        "'decoratorsBeforeExport' can't be used with legacy decorators.",
      );
    }
    if (typeof decoratorsBeforeExport !== "boolean") {
      throw new Error("'decoratorsBeforeExport' must be a boolean.");
    }
  }
  return {
    inherits: syntaxDecorators,
    manipulateOptions({ generatorOpts }) {
      generatorOpts.decoratorsBeforeExport = decoratorsBeforeExport;
    },
    visitor: legacy ? legacyVisitor : visitor,
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-proposal-decorators/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-proposal-decorators/src/transformer.js

import { types as t, template } from "@babel/core";
import splitExportDeclaration from "@babel/helper-split-export-declaration";
import ReplaceSupers from "@babel/helper-replace-supers";
function prop(key, value) {
  if (!value) return null;
  return t.objectProperty(t.identifier(key), value);
}
function value(body, params = [], async, generator) {
  const method = t.objectMethod("method", t.identifier("value"), params, body);
  method.async = !!async;
  method.generator = !!generator;
  return method;
}
function hasDecorators({ node }) {
  if (node.decorators && node.decorators.length > 0) return true;
  const body = node.body.body;
  for (let i = 0; i < body.length; i++) {
    const method = body[i];
    if (method.decorators && method.decorators.length > 0) {
      return true;
    }
  }
  return false;
}
function takeDecorators({ node }) {
  let result;
  if (node.decorators && node.decorators.length > 0) {
    result = t.arrayExpression(
      node.decorators.map(decorator => decorator.expression),
    );
  }
  node.decorators = undefined;
  return result;
}
function getKey(node) {
  if (node.computed) {
    return node.key;
  } else if (t.isIdentifier(node.key)) {
    return t.stringLiteral(node.key.name);
  } else {
    return t.stringLiteral(String(node.key.value));
  }
}
function getSingleElementDefinition(path, superRef, classRef, file) {
  const { node, scope } = path;
  const isMethod = path.isClassMethod();
  if (path.isPrivate()) {
    throw path.buildCodeFrameError(
      `Private ${
        isMethod ? "methods" : "fields"
      } in decorated classes are not supported yet.`,
    );
  }
  new ReplaceSupers(
    {
      methodPath: path,
      methodNode: node,
      objectRef: classRef,
      isStatic: node.static,
      superRef,
      scope,
      file,
    },
    true,
  ).replace();
  const properties = [
    prop("kind", t.stringLiteral(isMethod ? node.kind : "field")),
    prop("decorators", takeDecorators(path)),
    prop("static", node.static && t.booleanLiteral(true)),
    prop("key", getKey(node)),
    isMethod
      ? value(node.body, node.params, node.async, node.generator)
      : node.value
        ? value(template.ast`{ return ${node.value} }`)
        : prop("value", scope.buildUndefinedNode()),
  ].filter(Boolean);
  return t.objectExpression(properties);
}
function getElementsDefinitions(path, fId, file) {
  const elements = [];
  for (const p of path.get("body.body")) {
    if (!p.isClassMethod({ kind: "constructor" })) {
      elements.push(
        getSingleElementDefinition(p, path.node.superClass, fId, file),
      );
      p.remove();
    }
  }
  return t.arrayExpression(elements);
}
function getConstructorPath(path) {
  return path
    .get("body.body")
    .find(path => path.isClassMethod({ kind: "constructor" }));
}
const bareSupersVisitor = {
  CallExpression(path, { initializeInstanceElements }) {
    if (path.get("callee").isSuper()) {
      path.insertAfter(t.cloneNode(initializeInstanceElements));
    }
  },
  Function(path) {
    if (!path.isArrowFunctionExpression()) path.skip();
  },
};
function insertInitializeInstanceElements(path, initializeInstanceId) {
  const isBase = !path.node.superClass;
  const initializeInstanceElements = t.callExpression(initializeInstanceId, [
    t.thisExpression(),
  ]);
  const constructorPath = getConstructorPath(path);
  if (constructorPath) {
    if (isBase) {
      constructorPath
        .get("body")
        .unshiftContainer("body", [
          t.expressionStatement(initializeInstanceElements),
        ]);
    } else {
      constructorPath.traverse(bareSupersVisitor, {
        initializeInstanceElements,
      });
    }
  } else {
    const constructor = isBase
      ? t.classMethod(
          "constructor",
          t.identifier("constructor"),
          [],
          t.blockStatement([t.expressionStatement(initializeInstanceElements)]),
        )
      : t.classMethod(
          "constructor",
          t.identifier("constructor"),
          [t.restElement(t.identifier("args"))],
          t.blockStatement([
            t.expressionStatement(
              t.callExpression(t.Super(), [
                t.spreadElement(t.identifier("args")),
              ]),
            ),
            t.expressionStatement(initializeInstanceElements),
          ]),
        );
    path.node.body.body.push(constructor);
  }
}
function transformClass(path, file) {
  const isDeclaration = path.node.id && path.isDeclaration();
  const isStrict = path.isInStrictMode();
  const { superClass } = path.node;
  path.node.type = "ClassDeclaration";
  if (!path.node.id) path.node.id = path.scope.generateUidIdentifier("class");
  const initializeId = path.scope.generateUidIdentifier("initialize");
  const superId =
    superClass &&
    path.scope.generateUidIdentifierBasedOnNode(path.node.superClass, "super");
  if (superClass) path.node.superClass = superId;
  const classDecorators = takeDecorators(path);
  const definitions = getElementsDefinitions(path, path.node.id, file);
  insertInitializeInstanceElements(path, initializeId);
  const expr = template.expression.ast`
      ${addDecorateHelper(file)}(
        ${classDecorators || t.nullLiteral()},
        function (${initializeId}, ${superClass ? superId : null}) {
          ${path.node}
          return { F: ${t.cloneNode(path.node.id)}, d: ${definitions} };
        },
        ${superClass}
      )
    `;
  if (!isStrict) {
    expr.arguments[1].body.directives.push(
      t.directive(t.directiveLiteral("use strict")),
    );
  }
  return isDeclaration ? template.ast`let ${path.node.id} = ${expr}` : expr;
}
function addDecorateHelper(file) {
  try {
    return file.addHelper("decorate");
  } catch (err) {
    if (err.code === "BABEL_HELPER_UNKNOWN") {
      err.message +=
        "\n  '@babel/plugin-transform-decorators' in non-legacy mode" +
        " requires '@babel/core' version ^7.0.2 and you appear to be using" +
        " an older version.";
    }
    throw err;
  }
}
export default {
  ExportDefaultDeclaration(path) {
    let decl = path.get("declaration");
    if (!decl.isClassDeclaration() || !hasDecorators(decl)) return;
    if (decl.node.id) decl = splitExportDeclaration(path);
    decl.replaceWith(transformClass(decl, this.file));
  },
  Class(path) {
    if (hasDecorators(path)) {
      path.replaceWith(transformClass(path, this.file));
    }
  },
};

// </from> /home/qfox/apps/babel/packages/babel-plugin-proposal-decorators/src/transformer.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-proposal-decorators/src/transformer-legacy.js

// Fork of https://github.com/loganfsmyth/babel-plugin-proposal-decorators-legacy
import { template, types as t } from "@babel/core";
const buildClassDecorator = template(`
  DECORATOR(CLASS_REF = INNER) || CLASS_REF;
`);
const buildClassPrototype = template(`
  CLASS_REF.prototype;
`);
const buildGetDescriptor = template(`
    Object.getOwnPropertyDescriptor(TARGET, PROPERTY);
`);
const buildGetObjectInitializer = template(`
    (TEMP = Object.getOwnPropertyDescriptor(TARGET, PROPERTY), (TEMP = TEMP ? TEMP.value : undefined), {
        enumerable: true,
        configurable: true,
        writable: true,
        initializer: function(){
            return TEMP;
        }
    })
`);
const WARNING_CALLS = new WeakSet();
/**
 * If the decorator expressions are non-identifiers, hoist them to before the class so we can be sure
 * that they are evaluated in order.
 */
function applyEnsureOrdering(path) {
  // TODO: This should probably also hoist computed properties.
  const decorators = (path.isClass()
    ? [path].concat(path.get("body.body"))
    : path.get("properties")
  ).reduce((acc, prop) => acc.concat(prop.node.decorators || []), []);
  const identDecorators = decorators.filter(
    decorator => !t.isIdentifier(decorator.expression),
  );
  if (identDecorators.length === 0) return;
  return t.sequenceExpression(
    identDecorators
      .map(decorator => {
        const expression = decorator.expression;
        const id = (decorator.expression = path.scope.generateDeclaredUidIdentifier(
          "dec",
        ));
        return t.assignmentExpression("=", id, expression);
      })
      .concat([path.node]),
  );
}
/**
 * Given a class expression with class-level decorators, create a new expression
 * with the proper decorated behavior.
 */
function applyClassDecorators(classPath) {
  if (!hasClassDecorators(classPath.node)) return;
  const decorators = classPath.node.decorators || [];
  classPath.node.decorators = null;
  const name = classPath.scope.generateDeclaredUidIdentifier("class");
  return decorators
    .map(dec => dec.expression)
    .reverse()
    .reduce(function(acc, decorator) {
      return buildClassDecorator({
        CLASS_REF: t.cloneNode(name),
        DECORATOR: t.cloneNode(decorator),
        INNER: acc,
      }).expression;
    }, classPath.node);
}
function hasClassDecorators(classNode) {
  return !!(classNode.decorators && classNode.decorators.length);
}
/**
 * Given a class expression with method-level decorators, create a new expression
 * with the proper decorated behavior.
 */
function applyMethodDecorators(path, state) {
  if (!hasMethodDecorators(path.node.body.body)) return;
  return applyTargetDecorators(path, state, path.node.body.body);
}
function hasMethodDecorators(body) {
  return body.some(node => node.decorators && node.decorators.length);
}
/**
 * Given an object expression with property decorators, create a new expression
 * with the proper decorated behavior.
 */
function applyObjectDecorators(path, state) {
  if (!hasMethodDecorators(path.node.properties)) return;
  return applyTargetDecorators(path, state, path.node.properties);
}
/**
 * A helper to pull out property decorators into a sequence expression.
 */
function applyTargetDecorators(path, state, decoratedProps) {
  const name = path.scope.generateDeclaredUidIdentifier(
    path.isClass() ? "class" : "obj",
  );
  const exprs = decoratedProps.reduce(function(acc, node) {
    const decorators = node.decorators || [];
    node.decorators = null;
    if (decorators.length === 0) return acc;
    if (node.computed) {
      throw path.buildCodeFrameError(
        "Computed method/property decorators are not yet supported.",
      );
    }
    const property = t.isLiteral(node.key)
      ? node.key
      : t.stringLiteral(node.key.name);
    const target =
      path.isClass() && !node.static
        ? buildClassPrototype({
            CLASS_REF: name,
          }).expression
        : name;
    if (t.isClassProperty(node, { static: false })) {
      const descriptor = path.scope.generateDeclaredUidIdentifier("descriptor");
      const initializer = node.value
        ? t.functionExpression(
            null,
            [],
            t.blockStatement([t.returnStatement(node.value)]),
          )
        : t.nullLiteral();
      node.value = t.callExpression(
        state.addHelper("initializerWarningHelper"),
        [descriptor, t.thisExpression()],
      );
      WARNING_CALLS.add(node.value);
      acc = acc.concat([
        t.assignmentExpression(
          "=",
          descriptor,
          t.callExpression(state.addHelper("applyDecoratedDescriptor"), [
            t.cloneNode(target),
            t.cloneNode(property),
            t.arrayExpression(
              decorators.map(dec => t.cloneNode(dec.expression)),
            ),
            t.objectExpression([
              t.objectProperty(
                t.identifier("configurable"),
                t.booleanLiteral(true),
              ),
              t.objectProperty(
                t.identifier("enumerable"),
                t.booleanLiteral(true),
              ),
              t.objectProperty(
                t.identifier("writable"),
                t.booleanLiteral(true),
              ),
              t.objectProperty(t.identifier("initializer"), initializer),
            ]),
          ]),
        ),
      ]);
    } else {
      acc = acc.concat(
        t.callExpression(state.addHelper("applyDecoratedDescriptor"), [
          t.cloneNode(target),
          t.cloneNode(property),
          t.arrayExpression(decorators.map(dec => t.cloneNode(dec.expression))),
          t.isObjectProperty(node) || t.isClassProperty(node, { static: true })
            ? buildGetObjectInitializer({
                TEMP: path.scope.generateDeclaredUidIdentifier("init"),
                TARGET: t.cloneNode(target),
                PROPERTY: t.cloneNode(property),
              }).expression
            : buildGetDescriptor({
                TARGET: t.cloneNode(target),
                PROPERTY: t.cloneNode(property),
              }).expression,
          t.cloneNode(target),
        ]),
      );
    }
    return acc;
  }, []);
  return t.sequenceExpression([
    t.assignmentExpression("=", t.cloneNode(name), path.node),
    t.sequenceExpression(exprs),
    t.cloneNode(name),
  ]);
}
function decoratedClassToExpression({ node, scope }) {
  if (!hasClassDecorators(node) && !hasMethodDecorators(node.body.body)) {
    return;
  }
  const ref = node.id
    ? t.cloneNode(node.id)
    : scope.generateUidIdentifier("class");
  return t.variableDeclaration("let", [
    t.variableDeclarator(ref, t.toExpression(node)),
  ]);
}
export default {
  ExportDefaultDeclaration(path) {
    const decl = path.get("declaration");
    if (!decl.isClassDeclaration()) return;
    const replacement = decoratedClassToExpression(decl);
    if (replacement) {
      path.replaceWithMultiple([
        replacement,
        t.exportNamedDeclaration(null, [
          t.exportSpecifier(
            t.cloneNode(replacement.declarations[0].id),
            t.identifier("default"),
          ),
        ]),
      ]);
    }
  },
  ClassDeclaration(path) {
    const replacement = decoratedClassToExpression(path);
    if (replacement) {
      path.replaceWith(replacement);
    }
  },
  ClassExpression(path, state) {
    // Create a replacement for the class node if there is one. We do one pass to replace classes with
    // class decorators, and a second pass to process method decorators.
    const decoratedClass =
      applyEnsureOrdering(path) ||
      applyClassDecorators(path, state) ||
      applyMethodDecorators(path, state);
    if (decoratedClass) path.replaceWith(decoratedClass);
  },
  ObjectExpression(path, state) {
    const decoratedObject =
      applyEnsureOrdering(path) || applyObjectDecorators(path, state);
    if (decoratedObject) path.replaceWith(decoratedObject);
  },
  AssignmentExpression(path, state) {
    if (!WARNING_CALLS.has(path.node.right)) return;
    path.replaceWith(
      t.callExpression(state.addHelper("initializerDefineProperty"), [
        t.cloneNode(path.get("left.object").node),
        t.stringLiteral(path.get("left.property").node.name),
        t.cloneNode(path.get("right.arguments")[0].node),
        t.cloneNode(path.get("right.arguments")[1].node),
      ]),
    );
  },
};

// </from> /home/qfox/apps/babel/packages/babel-plugin-proposal-decorators/src/transformer-legacy.js

// <from> /home/qfox/apps/babel/packages/babel-helper-bindify-decorators/src/index.js

import * as t from "@babel/types";
export default function bindifyDecorators(
  decorators: Array<NodePath>,
): Array<NodePath> {
  for (const decoratorPath of decorators) {
    const decorator = decoratorPath.node;
    const expression = decorator.expression;
    if (!t.isMemberExpression(expression)) continue;
    const temp = decoratorPath.scope.maybeGenerateMemoised(expression.object);
    let ref;
    const nodes = [];
    if (temp) {
      ref = temp;
      nodes.push(t.assignmentExpression("=", temp, expression.object));
    } else {
      ref = expression.object;
    }
    nodes.push(
      t.callExpression(
        t.memberExpression(
          t.memberExpression(ref, expression.property, expression.computed),
          t.identifier("bind"),
        ),
        [ref],
      ),
    );
    if (nodes.length === 1) {
      decorator.expression = nodes[0];
    } else {
      decorator.expression = t.sequenceExpression(nodes);
    }
  }
}

// </from> /home/qfox/apps/babel/packages/babel-helper-bindify-decorators/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-modules-umd/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import { basename, extname } from "path";
import {
  isModule,
  rewriteModuleStatementsAndPrepareHeader,
  hasExports,
  isSideEffectImport,
  buildNamespaceInitStatements,
  ensureStatementsHoisted,
  wrapInterop,
} from "@babel/helper-module-transforms";
import { types as t, template } from "@babel/core";
const buildPrerequisiteAssignment = template(`
  GLOBAL_REFERENCE = GLOBAL_REFERENCE || {}
`);
const buildWrapper = template(`
  (function (global, factory) {
    if (typeof define === "function" && define.amd) {
      define(MODULE_NAME, AMD_ARGUMENTS, factory);
    } else if (typeof exports !== "undefined") {
      factory(COMMONJS_ARGUMENTS);
    } else {
      var mod = { exports: {} };
      factory(BROWSER_ARGUMENTS);
      GLOBAL_TO_ASSIGN;
    }
  })(this, function(IMPORT_NAMES) {
  })
`);
export default declare((api, options) => {
  api.assertVersion(7);
  const {
    globals,
    exactGlobals,
    loose,
    allowTopLevelThis,
    strict,
    strictMode,
    noInterop,
  } = options;
  /**
   * Build the assignment statements that initialize the UMD global.
   */
  function buildBrowserInit(
    browserGlobals,
    exactGlobals,
    filename,
    moduleName,
  ) {
    const moduleNameOrBasename = moduleName
      ? moduleName.value
      : basename(filename, extname(filename));
    let globalToAssign = t.memberExpression(
      t.identifier("global"),
      t.identifier(t.toIdentifier(moduleNameOrBasename)),
    );
    let initAssignments = [];
    if (exactGlobals) {
      const globalName = browserGlobals[moduleNameOrBasename];
      if (globalName) {
        initAssignments = [];
        const members = globalName.split(".");
        globalToAssign = members.slice(1).reduce((accum, curr) => {
          initAssignments.push(
            buildPrerequisiteAssignment({
              GLOBAL_REFERENCE: t.cloneNode(accum),
            }),
          );
          return t.memberExpression(accum, t.identifier(curr));
        }, t.memberExpression(t.identifier("global"), t.identifier(members[0])));
      }
    }
    initAssignments.push(
      t.expressionStatement(
        t.assignmentExpression(
          "=",
          globalToAssign,
          t.memberExpression(t.identifier("mod"), t.identifier("exports")),
        ),
      ),
    );
    return initAssignments;
  }
  /**
   * Build the member expression that reads from a global for a given source.
   */
  function buildBrowserArg(browserGlobals, exactGlobals, source) {
    let memberExpression;
    if (exactGlobals) {
      const globalRef = browserGlobals[source];
      if (globalRef) {
        memberExpression = globalRef
          .split(".")
          .reduce(
            (accum, curr) => t.memberExpression(accum, t.identifier(curr)),
            t.identifier("global"),
          );
      } else {
        memberExpression = t.memberExpression(
          t.identifier("global"),
          t.identifier(t.toIdentifier(source)),
        );
      }
    } else {
      const requireName = basename(source, extname(source));
      const globalName = browserGlobals[requireName] || requireName;
      memberExpression = t.memberExpression(
        t.identifier("global"),
        t.identifier(t.toIdentifier(globalName)),
      );
    }
    return memberExpression;
  }
  return {
    visitor: {
      Program: {
        exit(path) {
          if (!isModule(path)) return;
          const browserGlobals = globals || {};
          let moduleName = this.getModuleName();
          if (moduleName) moduleName = t.stringLiteral(moduleName);
          const { meta, headers } = rewriteModuleStatementsAndPrepareHeader(
            path,
            {
              loose,
              strict,
              strictMode,
              allowTopLevelThis,
              noInterop,
            },
          );
          const amdArgs = [];
          const commonjsArgs = [];
          const browserArgs = [];
          const importNames = [];
          if (hasExports(meta)) {
            amdArgs.push(t.stringLiteral("exports"));
            commonjsArgs.push(t.identifier("exports"));
            browserArgs.push(
              t.memberExpression(t.identifier("mod"), t.identifier("exports")),
            );
            importNames.push(t.identifier(meta.exportName));
          }
          for (const [source, metadata] of meta.source) {
            amdArgs.push(t.stringLiteral(source));
            commonjsArgs.push(
              t.callExpression(t.identifier("require"), [
                t.stringLiteral(source),
              ]),
            );
            browserArgs.push(
              buildBrowserArg(browserGlobals, exactGlobals, source),
            );
            importNames.push(t.identifier(metadata.name));
            if (!isSideEffectImport(metadata)) {
              const interop = wrapInterop(
                path,
                t.identifier(metadata.name),
                metadata.interop,
              );
              if (interop) {
                const header = t.expressionStatement(
                  t.assignmentExpression(
                    "=",
                    t.identifier(metadata.name),
                    interop,
                  ),
                );
                header.loc = meta.loc;
                headers.push(header);
              }
            }
            headers.push(
              ...buildNamespaceInitStatements(meta, metadata, loose),
            );
          }
          ensureStatementsHoisted(headers);
          path.unshiftContainer("body", headers);
          const { body, directives } = path.node;
          path.node.directives = [];
          path.node.body = [];
          const umdWrapper = path.pushContainer("body", [
            buildWrapper({
              MODULE_NAME: moduleName,
              AMD_ARGUMENTS: t.arrayExpression(amdArgs),
              COMMONJS_ARGUMENTS: commonjsArgs,
              BROWSER_ARGUMENTS: browserArgs,
              IMPORT_NAMES: importNames,
              GLOBAL_TO_ASSIGN: buildBrowserInit(
                browserGlobals,
                exactGlobals,
                this.filename || "unknown",
                moduleName,
              ),
            }),
          ])[0];
          const umdFactory = umdWrapper
            .get("expression.arguments")[1]
            .get("body");
          umdFactory.pushContainer("directives", directives);
          umdFactory.pushContainer("body", body);
        },
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-modules-umd/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-function-name/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import nameFunction from "@babel/helper-function-name";
export default declare(api => {
  api.assertVersion(7);
  return {
    visitor: {
      FunctionExpression: {
        exit(path) {
          if (path.key !== "value" && !path.parentPath.isObjectProperty()) {
            const replacement = nameFunction(path);
            if (replacement) path.replaceWith(replacement);
          }
        },
      },
      ObjectProperty(path) {
        const value = path.get("value");
        if (value.isFunction()) {
          const newNode = nameFunction(value);
          if (newNode) value.replaceWith(newNode);
        }
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-function-name/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-modules-systemjs/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import hoistVariables from "@babel/helper-hoist-variables";
import { template, types as t } from "@babel/core";
const buildTemplate = template(`
  SYSTEM_REGISTER(MODULE_NAME, SOURCES, function (EXPORT_IDENTIFIER, CONTEXT_IDENTIFIER) {
    "use strict";
    BEFORE_BODY;
    return {
      setters: SETTERS,
      execute: function () {
        BODY;
      }
    };
  });
`);
const buildExportAll = template(`
  for (var KEY in TARGET) {
    if (KEY !== "default" && KEY !== "__esModule") EXPORT_OBJ[KEY] = TARGET[KEY];
  }
`);
function constructExportCall(
  path,
  exportIdent,
  exportNames,
  exportValues,
  exportStarTarget,
) {
  const statements = [];
  if (exportNames.length === 1) {
    statements.push(
      t.expressionStatement(
        t.callExpression(exportIdent, [
          t.stringLiteral(exportNames[0]),
          exportValues[0],
        ]),
      ),
    );
  } else if (!exportStarTarget) {
    const objectProperties = [];
    for (let i = 0; i < exportNames.length; i++) {
      const exportName = exportNames[i];
      const exportValue = exportValues[i];
      objectProperties.push(
        t.objectProperty(t.identifier(exportName), exportValue),
      );
    }
    statements.push(
      t.expressionStatement(
        t.callExpression(exportIdent, [t.objectExpression(objectProperties)]),
      ),
    );
  } else {
    const exportObj = path.scope.generateUid("exportObj");
    statements.push(
      t.variableDeclaration("var", [
        t.variableDeclarator(t.identifier(exportObj), t.objectExpression([])),
      ]),
    );
    statements.push(
      buildExportAll({
        KEY: path.scope.generateUidIdentifier("key"),
        EXPORT_OBJ: t.identifier(exportObj),
        TARGET: exportStarTarget,
      }),
    );
    for (let i = 0; i < exportNames.length; i++) {
      const exportName = exportNames[i];
      const exportValue = exportValues[i];
      statements.push(
        t.expressionStatement(
          t.assignmentExpression(
            "=",
            t.memberExpression(
              t.identifier(exportObj),
              t.identifier(exportName),
            ),
            exportValue,
          ),
        ),
      );
    }
    statements.push(
      t.expressionStatement(
        t.callExpression(exportIdent, [t.identifier(exportObj)]),
      ),
    );
  }
  return statements;
}
const TYPE_IMPORT = "Import";
export default declare((api, options) => {
  api.assertVersion(7);
  const { systemGlobal = "System" } = options;
  const IGNORE_REASSIGNMENT_SYMBOL = Symbol();
  const reassignmentVisitor = {
    "AssignmentExpression|UpdateExpression"(path) {
      if (path.node[IGNORE_REASSIGNMENT_SYMBOL]) return;
      path.node[IGNORE_REASSIGNMENT_SYMBOL] = true;
      const arg = path.get(path.isAssignmentExpression() ? "left" : "argument");
      if (arg.isObjectPattern() || arg.isArrayPattern()) {
        const exprs = [path.node];
        for (const name in arg.getBindingIdentifiers()) {
          if (this.scope.getBinding(name) !== path.scope.getBinding(name)) {
            return;
          }
          const exportedNames = this.exports[name];
          if (!exportedNames) return;
          for (const exportedName of exportedNames) {
            exprs.push(
              this.buildCall(exportedName, t.identifier(name)).expression,
            );
          }
        }
        path.replaceWith(t.sequenceExpression(exprs));
        return;
      }
      if (!arg.isIdentifier()) return;
      const name = arg.node.name;
      // redeclared in this scope
      if (this.scope.getBinding(name) !== path.scope.getBinding(name)) return;
      const exportedNames = this.exports[name];
      if (!exportedNames) return;
      let node = path.node;
      // if it is a non-prefix update expression (x++ etc)
      // then we must replace with the expression (_export('x', x + 1), x++)
      // in order to ensure the same update expression value
      const isPostUpdateExpression = path.isUpdateExpression({ prefix: false });
      if (isPostUpdateExpression) {
        node = t.binaryExpression(
          node.operator[0],
          t.unaryExpression("+", t.cloneNode(node.argument)),
          t.numericLiteral(1),
        );
      }
      for (const exportedName of exportedNames) {
        node = this.buildCall(exportedName, node).expression;
      }
      if (isPostUpdateExpression) {
        node = t.sequenceExpression([node, path.node]);
      }
      path.replaceWith(node);
    },
  };
  return {
    visitor: {
      CallExpression(path, state) {
        if (path.node.callee.type === TYPE_IMPORT) {
          path.replaceWith(
            t.callExpression(
              t.memberExpression(
                t.identifier(state.contextIdent),
                t.identifier("import"),
              ),
              path.node.arguments,
            ),
          );
        }
      },
      MetaProperty(path, state) {
        if (
          path.node.meta.name === "import" &&
          path.node.property.name === "meta"
        ) {
          path.replaceWith(
            t.memberExpression(
              t.identifier(state.contextIdent),
              t.identifier("meta"),
            ),
          );
        }
      },
      ReferencedIdentifier(path, state) {
        if (
          path.node.name == "__moduleName" &&
          !path.scope.hasBinding("__moduleName")
        ) {
          path.replaceWith(
            t.memberExpression(
              t.identifier(state.contextIdent),
              t.identifier("id"),
            ),
          );
        }
      },
      Program: {
        enter(path, state) {
          state.contextIdent = path.scope.generateUid("context");
        },
        exit(path, state) {
          const exportIdent = path.scope.generateUid("export");
          const contextIdent = state.contextIdent;
          const exportNames = Object.create(null);
          const modules = [];
          let beforeBody = [];
          const setters = [];
          const sources = [];
          const variableIds = [];
          const removedPaths = [];
          function addExportName(key, val) {
            exportNames[key] = exportNames[key] || [];
            exportNames[key].push(val);
          }
          function pushModule(source, key, specifiers) {
            let module;
            modules.forEach(function(m) {
              if (m.key === source) {
                module = m;
              }
            });
            if (!module) {
              modules.push(
                (module = { key: source, imports: [], exports: [] }),
              );
            }
            module[key] = module[key].concat(specifiers);
          }
          function buildExportCall(name, val) {
            return t.expressionStatement(
              t.callExpression(t.identifier(exportIdent), [
                t.stringLiteral(name),
                val,
              ]),
            );
          }
          const body: Array<Object> = path.get("body");
          for (const path of body) {
            if (path.isFunctionDeclaration()) {
              beforeBody.push(path.node);
              removedPaths.push(path);
            } else if (path.isImportDeclaration()) {
              const source = path.node.source.value;
              pushModule(source, "imports", path.node.specifiers);
              for (const name in path.getBindingIdentifiers()) {
                path.scope.removeBinding(name);
                variableIds.push(t.identifier(name));
              }
              path.remove();
            } else if (path.isExportAllDeclaration()) {
              pushModule(path.node.source.value, "exports", path.node);
              path.remove();
            } else if (path.isExportDefaultDeclaration()) {
              const declar = path.get("declaration");
              if (
                declar.isClassDeclaration() ||
                declar.isFunctionDeclaration()
              ) {
                const id = declar.node.id;
                const nodes = [];
                if (id) {
                  nodes.push(declar.node);
                  nodes.push(buildExportCall("default", t.cloneNode(id)));
                  addExportName(id.name, "default");
                } else {
                  nodes.push(
                    buildExportCall("default", t.toExpression(declar.node)),
                  );
                }
                if (declar.isClassDeclaration()) {
                  path.replaceWithMultiple(nodes);
                } else {
                  beforeBody = beforeBody.concat(nodes);
                  removedPaths.push(path);
                }
              } else {
                path.replaceWith(buildExportCall("default", declar.node));
              }
            } else if (path.isExportNamedDeclaration()) {
              const declar = path.get("declaration");
              if (declar.node) {
                path.replaceWith(declar);
                if (path.isFunction()) {
                  const node = declar.node;
                  const name = node.id.name;
                  addExportName(name, name);
                  beforeBody.push(node);
                  beforeBody.push(buildExportCall(name, t.cloneNode(node.id)));
                  removedPaths.push(path);
                } else if (path.isClass()) {
                  const name = declar.node.id.name;
                  addExportName(name, name);
                  path.insertAfter([buildExportCall(name, t.identifier(name))]);
                } else {
                  for (const name in declar.getBindingIdentifiers()) {
                    addExportName(name, name);
                  }
                }
              } else {
                const specifiers = path.node.specifiers;
                if (specifiers && specifiers.length) {
                  if (path.node.source) {
                    pushModule(path.node.source.value, "exports", specifiers);
                    path.remove();
                  } else {
                    const nodes = [];
                    for (const specifier of specifiers) {
                      // only globals exported this way
                      if (!path.scope.getBinding(specifier.local.name)) {
                        nodes.push(
                          buildExportCall(
                            specifier.exported.name,
                            specifier.local,
                          ),
                        );
                      }
                      addExportName(
                        specifier.local.name,
                        specifier.exported.name,
                      );
                    }
                    path.replaceWithMultiple(nodes);
                  }
                }
              }
            }
          }
          modules.forEach(function(specifiers) {
            let setterBody = [];
            const target = path.scope.generateUid(specifiers.key);
            for (let specifier of specifiers.imports) {
              if (t.isImportNamespaceSpecifier(specifier)) {
                setterBody.push(
                  t.expressionStatement(
                    t.assignmentExpression(
                      "=",
                      specifier.local,
                      t.identifier(target),
                    ),
                  ),
                );
              } else if (t.isImportDefaultSpecifier(specifier)) {
                specifier = t.importSpecifier(
                  specifier.local,
                  t.identifier("default"),
                );
              }
              if (t.isImportSpecifier(specifier)) {
                setterBody.push(
                  t.expressionStatement(
                    t.assignmentExpression(
                      "=",
                      specifier.local,
                      t.memberExpression(
                        t.identifier(target),
                        specifier.imported,
                      ),
                    ),
                  ),
                );
              }
            }
            if (specifiers.exports.length) {
              const exportNames = [];
              const exportValues = [];
              let hasExportStar = false;
              for (const node of specifiers.exports) {
                if (t.isExportAllDeclaration(node)) {
                  hasExportStar = true;
                } else if (t.isExportSpecifier(node)) {
                  exportNames.push(node.exported.name);
                  exportValues.push(
                    t.memberExpression(t.identifier(target), node.local),
                  );
                } else {
                  // todo
                }
              }
              setterBody = setterBody.concat(
                constructExportCall(
                  path,
                  t.identifier(exportIdent),
                  exportNames,
                  exportValues,
                  hasExportStar ? t.identifier(target) : null,
                ),
              );
            }
            sources.push(t.stringLiteral(specifiers.key));
            setters.push(
              t.functionExpression(
                null,
                [t.identifier(target)],
                t.blockStatement(setterBody),
              ),
            );
          });
          let moduleName = this.getModuleName();
          if (moduleName) moduleName = t.stringLiteral(moduleName);
          const uninitializedVars = [];
          hoistVariables(
            path,
            (id, name, hasInit) => {
              variableIds.push(id);
              if (!hasInit) {
                uninitializedVars.push(name);
              }
            },
            null,
          );
          if (variableIds.length) {
            beforeBody.unshift(
              t.variableDeclaration(
                "var",
                variableIds.map(id => t.variableDeclarator(id)),
              ),
            );
          }
          if (uninitializedVars.length) {
            const undefinedValues = [];
            const undefinedIdent = path.scope.buildUndefinedNode();
            for (let i = 0; i < uninitializedVars.length; i++) {
              undefinedValues[i] = undefinedIdent;
            }
            beforeBody = beforeBody.concat(
              constructExportCall(
                path,
                t.identifier(exportIdent),
                uninitializedVars,
                undefinedValues,
                null,
              ),
            );
          }
          path.traverse(reassignmentVisitor, {
            exports: exportNames,
            buildCall: buildExportCall,
            scope: path.scope,
          });
          for (const path of removedPaths) {
            path.remove();
          }
          path.node.body = [
            buildTemplate({
              SYSTEM_REGISTER: t.memberExpression(
                t.identifier(systemGlobal),
                t.identifier("register"),
              ),
              BEFORE_BODY: beforeBody,
              MODULE_NAME: moduleName,
              SETTERS: t.arrayExpression(setters),
              SOURCES: t.arrayExpression(sources),
              BODY: path.node.body,
              EXPORT_IDENTIFIER: t.identifier(exportIdent),
              CONTEXT_IDENTIFIER: t.identifier(contextIdent),
            }),
          ];
        },
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-modules-systemjs/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-object-assign/src/index.js

import { declare } from "@babel/helper-plugin-utils";
export default declare(api => {
  api.assertVersion(7);
  return {
    visitor: {
      CallExpression: function(path, file) {
        if (path.get("callee").matchesPattern("Object.assign")) {
          path.node.callee = file.addHelper("extends");
        }
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-object-assign/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-block-scoping/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import { visitor as tdzVisitor } from "./tdz";
import values from "lodash/values";
import extend from "lodash/extend";
import { traverse, template, types as t } from "@babel/core";
const DONE = new WeakSet();
export default declare((api, opts) => {
  api.assertVersion(7);
  const { throwIfClosureRequired = false, tdz: tdzEnabled = false } = opts;
  if (typeof throwIfClosureRequired !== "boolean") {
    throw new Error(`.throwIfClosureRequired must be a boolean, or undefined`);
  }
  if (typeof tdzEnabled !== "boolean") {
    throw new Error(`.throwIfClosureRequired must be a boolean, or undefined`);
  }
  return {
    visitor: {
      VariableDeclaration(path) {
        const { node, parent, scope } = path;
        if (!isBlockScoped(node)) return;
        convertBlockScopedToVar(path, null, parent, scope, true);
        if (node._tdzThis) {
          const nodes = [node];
          for (let i = 0; i < node.declarations.length; i++) {
            const decl = node.declarations[i];
            if (decl.init) {
              const assign = t.assignmentExpression("=", decl.id, decl.init);
              assign._ignoreBlockScopingTDZ = true;
              nodes.push(t.expressionStatement(assign));
            }
            decl.init = this.addHelper("temporalUndefined");
          }
          node._blockHoist = 2;
          if (path.isCompletionRecord()) {
            // ensure we don't break completion record semantics by returning
            // the initialiser of the last declarator
            nodes.push(t.expressionStatement(scope.buildUndefinedNode()));
          }
          path.replaceWithMultiple(nodes);
        }
      },
      Loop(path, state) {
        const { parent, scope } = path;
        path.ensureBlock();
        const blockScoping = new BlockScoping(
          path,
          path.get("body"),
          parent,
          scope,
          throwIfClosureRequired,
          tdzEnabled,
          state,
        );
        const replace = blockScoping.run();
        if (replace) path.replaceWith(replace);
      },
      CatchClause(path, state) {
        const { parent, scope } = path;
        const blockScoping = new BlockScoping(
          null,
          path.get("body"),
          parent,
          scope,
          throwIfClosureRequired,
          tdzEnabled,
          state,
        );
        blockScoping.run();
      },
      "BlockStatement|SwitchStatement|Program"(path, state) {
        if (!ignoreBlock(path)) {
          const blockScoping = new BlockScoping(
            null,
            path,
            path.parent,
            path.scope,
            throwIfClosureRequired,
            tdzEnabled,
            state,
          );
          blockScoping.run();
        }
      },
    },
  };
});
function ignoreBlock(path) {
  return t.isLoop(path.parent) || t.isCatchClause(path.parent);
}
const buildRetCheck = template(`
  if (typeof RETURN === "object") return RETURN.v;
`);
function isBlockScoped(node) {
  if (!t.isVariableDeclaration(node)) return false;
  if (node[t.BLOCK_SCOPED_SYMBOL]) return true;
  if (node.kind !== "let" && node.kind !== "const") return false;
  return true;
}
/**
 * If there is a loop ancestor closer than the closest function, we
 * consider ourselves to be in a loop.
 */
function isInLoop(path) {
  const loopOrFunctionParent = path.find(
    path => path.isLoop() || path.isFunction(),
  );
  return loopOrFunctionParent && loopOrFunctionParent.isLoop();
}
function convertBlockScopedToVar(
  path,
  node,
  parent,
  scope,
  moveBindingsToParent = false,
) {
  if (!node) {
    node = path.node;
  }
  // https://github.com/babel/babel/issues/255
  if (isInLoop(path) && !t.isFor(parent)) {
    for (let i = 0; i < node.declarations.length; i++) {
      const declar = node.declarations[i];
      declar.init = declar.init || scope.buildUndefinedNode();
    }
  }
  node[t.BLOCK_SCOPED_SYMBOL] = true;
  node.kind = "var";
  // Move bindings from current block scope to function scope.
  if (moveBindingsToParent) {
    const parentScope = scope.getFunctionParent() || scope.getProgramParent();
    const ids = path.getBindingIdentifiers();
    for (const name in ids) {
      const binding = scope.getOwnBinding(name);
      if (binding) binding.kind = "var";
      scope.moveBindingTo(name, parentScope);
    }
  }
}
function isVar(node) {
  return t.isVariableDeclaration(node, { kind: "var" }) && !isBlockScoped(node);
}
const letReferenceBlockVisitor = traverse.visitors.merge([
  {
    Loop: {
      enter(path, state) {
        state.loopDepth++;
      },
      exit(path, state) {
        state.loopDepth--;
      },
    },
    Function(path, state) {
      // References to block-scoped variables only require added closures if it's
      // possible for the code to run more than once -- otherwise it is safe to
      // simply rename the variables.
      if (state.loopDepth > 0) {
        path.traverse(letReferenceFunctionVisitor, state);
      }
      return path.skip();
    },
  },
  tdzVisitor,
]);
const letReferenceFunctionVisitor = traverse.visitors.merge([
  {
    ReferencedIdentifier(path, state) {
      const ref = state.letReferences[path.node.name];
      // not a part of our scope
      if (!ref) return;
      // this scope has a variable with the same name so it couldn't belong
      // to our let scope
      const localBinding = path.scope.getBindingIdentifier(path.node.name);
      if (localBinding && localBinding !== ref) return;
      state.closurify = true;
    },
  },
  tdzVisitor,
]);
const hoistVarDeclarationsVisitor = {
  enter(path, self) {
    const { node, parent } = path;
    if (path.isForStatement()) {
      if (isVar(node.init, node)) {
        const nodes = self.pushDeclar(node.init);
        if (nodes.length === 1) {
          node.init = nodes[0];
        } else {
          node.init = t.sequenceExpression(nodes);
        }
      }
    } else if (path.isFor()) {
      if (isVar(node.left, node)) {
        self.pushDeclar(node.left);
        node.left = node.left.declarations[0].id;
      }
    } else if (isVar(node, parent)) {
      path.replaceWithMultiple(
        self.pushDeclar(node).map(expr => t.expressionStatement(expr)),
      );
    } else if (path.isFunction()) {
      return path.skip();
    }
  },
};
const loopLabelVisitor = {
  LabeledStatement({ node }, state) {
    state.innerLabels.push(node.label.name);
  },
};
const continuationVisitor = {
  enter(path, state) {
    if (path.isAssignmentExpression() || path.isUpdateExpression()) {
      const bindings = path.getBindingIdentifiers();
      for (const name in bindings) {
        if (
          state.outsideReferences[name] !==
          path.scope.getBindingIdentifier(name)
        ) {
          continue;
        }
        state.reassignments[name] = true;
      }
    } else if (path.isReturnStatement()) {
      state.returnStatements.push(path);
    }
  },
};
function loopNodeTo(node) {
  if (t.isBreakStatement(node)) {
    return "break";
  } else if (t.isContinueStatement(node)) {
    return "continue";
  }
}
const loopVisitor = {
  Loop(path, state) {
    const oldIgnoreLabeless = state.ignoreLabeless;
    state.ignoreLabeless = true;
    path.traverse(loopVisitor, state);
    state.ignoreLabeless = oldIgnoreLabeless;
    path.skip();
  },
  Function(path) {
    path.skip();
  },
  SwitchCase(path, state) {
    const oldInSwitchCase = state.inSwitchCase;
    state.inSwitchCase = true;
    path.traverse(loopVisitor, state);
    state.inSwitchCase = oldInSwitchCase;
    path.skip();
  },
  "BreakStatement|ContinueStatement|ReturnStatement"(path, state) {
    const { node, parent, scope } = path;
    if (node[this.LOOP_IGNORE]) return;
    let replace;
    let loopText = loopNodeTo(node);
    if (loopText) {
      if (node.label) {
        // we shouldn't be transforming this because it exists somewhere inside
        if (state.innerLabels.indexOf(node.label.name) >= 0) {
          return;
        }
        loopText = `${loopText}|${node.label.name}`;
      } else {
        // we shouldn't be transforming these statements because
        // they don't refer to the actual loop we're scopifying
        if (state.ignoreLabeless) return;
        // break statements mean something different in this context
        if (t.isBreakStatement(node) && t.isSwitchCase(parent)) return;
      }
      state.hasBreakContinue = true;
      state.map[loopText] = node;
      replace = t.stringLiteral(loopText);
    }
    if (path.isReturnStatement()) {
      state.hasReturn = true;
      replace = t.objectExpression([
        t.objectProperty(
          t.identifier("v"),
          node.argument || scope.buildUndefinedNode(),
        ),
      ]);
    }
    if (replace) {
      replace = t.returnStatement(replace);
      replace[this.LOOP_IGNORE] = true;
      path.skip();
      path.replaceWith(t.inherits(replace, node));
    }
  },
};
class BlockScoping {
  constructor(
    loopPath?: NodePath,
    blockPath: NodePath,
    parent: Object,
    scope: Scope,
    throwIfClosureRequired: boolean,
    tdzEnabled: boolean,
    state: Object,
  ) {
    this.parent = parent;
    this.scope = scope;
    this.state = state;
    this.throwIfClosureRequired = throwIfClosureRequired;
    this.tdzEnabled = tdzEnabled;
    this.blockPath = blockPath;
    this.block = blockPath.node;
    this.outsideLetReferences = Object.create(null);
    this.hasLetReferences = false;
    this.letReferences = Object.create(null);
    this.body = [];
    if (loopPath) {
      this.loopParent = loopPath.parent;
      this.loopLabel =
        t.isLabeledStatement(this.loopParent) && this.loopParent.label;
      this.loopPath = loopPath;
      this.loop = loopPath.node;
    }
  }
  /**
   * Start the ball rolling.
   */
  run() {
    const block = this.block;
    if (DONE.has(block)) return;
    DONE.add(block);
    const needsClosure = this.getLetReferences();
    this.checkConstants();
    // this is a block within a `Function/Program` so we can safely leave it be
    if (t.isFunction(this.parent) || t.isProgram(this.block)) {
      this.updateScopeInfo();
      return;
    }
    // we can skip everything
    if (!this.hasLetReferences) return;
    if (needsClosure) {
      this.wrapClosure();
    } else {
      this.remap();
    }
    this.updateScopeInfo(needsClosure);
    if (this.loopLabel && !t.isLabeledStatement(this.loopParent)) {
      return t.labeledStatement(this.loopLabel, this.loop);
    }
  }
  checkConstants() {
    const scope = this.scope;
    const state = this.state;
    for (const name in scope.bindings) {
      const binding = scope.bindings[name];
      if (binding.kind !== "const") continue;
      for (const violation of (binding.constantViolations: Array)) {
        const readOnlyError = state.addHelper("readOnlyError");
        const throwNode = t.callExpression(readOnlyError, [
          t.stringLiteral(name),
        ]);
        if (violation.isAssignmentExpression()) {
          violation
            .get("right")
            .replaceWith(
              t.sequenceExpression([throwNode, violation.get("right").node]),
            );
        } else if (violation.isUpdateExpression()) {
          violation.replaceWith(
            t.sequenceExpression([throwNode, violation.node]),
          );
        } else if (violation.isForXStatement()) {
          violation.ensureBlock();
          violation.node.body.body.unshift(t.expressionStatement(throwNode));
        }
      }
    }
  }
  updateScopeInfo(wrappedInClosure) {
    const scope = this.scope;
    const parentScope = scope.getFunctionParent() || scope.getProgramParent();
    const letRefs = this.letReferences;
    for (const key in letRefs) {
      const ref = letRefs[key];
      const binding = scope.getBinding(ref.name);
      if (!binding) continue;
      if (binding.kind === "let" || binding.kind === "const") {
        binding.kind = "var";
        if (wrappedInClosure) {
          scope.removeBinding(ref.name);
        } else {
          scope.moveBindingTo(ref.name, parentScope);
        }
      }
    }
  }
  remap() {
    const letRefs = this.letReferences;
    const scope = this.scope;
    // alright, so since we aren't wrapping this block in a closure
    // we have to check if any of our let variables collide with
    // those in upper scopes and then if they do, generate a uid
    // for them and replace all references with it
    for (const key in letRefs) {
      // just an Identifier node we collected in `getLetReferences`
      // this is the defining identifier of a declaration
      const ref = letRefs[key];
      // todo: could skip this if the colliding binding is in another function
      if (scope.parentHasBinding(key) || scope.hasGlobal(key)) {
        // The same identifier might have been bound separately in the block scope and
        // the enclosing scope (e.g. loop or catch statement), so we should handle both
        // individually
        if (scope.hasOwnBinding(key)) {
          scope.rename(ref.name);
        }
        if (this.blockPath.scope.hasOwnBinding(key)) {
          this.blockPath.scope.rename(ref.name);
        }
      }
    }
  }
  wrapClosure() {
    if (this.throwIfClosureRequired) {
      throw this.blockPath.buildCodeFrameError(
        "Compiling let/const in this block would add a closure " +
          "(throwIfClosureRequired).",
      );
    }
    const block = this.block;
    const outsideRefs = this.outsideLetReferences;
    // remap loop heads with colliding variables
    if (this.loop) {
      for (const name in outsideRefs) {
        const id = outsideRefs[name];
        if (
          this.scope.hasGlobal(id.name) ||
          this.scope.parentHasBinding(id.name)
        ) {
          delete outsideRefs[id.name];
          delete this.letReferences[id.name];
          this.scope.rename(id.name);
          this.letReferences[id.name] = id;
          outsideRefs[id.name] = id;
        }
      }
    }
    // if we're inside of a for loop then we search to see if there are any
    // `break`s, `continue`s, `return`s etc
    this.has = this.checkLoop();
    // hoist let references to retain scope
    this.hoistVarDeclarations();
    // turn outsideLetReferences into an array
    const args = values(outsideRefs).map(id => t.cloneNode(id));
    const params = args.map(id => t.cloneNode(id));
    const isSwitch = this.blockPath.isSwitchStatement();
    // build the closure that we're going to wrap the block with, possible wrapping switch(){}
    const fn = t.functionExpression(
      null,
      params,
      t.blockStatement(isSwitch ? [block] : block.body),
    );
    // continuation
    this.addContinuations(fn);
    let call = t.callExpression(t.nullLiteral(), args);
    let basePath = ".callee";
    // handle generators
    const hasYield = traverse.hasType(
      fn.body,
      "YieldExpression",
      t.FUNCTION_TYPES,
    );
    if (hasYield) {
      fn.generator = true;
      call = t.yieldExpression(call, true);
      basePath = ".argument" + basePath;
    }
    // handlers async functions
    const hasAsync = traverse.hasType(
      fn.body,
      "AwaitExpression",
      t.FUNCTION_TYPES,
    );
    if (hasAsync) {
      fn.async = true;
      call = t.awaitExpression(call);
      basePath = ".argument" + basePath;
    }
    let placeholderPath;
    let index;
    if (this.has.hasReturn || this.has.hasBreakContinue) {
      const ret = this.scope.generateUid("ret");
      this.body.push(
        t.variableDeclaration("var", [
          t.variableDeclarator(t.identifier(ret), call),
        ]),
      );
      placeholderPath = "declarations.0.init" + basePath;
      index = this.body.length - 1;
      this.buildHas(ret);
    } else {
      this.body.push(t.expressionStatement(call));
      placeholderPath = "expression" + basePath;
      index = this.body.length - 1;
    }
    let callPath;
    // replace the current block body with the one we're going to build
    if (isSwitch) {
      const { parentPath, listKey, key } = this.blockPath;
      this.blockPath.replaceWithMultiple(this.body);
      callPath = parentPath.get(listKey)[key + index];
    } else {
      block.body = this.body;
      callPath = this.blockPath.get("body")[index];
    }
    const placeholder = callPath.get(placeholderPath);
    let fnPath;
    if (this.loop) {
      const loopId = this.scope.generateUid("loop");
      const p = this.loopPath.insertBefore(
        t.variableDeclaration("var", [
          t.variableDeclarator(t.identifier(loopId), fn),
        ]),
      );
      placeholder.replaceWith(t.identifier(loopId));
      fnPath = p[0].get("declarations.0.init");
    } else {
      placeholder.replaceWith(fn);
      fnPath = placeholder;
    }
    // Ensure "this", "arguments", and "super" continue to work in the wrapped function.
    fnPath.unwrapFunctionEnvironment();
  }
  /**
   * If any of the outer let variables are reassigned then we need to rename them in
   * the closure so we can get direct access to the outer variable to continue the
   * iteration with bindings based on each iteration.
   *
   * Reference: https://github.com/babel/babel/issues/1078
   */
  addContinuations(fn) {
    const state = {
      reassignments: {},
      returnStatements: [],
      outsideReferences: this.outsideLetReferences,
    };
    this.scope.traverse(fn, continuationVisitor, state);
    for (let i = 0; i < fn.params.length; i++) {
      const param = fn.params[i];
      if (!state.reassignments[param.name]) continue;
      const paramName = param.name;
      const newParamName = this.scope.generateUid(param.name);
      fn.params[i] = t.identifier(newParamName);
      this.scope.rename(paramName, newParamName, fn);
      state.returnStatements.forEach(returnStatement => {
        returnStatement.insertBefore(
          t.expressionStatement(
            t.assignmentExpression(
              "=",
              t.identifier(paramName),
              t.identifier(newParamName),
            ),
          ),
        );
      });
      // assign outer reference as it's been modified internally and needs to be retained
      fn.body.body.push(
        t.expressionStatement(
          t.assignmentExpression(
            "=",
            t.identifier(paramName),
            t.identifier(newParamName),
          ),
        ),
      );
    }
  }
  getLetReferences() {
    const block = this.block;
    let declarators = [];
    if (this.loop) {
      const init = this.loop.left || this.loop.init;
      if (isBlockScoped(init)) {
        declarators.push(init);
        extend(this.outsideLetReferences, t.getBindingIdentifiers(init));
      }
    }
    const addDeclarationsFromChild = (path, node) => {
      node = node || path.node;
      if (
        t.isClassDeclaration(node) ||
        t.isFunctionDeclaration(node) ||
        isBlockScoped(node)
      ) {
        if (isBlockScoped(node)) {
          convertBlockScopedToVar(path, node, block, this.scope);
        }
        declarators = declarators.concat(node.declarations || node);
      }
      if (t.isLabeledStatement(node)) {
        addDeclarationsFromChild(path.get("body"), node.body);
      }
    };
    //
    if (block.body) {
      const declarPaths = this.blockPath.get("body");
      for (let i = 0; i < block.body.length; i++) {
        addDeclarationsFromChild(declarPaths[i]);
      }
    }
    if (block.cases) {
      const declarPaths = this.blockPath.get("cases");
      for (let i = 0; i < block.cases.length; i++) {
        const consequents = block.cases[i].consequent;
        for (let j = 0; j < consequents.length; j++) {
          const declar = consequents[j];
          addDeclarationsFromChild(declarPaths[i], declar);
        }
      }
    }
    //
    for (let i = 0; i < declarators.length; i++) {
      const declar = declarators[i];
      // Passing true as the third argument causes t.getBindingIdentifiers
      // to return only the *outer* binding identifiers of this
      // declaration, rather than (for example) mistakenly including the
      // parameters of a function declaration. Fixes #4880.
      const keys = t.getBindingIdentifiers(declar, false, true);
      extend(this.letReferences, keys);
      this.hasLetReferences = true;
    }
    // no let references so we can just quit
    if (!this.hasLetReferences) return;
    const state = {
      letReferences: this.letReferences,
      closurify: false,
      loopDepth: 0,
      tdzEnabled: this.tdzEnabled,
      addHelper: name => this.addHelper(name),
    };
    if (isInLoop(this.blockPath)) {
      state.loopDepth++;
    }
    // traverse through this block, stopping on functions and checking if they
    // contain any local let references
    this.blockPath.traverse(letReferenceBlockVisitor, state);
    return state.closurify;
  }
  /**
   * If we're inside of a loop then traverse it and check if it has one of
   * the following node types `ReturnStatement`, `BreakStatement`,
   * `ContinueStatement` and replace it with a return value that we can track
   * later on.
   */
  checkLoop(): Object {
    const state = {
      hasBreakContinue: false,
      ignoreLabeless: false,
      inSwitchCase: false,
      innerLabels: [],
      hasReturn: false,
      isLoop: !!this.loop,
      map: {},
      LOOP_IGNORE: Symbol(),
    };
    this.blockPath.traverse(loopLabelVisitor, state);
    this.blockPath.traverse(loopVisitor, state);
    return state;
  }
  /**
   * Hoist all let declarations in this block to before it so they retain scope
   * once we wrap everything in a closure.
   */
  hoistVarDeclarations() {
    this.blockPath.traverse(hoistVarDeclarationsVisitor, this);
  }
  /**
   * Turn a `VariableDeclaration` into an array of `AssignmentExpressions` with
   * their declarations hoisted to before the closure wrapper.
   */
  pushDeclar(node: { type: "VariableDeclaration" }): Array<Object> {
    const declars = [];
    const names = t.getBindingIdentifiers(node);
    for (const name in names) {
      declars.push(t.variableDeclarator(names[name]));
    }
    this.body.push(t.variableDeclaration(node.kind, declars));
    const replace = [];
    for (let i = 0; i < node.declarations.length; i++) {
      const declar = node.declarations[i];
      if (!declar.init) continue;
      const expr = t.assignmentExpression(
        "=",
        t.cloneNode(declar.id),
        t.cloneNode(declar.init),
      );
      replace.push(t.inherits(expr, declar));
    }
    return replace;
  }
  buildHas(ret: string) {
    const body = this.body;
    let retCheck;
    const has = this.has;
    const cases = [];
    if (has.hasReturn) {
      // typeof ret === "object"
      retCheck = buildRetCheck({
        RETURN: t.identifier(ret),
      });
    }
    if (has.hasBreakContinue) {
      for (const key in has.map) {
        cases.push(t.switchCase(t.stringLiteral(key), [has.map[key]]));
      }
      if (has.hasReturn) {
        cases.push(t.switchCase(null, [retCheck]));
      }
      if (cases.length === 1) {
        const single = cases[0];
        body.push(
          t.ifStatement(
            t.binaryExpression("===", t.identifier(ret), single.test),
            single.consequent[0],
          ),
        );
      } else {
        if (this.loop) {
          // https://github.com/babel/babel/issues/998
          for (let i = 0; i < cases.length; i++) {
            const caseConsequent = cases[i].consequent[0];
            if (t.isBreakStatement(caseConsequent) && !caseConsequent.label) {
              if (!this.loopLabel) {
                this.loopLabel = this.scope.generateUidIdentifier("loop");
              }
              caseConsequent.label = t.cloneNode(this.loopLabel);
            }
          }
        }
        body.push(t.switchStatement(t.identifier(ret), cases));
      }
    } else {
      if (has.hasReturn) {
        body.push(retCheck);
      }
    }
  }
}

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-block-scoping/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-block-scoping/src/tdz.js

import { types as t } from "@babel/core";
function getTDZStatus(refPath, bindingPath) {
  const executionStatus = bindingPath._guessExecutionStatusRelativeTo(refPath);
  if (executionStatus === "before") {
    return "inside";
  } else if (executionStatus === "after") {
    return "outside";
  } else {
    return "maybe";
  }
}
function buildTDZAssert(node, state) {
  return t.callExpression(state.addHelper("temporalRef"), [
    node,
    t.stringLiteral(node.name),
  ]);
}
function isReference(node, scope, state) {
  const declared = state.letReferences[node.name];
  if (!declared) return false;
  // declared node is different in this scope
  return scope.getBindingIdentifier(node.name) === declared;
}
export const visitor = {
  ReferencedIdentifier(path, state) {
    if (!state.tdzEnabled) return;
    const { node, parent, scope } = path;
    if (path.parentPath.isFor({ left: node })) return;
    if (!isReference(node, scope, state)) return;
    const bindingPath = scope.getBinding(node.name).path;
    if (bindingPath.isFunctionDeclaration()) return;
    const status = getTDZStatus(path, bindingPath);
    if (status === "inside") return;
    if (status === "maybe") {
      const assert = buildTDZAssert(node, state);
      // add tdzThis to parent variable declarator so it's exploded
      bindingPath.parent._tdzThis = true;
      path.skip();
      if (path.parentPath.isUpdateExpression()) {
        if (parent._ignoreBlockScopingTDZ) return;
        path.parentPath.replaceWith(t.sequenceExpression([assert, parent]));
      } else {
        path.replaceWith(assert);
      }
    } else if (status === "outside") {
      path.replaceWith(
        t.throwStatement(
          t.inherits(
            t.newExpression(t.identifier("ReferenceError"), [
              t.stringLiteral(
                `${node.name} is not defined - temporal dead zone`,
              ),
            ]),
            node,
          ),
        ),
      );
    }
  },
  AssignmentExpression: {
    exit(path, state) {
      if (!state.tdzEnabled) return;
      const { node } = path;
      if (node._ignoreBlockScopingTDZ) return;
      const nodes = [];
      const ids = path.getBindingIdentifiers();
      for (const name in ids) {
        const id = ids[name];
        if (isReference(id, path.scope, state)) {
          nodes.push(buildTDZAssert(id, state));
        }
      }
      if (nodes.length) {
        node._ignoreBlockScopingTDZ = true;
        nodes.push(node);
        path.replaceWithMultiple(nodes.map(t.expressionStatement));
      }
    },
  },
};

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-block-scoping/src/tdz.js

// <from> /home/qfox/apps/babel/packages/babel-helper-define-map/src/index.js

import nameFunction from "@babel/helper-function-name";
import has from "lodash/has";
import * as t from "@babel/types";
function toKind(node: Object) {
  if (t.isClassMethod(node) || t.isObjectMethod(node)) {
    if (node.kind === "get" || node.kind === "set") {
      return node.kind;
    }
  }
  return "value";
}
export function push(
  mutatorMap: Object,
  node: Object,
  kind: string,
  file,
  scope?,
): Object {
  const alias = t.toKeyAlias(node);
  //
  let map = {};
  if (has(mutatorMap, alias)) map = mutatorMap[alias];
  mutatorMap[alias] = map;
  //
  map._inherits = map._inherits || [];
  map._inherits.push(node);
  map._key = node.key;
  if (node.computed) {
    map._computed = true;
  }
  if (node.decorators) {
    const decorators = (map.decorators =
      map.decorators || t.arrayExpression([]));
    decorators.elements = decorators.elements.concat(
      node.decorators.map(dec => dec.expression).reverse(),
    );
  }
  if (map.value || map.initializer) {
    throw file.buildCodeFrameError(node, "Key conflict with sibling node");
  }
  let key, value;
  // save the key so we can possibly do function name inferences
  if (
    t.isObjectProperty(node) ||
    t.isObjectMethod(node) ||
    t.isClassMethod(node)
  ) {
    key = t.toComputedKey(node, node.key);
  }
  if (t.isProperty(node)) {
    value = node.value;
  } else if (t.isObjectMethod(node) || t.isClassMethod(node)) {
    value = t.functionExpression(
      null,
      node.params,
      node.body,
      node.generator,
      node.async,
    );
    value.returnType = node.returnType;
  }
  const inheritedKind = toKind(node);
  if (!kind || inheritedKind !== "value") {
    kind = inheritedKind;
  }
  // infer function name
  if (
    scope &&
    t.isStringLiteral(key) &&
    (kind === "value" || kind === "initializer") &&
    t.isFunctionExpression(value)
  ) {
    value = nameFunction({ id: key, node: value, scope });
  }
  if (value) {
    t.inheritsComments(value, node);
    map[kind] = value;
  }
  return map;
}
export function hasComputed(mutatorMap: Object): boolean {
  for (const key in mutatorMap) {
    if (mutatorMap[key]._computed) {
      return true;
    }
  }
  return false;
}
export function toComputedObjectFromClass(obj: Object): Object {
  const objExpr = t.arrayExpression([]);
  for (let i = 0; i < obj.properties.length; i++) {
    const prop = obj.properties[i];
    const val = prop.value;
    val.properties.unshift(
      t.objectProperty(t.identifier("key"), t.toComputedKey(prop)),
    );
    objExpr.elements.push(val);
  }
  return objExpr;
}
export function toClassObject(mutatorMap: Object): Object {
  const objExpr = t.objectExpression([]);
  Object.keys(mutatorMap).forEach(function(mutatorMapKey) {
    const map = mutatorMap[mutatorMapKey];
    const mapNode = t.objectExpression([]);
    const propNode = t.objectProperty(map._key, mapNode, map._computed);
    Object.keys(map).forEach(function(key) {
      const node = map[key];
      if (key[0] === "_") return;
      const prop = t.objectProperty(t.identifier(key), node);
      t.inheritsComments(prop, node);
      t.removeComments(node);
      mapNode.properties.push(prop);
    });
    objExpr.properties.push(propNode);
  });
  return objExpr;
}
export function toDefineObject(mutatorMap: Object): Object {
  Object.keys(mutatorMap).forEach(function(key) {
    const map = mutatorMap[key];
    if (map.value) map.writable = t.booleanLiteral(true);
    map.configurable = t.booleanLiteral(true);
    map.enumerable = t.booleanLiteral(true);
  });
  return toClassObject(mutatorMap);
}

// </from> /home/qfox/apps/babel/packages/babel-helper-define-map/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-helper-call-delegate/src/index.js

import hoistVariables from "@babel/helper-hoist-variables";
import * as t from "@babel/types";
const visitor = {
  enter(path, state) {
    if (path.isThisExpression()) {
      state.foundThis = true;
    }
    if (path.isReferencedIdentifier({ name: "arguments" })) {
      state.foundArguments = true;
    }
  },
  Function(path) {
    path.skip();
  },
};
export default function(path: NodePath, scope = path.scope) {
  const { node } = path;
  const container = t.functionExpression(
    null,
    [],
    node.body,
    node.generator,
    node.async,
  );
  let callee = container;
  let args = [];
  // todo: only hoist if necessary
  hoistVariables(path, id => scope.push({ id }));
  const state = {
    foundThis: false,
    foundArguments: false,
  };
  path.traverse(visitor, state);
  if (state.foundArguments) {
    callee = t.memberExpression(container, t.identifier("apply"));
    args = [];
    if (state.foundThis) {
      args.push(t.thisExpression());
    }
    if (state.foundArguments) {
      if (!state.foundThis) args.push(t.nullLiteral());
      args.push(t.identifier("arguments"));
    }
  }
  let call = t.callExpression(callee, args);
  if (node.generator) call = t.yieldExpression(call, true);
  return t.returnStatement(call);
}

// </from> /home/qfox/apps/babel/packages/babel-helper-call-delegate/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-proposal-optional-chaining/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import syntaxOptionalChaining from "@babel/plugin-syntax-optional-chaining";
import { types as t } from "@babel/core";
export default declare((api, options) => {
  api.assertVersion(7);
  const { loose = false } = options;
  function optional(path, replacementPath) {
    const { scope } = path;
    const optionals = [];
    let objectPath = path;
    while (
      objectPath.isOptionalMemberExpression() ||
      objectPath.isOptionalCallExpression()
    ) {
      const { node } = objectPath;
      if (node.optional) {
        optionals.push(node);
      }
      if (objectPath.isOptionalMemberExpression()) {
        objectPath.node.type = "MemberExpression";
        objectPath = objectPath.get("object");
      } else {
        objectPath.node.type = "CallExpression";
        objectPath = objectPath.get("callee");
      }
    }
    for (let i = optionals.length - 1; i >= 0; i--) {
      const node = optionals[i];
      node.optional = false;
      const isCall = t.isCallExpression(node);
      const replaceKey = isCall ? "callee" : "object";
      const chain = node[replaceKey];
      let ref;
      let check;
      if (loose && isCall) {
        // If we are using a loose transform (avoiding a Function#call) and we are at the call,
        // we can avoid a needless memoize.
        check = ref = chain;
      } else {
        ref = scope.maybeGenerateMemoised(chain);
        if (ref) {
          check = t.assignmentExpression(
            "=",
            t.cloneNode(ref),
            // Here `chain` MUST NOT be cloned because it could be updated
            // when generating the memoised context of a call espression
            chain,
          );
          node[replaceKey] = ref;
        } else {
          check = ref = chain;
        }
      }
      // Ensure call expressions have the proper `this`
      // `foo.bar()` has context `foo`.
      if (isCall && t.isMemberExpression(chain)) {
        if (loose) {
          // To avoid a Function#call, we can instead re-grab the property from the context object.
          // `a.?b.?()` translates roughly to `_a.b != null && _a.b()`
          node.callee = chain;
        } else {
          // Otherwise, we need to memoize the context object, and change the call into a Function#call.
          // `a.?b.?()` translates roughly to `(_b = _a.b) != null && _b.call(_a)`
          const { object } = chain;
          let context = scope.maybeGenerateMemoised(object);
          if (context) {
            chain.object = t.assignmentExpression("=", context, object);
          } else {
            context = object;
          }
          node.arguments.unshift(t.cloneNode(context));
          node.callee = t.memberExpression(node.callee, t.identifier("call"));
        }
      }
      replacementPath.replaceWith(
        t.conditionalExpression(
          loose
            ? t.binaryExpression("==", t.cloneNode(check), t.nullLiteral())
            : t.logicalExpression(
                "||",
                t.binaryExpression("===", t.cloneNode(check), t.nullLiteral()),
                t.binaryExpression(
                  "===",
                  t.cloneNode(ref),
                  scope.buildUndefinedNode(),
                ),
              ),
          scope.buildUndefinedNode(),
          replacementPath.node,
        ),
      );
      replacementPath = replacementPath.get("alternate");
    }
  }
  function findReplacementPath(path) {
    return path.find(path => {
      const { parentPath } = path;
      if (path.key == "object" && parentPath.isOptionalMemberExpression()) {
        return false;
      }
      if (path.key == "callee" && parentPath.isOptionalCallExpression()) {
        return false;
      }
      if (
        path.key == "argument" &&
        parentPath.isUnaryExpression({ operator: "delete" })
      ) {
        return false;
      }
      return true;
    });
  }
  return {
    inherits: syntaxOptionalChaining,
    visitor: {
      "OptionalCallExpression|OptionalMemberExpression"(path) {
        if (!path.node.optional) {
          return;
        }
        optional(path, findReplacementPath(path));
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-proposal-optional-chaining/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-helper-member-expression-to-functions/src/index.js

import * as t from "@babel/types";
class AssignmentMemoiser {
  constructor() {
    this._map = new WeakMap();
  }
  has(key) {
    return this._map.has(key);
  }
  get(key) {
    if (!this.has(key)) return;
    const record = this._map.get(key);
    const { value } = record;
    record.count--;
    if (record.count === 0) {
      // The `count` access is the outermost function call (hopefully), so it
      // does the assignment.
      return t.assignmentExpression("=", value, key);
    }
    return value;
  }
  set(key, value, count) {
    return this._map.set(key, { count, value });
  }
}
const handle = {
  memoise() {
    // noop.
  },
  handle(member) {
    const { node, parent, parentPath } = member;
    // MEMBER++   ->   _set(MEMBER, (_ref = (+_get(MEMBER))) + 1), _ref
    // ++MEMBER   ->   _set(MEMBER, (+_get(MEMBER)) + 1)
    if (parentPath.isUpdateExpression({ argument: node })) {
      const { operator, prefix } = parent;
      // Give the state handler a chance to memoise the member, since we'll
      // reference it twice. The second access (the set) should do the memo
      // assignment.
      this.memoise(member, 2);
      const value = t.binaryExpression(
        operator[0],
        t.unaryExpression("+", this.get(member)),
        t.numericLiteral(1),
      );
      if (prefix) {
        parentPath.replaceWith(this.set(member, value));
      } else {
        const { scope } = member;
        const ref = scope.generateUidIdentifierBasedOnNode(node);
        scope.push({ id: ref });
        value.left = t.assignmentExpression("=", t.cloneNode(ref), value.left);
        parentPath.replaceWith(
          t.sequenceExpression([this.set(member, value), t.cloneNode(ref)]),
        );
      }
      return;
    }
    // MEMBER = VALUE   ->   _set(MEMBER, VALUE)
    // MEMBER += VALUE   ->   _set(MEMBER, _get(MEMBER) + VALUE)
    if (parentPath.isAssignmentExpression({ left: node })) {
      const { operator, right } = parent;
      let value = right;
      if (operator !== "=") {
        // Give the state handler a chance to memoise the member, since we'll
        // reference it twice. The second access (the set) should do the memo
        // assignment.
        this.memoise(member, 2);
        value = t.binaryExpression(
          operator.slice(0, -1),
          this.get(member),
          value,
        );
      }
      parentPath.replaceWith(this.set(member, value));
      return;
    }
    // MEMBER(ARGS)   ->   _call(MEMBER, ARGS)
    if (parentPath.isCallExpression({ callee: node })) {
      const { arguments: args } = parent;
      parentPath.replaceWith(this.call(member, args));
      return;
    }
    // MEMBER   ->   _get(MEMBER)
    member.replaceWith(this.get(member));
  },
};
// We do not provide a default traversal visitor
// Instead, caller passes one, and must call `state.handle` on the members
// it wishes to be transformed.
// Additionally, the caller must pass in a state object with at least
// get, set, and call methods.
// Optionally, a memoise method may be defined on the state, which will be
// called when the member is a self-referential update.
export default function memberExpressionToFunctions(path, visitor, state) {
  path.traverse(visitor, {
    ...handle,
    ...state,
    memoiser: new AssignmentMemoiser(),
  });
}

// </from> /home/qfox/apps/babel/packages/babel-helper-member-expression-to-functions/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-unicode-regex/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import rewritePattern from "regexpu-core";
import * as regex from "@babel/helper-regex";
export default declare(api => {
  api.assertVersion(7);
  return {
    visitor: {
      RegExpLiteral({ node }) {
        if (!regex.is(node, "u")) return;
        node.pattern = rewritePattern(node.pattern, node.flags);
        regex.pullFlag(node, "u");
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-unicode-regex/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-syntax-nullish-coalescing-operator/src/index.js

import { declare } from "@babel/helper-plugin-utils";
export default declare(api => {
  api.assertVersion(7);
  return {
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("nullishCoalescingOperator");
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-syntax-nullish-coalescing-operator/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-syntax-export-default-from/src/index.js

import { declare } from "@babel/helper-plugin-utils";
export default declare(api => {
  api.assertVersion(7);
  return {
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("exportDefaultFrom");
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-syntax-export-default-from/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-helper-plugin-test-runner/src/index.js

import testRunner from "@babel/helper-transform-fixture-test-runner";
import path from "path";
export default function(loc) {
  const name = path.basename(path.dirname(loc));
  testRunner(loc + "/fixtures", name);
}

// </from> /home/qfox/apps/babel/packages/babel-helper-plugin-test-runner/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-runtime/helpers/toArray.js

var arrayWithHoles = require("./arrayWithHoles");
var iterableToArray = require("./iterableToArray");
var nonIterableRest = require("./nonIterableRest");
function _toArray(arr) {
  return arrayWithHoles(arr) || iterableToArray(arr) || nonIterableRest();
}
module.exports = _toArray;
// </from> /home/qfox/apps/babel/packages/babel-runtime/helpers/toArray.js

// <from> /home/qfox/apps/babel/packages/babel-runtime/helpers/esm/toArray.js

import arrayWithHoles from "./arrayWithHoles";
import iterableToArray from "./iterableToArray";
import nonIterableRest from "./nonIterableRest";
export default function _toArray(arr) {
  return arrayWithHoles(arr) || iterableToArray(arr) || nonIterableRest();
}
// </from> /home/qfox/apps/babel/packages/babel-runtime/helpers/esm/toArray.js

// <from> /home/qfox/apps/babel/packages/babel-runtime/helpers/esm/temporalRef.js

import undef from "./temporalUndefined";
export default function _temporalRef(val, name) {
  if (val === undef) {
    throw new ReferenceError(name + " is not defined - temporal dead zone");
  } else {
    return val;
  }
}
// </from> /home/qfox/apps/babel/packages/babel-runtime/helpers/esm/temporalRef.js

// <from> /home/qfox/apps/babel/packages/babel-runtime/helpers/esm/iterableToArray.js

export default function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}
// </from> /home/qfox/apps/babel/packages/babel-runtime/helpers/esm/iterableToArray.js

// <from> /home/qfox/apps/babel/packages/babel-runtime/helpers/temporalRef.js

var temporalUndefined = require("./temporalUndefined");
function _temporalRef(val, name) {
  if (val === temporalUndefined) {
    throw new ReferenceError(name + " is not defined - temporal dead zone");
  } else {
    return val;
  }
}
module.exports = _temporalRef;
// </from> /home/qfox/apps/babel/packages/babel-runtime/helpers/temporalRef.js

// <from> /home/qfox/apps/babel/packages/babel-runtime/helpers/iterableToArray.js

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}
module.exports = _iterableToArray;
// </from> /home/qfox/apps/babel/packages/babel-runtime/helpers/iterableToArray.js

// <from> /home/qfox/apps/babel/packages/babel-runtime/regenerator/index.js

module.exports = require("regenerator-runtime");

// </from> /home/qfox/apps/babel/packages/babel-runtime/regenerator/index.js

// <from> /home/qfox/apps/babel/packages/babel-register/src/index.js

/**
 * This file wraps the compiled ES6 module implementation of register so
 * that it can be used both from a standard CommonJS environment, and also
 * from a compiled Babel import.
 */
exports = module.exports = function(...args) {
  return register(...args);
};
exports.__esModule = true;
const node = require("./node");
const register = node.default;
Object.assign(exports, node);

// </from> /home/qfox/apps/babel/packages/babel-register/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-register/src/browser.js

// required to safely use babel/register within a browserify codebase
export default function register() {}
export function revert() {}

// </from> /home/qfox/apps/babel/packages/babel-register/src/browser.js

// <from> /home/qfox/apps/babel/packages/babel-register/src/cache.js

import path from "path";
import fs from "fs";
import { sync as mkdirpSync } from "mkdirp";
import homeOrTmp from "home-or-tmp";
import * as babel from "@babel/core";
import findCacheDir from "find-cache-dir";
const DEFAULT_CACHE_DIR =
  findCacheDir({ name: "@babel/register" }) || homeOrTmp;
const DEFAULT_FILENAME = path.join(
  DEFAULT_CACHE_DIR,
  `.babel.${babel.version}.${babel.getEnv()}.json`,
);
const FILENAME: string = process.env.BABEL_CACHE_PATH || DEFAULT_FILENAME;
let data: Object = {};
/**
 * Write stringified cache to disk.
 */
export function save() {
  let serialised: string = "{}";
  try {
    serialised = JSON.stringify(data, null, "  ");
  } catch (err) {
    if (err.message === "Invalid string length") {
      err.message = "Cache too large so it's been cleared.";
      console.error(err.stack);
    } else {
      throw err;
    }
  }
  mkdirpSync(path.dirname(FILENAME));
  fs.writeFileSync(FILENAME, serialised);
}
/**
 * Load cache from disk and parse.
 */
export function load() {
  if (process.env.BABEL_DISABLE_CACHE) return;
  process.on("exit", save);
  process.nextTick(save);
  if (!fs.existsSync(FILENAME)) return;
  try {
    data = JSON.parse(fs.readFileSync(FILENAME));
  } catch (err) {
    return;
  }
}
/**
 * Retrieve data from cache.
 */
export function get(): Object {
  return data;
}
/**
 * Clear the cache object.
 */
export function clear() {
  data = {};
}

// </from> /home/qfox/apps/babel/packages/babel-register/src/cache.js

// <from> /home/qfox/apps/babel/packages/babel-register/src/node.js

import deepClone from "lodash/cloneDeep";
import sourceMapSupport from "source-map-support";
import * as registerCache from "./cache";
import escapeRegExp from "lodash/escapeRegExp";
import * as babel from "@babel/core";
import { OptionManager, DEFAULT_EXTENSIONS } from "@babel/core";
import { addHook } from "pirates";
import fs from "fs";
import path from "path";
const maps = {};
let transformOpts = {};
let piratesRevert = null;
function installSourceMapSupport() {
  sourceMapSupport.install({
    handleUncaughtExceptions: false,
    environment: "node",
    retrieveSourceMap(source) {
      const map = maps && maps[source];
      if (map) {
        return {
          url: null,
          map: map,
        };
      } else {
        return null;
      }
    },
  });
}
let cache;
function mtime(filename) {
  return +fs.statSync(filename).mtime;
}
function compile(code, filename) {
  // merge in base options and resolve all the plugins and presets relative to this file
  const opts = new OptionManager().init(
    // sourceRoot can be overwritten
    {
      sourceRoot: path.dirname(filename),
      ...deepClone(transformOpts),
      filename,
    },
  );
  // Bail out ASAP if the file has been ignored.
  if (opts === null) return code;
  let cacheKey = `${JSON.stringify(opts)}:${babel.version}`;
  const env = babel.getEnv(false);
  if (env) cacheKey += `:${env}`;
  let cached = cache && cache[cacheKey];
  if (!cached || cached.mtime !== mtime(filename)) {
    cached = babel.transform(code, {
      ...opts,
      sourceMaps: opts.sourceMaps === undefined ? "both" : opts.sourceMaps,
      ast: false,
    });
    if (cache) {
      cache[cacheKey] = cached;
      cached.mtime = mtime(filename);
    }
  }
  if (cached.map) {
    if (Object.keys(maps).length === 0) {
      installSourceMapSupport();
    }
    maps[filename] = cached.map;
  }
  return cached.code;
}
let compiling = false;
function compileHook(code, filename) {
  if (compiling) return code;
  try {
    compiling = true;
    return compile(code, filename);
  } finally {
    compiling = false;
  }
}
function hookExtensions(exts) {
  if (piratesRevert) piratesRevert();
  piratesRevert = addHook(compileHook, { exts, ignoreNodeModules: false });
}
export function revert() {
  if (piratesRevert) piratesRevert();
}
register();
export default function register(opts?: Object = {}) {
  // Clone to avoid mutating the arguments object with the 'delete's below.
  opts = {
    ...opts,
  };
  hookExtensions(opts.extensions || DEFAULT_EXTENSIONS);
  if (opts.cache === false && cache) {
    registerCache.clear();
    cache = null;
  } else if (opts.cache !== false && !cache) {
    registerCache.load();
    cache = registerCache.get();
  }
  delete opts.extensions;
  delete opts.cache;
  transformOpts = {
    ...opts,
    caller: {
      name: "@babel/register",
      ...(opts.caller || {}),
    },
  };
  let { cwd = "." } = transformOpts;
  // Ensure that the working directory is resolved up front so that
  // things don't break if it changes later.
  cwd = transformOpts.cwd = path.resolve(cwd);
  if (transformOpts.ignore === undefined && transformOpts.only === undefined) {
    transformOpts.only = [
      // Only compile things inside the current working directory.
      new RegExp("^" + escapeRegExp(cwd), "i"),
    ];
    transformOpts.ignore = [
      // Ignore any node_modules inside the current working directory.
      new RegExp(
        "^" +
          escapeRegExp(cwd) +
          "(?:" +
          path.sep +
          ".*)?" +
          escapeRegExp(path.sep + "node_modules" + path.sep),
        "i",
      ),
    ];
  }
}

// </from> /home/qfox/apps/babel/packages/babel-register/src/node.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-react-jsx/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import jsx from "@babel/plugin-syntax-jsx";
import helper from "@babel/helper-builder-react-jsx";
import { types as t } from "@babel/core";
export default declare((api, options) => {
  api.assertVersion(7);
  const THROW_IF_NAMESPACE =
    options.throwIfNamespace === undefined ? true : !!options.throwIfNamespace;
  const PRAGMA_DEFAULT = options.pragma || "React.createElement";
  const PRAGMA_FRAG_DEFAULT = options.pragmaFrag || "React.Fragment";
  const JSX_ANNOTATION_REGEX = /\*?\s*@jsx\s+([^\s]+)/;
  const JSX_FRAG_ANNOTATION_REGEX = /\*?\s*@jsxFrag\s+([^\s]+)/;
  // returns a closure that returns an identifier or memberExpression node
  // based on the given id
  const createIdentifierParser = (id: string) => () => {
    return id
      .split(".")
      .map(name => t.identifier(name))
      .reduce((object, property) => t.memberExpression(object, property));
  };
  const visitor = helper({
    pre(state) {
      const tagName = state.tagName;
      const args = state.args;
      if (t.react.isCompatTag(tagName)) {
        args.push(t.stringLiteral(tagName));
      } else {
        args.push(state.tagExpr);
      }
    },
    post(state, pass) {
      state.callee = pass.get("jsxIdentifier")();
    },
    throwIfNamespace: THROW_IF_NAMESPACE,
  });
  visitor.Program = {
    enter(path, state) {
      const { file } = state;
      let pragma = PRAGMA_DEFAULT;
      let pragmaFrag = PRAGMA_FRAG_DEFAULT;
      let pragmaSet = !!options.pragma;
      let pragmaFragSet = !!options.pragmaFrag;
      for (const comment of (file.ast.comments: Array<Object>)) {
        const jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);
        if (jsxMatches) {
          pragma = jsxMatches[1];
          pragmaSet = true;
        }
        const jsxFragMatches = JSX_FRAG_ANNOTATION_REGEX.exec(comment.value);
        if (jsxFragMatches) {
          pragmaFrag = jsxFragMatches[1];
          pragmaFragSet = true;
        }
      }
      state.set("jsxIdentifier", createIdentifierParser(pragma));
      state.set("jsxFragIdentifier", createIdentifierParser(pragmaFrag));
      state.set("usedFragment", false);
      state.set("pragmaSet", pragmaSet);
      state.set("pragmaFragSet", pragmaFragSet);
    },
    exit(path, state) {
      if (
        state.get("pragmaSet") &&
        state.get("usedFragment") &&
        !state.get("pragmaFragSet")
      ) {
        throw new Error(
          "transform-react-jsx: pragma has been set but " +
            "pragmafrag has not been set",
        );
      }
    },
  };
  visitor.JSXAttribute = function(path) {
    if (t.isJSXElement(path.node.value)) {
      path.node.value = t.jsxExpressionContainer(path.node.value);
    }
  };
  return {
    inherits: jsx,
    visitor,
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-react-jsx/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/index.js

// @flow
export { default as File } from "./transformation/file/file";
export {
  default as buildExternalHelpers,
} from "./tools/build-external-helpers";
export { resolvePlugin, resolvePreset } from "./config/files";
export { version } from "../package.json";
export { getEnv } from "./config/helpers/environment";
export * as types from "@babel/types";
export { default as traverse } from "@babel/traverse";
export { default as template } from "@babel/template";
export { createConfigItem } from "./config/item";
export { loadPartialConfig, loadOptions } from "./config";
export { transform, transformSync, transformAsync } from "./transform";
export {
  transformFile,
  transformFileSync,
  transformFileAsync,
} from "./transform-file";
export {
  transformFromAst,
  transformFromAstSync,
  transformFromAstAsync,
} from "./transform-ast";
export { parse, parseSync, parseAsync } from "./parse";
/**
 * Recommended set of compilable extensions. Not used in @babel/core directly, but meant as
 * as an easy source for tooling making use of @babel/core.
 */
export const DEFAULT_EXTENSIONS = Object.freeze([
  ".js",
  ".jsx",
  ".es6",
  ".es",
  ".mjs",
]);
// For easier backward-compatibility, provide an API like the one we exposed in Babel 6.
import { loadOptions } from "./config";
export class OptionManager {
  init(opts: {}) {
    return loadOptions(opts);
  }
}
export function Plugin(alias: string) {
  throw new Error(
    `The (${alias}) Babel 5 plugin is being run with an unsupported Babel version.`,
  );
}

// </from> /home/qfox/apps/babel/packages/babel-core/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/transform-file-browser.js

// @flow
export default function transformFile(
  filename: string,
  opts?: Object = {},
  callback: (?Error, FileResult | null) => void,
) {
  if (typeof opts === "function") {
    callback = opts;
  }
  callback(new Error("Transforming files is not supported in browsers"), null);
}

// </from> /home/qfox/apps/babel/packages/babel-core/src/transform-file-browser.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/transform-ast.js

// @flow
import loadConfig, { type InputOptions } from "./config";
import {
  runSync,
  runAsync,
  type FileResult,
  type FileResultCallback,
} from "./transformation";
type AstRoot = BabelNodeFile | BabelNodeProgram;
type TransformFromAst = {
  (ast: AstRoot, code: string, callback: FileResultCallback): void,
  (
    ast: AstRoot,
    code: string,
    opts: ?InputOptions,
    callback: FileResultCallback,
  ): void,
  // Here for backward-compatibility. Ideally use ".transformSync" if you want
  // a synchronous API.
  (ast: AstRoot, code: string, opts: ?InputOptions): FileResult | null,
};
export const transformFromAst: TransformFromAst = (function transformFromAst(
  ast,
  code,
  opts,
  callback,
) {
  if (typeof opts === "function") {
    callback = opts;
    opts = undefined;
  }
  // For backward-compat with Babel 6, we allow sync transformation when
  // no callback is given. Will be dropped in some future Babel major version.
  if (callback === undefined) return transformFromAstSync(ast, code, opts);
  // Reassign to keep Flowtype happy.
  const cb = callback;
  // Just delaying the transform one tick for now to simulate async behavior
  // but more async logic may land here eventually.
  process.nextTick(() => {
    let cfg;
    try {
      cfg = loadConfig(opts);
      if (cfg === null) return cb(null, null);
    } catch (err) {
      return cb(err);
    }
    if (!ast) return cb(new Error("No AST given"));
    runAsync(cfg, code, ast, cb);
  });
}: Function);
export function transformFromAstSync(
  ast: AstRoot,
  code: string,
  opts: ?InputOptions,
): FileResult | null {
  const config = loadConfig(opts);
  if (config === null) return null;
  if (!ast) throw new Error("No AST given");
  return runSync(config, code, ast);
}
export function transformFromAstAsync(
  ast: AstRoot,
  code: string,
  opts: ?InputOptions,
): Promise<FileResult | null> {
  return new Promise((res, rej) => {
    transformFromAst(ast, code, opts, (err, result) => {
      if (err == null) res(result);
      else rej(err);
    });
  });
}

// </from> /home/qfox/apps/babel/packages/babel-core/src/transform-ast.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/parse.js

// @flow
import loadConfig, { type InputOptions } from "./config";
import normalizeFile from "./transformation/normalize-file";
import normalizeOptions from "./transformation/normalize-opts";
type AstRoot = BabelNodeFile | BabelNodeProgram;
export type ParseResult = AstRoot;
export type FileParseCallback = {
  (Error, null): any,
  (null, ParseResult | null): any,
};
type Parse = {
  (code: string, callback: FileParseCallback): void,
  (code: string, opts: ?InputOptions, callback: FileParseCallback): void,
  // Here for backward-compatibility. Ideally use ".parseSync" if you want
  // a synchronous API.
  (code: string, opts: ?InputOptions): ParseResult | null,
};
export const parse: Parse = (function parse(code, opts, callback) {
  if (typeof opts === "function") {
    callback = opts;
    opts = undefined;
  }
  // For backward-compat with Babel 7's early betas, we allow sync parsing when
  // no callback is given. Will be dropped in some future Babel major version.
  if (callback === undefined) return parseSync(code, opts);
  const config = loadConfig(opts);
  if (config === null) {
    return null;
  }
  // Reassign to keep Flowtype happy.
  const cb = callback;
  // Just delaying the transform one tick for now to simulate async behavior
  // but more async logic may land here eventually.
  process.nextTick(() => {
    let ast = null;
    try {
      const cfg = loadConfig(opts);
      if (cfg === null) return cb(null, null);
      ast = normalizeFile(cfg.passes, normalizeOptions(cfg), code).ast;
    } catch (err) {
      return cb(err);
    }
    cb(null, ast);
  });
}: Function);
export function parseSync(
  code: string,
  opts?: InputOptions,
): ParseResult | null {
  const config = loadConfig(opts);
  if (config === null) {
    return null;
  }
  return normalizeFile(config.passes, normalizeOptions(config), code).ast;
}
export function parseAsync(
  code: string,
  opts?: InputOptions,
): Promise<ParseResult | null> {
  return new Promise((res, rej) => {
    parse(code, opts, (err, result) => {
      if (err == null) res(result);
      else rej(err);
    });
  });
}

// </from> /home/qfox/apps/babel/packages/babel-core/src/parse.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/transform-file-sync-browser.js

// @flow
export default function transformFileSync() {
  throw new Error("Transforming files is not supported in browsers");
}

// </from> /home/qfox/apps/babel/packages/babel-core/src/transform-file-sync-browser.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/config/index.js

// @flow
import loadFullConfig from "./full";
export type {
  ResolvedConfig,
  InputOptions,
  PluginPasses,
  Plugin,
} from "./full";
export { loadFullConfig as default };
export { loadPartialConfig } from "./partial";
export type { PartialConfig } from "./partial";
export function loadOptions(opts: {}): Object | null {
  const config = loadFullConfig(opts);
  return config ? config.options : null;
}

// </from> /home/qfox/apps/babel/packages/babel-core/src/config/index.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/config/validation/removed.js

// @flow
export default {
  auxiliaryComment: {
    message: "Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`",
  },
  blacklist: {
    message: "Put the specific transforms you want in the `plugins` option",
  },
  breakConfig: {
    message: "This is not a necessary option in Babel 6",
  },
  experimental: {
    message: "Put the specific transforms you want in the `plugins` option",
  },
  externalHelpers: {
    message:
      "Use the `external-helpers` plugin instead. " +
      "Check out http://babeljs.io/docs/plugins/external-helpers/",
  },
  extra: {
    message: "",
  },
  jsxPragma: {
    message:
      "use the `pragma` option in the `react-jsx` plugin. " +
      "Check out http://babeljs.io/docs/plugins/transform-react-jsx/",
  },
  loose: {
    message:
      "Specify the `loose` option for the relevant plugin you are using " +
      "or use a preset that sets the option.",
  },
  metadataUsedHelpers: {
    message: "Not required anymore as this is enabled by default",
  },
  modules: {
    message:
      "Use the corresponding module transform plugin in the `plugins` option. " +
      "Check out http://babeljs.io/docs/plugins/#modules",
  },
  nonStandard: {
    message:
      "Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. " +
      "Also check out the react preset http://babeljs.io/docs/plugins/preset-react/",
  },
  optional: {
    message: "Put the specific transforms you want in the `plugins` option",
  },
  sourceMapName: {
    message:
      "The `sourceMapName` option has been removed because it makes more sense for the " +
      "tooling that calls Babel to assign `map.file` themselves.",
  },
  stage: {
    message:
      "Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets",
  },
  whitelist: {
    message: "Put the specific transforms you want in the `plugins` option",
  },
  resolveModuleSource: {
    version: 6,
    message: "Use `babel-plugin-module-resolver@3`'s 'resolvePath' options",
  },
  metadata: {
    version: 6,
    message:
      "Generated plugin metadata is always included in the output result",
  },
  sourceMapTarget: {
    version: 6,
    message:
      "The `sourceMapTarget` option has been removed because it makes more sense for the tooling " +
      "that calls Babel to assign `map.file` themselves.",
  },
};

// </from> /home/qfox/apps/babel/packages/babel-core/src/config/validation/removed.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/config/validation/option-assertions.js

// @flow
  ConfigFileSearch,
  BabelrcSearch,
  IgnoreList,
  IgnoreItem,
  PluginList,
  PluginItem,
  PluginTarget,
  ConfigApplicableTest,
  SourceMapsOption,
  SourceTypeOption,
  CompactOption,
  RootInputSourceMapOption,
  NestingPath,
  CallerMetadata,
  RootMode,
} from "./options";
export type ValidatorSet = {
  [string]: Validator<any>,
};
export type Validator<T> = (OptionPath, mixed) => T;
export function msg(loc: NestingPath | GeneralPath) {
  switch (loc.type) {
    case "root":
      return ``;
    case "env":
      return `${msg(loc.parent)}.env["${loc.name}"]`;
    case "overrides":
      return `${msg(loc.parent)}.overrides[${loc.index}]`;
    case "option":
      return `${msg(loc.parent)}.${loc.name}`;
    case "access":
      return `${msg(loc.parent)}[${JSON.stringify(loc.name)}]`;
    default:
      throw new Error(`Assertion failure: Unknown type ${loc.type}`);
  }
}
export function access(loc: GeneralPath, name: string | number): AccessPath {
  return {
    type: "access",
    name,
    parent: loc,
  };
}
export type OptionPath = $ReadOnly<{
  type: "option",
  name: string,
  parent: NestingPath,
}>;
type AccessPath = $ReadOnly<{
  type: "access",
  name: string | number,
  parent: GeneralPath,
}>;
type GeneralPath = OptionPath | AccessPath;
export function assertRootMode(loc: OptionPath, value: mixed): RootMode | void {
  if (
    value !== undefined &&
    value !== "root" &&
    value !== "upward" &&
    value !== "upward-optional"
  ) {
    throw new Error(
      `${msg(loc)} must be a "root", "upward", "upward-optional" or undefined`,
    );
  }
  return value;
}
export function assertSourceMaps(
  loc: OptionPath,
  value: mixed,
): SourceMapsOption | void {
  if (
    value !== undefined &&
    typeof value !== "boolean" &&
    value !== "inline" &&
    value !== "both"
  ) {
    throw new Error(
      `${msg(loc)} must be a boolean, "inline", "both", or undefined`,
    );
  }
  return value;
}
export function assertCompact(
  loc: OptionPath,
  value: mixed,
): CompactOption | void {
  if (value !== undefined && typeof value !== "boolean" && value !== "auto") {
    throw new Error(`${msg(loc)} must be a boolean, "auto", or undefined`);
  }
  return value;
}
export function assertSourceType(
  loc: OptionPath,
  value: mixed,
): SourceTypeOption | void {
  if (
    value !== undefined &&
    value !== "module" &&
    value !== "script" &&
    value !== "unambiguous"
  ) {
    throw new Error(
      `${msg(loc)} must be "module", "script", "unambiguous", or undefined`,
    );
  }
  return value;
}
export function assertCallerMetadata(
  loc: OptionPath,
  value: mixed,
): CallerMetadata | void {
  const obj = assertObject(loc, value);
  if (obj) {
    if (typeof obj[("name": string)] !== "string") {
      throw new Error(
        `${msg(loc)} set but does not contain "name" property string`,
      );
    }
    for (const prop of Object.keys(obj)) {
      const propLoc = access(loc, prop);
      const value = obj[prop];
      if (
        value != null &&
        typeof value !== "boolean" &&
        typeof value !== "string" &&
        typeof value !== "number"
      ) {
        // NOTE(logan): I'm limiting the type here so that we can guarantee that
        // the "caller" value will serialize to JSON nicely. We can always
        // allow more complex structures later though.
        throw new Error(
          `${msg(
            propLoc,
          )} must be null, undefined, a boolean, a string, or a number.`,
        );
      }
    }
  }
  return (value: any);
}
export function assertInputSourceMap(
  loc: OptionPath,
  value: mixed,
): RootInputSourceMapOption | void {
  if (
    value !== undefined &&
    typeof value !== "boolean" &&
    (typeof value !== "object" || !value)
  ) {
    throw new Error(`${msg(loc)} must be a boolean, object, or undefined`);
  }
  return value;
}
export function assertString(loc: GeneralPath, value: mixed): string | void {
  if (value !== undefined && typeof value !== "string") {
    throw new Error(`${msg(loc)} must be a string, or undefined`);
  }
  return value;
}
export function assertFunction(
  loc: GeneralPath,
  value: mixed,
): Function | void {
  if (value !== undefined && typeof value !== "function") {
    throw new Error(`${msg(loc)} must be a function, or undefined`);
  }
  return value;
}
export function assertBoolean(loc: GeneralPath, value: mixed): boolean | void {
  if (value !== undefined && typeof value !== "boolean") {
    throw new Error(`${msg(loc)} must be a boolean, or undefined`);
  }
  return value;
}
export function assertObject(loc: GeneralPath, value: mixed): {} | void {
  if (
    value !== undefined &&
    (typeof value !== "object" || Array.isArray(value) || !value)
  ) {
    throw new Error(`${msg(loc)} must be an object, or undefined`);
  }
  return value;
}
export function assertArray(
  loc: GeneralPath,
  value: mixed,
): ?$ReadOnlyArray<mixed> {
  if (value != null && !Array.isArray(value)) {
    throw new Error(`${msg(loc)} must be an array, or undefined`);
  }
  return value;
}
export function assertIgnoreList(
  loc: OptionPath,
  value: mixed,
): IgnoreList | void {
  const arr = assertArray(loc, value);
  if (arr) {
    arr.forEach((item, i) => assertIgnoreItem(access(loc, i), item));
  }
  return (arr: any);
}
function assertIgnoreItem(loc: GeneralPath, value: mixed): IgnoreItem {
  if (
    typeof value !== "string" &&
    typeof value !== "function" &&
    !(value instanceof RegExp)
  ) {
    throw new Error(
      `${msg(
        loc,
      )} must be an array of string/Funtion/RegExp values, or undefined`,
    );
  }
  return value;
}
export function assertConfigApplicableTest(
  loc: OptionPath,
  value: mixed,
): ConfigApplicableTest | void {
  if (value === undefined) return value;
  if (Array.isArray(value)) {
    value.forEach((item, i) => {
      if (!checkValidTest(item)) {
        throw new Error(
          `${msg(access(loc, i))} must be a string/Function/RegExp.`,
        );
      }
    });
  } else if (!checkValidTest(value)) {
    throw new Error(
      `${msg(loc)} must be a string/Function/RegExp, or an array of those`,
    );
  }
  return (value: any);
}
function checkValidTest(value: mixed): boolean {
  return (
    typeof value === "string" ||
    typeof value === "function" ||
    value instanceof RegExp
  );
}
export function assertConfigFileSearch(
  loc: OptionPath,
  value: mixed,
): ConfigFileSearch | void {
  if (
    value !== undefined &&
    typeof value !== "boolean" &&
    typeof value !== "string"
  ) {
    throw new Error(
      `${msg(loc)} must be a undefined, a boolean, a string, ` +
        `got ${JSON.stringify(value)}`,
    );
  }
  return value;
}
export function assertBabelrcSearch(
  loc: OptionPath,
  value: mixed,
): BabelrcSearch | void {
  if (value === undefined || typeof value === "boolean") return value;
  if (Array.isArray(value)) {
    value.forEach((item, i) => {
      if (!checkValidTest(item)) {
        throw new Error(
          `${msg(access(loc, i))} must be a string/Function/RegExp.`,
        );
      }
    });
  } else if (!checkValidTest(value)) {
    throw new Error(
      `${msg(loc)} must be a undefined, a boolean, a string/Function/RegExp ` +
        `or an array of those, got ${JSON.stringify(value)}`,
    );
  }
  return (value: any);
}
export function assertPluginList(
  loc: OptionPath,
  value: mixed,
): PluginList | void {
  const arr = assertArray(loc, value);
  if (arr) {
    // Loop instead of using `.map` in order to preserve object identity
    // for plugin array for use during config chain processing.
    arr.forEach((item, i) => assertPluginItem(access(loc, i), item));
  }
  return (arr: any);
}
function assertPluginItem(loc: GeneralPath, value: mixed): PluginItem {
  if (Array.isArray(value)) {
    if (value.length === 0) {
      throw new Error(`${msg(loc)} must include an object`);
    }
    if (value.length > 3) {
      throw new Error(`${msg(loc)} may only be a two-tuple or three-tuple`);
    }
    assertPluginTarget(access(loc, 0), value[0]);
    if (value.length > 1) {
      const opts = value[1];
      if (
        opts !== undefined &&
        opts !== false &&
        (typeof opts !== "object" || Array.isArray(opts))
      ) {
        throw new Error(
          `${msg(access(loc, 1))} must be an object, false, or undefined`,
        );
      }
    }
    if (value.length === 3) {
      const name = value[2];
      if (name !== undefined && typeof name !== "string") {
        throw new Error(
          `${msg(access(loc, 2))} must be a string, or undefined`,
        );
      }
    }
  } else {
    assertPluginTarget(loc, value);
  }
  return (value: any);
}
function assertPluginTarget(loc: GeneralPath, value: mixed): PluginTarget {
  if (
    (typeof value !== "object" || !value) &&
    typeof value !== "string" &&
    typeof value !== "function"
  ) {
    throw new Error(`${msg(loc)} must be a string, object, function`);
  }
  return value;
}

// </from> /home/qfox/apps/babel/packages/babel-core/src/config/validation/option-assertions.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/config/validation/plugins.js

import {
  assertString,
  assertFunction,
  assertObject,
  type ValidatorSet,
  type Validator,
} from "./option-assertions";
// Note: The casts here are just meant to be static assertions to make sure
// that the assertion functions actually assert that the value's type matches
// the declared types.
const VALIDATORS: ValidatorSet = {
  name: (assertString: Validator<$PropertyType<PluginObject, "name">>),
  manipulateOptions: (assertFunction: Validator<
    $PropertyType<PluginObject, "manipulateOptions">,
  >),
  pre: (assertFunction: Validator<$PropertyType<PluginObject, "pre">>),
  post: (assertFunction: Validator<$PropertyType<PluginObject, "post">>),
  inherits: (assertFunction: Validator<
    $PropertyType<PluginObject, "inherits">,
  >),
  visitor: (assertVisitorMap: Validator<
    $PropertyType<PluginObject, "visitor">,
  >),
  parserOverride: (assertFunction: Validator<
    $PropertyType<PluginObject, "parserOverride">,
  >),
  generatorOverride: (assertFunction: Validator<
    $PropertyType<PluginObject, "generatorOverride">,
  >),
};
function assertVisitorMap(key: string, value: mixed): VisitorMap {
  const obj = assertObject(key, value);
  if (obj) {
    Object.keys(obj).forEach(prop => assertVisitorHandler(prop, obj[prop]));
    if (obj.enter || obj.exit) {
      throw new Error(
        `.${key} cannot contain catch-all "enter" or "exit" handlers. Please target individual nodes.`,
      );
    }
  }
  return (obj: any);
}
function assertVisitorHandler(
  key: string,
  value: mixed,
): VisitorHandler | void {
  if (value && typeof value === "object") {
    Object.keys(value).forEach(handler => {
      if (handler !== "enter" && handler !== "exit") {
        throw new Error(
          `.visitor["${key}"] may only have .enter and/or .exit handlers.`,
        );
      }
    });
  } else if (typeof value !== "function") {
    throw new Error(`.visitor["${key}"] must be a function`);
  }
  return (value: any);
}
type VisitorHandler = Function | { enter?: Function, exit?: Function };
export type VisitorMap = {
  [string]: VisitorHandler,
};
export type PluginObject = {
  name?: string,
  manipulateOptions?: Function,
  pre?: Function,
  post?: Function,
  inherits?: Function,
  visitor?: VisitorMap,
  parserOverride?: Function,
  generatorOverride?: Function,
};
export function validatePluginObject(obj: {}): PluginObject {
  Object.keys(obj).forEach(key => {
    const validator = VALIDATORS[key];
    if (validator) validator(key, obj[key]);
    else throw new Error(`.${key} is not a valid Plugin property`);
  });
  return (obj: any);
}

// </from> /home/qfox/apps/babel/packages/babel-core/src/config/validation/plugins.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/config/validation/options.js

// @flow
import Plugin from "../plugin";
import removed from "./removed";
import {
  msg,
  access,
  assertString,
  assertBoolean,
  assertObject,
  assertArray,
  assertCallerMetadata,
  assertInputSourceMap,
  assertIgnoreList,
  assertPluginList,
  assertConfigApplicableTest,
  assertConfigFileSearch,
  assertBabelrcSearch,
  assertFunction,
  assertRootMode,
  assertSourceMaps,
  assertCompact,
  assertSourceType,
  type ValidatorSet,
  type Validator,
  type OptionPath,
} from "./option-assertions";
const ROOT_VALIDATORS: ValidatorSet = {
  cwd: (assertString: Validator<$PropertyType<ValidatedOptions, "cwd">>),
  root: (assertString: Validator<$PropertyType<ValidatedOptions, "root">>),
  rootMode: (assertRootMode: Validator<
    $PropertyType<ValidatedOptions, "rootMode">,
  >),
  configFile: (assertConfigFileSearch: Validator<
    $PropertyType<ValidatedOptions, "configFile">,
  >),
  caller: (assertCallerMetadata: Validator<
    $PropertyType<ValidatedOptions, "caller">,
  >),
  filename: (assertString: Validator<
    $PropertyType<ValidatedOptions, "filename">,
  >),
  filenameRelative: (assertString: Validator<
    $PropertyType<ValidatedOptions, "filenameRelative">,
  >),
  code: (assertBoolean: Validator<$PropertyType<ValidatedOptions, "code">>),
  ast: (assertBoolean: Validator<$PropertyType<ValidatedOptions, "ast">>),
  envName: (assertString: Validator<
    $PropertyType<ValidatedOptions, "envName">,
  >),
};
const BABELRC_VALIDATORS: ValidatorSet = {
  babelrc: (assertBoolean: Validator<
    $PropertyType<ValidatedOptions, "babelrc">,
  >),
  babelrcRoots: (assertBabelrcSearch: Validator<
    $PropertyType<ValidatedOptions, "babelrcRoots">,
  >),
};
const NONPRESET_VALIDATORS: ValidatorSet = {
  extends: (assertString: Validator<
    $PropertyType<ValidatedOptions, "extends">,
  >),
  ignore: (assertIgnoreList: Validator<
    $PropertyType<ValidatedOptions, "ignore">,
  >),
  only: (assertIgnoreList: Validator<$PropertyType<ValidatedOptions, "only">>),
};
const COMMON_VALIDATORS: ValidatorSet = {
  // TODO: Should 'inputSourceMap' be moved to be a root-only option?
  // We may want a boolean-only version to be a common option, with the
  // object only allowed as a root config argument.
  inputSourceMap: (assertInputSourceMap: Validator<
    $PropertyType<ValidatedOptions, "inputSourceMap">,
  >),
  presets: (assertPluginList: Validator<
    $PropertyType<ValidatedOptions, "presets">,
  >),
  plugins: (assertPluginList: Validator<
    $PropertyType<ValidatedOptions, "plugins">,
  >),
  passPerPreset: (assertBoolean: Validator<
    $PropertyType<ValidatedOptions, "passPerPreset">,
  >),
  env: (assertEnvSet: Validator<$PropertyType<ValidatedOptions, "env">>),
  overrides: (assertOverridesList: Validator<
    $PropertyType<ValidatedOptions, "overrides">,
  >),
  // We could limit these to 'overrides' blocks, but it's not clear why we'd
  // bother, when the ability to limit a config to a specific set of files
  // is a fairly general useful feature.
  test: (assertConfigApplicableTest: Validator<
    $PropertyType<ValidatedOptions, "test">,
  >),
  include: (assertConfigApplicableTest: Validator<
    $PropertyType<ValidatedOptions, "include">,
  >),
  exclude: (assertConfigApplicableTest: Validator<
    $PropertyType<ValidatedOptions, "exclude">,
  >),
  retainLines: (assertBoolean: Validator<
    $PropertyType<ValidatedOptions, "retainLines">,
  >),
  comments: (assertBoolean: Validator<
    $PropertyType<ValidatedOptions, "comments">,
  >),
  shouldPrintComment: (assertFunction: Validator<
    $PropertyType<ValidatedOptions, "shouldPrintComment">,
  >),
  compact: (assertCompact: Validator<
    $PropertyType<ValidatedOptions, "compact">,
  >),
  minified: (assertBoolean: Validator<
    $PropertyType<ValidatedOptions, "minified">,
  >),
  auxiliaryCommentBefore: (assertString: Validator<
    $PropertyType<ValidatedOptions, "auxiliaryCommentBefore">,
  >),
  auxiliaryCommentAfter: (assertString: Validator<
    $PropertyType<ValidatedOptions, "auxiliaryCommentAfter">,
  >),
  sourceType: (assertSourceType: Validator<
    $PropertyType<ValidatedOptions, "sourceType">,
  >),
  wrapPluginVisitorMethod: (assertFunction: Validator<
    $PropertyType<ValidatedOptions, "wrapPluginVisitorMethod">,
  >),
  highlightCode: (assertBoolean: Validator<
    $PropertyType<ValidatedOptions, "highlightCode">,
  >),
  sourceMaps: (assertSourceMaps: Validator<
    $PropertyType<ValidatedOptions, "sourceMaps">,
  >),
  sourceMap: (assertSourceMaps: Validator<
    $PropertyType<ValidatedOptions, "sourceMap">,
  >),
  sourceFileName: (assertString: Validator<
    $PropertyType<ValidatedOptions, "sourceFileName">,
  >),
  sourceRoot: (assertString: Validator<
    $PropertyType<ValidatedOptions, "sourceRoot">,
  >),
  getModuleId: (assertFunction: Validator<
    $PropertyType<ValidatedOptions, "getModuleId">,
  >),
  moduleRoot: (assertString: Validator<
    $PropertyType<ValidatedOptions, "moduleRoot">,
  >),
  moduleIds: (assertBoolean: Validator<
    $PropertyType<ValidatedOptions, "moduleIds">,
  >),
  moduleId: (assertString: Validator<
    $PropertyType<ValidatedOptions, "moduleId">,
  >),
  parserOpts: (assertObject: Validator<
    $PropertyType<ValidatedOptions, "parserOpts">,
  >),
  generatorOpts: (assertObject: Validator<
    $PropertyType<ValidatedOptions, "generatorOpts">,
  >),
};
export type InputOptions = ValidatedOptions;
export type ValidatedOptions = {
  cwd?: string,
  filename?: string,
  filenameRelative?: string,
  babelrc?: boolean,
  babelrcRoots?: BabelrcSearch,
  configFile?: ConfigFileSearch,
  root?: string,
  rootMode?: RootMode,
  code?: boolean,
  ast?: boolean,
  inputSourceMap?: RootInputSourceMapOption,
  envName?: string,
  caller?: CallerMetadata,
  extends?: string,
  env?: EnvSet<ValidatedOptions>,
  ignore?: IgnoreList,
  only?: IgnoreList,
  overrides?: OverridesList,
  // Generally verify if a given config object should be applied to the given file.
  test?: ConfigApplicableTest,
  include?: ConfigApplicableTest,
  exclude?: ConfigApplicableTest,
  presets?: PluginList,
  plugins?: PluginList,
  passPerPreset?: boolean,
  // Options for @babel/generator
  retainLines?: boolean,
  comments?: boolean,
  shouldPrintComment?: Function,
  compact?: CompactOption,
  minified?: boolean,
  auxiliaryCommentBefore?: string,
  auxiliaryCommentAfter?: string,
  // Parser
  sourceType?: SourceTypeOption,
  wrapPluginVisitorMethod?: Function,
  highlightCode?: boolean,
  // Sourcemap generation options.
  sourceMaps?: SourceMapsOption,
  sourceMap?: SourceMapsOption,
  sourceFileName?: string,
  sourceRoot?: string,
  // AMD/UMD/SystemJS module naming options.
  getModuleId?: Function,
  moduleRoot?: string,
  moduleIds?: boolean,
  moduleId?: string,
  // Deprecate top level parserOpts
  parserOpts?: {},
  // Deprecate top level generatorOpts
  generatorOpts?: {},
};
export type CallerMetadata = {
  // If 'caller' is specified, require that the name is given for debugging
  // messages.
  name: string,
};
export type EnvSet<T> = {
  [string]: ?T,
};
export type IgnoreItem = string | Function | RegExp;
export type IgnoreList = $ReadOnlyArray<IgnoreItem>;
export type PluginOptions = {} | void | false;
export type PluginTarget = string | {} | Function;
export type PluginItem =
  | ConfigItem
  | Plugin
  | PluginTarget
  | [PluginTarget, PluginOptions]
  | [PluginTarget, PluginOptions, string | void];
export type PluginList = $ReadOnlyArray<PluginItem>;
export type OverridesList = Array<ValidatedOptions>;
export type ConfigApplicableTest = IgnoreItem | Array<IgnoreItem>;
export type ConfigFileSearch = string | boolean;
export type BabelrcSearch = boolean | IgnoreItem | IgnoreList;
export type SourceMapsOption = boolean | "inline" | "both";
export type SourceTypeOption = "module" | "script" | "unambiguous";
export type CompactOption = boolean | "auto";
export type RootInputSourceMapOption = {} | boolean;
export type RootMode = "root" | "upward" | "upward-optional";
export type OptionsSource =
  | "arguments"
  | "configfile"
  | "babelrcfile"
  | "extendsfile"
  | "preset";
type RootPath = $ReadOnly<{
  type: "root",
  source: OptionsSource,
}>;
type OverridesPath = $ReadOnly<{
  type: "overrides",
  index: number,
  parent: RootPath,
}>;
type EnvPath = $ReadOnly<{
  type: "env",
  name: string,
  parent: RootPath | OverridesPath,
}>;
export type NestingPath = RootPath | OverridesPath | EnvPath;
function getSource(loc: NestingPath): OptionsSource {
  return loc.type === "root" ? loc.source : getSource(loc.parent);
}
export function validate(type: OptionsSource, opts: {}): ValidatedOptions {
  return validateNested(
    {
      type: "root",
      source: type,
    },
    opts,
  );
}
function validateNested(loc: NestingPath, opts: {}) {
  const type = getSource(loc);
  assertNoDuplicateSourcemap(opts);
  Object.keys(opts).forEach(key => {
    const optLoc = {
      type: "option",
      name: key,
      parent: loc,
    };
    if (type === "preset" && NONPRESET_VALIDATORS[key]) {
      throw new Error(`${msg(optLoc)} is not allowed in preset options`);
    }
    if (type !== "arguments" && ROOT_VALIDATORS[key]) {
      throw new Error(
        `${msg(optLoc)} is only allowed in root programmatic options`,
      );
    }
    if (
      type !== "arguments" &&
      type !== "configfile" &&
      BABELRC_VALIDATORS[key]
    ) {
      if (type === "babelrcfile" || type === "extendsfile") {
        throw new Error(
          `${msg(
            optLoc,
          )} is not allowed in .babelrc or "extends"ed files, only in root programmatic options, ` +
            `or babel.config.js/config file options`,
        );
      }
      throw new Error(
        `${msg(
          optLoc,
        )} is only allowed in root programmatic options, or babel.config.js/config file options`,
      );
    }
    const validator =
      COMMON_VALIDATORS[key] ||
      NONPRESET_VALIDATORS[key] ||
      BABELRC_VALIDATORS[key] ||
      ROOT_VALIDATORS[key] ||
      throwUnknownError;
    validator(optLoc, opts[key]);
  });
  return (opts: any);
}
function throwUnknownError(loc: OptionPath) {
  const key = loc.name;
  if (removed[key]) {
    const { message, version = 5 } = removed[key];
    throw new ReferenceError(
      `Using removed Babel ${version} option: ${msg(loc)} - ${message}`,
    );
  } else {
    // eslint-disable-next-line max-len
    const unknownOptErr = `Unknown option: ${msg(
      loc,
    )}. Check out https://babeljs.io/docs/en/babel-core/#options for more information about options.`;
    throw new ReferenceError(unknownOptErr);
  }
}
function has(obj: {}, key: string) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function assertNoDuplicateSourcemap(opts: {}): void {
  if (has(opts, "sourceMap") && has(opts, "sourceMaps")) {
    throw new Error(".sourceMap is an alias for .sourceMaps, cannot use both");
  }
}
function assertEnvSet(loc: OptionPath, value: mixed): EnvSet<ValidatedOptions> {
  if (loc.parent.type === "env") {
    throw new Error(`${msg(loc)} is not allowed inside of another .env block`);
  }
  const parent: RootPath | OverridesPath = loc.parent;
  const obj = assertObject(loc, value);
  if (obj) {
    // Validate but don't copy the .env object in order to preserve
    // object identity for use during config chain processing.
    for (const envName of Object.keys(obj)) {
      const env = assertObject(access(loc, envName), obj[envName]);
      if (!env) continue;
      const envLoc = {
        type: "env",
        name: envName,
        parent,
      };
      validateNested(envLoc, env);
    }
  }
  return (obj: any);
}
function assertOverridesList(loc: OptionPath, value: mixed): OverridesList {
  if (loc.parent.type === "env") {
    throw new Error(`${msg(loc)} is not allowed inside an .env block`);
  }
  if (loc.parent.type === "overrides") {
    throw new Error(`${msg(loc)} is not allowed inside an .overrides block`);
  }
  const parent: RootPath = loc.parent;
  const arr = assertArray(loc, value);
  if (arr) {
    for (const [index, item] of arr.entries()) {
      const objLoc = access(loc, index);
      const env = assertObject(objLoc, item);
      if (!env) throw new Error(`${msg(objLoc)} must be an object`);
      const overridesLoc = {
        type: "overrides",
        index,
        parent,
      };
      validateNested(overridesLoc, env);
    }
  }
  return (arr: any);
}

// </from> /home/qfox/apps/babel/packages/babel-core/src/config/validation/options.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/config/pattern-to-regex.js

// @flow
import path from "path";
import escapeRegExp from "lodash/escapeRegExp";
const sep = `\\${path.sep}`;
const endSep = `(?:${sep}|$)`;
const substitution = `[^${sep}]+`;
const starPat = `(?:${substitution}${sep})`;
const starPatLast = `(?:${substitution}${endSep})`;
const starStarPat = `${starPat}*?`;
const starStarPatLast = `${starPat}*?${starPatLast}?`;
/**
 * Implement basic pattern matching that will allow users to do the simple
 * tests with * and **. If users want full complex pattern matching, then can
 * always use regex matching, or function validation.
 */
export default function pathToPattern(
  pattern: string,
  dirname: string,
): RegExp {
  const parts = path.resolve(dirname, pattern).split(path.sep);
  return new RegExp(
    [
      "^",
      ...parts.map((part, i) => {
        const last = i === parts.length - 1;
        // ** matches 0 or more path parts.
        if (part === "**") return last ? starStarPatLast : starStarPat;
        // * matches 1 path part.
        if (part === "*") return last ? starPatLast : starPat;
        // *.ext matches a wildcard with an extension.
        if (part.indexOf("*.") === 0) {
          return (
            substitution + escapeRegExp(part.slice(1)) + (last ? endSep : sep)
          );
        }
        // Otherwise match the pattern text.
        return escapeRegExp(part) + (last ? endSep : sep);
      }),
    ].join(""),
  );
}

// </from> /home/qfox/apps/babel/packages/babel-core/src/config/pattern-to-regex.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/config/config-chain.js

// @flow
import path from "path";
import buildDebug from "debug";
import {
  validate,
  type ValidatedOptions,
  type IgnoreList,
  type ConfigApplicableTest,
  type BabelrcSearch,
  type CallerMetadata,
} from "./validation/options";
import pathPatternToRegex from "./pattern-to-regex";
const debug = buildDebug("babel:config:config-chain");
import {
  findPackageData,
  findRelativeConfig,
  findRootConfig,
  loadConfig,
  type ConfigFile,
  type IgnoreFile,
  type FilePackageData,
} from "./files";
import { makeWeakCache, makeStrongCache } from "./caching";
import {
  createCachedDescriptors,
  createUncachedDescriptors,
  type UnloadedDescriptor,
  type OptionsAndDescriptors,
  type ValidatedFile,
} from "./config-descriptors";
export type ConfigChain = {
  plugins: Array<UnloadedDescriptor>,
  presets: Array<UnloadedDescriptor>,
  options: Array<ValidatedOptions>,
};
export type PresetInstance = {
  options: ValidatedOptions,
  alias: string,
  dirname: string,
};
export type ConfigContext = {
  filename: string | void,
  cwd: string,
  root: string,
  envName: string,
  caller: CallerMetadata | void,
};
/**
 * Build a config chain for a given preset.
 */
export function buildPresetChain(
  arg: PresetInstance,
  context: *,
): ConfigChain | null {
  const chain = buildPresetChainWalker(arg, context);
  if (!chain) return null;
  return {
    plugins: dedupDescriptors(chain.plugins),
    presets: dedupDescriptors(chain.presets),
    options: chain.options,
  };
}
export const buildPresetChainWalker: (
  arg: PresetInstance,
  context: *,
) => * = makeChainWalker({
  init: arg => arg,
  root: preset => loadPresetDescriptors(preset),
  env: (preset, envName) => loadPresetEnvDescriptors(preset)(envName),
  overrides: (preset, index) => loadPresetOverridesDescriptors(preset)(index),
  overridesEnv: (preset, index, envName) =>
    loadPresetOverridesEnvDescriptors(preset)(index)(envName),
});
const loadPresetDescriptors = makeWeakCache((preset: PresetInstance) =>
  buildRootDescriptors(preset, preset.alias, createUncachedDescriptors),
);
const loadPresetEnvDescriptors = makeWeakCache((preset: PresetInstance) =>
  makeStrongCache((envName: string) =>
    buildEnvDescriptors(
      preset,
      preset.alias,
      createUncachedDescriptors,
      envName,
    ),
  ),
);
const loadPresetOverridesDescriptors = makeWeakCache((preset: PresetInstance) =>
  makeStrongCache((index: number) =>
    buildOverrideDescriptors(
      preset,
      preset.alias,
      createUncachedDescriptors,
      index,
    ),
  ),
);
const loadPresetOverridesEnvDescriptors = makeWeakCache(
  (preset: PresetInstance) =>
    makeStrongCache((index: number) =>
      makeStrongCache((envName: string) =>
        buildOverrideEnvDescriptors(
          preset,
          preset.alias,
          createUncachedDescriptors,
          index,
          envName,
        ),
      ),
    ),
);
export type RootConfigChain = ConfigChain & {
  babelrc: ConfigFile | void,
  config: ConfigFile | void,
  ignore: IgnoreFile | void,
};
/**
 * Build a config chain for Babel's full root configuration.
 */
export function buildRootChain(
  opts: ValidatedOptions,
  context: ConfigContext,
): RootConfigChain | null {
  const programmaticChain = loadProgrammaticChain(
    {
      options: opts,
      dirname: context.cwd,
    },
    context,
  );
  if (!programmaticChain) return null;
  let configFile;
  if (typeof opts.configFile === "string") {
    configFile = loadConfig(
      opts.configFile,
      context.cwd,
      context.envName,
      context.caller,
    );
  } else if (opts.configFile !== false) {
    configFile = findRootConfig(context.root, context.envName, context.caller);
  }
  let { babelrc, babelrcRoots } = opts;
  const configFileChain = emptyChain();
  if (configFile) {
    const validatedFile = validateConfigFile(configFile);
    const result = loadFileChain(validatedFile, context);
    if (!result) return null;
    // Allow config files to toggle `.babelrc` resolution on and off and
    // specify where the roots are.
    if (babelrc === undefined) {
      babelrc = validatedFile.options.babelrc;
    }
    if (babelrcRoots === undefined) {
      babelrcRoots = validatedFile.options.babelrcRoots;
    }
    mergeChain(configFileChain, result);
  }
  const pkgData =
    typeof context.filename === "string"
      ? findPackageData(context.filename)
      : null;
  let ignoreFile, babelrcFile;
  const fileChain = emptyChain();
  // resolve all .babelrc files
  if (
    (babelrc === true || babelrc === undefined) &&
    pkgData &&
    babelrcLoadEnabled(context, pkgData, babelrcRoots)
  ) {
    ({ ignore: ignoreFile, config: babelrcFile } = findRelativeConfig(
      pkgData,
      context.envName,
      context.caller,
    ));
    if (
      ignoreFile &&
      shouldIgnore(context, ignoreFile.ignore, null, ignoreFile.dirname)
    ) {
      return null;
    }
    if (babelrcFile) {
      const result = loadFileChain(validateBabelrcFile(babelrcFile), context);
      if (!result) return null;
      mergeChain(fileChain, result);
    }
  }
  // Insert file chain in front so programmatic options have priority
  // over configuration file chain items.
  const chain = mergeChain(
    mergeChain(mergeChain(emptyChain(), configFileChain), fileChain),
    programmaticChain,
  );
  return {
    plugins: dedupDescriptors(chain.plugins),
    presets: dedupDescriptors(chain.presets),
    options: chain.options.map(o => normalizeOptions(o)),
    ignore: ignoreFile || undefined,
    babelrc: babelrcFile || undefined,
    config: configFile || undefined,
  };
}
function babelrcLoadEnabled(
  context: ConfigContext,
  pkgData: FilePackageData,
  babelrcRoots: BabelrcSearch | void,
): boolean {
  if (typeof babelrcRoots === "boolean") return babelrcRoots;
  const absoluteRoot = context.root;
  // Fast path to avoid having to match patterns if the babelrc is just
  // loading in the standard root directory.
  if (babelrcRoots === undefined) {
    return pkgData.directories.indexOf(absoluteRoot) !== -1;
  }
  let babelrcPatterns = babelrcRoots;
  if (!Array.isArray(babelrcPatterns)) babelrcPatterns = [babelrcPatterns];
  babelrcPatterns = babelrcPatterns.map(pat => {
    return typeof pat === "string" ? path.resolve(context.cwd, pat) : pat;
  });
  // Fast path to avoid having to match patterns if the babelrc is just
  // loading in the standard root directory.
  if (babelrcPatterns.length === 1 && babelrcPatterns[0] === absoluteRoot) {
    return pkgData.directories.indexOf(absoluteRoot) !== -1;
  }
  return babelrcPatterns.some(pat => {
    if (typeof pat === "string") pat = pathPatternToRegex(pat, context.cwd);
    return pkgData.directories.some(directory => {
      return matchPattern(pat, context.cwd, directory, context);
    });
  });
}
const validateConfigFile = makeWeakCache(
  (file: ConfigFile): ValidatedFile => ({
    filepath: file.filepath,
    dirname: file.dirname,
    options: validate("configfile", file.options),
  }),
);
const validateBabelrcFile = makeWeakCache(
  (file: ConfigFile): ValidatedFile => ({
    filepath: file.filepath,
    dirname: file.dirname,
    options: validate("babelrcfile", file.options),
  }),
);
const validateExtendFile = makeWeakCache(
  (file: ConfigFile): ValidatedFile => ({
    filepath: file.filepath,
    dirname: file.dirname,
    options: validate("extendsfile", file.options),
  }),
);
/**
 * Build a config chain for just the programmatic options passed into Babel.
 */
const loadProgrammaticChain = makeChainWalker({
  root: input => buildRootDescriptors(input, "base", createCachedDescriptors),
  env: (input, envName) =>
    buildEnvDescriptors(input, "base", createCachedDescriptors, envName),
  overrides: (input, index) =>
    buildOverrideDescriptors(input, "base", createCachedDescriptors, index),
  overridesEnv: (input, index, envName) =>
    buildOverrideEnvDescriptors(
      input,
      "base",
      createCachedDescriptors,
      index,
      envName,
    ),
});
/**
 * Build a config chain for a given file.
 */
const loadFileChain = makeChainWalker({
  root: file => loadFileDescriptors(file),
  env: (file, envName) => loadFileEnvDescriptors(file)(envName),
  overrides: (file, index) => loadFileOverridesDescriptors(file)(index),
  overridesEnv: (file, index, envName) =>
    loadFileOverridesEnvDescriptors(file)(index)(envName),
});
const loadFileDescriptors = makeWeakCache((file: ValidatedFile) =>
  buildRootDescriptors(file, file.filepath, createUncachedDescriptors),
);
const loadFileEnvDescriptors = makeWeakCache((file: ValidatedFile) =>
  makeStrongCache((envName: string) =>
    buildEnvDescriptors(
      file,
      file.filepath,
      createUncachedDescriptors,
      envName,
    ),
  ),
);
const loadFileOverridesDescriptors = makeWeakCache((file: ValidatedFile) =>
  makeStrongCache((index: number) =>
    buildOverrideDescriptors(
      file,
      file.filepath,
      createUncachedDescriptors,
      index,
    ),
  ),
);
const loadFileOverridesEnvDescriptors = makeWeakCache((file: ValidatedFile) =>
  makeStrongCache((index: number) =>
    makeStrongCache((envName: string) =>
      buildOverrideEnvDescriptors(
        file,
        file.filepath,
        createUncachedDescriptors,
        index,
        envName,
      ),
    ),
  ),
);
function buildRootDescriptors({ dirname, options }, alias, descriptors) {
  return descriptors(dirname, options, alias);
}
function buildEnvDescriptors(
  { dirname, options },
  alias,
  descriptors,
  envName,
) {
  const opts = options.env && options.env[envName];
  return opts ? descriptors(dirname, opts, `${alias}.env["${envName}"]`) : null;
}
function buildOverrideDescriptors(
  { dirname, options },
  alias,
  descriptors,
  index,
) {
  const opts = options.overrides && options.overrides[index];
  if (!opts) throw new Error("Assertion failure - missing override");
  return descriptors(dirname, opts, `${alias}.overrides[${index}]`);
}
function buildOverrideEnvDescriptors(
  { dirname, options },
  alias,
  descriptors,
  index,
  envName,
) {
  const override = options.overrides && options.overrides[index];
  if (!override) throw new Error("Assertion failure - missing override");
  const opts = override.env && override.env[envName];
  return opts
    ? descriptors(
        dirname,
        opts,
        `${alias}.overrides[${index}].env["${envName}"]`,
      )
    : null;
}
function makeChainWalker<ArgT: { options: ValidatedOptions, dirname: string }>({
  root,
  env,
  overrides,
  overridesEnv,
}: {
  root: ArgT => OptionsAndDescriptors,
  env: (ArgT, string) => OptionsAndDescriptors | null,
  overrides: (ArgT, number) => OptionsAndDescriptors,
  overridesEnv: (ArgT, number, string) => OptionsAndDescriptors | null,
}): (ArgT, ConfigContext, Set<ConfigFile> | void) => ConfigChain | null {
  return (input, context, files = new Set()) => {
    const { dirname } = input;
    const flattenedConfigs = [];
    const rootOpts = root(input);
    if (configIsApplicable(rootOpts, dirname, context)) {
      flattenedConfigs.push(rootOpts);
      const envOpts = env(input, context.envName);
      if (envOpts && configIsApplicable(envOpts, dirname, context)) {
        flattenedConfigs.push(envOpts);
      }
      (rootOpts.options.overrides || []).forEach((_, index) => {
        const overrideOps = overrides(input, index);
        if (configIsApplicable(overrideOps, dirname, context)) {
          flattenedConfigs.push(overrideOps);
          const overrideEnvOpts = overridesEnv(input, index, context.envName);
          if (
            overrideEnvOpts &&
            configIsApplicable(overrideEnvOpts, dirname, context)
          ) {
            flattenedConfigs.push(overrideEnvOpts);
          }
        }
      });
    }
    // Process 'ignore' and 'only' before 'extends' items are processed so
    // that we don't do extra work loading extended configs if a file is
    // ignored.
    if (
      flattenedConfigs.some(({ options: { ignore, only } }) =>
        shouldIgnore(context, ignore, only, dirname),
      )
    ) {
      return null;
    }
    const chain = emptyChain();
    for (const op of flattenedConfigs) {
      if (!mergeExtendsChain(chain, op.options, dirname, context, files)) {
        return null;
      }
      mergeChainOpts(chain, op);
    }
    return chain;
  };
}
function mergeExtendsChain(
  chain: ConfigChain,
  opts: ValidatedOptions,
  dirname: string,
  context: ConfigContext,
  files: Set<ConfigFile>,
): boolean {
  if (opts.extends === undefined) return true;
  const file = loadConfig(
    opts.extends,
    dirname,
    context.envName,
    context.caller,
  );
  if (files.has(file)) {
    throw new Error(
      `Configuration cycle detected loading ${file.filepath}.\n` +
        `File already loaded following the config chain:\n` +
        Array.from(files, file => ` - ${file.filepath}`).join("\n"),
    );
  }
  files.add(file);
  const fileChain = loadFileChain(validateExtendFile(file), context, files);
  files.delete(file);
  if (!fileChain) return false;
  mergeChain(chain, fileChain);
  return true;
}
function mergeChain(target: ConfigChain, source: ConfigChain): ConfigChain {
  target.options.push(...source.options);
  target.plugins.push(...source.plugins);
  target.presets.push(...source.presets);
  return target;
}
function mergeChainOpts(
  target: ConfigChain,
  { options, plugins, presets }: OptionsAndDescriptors,
): ConfigChain {
  target.options.push(options);
  target.plugins.push(...plugins());
  target.presets.push(...presets());
  return target;
}
function emptyChain(): ConfigChain {
  return {
    options: [],
    presets: [],
    plugins: [],
  };
}
function normalizeOptions(opts: ValidatedOptions): ValidatedOptions {
  const options = {
    ...opts,
  };
  delete options.extends;
  delete options.env;
  delete options.overrides;
  delete options.plugins;
  delete options.presets;
  delete options.passPerPreset;
  delete options.ignore;
  delete options.only;
  delete options.test;
  delete options.include;
  delete options.exclude;
  // "sourceMap" is just aliased to sourceMap, so copy it over as
  // we merge the options together.
  if (options.hasOwnProperty("sourceMap")) {
    options.sourceMaps = options.sourceMap;
    delete options.sourceMap;
  }
  return options;
}
function dedupDescriptors(
  items: Array<UnloadedDescriptor>,
): Array<UnloadedDescriptor> {
  const map: Map<
    Function,
    Map<string | void, { value: UnloadedDescriptor }>,
  > = new Map();
  const descriptors = [];
  for (const item of items) {
    if (typeof item.value === "function") {
      const fnKey = item.value;
      let nameMap = map.get(fnKey);
      if (!nameMap) {
        nameMap = new Map();
        map.set(fnKey, nameMap);
      }
      let desc = nameMap.get(item.name);
      if (!desc) {
        desc = { value: item };
        descriptors.push(desc);
        // Treat passPerPreset presets as unique, skipping them
        // in the merge processing steps.
        if (!item.ownPass) nameMap.set(item.name, desc);
      } else {
        desc.value = item;
      }
    } else {
      descriptors.push({ value: item });
    }
  }
  return descriptors.reduce((acc, desc) => {
    acc.push(desc.value);
    return acc;
  }, []);
}
function configIsApplicable(
  { options }: OptionsAndDescriptors,
  dirname: string,
  context: ConfigContext,
): boolean {
  return (
    (options.test === undefined ||
      configFieldIsApplicable(context, options.test, dirname)) &&
    (options.include === undefined ||
      configFieldIsApplicable(context, options.include, dirname)) &&
    (options.exclude === undefined ||
      !configFieldIsApplicable(context, options.exclude, dirname))
  );
}
function configFieldIsApplicable(
  context: ConfigContext,
  test: ConfigApplicableTest,
  dirname: string,
): boolean {
  const patterns = Array.isArray(test) ? test : [test];
  return matchesPatterns(context, patterns, dirname);
}
/**
 * Tests if a filename should be ignored based on "ignore" and "only" options.
 */
function shouldIgnore(
  context: ConfigContext,
  ignore: ?IgnoreList,
  only: ?IgnoreList,
  dirname: string,
): boolean {
  if (ignore && matchesPatterns(context, ignore, dirname)) {
    debug(
      "Ignored %o because it matched one of %O from %o",
      context.filename,
      ignore,
      dirname,
    );
    return true;
  }
  if (only && !matchesPatterns(context, only, dirname)) {
    debug(
      "Ignored %o because it failed to match one of %O from %o",
      context.filename,
      only,
      dirname,
    );
    return true;
  }
  return false;
}
/**
 * Returns result of calling function with filename if pattern is a function.
 * Otherwise returns result of matching pattern Regex with filename.
 */
function matchesPatterns(
  context: ConfigContext,
  patterns: IgnoreList,
  dirname: string,
): boolean {
  return patterns.some(pattern =>
    matchPattern(pattern, dirname, context.filename, context),
  );
}
function matchPattern(
  pattern,
  dirname,
  pathToTest,
  context: ConfigContext,
): boolean {
  if (typeof pattern === "function") {
    return !!pattern(pathToTest, {
      dirname,
      envName: context.envName,
      caller: context.caller,
    });
  }
  if (typeof pathToTest !== "string") {
    throw new Error(
      `Configuration contains string/RegExp pattern, but no filename was passed to Babel`,
    );
  }
  if (typeof pattern === "string") {
    pattern = pathPatternToRegex(pattern, dirname);
  }
  return pattern.test(pathToTest);
}

// </from> /home/qfox/apps/babel/packages/babel-core/src/config/config-chain.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/config/partial.js

// @flow
import path from "path";
import Plugin from "./plugin";
import { mergeOptions } from "./util";
import { createItemFromDescriptor } from "./item";
import { buildRootChain, type ConfigContext } from "./config-chain";
import { getEnv } from "./helpers/environment";
import {
  validate,
  type ValidatedOptions,
  type RootMode,
} from "./validation/options";
import { findConfigUpwards, type ConfigFile, type IgnoreFile } from "./files";
function resolveRootMode(rootDir: string, rootMode: RootMode): string {
  switch (rootMode) {
    case "root":
      return rootDir;
    case "upward-optional": {
      const upwardRootDir = findConfigUpwards(rootDir);
      return upwardRootDir === null ? rootDir : upwardRootDir;
    }
    case "upward": {
      const upwardRootDir = findConfigUpwards(rootDir);
      if (upwardRootDir !== null) return upwardRootDir;
      throw Object.assign(
        (new Error(
          `Babel was run with rootMode:"upward" but a root could not ` +
            `be found when searching upward from "${rootDir}"`,
        ): any),
        {
          code: "BABEL_ROOT_NOT_FOUND",
          dirname: rootDir,
        },
      );
    }
    default:
      throw new Error(`Assertion failure - unknown rootMode value`);
  }
}
export default function loadPrivatePartialConfig(
  inputOpts: mixed,
): {
  options: ValidatedOptions,
  context: ConfigContext,
  ignore: IgnoreFile | void,
  babelrc: ConfigFile | void,
  config: ConfigFile | void,
} | null {
  if (
    inputOpts != null &&
    (typeof inputOpts !== "object" || Array.isArray(inputOpts))
  ) {
    throw new Error("Babel options must be an object, null, or undefined");
  }
  const args = inputOpts ? validate("arguments", inputOpts) : {};
  const {
    envName = getEnv(),
    cwd = ".",
    root: rootDir = ".",
    rootMode = "root",
    caller,
  } = args;
  const absoluteCwd = path.resolve(cwd);
  const absoluteRootDir = resolveRootMode(
    path.resolve(absoluteCwd, rootDir),
    rootMode,
  );
  const context: ConfigContext = {
    filename:
      typeof args.filename === "string"
        ? path.resolve(cwd, args.filename)
        : undefined,
    cwd: absoluteCwd,
    root: absoluteRootDir,
    envName,
    caller,
  };
  const configChain = buildRootChain(args, context);
  if (!configChain) return null;
  const options = {};
  configChain.options.forEach(opts => {
    mergeOptions(options, opts);
  });
  // Tack the passes onto the object itself so that, if this object is
  // passed back to Babel a second time, it will be in the right structure
  // to not change behavior.
  options.babelrc = false;
  options.configFile = false;
  options.passPerPreset = false;
  options.envName = context.envName;
  options.cwd = context.cwd;
  options.root = context.root;
  options.filename =
    typeof context.filename === "string" ? context.filename : undefined;
  options.plugins = configChain.plugins.map(descriptor =>
    createItemFromDescriptor(descriptor),
  );
  options.presets = configChain.presets.map(descriptor =>
    createItemFromDescriptor(descriptor),
  );
  return {
    options,
    context,
    ignore: configChain.ignore,
    babelrc: configChain.babelrc,
    config: configChain.config,
  };
}
export function loadPartialConfig(inputOpts: mixed): PartialConfig | null {
  const result = loadPrivatePartialConfig(inputOpts);
  if (!result) return null;
  const { options, babelrc, ignore, config } = result;
  (options.plugins || []).forEach(item => {
    if (item.value instanceof Plugin) {
      throw new Error(
        "Passing cached plugin instances is not supported in " +
          "babel.loadPartialConfig()",
      );
    }
  });
  return new PartialConfig(
    options,
    babelrc ? babelrc.filepath : undefined,
    ignore ? ignore.filepath : undefined,
    config ? config.filepath : undefined,
  );
}
export type { PartialConfig };
class PartialConfig {
  /**
   * These properties are public, so any changes to them should be considered
   * a breaking change to Babel's API.
   */
  options: ValidatedOptions;
  babelrc: string | void;
  babelignore: string | void;
  config: string | void;
  constructor(
    options: ValidatedOptions,
    babelrc: string | void,
    ignore: string | void,
    config: string | void,
  ) {
    this.options = options;
    this.babelignore = ignore;
    this.babelrc = babelrc;
    this.config = config;
    // Freeze since this is a public API and it should be extremely obvious that
    // reassigning properties on here does nothing.
    Object.freeze(this);
  }
  /**
   * Returns true if their is a config file in the filesystem for this config.
   *
   * While this only means .babelrc(.mjs)?/package.json#babel right now, it
   * may well expand in the future, so using this is recommended vs checking
   * this.babelrc directly.
   */
  hasFilesystemConfig(): boolean {
    return this.babelrc !== undefined || this.config !== undefined;
  }
}
Object.freeze(PartialConfig.prototype);

// </from> /home/qfox/apps/babel/packages/babel-core/src/config/partial.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/config/files/index.js

// @flow
import typeof * as indexBrowserType from "./index-browser";
import typeof * as indexType from "./index";
// Kind of gross, but essentially asserting that the exports of this module are the same as the
// exports of index-browser, since this file may be replaced at bundle time with index-browser.
((({}: any): $Exact<indexBrowserType>): $Exact<indexType>);
export { findPackageData } from "./package";
export {
  findConfigUpwards,
  findRelativeConfig,
  findRootConfig,
  loadConfig,
} from "./configuration";
export type {
  ConfigFile,
  IgnoreFile,
  RelativeConfig,
  FilePackageData,
} from "./types";
export {
  resolvePlugin,
  resolvePreset,
  loadPlugin,
  loadPreset,
} from "./plugins";

// </from> /home/qfox/apps/babel/packages/babel-core/src/config/files/index.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/config/files/plugins.js

// @flow
/**
 * This file handles all logic for converting string-based configuration references into loaded objects.
 */
import buildDebug from "debug";
import resolve from "resolve";
import path from "path";
const debug = buildDebug("babel:config:loading:files:plugins");
const EXACT_RE = /^module:/;
const BABEL_PLUGIN_PREFIX_RE = /^(?!@|module:|[^/]+\/|babel-plugin-)/;
const BABEL_PRESET_PREFIX_RE = /^(?!@|module:|[^/]+\/|babel-preset-)/;
const BABEL_PLUGIN_ORG_RE = /^(@babel\/)(?!plugin-|[^/]+\/)/;
const BABEL_PRESET_ORG_RE = /^(@babel\/)(?!preset-|[^/]+\/)/;
const OTHER_PLUGIN_ORG_RE = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-plugin(?:-|\/|$)|[^/]+\/)/;
const OTHER_PRESET_ORG_RE = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-preset(?:-|\/|$)|[^/]+\/)/;
const OTHER_ORG_DEFAULT_RE = /^(@(?!babel$)[^/]+)$/;
export function resolvePlugin(name: string, dirname: string): string | null {
  return resolveStandardizedName("plugin", name, dirname);
}
export function resolvePreset(name: string, dirname: string): string | null {
  return resolveStandardizedName("preset", name, dirname);
}
export function loadPlugin(
  name: string,
  dirname: string,
): { filepath: string, value: mixed } {
  const filepath = resolvePlugin(name, dirname);
  if (!filepath) {
    throw new Error(`Plugin ${name} not found relative to ${dirname}`);
  }
  const value = requireModule("plugin", filepath);
  debug("Loaded plugin %o from %o.", name, dirname);
  return { filepath, value };
}
export function loadPreset(
  name: string,
  dirname: string,
): { filepath: string, value: mixed } {
  const filepath = resolvePreset(name, dirname);
  if (!filepath) {
    throw new Error(`Preset ${name} not found relative to ${dirname}`);
  }
  const value = requireModule("preset", filepath);
  debug("Loaded preset %o from %o.", name, dirname);
  return { filepath, value };
}
function standardizeName(type: "plugin" | "preset", name: string) {
  // Let absolute and relative paths through.
  if (path.isAbsolute(name)) return name;
  const isPreset = type === "preset";
  return (
    name
      // foo -> babel-preset-foo
      .replace(
        isPreset ? BABEL_PRESET_PREFIX_RE : BABEL_PLUGIN_PREFIX_RE,
        `babel-${type}-`,
      )
      // @babel/es2015 -> @babel/preset-es2015
      .replace(
        isPreset ? BABEL_PRESET_ORG_RE : BABEL_PLUGIN_ORG_RE,
        `$1${type}-`,
      )
      // @foo/mypreset -> @foo/babel-preset-mypreset
      .replace(
        isPreset ? OTHER_PRESET_ORG_RE : OTHER_PLUGIN_ORG_RE,
        `$1babel-${type}-`,
      )
      // @foo -> @foo/babel-preset
      .replace(OTHER_ORG_DEFAULT_RE, `$1/babel-${type}`)
      // module:mypreset -> mypreset
      .replace(EXACT_RE, "")
  );
}
function resolveStandardizedName(
  type: "plugin" | "preset",
  name: string,
  dirname: string = process.cwd(),
) {
  const standardizedName = standardizeName(type, name);
  try {
    return resolve.sync(standardizedName, { basedir: dirname });
  } catch (e) {
    if (e.code !== "MODULE_NOT_FOUND") throw e;
    if (standardizedName !== name) {
      let resolvedOriginal = false;
      try {
        resolve.sync(name, { basedir: dirname });
        resolvedOriginal = true;
      } catch (e2) {}
      if (resolvedOriginal) {
        e.message += `\n- If you want to resolve "${name}", use "module:${name}"`;
      }
    }
    let resolvedBabel = false;
    try {
      resolve.sync(standardizeName(type, "@babel/" + name), {
        basedir: dirname,
      });
      resolvedBabel = true;
    } catch (e2) {}
    if (resolvedBabel) {
      e.message += `\n- Did you mean "@babel/${name}"?`;
    }
    let resolvedOppositeType = false;
    const oppositeType = type === "preset" ? "plugin" : "preset";
    try {
      resolve.sync(standardizeName(oppositeType, name), { basedir: dirname });
      resolvedOppositeType = true;
    } catch (e2) {}
    if (resolvedOppositeType) {
      e.message += `\n- Did you accidentally pass a ${type} as a ${oppositeType}?`;
    }
    throw e;
  }
}
const LOADING_MODULES = new Set();
function requireModule(type: string, name: string): mixed {
  if (LOADING_MODULES.has(name)) {
    throw new Error(
      `Reentrant ${type} detected trying to load "${name}". This module is not ignored ` +
        "and is trying to load itself while compiling itself, leading to a dependency cycle. " +
        'We recommend adding it to your "ignore" list in your babelrc, or to a .babelignore.',
    );
  }
  try {
    LOADING_MODULES.add(name);
    // $FlowIssue
    return require(name);
  } finally {
    LOADING_MODULES.delete(name);
  }
}

// </from> /home/qfox/apps/babel/packages/babel-core/src/config/files/plugins.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/config/files/configuration.js

// @flow
import buildDebug from "debug";
import path from "path";
import fs from "fs";
import json5 from "json5";
import resolve from "resolve";
import {
  makeStrongCache,
  makeWeakCache,
  type CacheConfigurator,
} from "../caching";
import makeAPI from "../helpers/config-api";
import { makeStaticFileCache } from "./utils";
import pathPatternToRegex from "../pattern-to-regex";
const debug = buildDebug("babel:config:loading:files:configuration");
const BABEL_CONFIG_JS_FILENAME = "babel.config.js";
const BABELRC_FILENAME = ".babelrc";
const BABELRC_JS_FILENAME = ".babelrc.js";
const BABELIGNORE_FILENAME = ".babelignore";
export function findConfigUpwards(rootDir: string): string | null {
  let dirname = rootDir;
  while (true) {
    if (fs.existsSync(path.join(dirname, BABEL_CONFIG_JS_FILENAME))) {
      return dirname;
    }
    const nextDir = path.dirname(dirname);
    if (dirname === nextDir) break;
    dirname = nextDir;
  }
  return null;
}
export function findRelativeConfig(
  packageData: FilePackageData,
  envName: string,
  caller: CallerMetadata | void,
): RelativeConfig {
  let config = null;
  let ignore = null;
  const dirname = path.dirname(packageData.filepath);
  for (const loc of packageData.directories) {
    if (!config) {
      config = [BABELRC_FILENAME, BABELRC_JS_FILENAME].reduce(
        (previousConfig: ConfigFile | null, name) => {
          const filepath = path.join(loc, name);
          const config = readConfig(filepath, envName, caller);
          if (config && previousConfig) {
            throw new Error(
              `Multiple configuration files found. Please remove one:\n` +
                ` - ${path.basename(previousConfig.filepath)}\n` +
                ` - ${name}\n` +
                `from ${loc}`,
            );
          }
          return config || previousConfig;
        },
        null,
      );
      const pkgConfig =
        packageData.pkg && packageData.pkg.dirname === loc
          ? packageToBabelConfig(packageData.pkg)
          : null;
      if (pkgConfig) {
        if (config) {
          throw new Error(
            `Multiple configuration files found. Please remove one:\n` +
              ` - ${path.basename(pkgConfig.filepath)}#babel\n` +
              ` - ${path.basename(config.filepath)}\n` +
              `from ${loc}`,
          );
        }
        config = pkgConfig;
      }
      if (config) {
        debug("Found configuration %o from %o.", config.filepath, dirname);
      }
    }
    if (!ignore) {
      const ignoreLoc = path.join(loc, BABELIGNORE_FILENAME);
      ignore = readIgnoreConfig(ignoreLoc);
      if (ignore) {
        debug("Found ignore %o from %o.", ignore.filepath, dirname);
      }
    }
  }
  return { config, ignore };
}
export function findRootConfig(
  dirname: string,
  envName: string,
  caller: CallerMetadata | void,
): ConfigFile | null {
  const filepath = path.resolve(dirname, BABEL_CONFIG_JS_FILENAME);
  const conf = readConfig(filepath, envName, caller);
  if (conf) {
    debug("Found root config %o in $o.", BABEL_CONFIG_JS_FILENAME, dirname);
  }
  return conf;
}
export function loadConfig(
  name: string,
  dirname: string,
  envName: string,
  caller: CallerMetadata | void,
): ConfigFile {
  const filepath = resolve.sync(name, { basedir: dirname });
  const conf = readConfig(filepath, envName, caller);
  if (!conf) {
    throw new Error(`Config file ${filepath} contains no configuration data`);
  }
  debug("Loaded config %o from $o.", name, dirname);
  return conf;
}
/**
 * Read the given config file, returning the result. Returns null if no config was found, but will
 * throw if there are parsing errors while loading a config.
 */
function readConfig(filepath, envName, caller): ConfigFile | null {
  return path.extname(filepath) === ".js"
    ? readConfigJS(filepath, { envName, caller })
    : readConfigJSON5(filepath);
}
const LOADING_CONFIGS = new Set();
const readConfigJS = makeStrongCache(
  (
    filepath,
    cache: CacheConfigurator<{
      envName: string,
      caller: CallerMetadata | void,
    }>,
  ) => {
    if (!fs.existsSync(filepath)) {
      cache.forever();
      return null;
    }
    // The `require()` call below can make this code reentrant if a require hook like @babel/register has been
    // loaded into the system. That would cause Babel to attempt to compile the `.babelrc.js` file as it loads
    // below. To cover this case, we auto-ignore re-entrant config processing.
    if (LOADING_CONFIGS.has(filepath)) {
      cache.never();
      debug("Auto-ignoring usage of config %o.", filepath);
      return {
        filepath,
        dirname: path.dirname(filepath),
        options: {},
      };
    }
    let options;
    try {
      LOADING_CONFIGS.add(filepath);
      // $FlowIssue
      const configModule = (require(filepath): mixed);
      options =
        configModule && configModule.__esModule
          ? configModule.default || undefined
          : configModule;
    } catch (err) {
      err.message = `${filepath}: Error while loading config - ${err.message}`;
      throw err;
    } finally {
      LOADING_CONFIGS.delete(filepath);
    }
    if (typeof options === "function") {
      options = options(makeAPI(cache));
      if (!cache.configured()) throwConfigError();
    }
    if (!options || typeof options !== "object" || Array.isArray(options)) {
      throw new Error(
        `${filepath}: Configuration should be an exported JavaScript object.`,
      );
    }
    if (typeof options.then === "function") {
      throw new Error(
        `You appear to be using an async configuration, ` +
          `which your current version of Babel does not support. ` +
          `We may add support for this in the future, ` +
          `but if you're on the most recent version of @babel/core and still ` +
          `seeing this error, then you'll need to synchronously return your config.`,
      );
    }
    return {
      filepath,
      dirname: path.dirname(filepath),
      options,
    };
  },
);
const packageToBabelConfig = makeWeakCache(
  (file: ConfigFile): ConfigFile | null => {
    const babel = file.options[("babel": string)];
    if (typeof babel === "undefined") return null;
    if (typeof babel !== "object" || Array.isArray(babel) || babel === null) {
      throw new Error(`${file.filepath}: .babel property must be an object`);
    }
    return {
      filepath: file.filepath,
      dirname: file.dirname,
      options: babel,
    };
  },
);
const readConfigJSON5 = makeStaticFileCache((filepath, content) => {
  let options;
  try {
    options = json5.parse(content);
  } catch (err) {
    err.message = `${filepath}: Error while parsing config - ${err.message}`;
    throw err;
  }
  if (!options) throw new Error(`${filepath}: No config detected`);
  if (typeof options !== "object") {
    throw new Error(`${filepath}: Config returned typeof ${typeof options}`);
  }
  if (Array.isArray(options)) {
    throw new Error(`${filepath}: Expected config object but found array`);
  }
  return {
    filepath,
    dirname: path.dirname(filepath),
    options,
  };
});
const readIgnoreConfig = makeStaticFileCache((filepath, content) => {
  const ignoreDir = path.dirname(filepath);
  const ignorePatterns = content
    .split("\n")
    .map(line => line.replace(/#(.*?)$/, "").trim())
    .filter(line => !!line);
  for (const pattern of ignorePatterns) {
    if (pattern[0] === "!") {
      throw new Error(`Negation of file paths is not supported.`);
    }
  }
  return {
    filepath,
    dirname: path.dirname(filepath),
    ignore: ignorePatterns.map(pattern =>
      pathPatternToRegex(pattern, ignoreDir),
    ),
  };
});
function throwConfigError() {
  throw new Error(`\
Caching was left unconfigured. Babel's plugins, presets, and .babelrc.js files can be configured
for various types of caching, using the first param of their handler functions:
module.exports = function(api) {
  // The API exposes the following:
  // Cache the returned value forever and don't call this function again.
  api.cache(true);
  // Don't cache at all. Not recommended because it will be very slow.
  api.cache(false);
  // Cached based on the value of some function. If this function returns a value different from
  // a previously-encountered value, the plugins will re-evaluate.
  var env = api.cache(() => process.env.NODE_ENV);
  // If testing for a specific env, we recommend specifics to avoid instantiating a plugin for
  // any possible NODE_ENV value that might come up during plugin execution.
  var isProd = api.cache(() => process.env.NODE_ENV === "production");
  // .cache(fn) will perform a linear search though instances to find the matching plugin based
  // based on previous instantiated plugins. If you want to recreate the plugin and discard the
  // previous instance whenever something changes, you may use:
  var isProd = api.cache.invalidate(() => process.env.NODE_ENV === "production");
  // Note, we also expose the following more-verbose versions of the above examples:
  api.cache.forever(); // api.cache(true)
  api.cache.never();   // api.cache(false)
  api.cache.using(fn); // api.cache(fn)
  // Return the value that will be cached.
  return { };
};`);
}

// </from> /home/qfox/apps/babel/packages/babel-core/src/config/files/configuration.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/config/files/index-browser.js

// @flow
  ConfigFile,
  IgnoreFile,
  RelativeConfig,
  FilePackageData,
} from "./types";
export type { ConfigFile, IgnoreFile, RelativeConfig, FilePackageData };
export function findConfigUpwards(
  rootDir: string, // eslint-disable-line no-unused-vars
): string | null {
  return null;
}
export function findPackageData(filepath: string): FilePackageData {
  return {
    filepath,
    directories: [],
    pkg: null,
    isPackage: false,
  };
}
export function findRelativeConfig(
  pkgData: FilePackageData, // eslint-disable-line no-unused-vars
  envName: string, // eslint-disable-line no-unused-vars
  caller: CallerMetadata | void, // eslint-disable-line no-unused-vars
): RelativeConfig {
  return { pkg: null, config: null, ignore: null };
}
export function findRootConfig(
  dirname: string, // eslint-disable-line no-unused-vars
  envName: string, // eslint-disable-line no-unused-vars
  caller: CallerMetadata | void, // eslint-disable-line no-unused-vars
): ConfigFile | null {
  return null;
}
export function loadConfig(
  name: string,
  dirname: string,
  envName: string, // eslint-disable-line no-unused-vars
  caller: CallerMetadata | void, // eslint-disable-line no-unused-vars
): ConfigFile {
  throw new Error(`Cannot load ${name} relative to ${dirname} in a browser`);
}
// eslint-disable-next-line no-unused-vars
export function resolvePlugin(name: string, dirname: string): string | null {
  return null;
}
// eslint-disable-next-line no-unused-vars
export function resolvePreset(name: string, dirname: string): string | null {
  return null;
}
export function loadPlugin(
  name: string,
  dirname: string,
): { filepath: string, value: mixed } {
  throw new Error(
    `Cannot load plugin ${name} relative to ${dirname} in a browser`,
  );
}
export function loadPreset(
  name: string,
  dirname: string,
): { filepath: string, value: mixed } {
  throw new Error(
    `Cannot load preset ${name} relative to ${dirname} in a browser`,
  );
}

// </from> /home/qfox/apps/babel/packages/babel-core/src/config/files/index-browser.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/config/files/types.js

// @flow
export type ConfigFile = {
  filepath: string,
  dirname: string,
  options: {},
};
export type IgnoreFile = {
  filepath: string,
  dirname: string,
  ignore: Array<RegExp>,
};
export type RelativeConfig = {
  // The actual config, either from package.json#babel, .babelrc, or
  // .babelrc.js, if there was one.
  config: ConfigFile | null,
  // The .babelignore, if there was one.
  ignore: IgnoreFile | null,
};
export type FilePackageData = {
  // The file in the package.
  filepath: string,
  // Any ancestor directories of the file that are within the package.
  directories: Array<string>,
  // The contents of the package.json. May not be found if the package just
  // terminated at a node_modules folder without finding one.
  pkg: ConfigFile | null,
  // True if a package.json or node_modules folder was found while traversing
  // the directory structure.
  isPackage: boolean,
};

// </from> /home/qfox/apps/babel/packages/babel-core/src/config/files/types.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/config/files/package.js

// @flow
import path from "path";
import { makeStaticFileCache } from "./utils";
const PACKAGE_FILENAME = "package.json";
/**
 * Find metadata about the package that this file is inside of. Resolution
 * of Babel's config requires general package information to decide when to
 * search for .babelrc files
 */
export function findPackageData(filepath: string): FilePackageData {
  let pkg = null;
  const directories = [];
  let isPackage = true;
  let dirname = path.dirname(filepath);
  while (!pkg && path.basename(dirname) !== "node_modules") {
    directories.push(dirname);
    pkg = readConfigPackage(path.join(dirname, PACKAGE_FILENAME));
    const nextLoc = path.dirname(dirname);
    if (dirname === nextLoc) {
      isPackage = false;
      break;
    }
    dirname = nextLoc;
  }
  return { filepath, directories, pkg, isPackage };
}
const readConfigPackage = makeStaticFileCache(
  (filepath, content): ConfigFile => {
    let options;
    try {
      options = JSON.parse(content);
    } catch (err) {
      err.message = `${filepath}: Error while parsing JSON - ${err.message}`;
      throw err;
    }
    if (typeof options !== "object") {
      throw new Error(`${filepath}: Config returned typeof ${typeof options}`);
    }
    if (Array.isArray(options)) {
      throw new Error(`${filepath}: Expected config object but found array`);
    }
    return {
      filepath,
      dirname: path.dirname(filepath),
      options,
    };
  },
);

// </from> /home/qfox/apps/babel/packages/babel-core/src/config/files/package.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/config/files/utils.js

// @flow
import fs from "fs";
import { makeStrongCache } from "../caching";
export function makeStaticFileCache<T>(
  fn: (string, string) => T,
): string => T | null {
  return makeStrongCache((filepath, cache) => {
    if (cache.invalidate(() => fileMtime(filepath)) === null) {
      cache.forever();
      return null;
    }
    return fn(filepath, fs.readFileSync(filepath, "utf8"));
  });
}
function fileMtime(filepath: string): number | null {
  try {
    return +fs.statSync(filepath).mtime;
  } catch (e) {
    if (e.code !== "ENOENT" && e.code !== "ENOTDIR") throw e;
  }
  return null;
}

// </from> /home/qfox/apps/babel/packages/babel-core/src/config/files/utils.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/config/plugin.js

// @flow
export default class Plugin {
  key: ?string;
  manipulateOptions: Function | void;
  post: Function | void;
  pre: Function | void;
  visitor: {};
  parserOverride: Function | void;
  generatorOverride: Function | void;
  options: {};
  constructor(plugin: PluginObject, options: {}, key?: string) {
    this.key = plugin.name || key;
    this.manipulateOptions = plugin.manipulateOptions;
    this.post = plugin.post;
    this.pre = plugin.pre;
    this.visitor = plugin.visitor || {};
    this.parserOverride = plugin.parserOverride;
    this.generatorOverride = plugin.generatorOverride;
    this.options = options;
  }
}

// </from> /home/qfox/apps/babel/packages/babel-core/src/config/plugin.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/config/util.js

// @flow
export function mergeOptions(
  target: ValidatedOptions,
  source: ValidatedOptions,
): void {
  for (const k of Object.keys(source)) {
    if (k === "parserOpts" && source.parserOpts) {
      const parserOpts = source.parserOpts;
      const targetObj = (target.parserOpts = target.parserOpts || {});
      mergeDefaultFields(targetObj, parserOpts);
    } else if (k === "generatorOpts" && source.generatorOpts) {
      const generatorOpts = source.generatorOpts;
      const targetObj = (target.generatorOpts = target.generatorOpts || {});
      mergeDefaultFields(targetObj, generatorOpts);
    } else {
      const val = source[k];
      if (val !== undefined) target[k] = (val: any);
    }
  }
}
function mergeDefaultFields<T: {}>(target: T, source: T) {
  for (const k of Object.keys(source)) {
    const val = source[k];
    if (val !== undefined) target[k] = (val: any);
  }
}

// </from> /home/qfox/apps/babel/packages/babel-core/src/config/util.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/config/full.js

// @flow
import { mergeOptions } from "./util";
import * as context from "../index";
import Plugin from "./plugin";
import { getItemDescriptor } from "./item";
import {
  buildPresetChain,
  type ConfigContext,
  type ConfigChain,
  type PresetInstance,
} from "./config-chain";
import traverse from "@babel/traverse";
import { makeWeakCache, type CacheConfigurator } from "./caching";
import { validate, type CallerMetadata } from "./validation/options";
import { validatePluginObject } from "./validation/plugins";
import makeAPI from "./helpers/config-api";
import loadPrivatePartialConfig from "./partial";
type LoadedDescriptor = {
  value: {},
  options: {},
  dirname: string,
  alias: string,
};
export type { InputOptions } from "./validation/options";
export type ResolvedConfig = {
  options: Object,
  passes: PluginPasses,
};
export type { Plugin };
export type PluginPassList = Array<Plugin>;
export type PluginPasses = Array<PluginPassList>;
// Context not including filename since it is used in places that cannot
// process 'ignore'/'only' and other filename-based logic.
type SimpleContext = {
  envName: string,
  caller: CallerMetadata | void,
};
export default function loadFullConfig(
  inputOpts: mixed,
): ResolvedConfig | null {
  const result = loadPrivatePartialConfig(inputOpts);
  if (!result) {
    return null;
  }
  const { options, context } = result;
  const optionDefaults = {};
  const passes = [[]];
  try {
    const { plugins, presets } = options;
    if (!plugins || !presets) {
      throw new Error("Assertion failure - plugins and presets exist");
    }
    const ignored = (function recurseDescriptors(
      config: {
        plugins: Array<UnloadedDescriptor>,
        presets: Array<UnloadedDescriptor>,
      },
      pass: Array<Plugin>,
    ) {
      const plugins = config.plugins.reduce((acc, descriptor) => {
        if (descriptor.options !== false) {
          acc.push(loadPluginDescriptor(descriptor, context));
        }
        return acc;
      }, []);
      const presets = config.presets.reduce((acc, descriptor) => {
        if (descriptor.options !== false) {
          acc.push({
            preset: loadPresetDescriptor(descriptor, context),
            pass: descriptor.ownPass ? [] : pass,
          });
        }
        return acc;
      }, []);
      // resolve presets
      if (presets.length > 0) {
        // The passes are created in the same order as the preset list, but are inserted before any
        // existing additional passes.
        passes.splice(
          1,
          0,
          ...presets.map(o => o.pass).filter(p => p !== pass),
        );
        for (const { preset, pass } of presets) {
          if (!preset) return true;
          const ignored = recurseDescriptors(
            {
              plugins: preset.plugins,
              presets: preset.presets,
            },
            pass,
          );
          if (ignored) return true;
          preset.options.forEach(opts => {
            mergeOptions(optionDefaults, opts);
          });
        }
      }
      // resolve plugins
      if (plugins.length > 0) {
        pass.unshift(...plugins);
      }
    })(
      {
        plugins: plugins.map(item => {
          const desc = getItemDescriptor(item);
          if (!desc) {
            throw new Error("Assertion failure - must be config item");
          }
          return desc;
        }),
        presets: presets.map(item => {
          const desc = getItemDescriptor(item);
          if (!desc) {
            throw new Error("Assertion failure - must be config item");
          }
          return desc;
        }),
      },
      passes[0],
    );
    if (ignored) return null;
  } catch (e) {
    // There are a few case where thrown errors will try to annotate themselves multiple times, so
    // to keep things simple we just bail out if re-wrapping the message.
    if (!/^\[BABEL\]/.test(e.message)) {
      e.message = `[BABEL] ${context.filename || "unknown"}: ${e.message}`;
    }
    throw e;
  }
  const opts: Object = optionDefaults;
  mergeOptions(opts, options);
  opts.plugins = passes[0];
  opts.presets = passes
    .slice(1)
    .filter(plugins => plugins.length > 0)
    .map(plugins => ({ plugins }));
  opts.passPerPreset = opts.presets.length > 0;
  return {
    options: opts,
    passes: passes,
  };
}
/**
 * Load a generic plugin/preset from the given descriptor loaded from the config object.
 */
const loadDescriptor = makeWeakCache(
  (
    { value, options, dirname, alias }: UnloadedDescriptor,
    cache: CacheConfigurator<SimpleContext>,
  ): LoadedDescriptor => {
    // Disabled presets should already have been filtered out
    if (options === false) throw new Error("Assertion failure");
    options = options || {};
    let item = value;
    if (typeof value === "function") {
      const api = {
        ...context,
        ...makeAPI(cache),
      };
      try {
        item = value(api, options, dirname);
      } catch (e) {
        if (alias) {
          e.message += ` (While processing: ${JSON.stringify(alias)})`;
        }
        throw e;
      }
    }
    if (!item || typeof item !== "object") {
      throw new Error("Plugin/Preset did not return an object.");
    }
    if (typeof item.then === "function") {
      throw new Error(
        `You appear to be using an async plugin, ` +
          `which your current version of Babel does not support.` +
          `If you're using a published plugin, ` +
          `you may need to upgrade your @babel/core version.`,
      );
    }
    return { value: item, options, dirname, alias };
  },
);
/**
 * Instantiate a plugin for the given descriptor, returning the plugin/options pair.
 */
function loadPluginDescriptor(
  descriptor: UnloadedDescriptor,
  context: SimpleContext,
): Plugin {
  if (descriptor.value instanceof Plugin) {
    if (descriptor.options) {
      throw new Error(
        "Passed options to an existing Plugin instance will not work.",
      );
    }
    return descriptor.value;
  }
  return instantiatePlugin(loadDescriptor(descriptor, context), context);
}
const instantiatePlugin = makeWeakCache(
  (
    { value, options, dirname, alias }: LoadedDescriptor,
    cache: CacheConfigurator<SimpleContext>,
  ): Plugin => {
    const pluginObj = validatePluginObject(value);
    const plugin = {
      ...pluginObj,
    };
    if (plugin.visitor) {
      plugin.visitor = traverse.explode({
        ...plugin.visitor,
      });
    }
    if (plugin.inherits) {
      const inheritsDescriptor = {
        name: undefined,
        alias: `${alias}$inherits`,
        value: plugin.inherits,
        options,
        dirname,
      };
      // If the inherited plugin changes, reinstantiate this plugin.
      const inherits = cache.invalidate(data =>
        loadPluginDescriptor(inheritsDescriptor, data),
      );
      plugin.pre = chain(inherits.pre, plugin.pre);
      plugin.post = chain(inherits.post, plugin.post);
      plugin.manipulateOptions = chain(
        inherits.manipulateOptions,
        plugin.manipulateOptions,
      );
      plugin.visitor = traverse.visitors.merge([
        inherits.visitor || {},
        plugin.visitor || {},
      ]);
    }
    return new Plugin(plugin, options, alias);
  },
);
/**
 * Generate a config object that will act as the root of a new nested config.
 */
const loadPresetDescriptor = (
  descriptor: UnloadedDescriptor,
  context: ConfigContext,
): ConfigChain | null => {
  return buildPresetChain(
    instantiatePreset(loadDescriptor(descriptor, context)),
    context,
  );
};
const instantiatePreset = makeWeakCache(
  ({ value, dirname, alias }: LoadedDescriptor): PresetInstance => {
    return {
      options: validate("preset", value),
      alias,
      dirname,
    };
  },
);
function chain(a, b) {
  const fns = [a, b].filter(Boolean);
  if (fns.length <= 1) return fns[0];
  return function(...args) {
    for (const fn of fns) {
      fn.apply(this, args);
    }
  };
}

// </from> /home/qfox/apps/babel/packages/babel-core/src/config/full.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/config/helpers/environment.js

// @flow
export function getEnv(defaultValue: string = "development"): string {
  return process.env.BABEL_ENV || process.env.NODE_ENV || defaultValue;
}

// </from> /home/qfox/apps/babel/packages/babel-core/src/config/helpers/environment.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/config/helpers/config-api.js

// @flow
import semver from "semver";
import { version as coreVersion } from "../../";
import {
  assertSimpleType,
  type CacheConfigurator,
  type SimpleCacheConfigurator,
} from "../caching";
type EnvFunction = {
  (): string,
  <T>((string) => T): T,
  (string): boolean,
  (Array<string>): boolean,
};
export type PluginAPI = {
  version: string,
  cache: SimpleCacheConfigurator,
  env: EnvFunction,
  async: () => boolean,
  assertVersion: typeof assertVersion,
};
export default function makeAPI(
  cache: CacheConfigurator<{ envName: string, caller: CallerMetadata | void }>,
): PluginAPI {
  const env: any = value =>
    cache.using(data => {
      if (typeof value === "undefined") return data.envName;
      if (typeof value === "function") {
        return assertSimpleType(value(data.envName));
      }
      if (!Array.isArray(value)) value = [value];
      return value.some(entry => {
        if (typeof entry !== "string") {
          throw new Error("Unexpected non-string value");
        }
        return entry === data.envName;
      });
    });
  const caller: any = cb =>
    cache.using(data => assertSimpleType(cb(data.caller)));
  return {
    version: coreVersion,
    cache: cache.simple(),
    // Expose ".env()" so people can easily get the same env that we expose using the "env" key.
    env,
    async: () => false,
    caller,
    assertVersion,
  };
}
function assertVersion(range: string | number): void {
  if (typeof range === "number") {
    if (!Number.isInteger(range)) {
      throw new Error("Expected string or integer value.");
    }
    range = `^${range}.0.0-0`;
  }
  if (typeof range !== "string") {
    throw new Error("Expected string or integer value.");
  }
  if (semver.satisfies(coreVersion, range)) return;
  const limit = Error.stackTraceLimit;
  if (typeof limit === "number" && limit < 25) {
    // Bump up the limit if needed so that users are more likely
    // to be able to see what is calling Babel.
    Error.stackTraceLimit = 25;
  }
  const err = new Error(
    `Requires Babel "${range}", but was loaded with "${coreVersion}". ` +
      `If you are sure you have a compatible version of @babel/core, ` +
      `it is likely that something in your build process is loading the ` +
      `wrong version. Inspect the stack trace of this error to look for ` +
      `the first entry that doesn't mention "@babel/core" or "babel-core" ` +
      `to see what is calling Babel.`,
  );
  if (typeof limit === "number") {
    Error.stackTraceLimit = limit;
  }
  throw Object.assign(
    err,
    ({
      code: "BABEL_VERSION_UNSUPPORTED",
      version: coreVersion,
      range,
    }: any),
  );
}

// </from> /home/qfox/apps/babel/packages/babel-core/src/config/helpers/config-api.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/config/config-descriptors.js

// @flow
import { loadPlugin, loadPreset } from "./files";
import { getItemDescriptor } from "./item";
import {
  makeWeakCache,
  makeStrongCache,
  type CacheConfigurator,
} from "./caching";
  ValidatedOptions,
  PluginList,
  PluginItem,
} from "./validation/options";
// Represents a config object and functions to lazily load the descriptors
// for the plugins and presets so we don't load the plugins/presets unless
// the options object actually ends up being applicable.
export type OptionsAndDescriptors = {
  options: ValidatedOptions,
  plugins: () => Array<UnloadedDescriptor>,
  presets: () => Array<UnloadedDescriptor>,
};
// Represents a plugin or presets at a given location in a config object.
// At this point these have been resolved to a specific object or function,
// but have not yet been executed to call functions with options.
export type UnloadedDescriptor = {
  name: string | void,
  value: {} | Function,
  options: {} | void | false,
  dirname: string,
  alias: string,
  ownPass?: boolean,
  file?: {
    request: string,
    resolved: string,
  } | void,
};
function isEqualDescriptor(
  a: UnloadedDescriptor,
  b: UnloadedDescriptor,
): boolean {
  return (
    a.name === b.name &&
    a.value === b.value &&
    a.options === b.options &&
    a.dirname === b.dirname &&
    a.alias === b.alias &&
    a.ownPass === b.ownPass &&
    (a.file && a.file.request) === (b.file && b.file.request) &&
    (a.file && a.file.resolved) === (b.file && b.file.resolved)
  );
}
export type ValidatedFile = {
  filepath: string,
  dirname: string,
  options: ValidatedOptions,
};
/**
 * Create a set of descriptors from a given options object, preserving
 * descriptor identity based on the identity of the plugin/preset arrays
 * themselves, and potentially on the identity of the plugins/presets + options.
 */
export function createCachedDescriptors(
  dirname: string,
  options: ValidatedOptions,
  alias: string,
): OptionsAndDescriptors {
  const { plugins, presets, passPerPreset } = options;
  return {
    options,
    plugins: plugins
      ? () => createCachedPluginDescriptors(plugins, dirname)(alias)
      : () => [],
    presets: presets
      ? () =>
          createCachedPresetDescriptors(presets, dirname)(alias)(
            !!passPerPreset,
          )
      : () => [],
  };
}
/**
 * Create a set of descriptors from a given options object, with consistent
 * identity for the descriptors, but not caching based on any specific identity.
 */
export function createUncachedDescriptors(
  dirname: string,
  options: ValidatedOptions,
  alias: string,
): OptionsAndDescriptors {
  // The returned result here is cached to represent a config object in
  // memory, so we build and memoize the descriptors to ensure the same
  // values are returned consistently.
  let plugins;
  let presets;
  return {
    options,
    plugins: () => {
      if (!plugins) {
        plugins = createPluginDescriptors(
          options.plugins || [],
          dirname,
          alias,
        );
      }
      return plugins;
    },
    presets: () => {
      if (!presets) {
        presets = createPresetDescriptors(
          options.presets || [],
          dirname,
          alias,
          !!options.passPerPreset,
        );
      }
      return presets;
    },
  };
}
const PRESET_DESCRIPTOR_CACHE = new WeakMap();
const createCachedPresetDescriptors = makeWeakCache(
  (items: PluginList, cache: CacheConfigurator<string>) => {
    const dirname = cache.using(dir => dir);
    return makeStrongCache((alias: string) =>
      makeStrongCache((passPerPreset: boolean) =>
        createPresetDescriptors(items, dirname, alias, passPerPreset).map(
          // Items are cached using the overall preset array identity when
          // possibly, but individual descriptors are also cached if a match
          // can be found in the previously-used descriptor lists.
          desc => loadCachedDescriptor(PRESET_DESCRIPTOR_CACHE, desc),
        ),
      ),
    );
  },
);
const PLUGIN_DESCRIPTOR_CACHE = new WeakMap();
const createCachedPluginDescriptors = makeWeakCache(
  (items: PluginList, cache: CacheConfigurator<string>) => {
    const dirname = cache.using(dir => dir);
    return makeStrongCache((alias: string) =>
      createPluginDescriptors(items, dirname, alias).map(
        // Items are cached using the overall plugin array identity when
        // possibly, but individual descriptors are also cached if a match
        // can be found in the previously-used descriptor lists.
        desc => loadCachedDescriptor(PLUGIN_DESCRIPTOR_CACHE, desc),
      ),
    );
  },
);
/**
 * When no options object is given in a descriptor, this object is used
 * as a WeakMap key in order to have consistent identity.
 */
const DEFAULT_OPTIONS = {};
/**
 * Given the cache and a descriptor, returns a matching descriptor from the
 * cache, or else returns the input descriptor and adds it to the cache for
 * next time.
 */
function loadCachedDescriptor(
  cache: WeakMap<{} | Function, WeakMap<{}, Array<UnloadedDescriptor>>>,
  desc: UnloadedDescriptor,
) {
  const { value, options = DEFAULT_OPTIONS } = desc;
  if (options === false) return desc;
  let cacheByOptions = cache.get(value);
  if (!cacheByOptions) {
    cacheByOptions = new WeakMap();
    cache.set(value, cacheByOptions);
  }
  let possibilities = cacheByOptions.get(options);
  if (!possibilities) {
    possibilities = [];
    cacheByOptions.set(options, possibilities);
  }
  if (possibilities.indexOf(desc) === -1) {
    const matches = possibilities.filter(possibility =>
      isEqualDescriptor(possibility, desc),
    );
    if (matches.length > 0) {
      return matches[0];
    }
    possibilities.push(desc);
  }
  return desc;
}
function createPresetDescriptors(
  items: PluginList,
  dirname: string,
  alias: string,
  passPerPreset: boolean,
): Array<UnloadedDescriptor> {
  return createDescriptors("preset", items, dirname, alias, passPerPreset);
}
function createPluginDescriptors(
  items: PluginList,
  dirname: string,
  alias: string,
): Array<UnloadedDescriptor> {
  return createDescriptors("plugin", items, dirname, alias);
}
function createDescriptors(
  type: "plugin" | "preset",
  items: PluginList,
  dirname: string,
  alias: string,
  ownPass?: boolean,
): Array<UnloadedDescriptor> {
  const descriptors = items.map((item, index) =>
    createDescriptor(item, dirname, {
      type,
      alias: `${alias}$${index}`,
      ownPass: !!ownPass,
    }),
  );
  assertNoDuplicates(descriptors);
  return descriptors;
}
/**
 * Given a plugin/preset item, resolve it into a standard format.
 */
export function createDescriptor(
  pair: PluginItem,
  dirname: string,
  {
    type,
    alias,
    ownPass,
  }: {
    type?: "plugin" | "preset",
    alias: string,
    ownPass?: boolean,
  },
): UnloadedDescriptor {
  const desc = getItemDescriptor(pair);
  if (desc) {
    return desc;
  }
  let name;
  let options;
  let value = pair;
  if (Array.isArray(value)) {
    if (value.length === 3) {
      // $FlowIgnore - Flow doesn't like the multiple tuple types.
      [value, options, name] = value;
    } else {
      [value, options] = value;
    }
  }
  let file = undefined;
  let filepath = null;
  if (typeof value === "string") {
    if (typeof type !== "string") {
      throw new Error(
        "To resolve a string-based item, the type of item must be given",
      );
    }
    const resolver = type === "plugin" ? loadPlugin : loadPreset;
    const request = value;
    ({ filepath, value } = resolver(value, dirname));
    file = {
      request,
      resolved: filepath,
    };
  }
  if (!value) {
    throw new Error(`Unexpected falsy value: ${String(value)}`);
  }
  if (typeof value === "object" && value.__esModule) {
    if (value.default) {
      value = value.default;
    } else {
      throw new Error("Must export a default export when using ES6 modules.");
    }
  }
  if (typeof value !== "object" && typeof value !== "function") {
    throw new Error(
      `Unsupported format: ${typeof value}. Expected an object or a function.`,
    );
  }
  if (filepath !== null && typeof value === "object" && value) {
    // We allow object values for plugins/presets nested directly within a
    // config object, because it can be useful to define them in nested
    // configuration contexts.
    throw new Error(
      `Plugin/Preset files are not allowed to export objects, only functions. In ${filepath}`,
    );
  }
  return {
    name,
    alias: filepath || alias,
    value,
    options,
    dirname,
    ownPass,
    file,
  };
}
function assertNoDuplicates(items: Array<UnloadedDescriptor>): void {
  const map = new Map();
  for (const item of items) {
    if (typeof item.value !== "function") continue;
    let nameMap = map.get(item.value);
    if (!nameMap) {
      nameMap = new Set();
      map.set(item.value, nameMap);
    }
    if (nameMap.has(item.name)) {
      throw new Error(
        [
          `Duplicate plugin/preset detected.`,
          `If you'd like to use two separate instances of a plugin,`,
          `they need separate names, e.g.`,
          ``,
          `  plugins: [`,
          `    ['some-plugin', {}],`,
          `    ['some-plugin', {}, 'some unique name'],`,
          `  ]`,
        ].join("\n"),
      );
    }
    nameMap.add(item.name);
  }
}

// </from> /home/qfox/apps/babel/packages/babel-core/src/config/config-descriptors.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/config/item.js

// @flow
import path from "path";
import {
  createDescriptor,
  type UnloadedDescriptor,
} from "./config-descriptors";
export function createItemFromDescriptor(desc: UnloadedDescriptor): ConfigItem {
  return new ConfigItem(desc);
}
/**
 * Create a config item using the same value format used in Babel's config
 * files. Items returned from this function should be cached by the caller
 * ideally, as recreating the config item will mean re-resolving the item
 * and re-evaluating the plugin/preset function.
 */
export function createConfigItem(
  value:
    | PluginTarget
    | [PluginTarget, PluginOptions]
    | [PluginTarget, PluginOptions, string | void],
  {
    dirname = ".",
    type,
  }: {
    dirname?: string,
    type?: "preset" | "plugin",
  } = {},
): ConfigItem {
  const descriptor = createDescriptor(value, path.resolve(dirname), {
    type,
    alias: "programmatic item",
  });
  return createItemFromDescriptor(descriptor);
}
export function getItemDescriptor(item: mixed): UnloadedDescriptor | void {
  if (item instanceof ConfigItem) {
    return item._descriptor;
  }
  return undefined;
}
export type { ConfigItem };
/**
 * A public representation of a plugin/preset that will _eventually_ be load.
 * Users can use this to interact with the results of a loaded Babel
 * configuration.
 *
 * Any changes to public properties of this class should be considered a
 * breaking change to Babel's API.
 */
class ConfigItem {
  /**
   * The private underlying descriptor that Babel actually cares about.
   * If you access this, you are a bad person.
   */
  _descriptor: UnloadedDescriptor;
  /**
   * The resolved value of the item itself.
   */
  value: {} | Function;
  /**
   * The options, if any, that were passed to the item.
   * Mutating this will lead to undefined behavior.
   *
   * "false" means that this item has been disabled.
   */
  options: {} | void | false;
  /**
   * The directory that the options for this item are relative to.
   */
  dirname: string;
  /**
   * Get the name of the plugin, if the user gave it one.
   */
  name: string | void;
  /**
   * Data about the file that the item was loaded from, if Babel knows it.
   */
  file: {
    // The requested path, e.g. "@babel/env".
    request: string,
    // The resolved absolute path of the file.
    resolved: string,
  } | void;
  constructor(descriptor: UnloadedDescriptor) {
    // Make people less likely to stumble onto this if they are exploring
    // programmatically, and also make sure that if people happen to
    // pass the item through JSON.stringify, it doesn't show up.
    this._descriptor = descriptor;
    Object.defineProperty(this, "_descriptor", ({ enumerable: false }: any));
    this.value = this._descriptor.value;
    this.options = this._descriptor.options;
    this.dirname = this._descriptor.dirname;
    this.name = this._descriptor.name;
    this.file = this._descriptor.file
      ? {
          request: this._descriptor.file.request,
          resolved: this._descriptor.file.resolved,
        }
      : undefined;
    // Freeze the object to make it clear that people shouldn't expect mutating
    // this object to do anything. A new item should be created if they want
    // to change something.
    Object.freeze(this);
  }
}
Object.freeze(ConfigItem.prototype);

// </from> /home/qfox/apps/babel/packages/babel-core/src/config/item.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/config/caching.js

// @flow
export type SimpleCacheConfigurator = SimpleCacheConfiguratorFn &
  SimpleCacheConfiguratorObj;
type SimpleCacheConfiguratorFn = {
  (boolean): void,
  <T>(handler: () => T): T,
};
type SimpleCacheConfiguratorObj = {
  forever: () => void,
  never: () => void,
  using: <T>(handler: () => T) => T,
  invalidate: <T>(handler: () => T) => T,
};
type CacheEntry<ResultT, SideChannel> = Array<{
  value: ResultT,
  valid: SideChannel => boolean,
}>;
export type { CacheConfigurator };
/**
 * Given a function with a single argument, cache its results based on its argument and how it
 * configures its caching behavior. Cached values are stored strongly.
 */
export function makeStrongCache<ArgT, ResultT, SideChannel>(
  handler: (ArgT, CacheConfigurator<SideChannel>) => ResultT,
): (ArgT, SideChannel) => ResultT {
  return makeCachedFunction(new Map(), handler);
}
/**
 * Given a function with a single argument, cache its results based on its argument and how it
 * configures its caching behavior. Cached values are stored weakly and the function argument must be
 * an object type.
 */
export function makeWeakCache<
  ArgT: {} | Array<*> | $ReadOnlyArray<*>,
  ResultT,
  SideChannel,
>(
  handler: (ArgT, CacheConfigurator<SideChannel>) => ResultT,
): (ArgT, SideChannel) => ResultT {
  return makeCachedFunction(new WeakMap(), handler);
}
type CacheMap<ArgT, ResultT, SideChannel> =
  | Map<ArgT, CacheEntry<ResultT, SideChannel>>
  | WeakMap<ArgT, CacheEntry<ResultT, SideChannel>>;
function makeCachedFunction<
  ArgT,
  ResultT,
  SideChannel,
  Cache: CacheMap<ArgT, ResultT, SideChannel>,
>(
  callCache: Cache,
  handler: (ArgT, CacheConfigurator<SideChannel>) => ResultT,
): (ArgT, SideChannel) => ResultT {
  return function cachedFunction(arg, data) {
    let cachedValue: CacheEntry<ResultT, SideChannel> | void = callCache.get(
      arg,
    );
    if (cachedValue) {
      for (const { value, valid } of cachedValue) {
        if (valid(data)) return value;
      }
    }
    const cache = new CacheConfigurator(data);
    const value = handler(arg, cache);
    if (!cache.configured()) cache.forever();
    cache.deactivate();
    switch (cache.mode()) {
      case "forever":
        cachedValue = [{ value, valid: () => true }];
        callCache.set(arg, cachedValue);
        break;
      case "invalidate":
        cachedValue = [{ value, valid: cache.validator() }];
        callCache.set(arg, cachedValue);
        break;
      case "valid":
        if (cachedValue) {
          cachedValue.push({ value, valid: cache.validator() });
        } else {
          cachedValue = [{ value, valid: cache.validator() }];
          callCache.set(arg, cachedValue);
        }
    }
    return value;
  };
}
class CacheConfigurator<SideChannel = void> {
  _active: boolean = true;
  _never: boolean = false;
  _forever: boolean = false;
  _invalidate: boolean = false;
  _configured: boolean = false;
  _pairs: Array<[mixed, (SideChannel) => mixed]> = [];
  _data: SideChannel;
  constructor(data: SideChannel) {
    this._data = data;
  }
  simple() {
    return makeSimpleConfigurator(this);
  }
  mode() {
    if (this._never) return "never";
    if (this._forever) return "forever";
    if (this._invalidate) return "invalidate";
    return "valid";
  }
  forever() {
    if (!this._active) {
      throw new Error("Cannot change caching after evaluation has completed.");
    }
    if (this._never) {
      throw new Error("Caching has already been configured with .never()");
    }
    this._forever = true;
    this._configured = true;
  }
  never() {
    if (!this._active) {
      throw new Error("Cannot change caching after evaluation has completed.");
    }
    if (this._forever) {
      throw new Error("Caching has already been configured with .forever()");
    }
    this._never = true;
    this._configured = true;
  }
  using<T>(handler: SideChannel => T): T {
    if (!this._active) {
      throw new Error("Cannot change caching after evaluation has completed.");
    }
    if (this._never || this._forever) {
      throw new Error(
        "Caching has already been configured with .never or .forever()",
      );
    }
    this._configured = true;
    const key = handler(this._data);
    this._pairs.push([key, handler]);
    return key;
  }
  invalidate<T>(handler: SideChannel => T): T {
    if (!this._active) {
      throw new Error("Cannot change caching after evaluation has completed.");
    }
    if (this._never || this._forever) {
      throw new Error(
        "Caching has already been configured with .never or .forever()",
      );
    }
    this._invalidate = true;
    this._configured = true;
    const key = handler(this._data);
    this._pairs.push([key, handler]);
    return key;
  }
  validator(): SideChannel => boolean {
    const pairs = this._pairs;
    return (data: SideChannel) => pairs.every(([key, fn]) => key === fn(data));
  }
  deactivate() {
    this._active = false;
  }
  configured() {
    return this._configured;
  }
}
function makeSimpleConfigurator(
  cache: CacheConfigurator<any>,
): SimpleCacheConfigurator {
  function cacheFn(val) {
    if (typeof val === "boolean") {
      if (val) cache.forever();
      else cache.never();
      return;
    }
    return cache.using(() => assertSimpleType(val()));
  }
  cacheFn.forever = () => cache.forever();
  cacheFn.never = () => cache.never();
  cacheFn.using = cb => cache.using(() => assertSimpleType(cb()));
  cacheFn.invalidate = cb => cache.invalidate(() => assertSimpleType(cb()));
  return (cacheFn: any);
}
// Types are limited here so that in the future these values can be used
// as part of Babel's caching logic.
type SimpleType = string | boolean | number | null | void;
export function assertSimpleType(value: mixed): SimpleType {
  if (
    value != null &&
    typeof value !== "string" &&
    typeof value !== "boolean" &&
    typeof value !== "number"
  ) {
    throw new Error(
      "Cache keys must be either string, boolean, number, null, or undefined.",
    );
  }
  return value;
}

// </from> /home/qfox/apps/babel/packages/babel-core/src/config/caching.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/transformation/file/merge-map.js

// @flow
import sourceMap from "source-map";
export default function mergeSourceMap(
  inputMap: SourceMap,
  map: SourceMap,
): SourceMap {
  const input = buildMappingData(inputMap);
  const output = buildMappingData(map);
  const mergedGenerator = new sourceMap.SourceMapGenerator();
  for (const { source } of input.sources) {
    if (typeof source.content === "string") {
      mergedGenerator.setSourceContent(source.path, source.content);
    }
  }
  if (output.sources.length === 1) {
    const defaultSource = output.sources[0];
    const insertedMappings = new Map();
    // Process each generated range in the input map, e.g. each range over the
    // code that Babel was originally given.
    eachInputGeneratedRange(input, (generated, original, source) => {
      // Then pick out each range over Babel's _output_ that corresponds with
      // the given range on the code given to Babel.
      eachOverlappingGeneratedOutputRange(defaultSource, generated, item => {
        // It's possible that multiple input ranges will overlap the same
        // generated range. Since sourcemap don't traditionally represent
        // generated locations with multiple original locations, we explicitly
        // skip generated locations once we've seen them the first time.
        const key = makeMappingKey(item);
        if (insertedMappings.has(key)) return;
        insertedMappings.set(key, item);
        mergedGenerator.addMapping({
          source: source.path,
          original: {
            line: original.line,
            column: original.columnStart,
          },
          generated: {
            line: item.line,
            column: item.columnStart,
          },
          name: original.name,
        });
      });
    });
    // Since mappings are manipulated using single locations, but are interpreted
    // as ranges, the insertions above may not actually have their ending
    // locations mapped yet. Here be go through each one and ensure that it has
    // a well-defined ending location, if one wasn't already created by the start
    // of a different range.
    for (const item of insertedMappings.values()) {
      if (item.columnEnd === Infinity) {
        continue;
      }
      const clearItem = {
        line: item.line,
        columnStart: item.columnEnd,
      };
      const key = makeMappingKey(clearItem);
      if (insertedMappings.has(key)) {
        continue;
      }
      // Insert mappings with no original position to terminate any mappings
      // that were found above, so that they don't expand beyond their correct
      // range.
      mergedGenerator.addMapping({
        generated: {
          line: clearItem.line,
          column: clearItem.columnStart,
        },
      });
    }
  }
  const result = mergedGenerator.toJSON();
  // addMapping expects a relative path, and setSourceContent expects an
  // absolute path. To avoid this whole confusion, we leave the root out
  // entirely, and add it at the end here.
  if (typeof input.sourceRoot === "string") {
    result.sourceRoot = input.sourceRoot;
  }
  return result;
}
function makeMappingKey(item: { line: number, columnStart: number }) {
  return `${item.line}/${item.columnStart}`;
}
function eachOverlappingGeneratedOutputRange(
  outputFile: ResolvedFileMappings,
  inputGeneratedRange: ResolvedGeneratedRange,
  callback: ResolvedGeneratedRange => mixed,
) {
  // Find the Babel-generated mappings that overlap with this range in the
  // input sourcemap. Generated locations within the input sourcemap
  // correspond with the original locations in the map Babel generates.
  const overlappingOriginal = filterApplicableOriginalRanges(
    outputFile,
    inputGeneratedRange,
  );
  for (const { generated } of overlappingOriginal) {
    for (const item of generated) {
      callback(item);
    }
  }
}
function filterApplicableOriginalRanges(
  { mappings }: ResolvedFileMappings,
  { line, columnStart, columnEnd }: ResolvedGeneratedRange,
): OriginalMappings {
  // The mapping array is sorted by original location, so we can
  // binary-search it for the overlapping ranges.
  return filterSortedArray(mappings, ({ original: outOriginal }) => {
    if (line > outOriginal.line) return -1;
    if (line < outOriginal.line) return 1;
    if (columnStart >= outOriginal.columnEnd) return -1;
    if (columnEnd <= outOriginal.columnStart) return 1;
    return 0;
  });
}
function eachInputGeneratedRange(
  map: ResolvedMappings,
  callback: (
    ResolvedGeneratedRange,
    ResolvedOriginalRange,
    ResolvedSource,
  ) => mixed,
) {
  for (const { source, mappings } of map.sources) {
    for (const { original, generated } of mappings) {
      for (const item of generated) {
        callback(item, original, source);
      }
    }
  }
}
type ResolvedMappings = {|
  file: ?string,
  sourceRoot: ?string,
  sources: Array<ResolvedFileMappings>,
|};
type ResolvedFileMappings = {|
  source: ResolvedSource,
  mappings: OriginalMappings,
|};
type OriginalMappings = Array<{|
  original: ResolvedOriginalRange,
  generated: Array<ResolvedGeneratedRange>,
|}>;
type ResolvedSource = {|
  path: string,
  content: string | null,
|};
type ResolvedOriginalRange = {|
  line: number,
  columnStart: number,
  columnEnd: number,
  name: string | null,
|};
type ResolvedGeneratedRange = {|
  line: number,
  columnStart: number,
  columnEnd: number,
|};
function buildMappingData(map: SourceMap): ResolvedMappings {
  const consumer = new sourceMap.SourceMapConsumer({
    ...map,
    // This is a bit hack. .addMapping expects source values to be relative,
    // but eachMapping returns mappings with absolute paths. To avoid that
    // incompatibility, we leave the sourceRoot out here and add it to the
    // final map at the end instead.
    sourceRoot: null,
  });
  const sources = new Map();
  const mappings = new Map();
  let last = null;
  consumer.computeColumnSpans();
  consumer.eachMapping(
    m => {
      if (m.originalLine === null) return;
      let source = sources.get(m.source);
      if (!source) {
        source = {
          path: m.source,
          content: consumer.sourceContentFor(m.source, true),
        };
        sources.set(m.source, source);
      }
      let sourceData = mappings.get(source);
      if (!sourceData) {
        sourceData = {
          source,
          mappings: [],
        };
        mappings.set(source, sourceData);
      }
      const obj = {
        line: m.originalLine,
        columnStart: m.originalColumn,
        columnEnd: Infinity,
        name: m.name,
      };
      if (
        last &&
        last.source === source &&
        last.mapping.line === m.originalLine
      ) {
        last.mapping.columnEnd = m.originalColumn;
      }
      last = {
        source,
        mapping: obj,
      };
      sourceData.mappings.push({
        original: obj,
        generated: consumer
          .allGeneratedPositionsFor({
            source: m.source,
            line: m.originalLine,
            column: m.originalColumn,
          })
          .map(item => ({
            line: item.line,
            columnStart: item.column,
            // source-map's lastColumn is inclusive, not exclusive, so we need
            // to add 1 to it.
            columnEnd: item.lastColumn + 1,
          })),
      });
    },
    null,
    sourceMap.SourceMapConsumer.ORIGINAL_ORDER,
  );
  return {
    file: map.file,
    sourceRoot: map.sourceRoot,
    sources: Array.from(mappings.values()),
  };
}
function findInsertionLocation<T>(
  array: Array<T>,
  callback: T => number,
): number {
  let left = 0;
  let right = array.length;
  while (left < right) {
    const mid = Math.floor((left + right) / 2);
    const item = array[mid];
    const result = callback(item);
    if (result === 0) {
      left = mid;
      break;
    }
    if (result >= 0) {
      right = mid;
    } else {
      left = mid + 1;
    }
  }
  // Ensure the value is the start of any set of matches.
  let i = left;
  if (i < array.length) {
    while (i >= 0 && callback(array[i]) >= 0) {
      i--;
    }
    return i + 1;
  }
  return i;
}
function filterSortedArray<T>(
  array: Array<T>,
  callback: T => number,
): Array<T> {
  const start = findInsertionLocation(array, callback);
  const results = [];
  for (let i = start; i < array.length && callback(array[i]) === 0; i++) {
    results.push(array[i]);
  }
  return results;
}

// </from> /home/qfox/apps/babel/packages/babel-core/src/transformation/file/merge-map.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/transformation/file/generate.js

// @flow
import convertSourceMap, { type SourceMap } from "convert-source-map";
import generate from "@babel/generator";
import mergeSourceMap from "./merge-map";
export default function generateCode(
  pluginPasses: PluginPasses,
  file: File,
): {
  outputCode: string,
  outputMap: SourceMap | null,
} {
  const { opts, ast, code, inputMap } = file;
  const results = [];
  for (const plugins of pluginPasses) {
    for (const plugin of plugins) {
      const { generatorOverride } = plugin;
      if (generatorOverride) {
        const result = generatorOverride(
          ast,
          opts.generatorOpts,
          code,
          generate,
        );
        if (result !== undefined) results.push(result);
      }
    }
  }
  let result;
  if (results.length === 0) {
    result = generate(ast, opts.generatorOpts, code);
  } else if (results.length === 1) {
    result = results[0];
    if (typeof result.then === "function") {
      throw new Error(
        `You appear to be using an async parser plugin, ` +
          `which your current version of Babel does not support. ` +
          `If you're using a published plugin, ` +
          `you may need to upgrade your @babel/core version.`,
      );
    }
  } else {
    throw new Error("More than one plugin attempted to override codegen.");
  }
  let { code: outputCode, map: outputMap } = result;
  if (outputMap && inputMap) {
    outputMap = mergeSourceMap(inputMap.toObject(), outputMap);
  }
  if (opts.sourceMaps === "inline" || opts.sourceMaps === "both") {
    outputCode += "\n" + convertSourceMap.fromObject(outputMap).toComment();
  }
  if (opts.sourceMaps === "inline") {
    outputMap = null;
  }
  return { outputCode, outputMap };
}

// </from> /home/qfox/apps/babel/packages/babel-core/src/transformation/file/generate.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/transformation/file/file.js

// @flow
import * as helpers from "@babel/helpers";
import { NodePath, Scope, type HubInterface } from "@babel/traverse";
import { codeFrameColumns } from "@babel/code-frame";
import traverse from "@babel/traverse";
import * as t from "@babel/types";
import semver from "semver";
const errorVisitor = {
  enter(path, state) {
    const loc = path.node.loc;
    if (loc) {
      state.loc = loc;
      path.stop();
    }
  },
};
export default class File {
  _map: Map<any, any> = new Map();
  opts: Object;
  declarations: Object = {};
  path: NodePath = null;
  ast: Object = {};
  scope: Scope;
  metadata: {} = {};
  code: string = "";
  inputMap: Object | null = null;
  hub: HubInterface = {
    // keep it for the usage in babel-core, ex: path.hub.file.opts.filename
    file: this,
    getCode: () => this.code,
    getScope: () => this.scope,
    addHelper: this.addHelper.bind(this),
    buildError: this.buildCodeFrameError.bind(this),
  };
  constructor(options: {}, { code, ast, inputMap }: NormalizedFile) {
    this.opts = options;
    this.code = code;
    this.ast = ast;
    this.inputMap = inputMap;
    this.path = NodePath.get({
      hub: this.hub,
      parentPath: null,
      parent: this.ast,
      container: this.ast,
      key: "program",
    }).setContext();
    this.scope = this.path.scope;
  }
  /**
   * Provide backward-compatible access to the interpreter directive handling
   * in Babel 6.x. If you are writing a plugin for Babel 7.x, it would be
   * best to use 'program.interpreter' directly.
   */
  get shebang(): string {
    const { interpreter } = this.path.node;
    return interpreter ? interpreter.value : "";
  }
  set shebang(value: string): void {
    if (value) {
      this.path.get("interpreter").replaceWith(t.interpreterDirective(value));
    } else {
      this.path.get("interpreter").remove();
    }
  }
  set(key: mixed, val: mixed) {
    if (key === "helpersNamespace") {
      throw new Error(
        "Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility." +
          "If you are using @babel/plugin-external-helpers you will need to use a newer " +
          "version than the one you currently have installed. " +
          "If you have your own implementation, you'll want to explore using 'helperGenerator' " +
          "alongside 'file.availableHelper()'.",
      );
    }
    this._map.set(key, val);
  }
  get(key: mixed): any {
    return this._map.get(key);
  }
  has(key: mixed): boolean {
    return this._map.has(key);
  }
  getModuleName(): ?string {
    const {
      filename,
      filenameRelative = filename,
      moduleId,
      moduleIds = !!moduleId,
      getModuleId,
      sourceRoot: sourceRootTmp,
      moduleRoot = sourceRootTmp,
      sourceRoot = moduleRoot,
    } = this.opts;
    if (!moduleIds) return null;
    // moduleId is n/a if a `getModuleId()` is provided
    if (moduleId != null && !getModuleId) {
      return moduleId;
    }
    let moduleName = moduleRoot != null ? moduleRoot + "/" : "";
    if (filenameRelative) {
      const sourceRootReplacer =
        sourceRoot != null ? new RegExp("^" + sourceRoot + "/?") : "";
      moduleName += filenameRelative
        // remove sourceRoot from filename
        .replace(sourceRootReplacer, "")
        // remove extension
        .replace(/\.(\w*?)$/, "");
    }
    // normalize path separators
    moduleName = moduleName.replace(/\\/g, "/");
    if (getModuleId) {
      // If return is falsy, assume they want us to use our generated default name
      return getModuleId(moduleName) || moduleName;
    } else {
      return moduleName;
    }
  }
  addImport() {
    throw new Error(
      "This API has been removed. If you're looking for this " +
        "functionality in Babel 7, you should import the " +
        "'@babel/helper-module-imports' module and use the functions exposed " +
        " from that module, such as 'addNamed' or 'addDefault'.",
    );
  }
  /**
   * Check if a given helper is available in @babel/core's helper list.
   *
   * This _also_ allows you to pass a Babel version specifically. If the
   * helper exists, but was not available for the full given range, it will be
   * considered unavailable.
   */
  availableHelper(name: string, versionRange: ?string): boolean {
    let minVersion;
    try {
      minVersion = helpers.minVersion(name);
    } catch (err) {
      if (err.code !== "BABEL_HELPER_UNKNOWN") throw err;
      return false;
    }
    if (typeof versionRange !== "string") return true;
    // semver.intersects() has some surprising behavior with comparing ranges
    // with preprelease versions. We add '^' to ensure that we are always
    // comparing ranges with ranges, which sidesteps this logic.
    // For example:
    //
    //   semver.intersects(`<7.0.1`, "7.0.0-beta.0") // false - surprising
    //   semver.intersects(`<7.0.1`, "^7.0.0-beta.0") // true - expected
    //
    // This is because the first falls back to
    //
    //   semver.satisfies("7.0.0-beta.0", `<7.0.1`) // false - surprising
    //
    // and this fails because a prerelease version can only satisfy a range
    // if it is a prerelease within the same major/minor/patch range.
    //
    // Note: If this is found to have issues, please also revist the logic in
    // transform-runtime's definitions.js file.
    if (semver.valid(versionRange)) versionRange = `^${versionRange}`;
    return (
      !semver.intersects(`<${minVersion}`, versionRange) &&
      !semver.intersects(`>=8.0.0`, versionRange)
    );
  }
  addHelper(name: string): Object {
    const declar = this.declarations[name];
    if (declar) return t.cloneNode(declar);
    const generator = this.get("helperGenerator");
    if (generator) {
      const res = generator(name);
      if (res) return res;
    }
    const uid = (this.declarations[name] = this.scope.generateUidIdentifier(
      name,
    ));
    const dependencies = {};
    for (const dep of helpers.getDependencies(name)) {
      dependencies[dep] = this.addHelper(dep);
    }
    const { nodes, globals } = helpers.get(
      name,
      dep => dependencies[dep],
      uid,
      Object.keys(this.scope.getAllBindings()),
    );
    globals.forEach(name => {
      if (this.path.scope.hasBinding(name, true /* noGlobals */)) {
        this.path.scope.rename(name);
      }
    });
    nodes.forEach(node => {
      node._compact = true;
    });
    this.path.unshiftContainer("body", nodes);
    // TODO: NodePath#unshiftContainer should automatically register new
    // bindings.
    this.path.get("body").forEach(path => {
      if (nodes.indexOf(path.node) === -1) return;
      if (path.isVariableDeclaration()) this.scope.registerDeclaration(path);
    });
    return uid;
  }
  addTemplateObject() {
    throw new Error(
      "This function has been moved into the template literal transform itself.",
    );
  }
  buildCodeFrameError(
    node: ?{
      loc?: { start: { line: number, column: number } },
      _loc?: { start: { line: number, column: number } },
    },
    msg: string,
    Error: typeof Error = SyntaxError,
  ): Error {
    let loc = node && (node.loc || node._loc);
    msg = `${this.opts.filename}: ${msg}`;
    if (!loc && node) {
      const state = {
        loc: null,
      };
      traverse(node, errorVisitor, this.scope, state);
      loc = state.loc;
      let txt =
        "This is an error on an internal node. Probably an internal error.";
      if (loc) txt += " Location has been estimated.";
      msg += ` (${txt})`;
    }
    if (loc) {
      const { highlightCode = true } = this.opts;
      msg +=
        "\n" +
        codeFrameColumns(
          this.code,
          {
            start: {
              line: loc.start.line,
              column: loc.start.column + 1,
            },
          },
          { highlightCode },
        );
    }
    return new Error(msg);
  }
}

// </from> /home/qfox/apps/babel/packages/babel-core/src/transformation/file/file.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/transformation/plugin-pass.js

// @flow
export default class PluginPass {
  _map: Map<mixed, mixed> = new Map();
  key: ?string;
  file: File;
  opts: Object;
  // The working directory that Babel's programmatic options are loaded
  // relative to.
  cwd: string;
  // The absolute path of the file being compiled.
  filename: string | void;
  constructor(file: File, key: ?string, options: ?Object) {
    this.key = key;
    this.file = file;
    this.opts = options || {};
    this.cwd = file.opts.cwd;
    this.filename = file.opts.filename;
  }
  set(key: mixed, val: mixed) {
    this._map.set(key, val);
  }
  get(key: mixed): any {
    return this._map.get(key);
  }
  availableHelper(name: string, versionRange: ?string) {
    return this.file.availableHelper(name, versionRange);
  }
  addHelper(name: string) {
    return this.file.addHelper(name);
  }
  addImport() {
    return this.file.addImport();
  }
  getModuleName(): ?string {
    return this.file.getModuleName();
  }
  buildCodeFrameError(
    node: ?{
      loc?: { start: { line: number, column: number } },
      _loc?: { start: { line: number, column: number } },
    },
    msg: string,
    Error?: typeof Error,
  ) {
    return this.file.buildCodeFrameError(node, msg, Error);
  }
}

// </from> /home/qfox/apps/babel/packages/babel-core/src/transformation/plugin-pass.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/transformation/index.js

// @flow
import traverse from "@babel/traverse";
import PluginPass from "./plugin-pass";
import loadBlockHoistPlugin from "./block-hoist-plugin";
import normalizeOptions from "./normalize-opts";
import normalizeFile from "./normalize-file";
import generateCode from "./file/generate";
export type FileResultCallback = {
  (Error, null): any,
  (null, FileResult | null): any,
};
export type FileResult = {
  metadata: {},
  options: {},
  ast: {} | null,
  code: string | null,
  map: SourceMap | null,
};
export function runAsync(
  config: ResolvedConfig,
  code: string,
  ast: ?(BabelNodeFile | BabelNodeProgram),
  callback: Function,
) {
  let result;
  try {
    result = runSync(config, code, ast);
  } catch (err) {
    return callback(err);
  }
  // We don't actually care about calling this synchronously here because it is
  // already running within a .nextTick handler from the transform calls above.
  return callback(null, result);
}
export function runSync(
  config: ResolvedConfig,
  code: string,
  ast: ?(BabelNodeFile | BabelNodeProgram),
): FileResult {
  const file = normalizeFile(
    config.passes,
    normalizeOptions(config),
    code,
    ast,
  );
  transformFile(file, config.passes);
  const opts = file.opts;
  const { outputCode, outputMap } =
    opts.code !== false ? generateCode(config.passes, file) : {};
  return {
    metadata: file.metadata,
    options: opts,
    ast: opts.ast === true ? file.ast : null,
    code: outputCode === undefined ? null : outputCode,
    map: outputMap === undefined ? null : outputMap,
    sourceType: file.ast.program.sourceType,
  };
}
function transformFile(file: File, pluginPasses: PluginPasses): void {
  for (const pluginPairs of pluginPasses) {
    const passPairs = [];
    const passes = [];
    const visitors = [];
    for (const plugin of pluginPairs.concat([loadBlockHoistPlugin()])) {
      const pass = new PluginPass(file, plugin.key, plugin.options);
      passPairs.push([plugin, pass]);
      passes.push(pass);
      visitors.push(plugin.visitor);
    }
    for (const [plugin, pass] of passPairs) {
      const fn = plugin.pre;
      if (fn) {
        const result = fn.call(pass, file);
        if (isThenable(result)) {
          throw new Error(
            `You appear to be using an plugin with an async .pre, ` +
              `which your current version of Babel does not support.` +
              `If you're using a published plugin, you may need to upgrade ` +
              `your @babel/core version.`,
          );
        }
      }
    }
    // merge all plugin visitors into a single visitor
    const visitor = traverse.visitors.merge(
      visitors,
      passes,
      file.opts.wrapPluginVisitorMethod,
    );
    traverse(file.ast, visitor, file.scope);
    for (const [plugin, pass] of passPairs) {
      const fn = plugin.post;
      if (fn) {
        const result = fn.call(pass, file);
        if (isThenable(result)) {
          throw new Error(
            `You appear to be using an plugin with an async .post, ` +
              `which your current version of Babel does not support.` +
              `If you're using a published plugin, you may need to upgrade ` +
              `your @babel/core version.`,
          );
        }
      }
    }
  }
}
function isThenable(val: mixed): boolean {
  return (
    !!val &&
    (typeof val === "object" || typeof val === "function") &&
    typeof val.then === "function"
  );
}

// </from> /home/qfox/apps/babel/packages/babel-core/src/transformation/index.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/transformation/block-hoist-plugin.js

// @flow
import sortBy from "lodash/sortBy";
import loadConfig, { type Plugin } from "../config";
let LOADED_PLUGIN: Plugin | void;
export default function loadBlockHoistPlugin(): Plugin {
  if (!LOADED_PLUGIN) {
    // Lazy-init the internal plugin to remove the init-time circular
    // dependency between plugins being passed @babel/core's export object,
    // which loads this file, and this 'loadConfig' loading plugins.
    const config = loadConfig({
      babelrc: false,
      configFile: false,
      plugins: [blockHoistPlugin],
    });
    LOADED_PLUGIN = config ? config.passes[0][0] : undefined;
    if (!LOADED_PLUGIN) throw new Error("Assertion failure");
  }
  return LOADED_PLUGIN;
}
const blockHoistPlugin = {
  /**
   * [Please add a description.]
   *
   * Priority:
   *
   *  - 0 We want this to be at the **very** bottom
   *  - 1 Default node position
   *  - 2 Priority over normal nodes
   *  - 3 We want this to be at the **very** top
   *  - 4 Reserved for the helpers used to implement module imports.
   */
  name: "internal.blockHoist",
  visitor: {
    Block: {
      exit({ node }) {
        let hasChange = false;
        for (let i = 0; i < node.body.length; i++) {
          const bodyNode = node.body[i];
          if (bodyNode && bodyNode._blockHoist != null) {
            hasChange = true;
            break;
          }
        }
        if (!hasChange) return;
        node.body = sortBy(node.body, function(bodyNode) {
          let priority = bodyNode && bodyNode._blockHoist;
          if (priority == null) priority = 1;
          if (priority === true) priority = 2;
          // Higher priorities should move toward the top.
          return -1 * priority;
        });
      },
    },
  },
};

// </from> /home/qfox/apps/babel/packages/babel-core/src/transformation/block-hoist-plugin.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/transformation/normalize-file.js

// @flow
import path from "path";
import buildDebug from "debug";
import cloneDeep from "lodash/cloneDeep";
import * as t from "@babel/types";
import convertSourceMap, { typeof Converter } from "convert-source-map";
import { parse } from "@babel/parser";
import { codeFrameColumns } from "@babel/code-frame";
import File from "./file/file";
import generateMissingPluginMessage from "./util/missing-plugin-helper";
const debug = buildDebug("babel:transform:file");
export type NormalizedFile = {
  code: string,
  ast: {},
  inputMap: Converter | null,
};
export default function normalizeFile(
  pluginPasses: PluginPasses,
  options: Object,
  code: string,
  ast: ?(BabelNodeFile | BabelNodeProgram),
): File {
  code = `${code || ""}`;
  let inputMap = null;
  if (options.inputSourceMap !== false) {
    // If an explicit object is passed in, it overrides the processing of
    // source maps that may be in the file itself.
    if (typeof options.inputSourceMap === "object") {
      inputMap = convertSourceMap.fromObject(options.inputSourceMap);
    }
    if (!inputMap) {
      try {
        inputMap = convertSourceMap.fromSource(code);
        if (inputMap) {
          code = convertSourceMap.removeComments(code);
        }
      } catch (err) {
        debug("discarding unknown inline input sourcemap", err);
        code = convertSourceMap.removeComments(code);
      }
    }
    if (!inputMap) {
      if (typeof options.filename === "string") {
        try {
          inputMap = convertSourceMap.fromMapFileSource(
            code,
            path.dirname(options.filename),
          );
          if (inputMap) {
            code = convertSourceMap.removeMapFileComments(code);
          }
        } catch (err) {
          debug("discarding unknown file input sourcemap", err);
          code = convertSourceMap.removeMapFileComments(code);
        }
      } else {
        debug("discarding un-loadable file input sourcemap");
        code = convertSourceMap.removeMapFileComments(code);
      }
    }
  }
  if (ast) {
    if (ast.type === "Program") {
      ast = t.file(ast, [], []);
    } else if (ast.type !== "File") {
      throw new Error("AST root must be a Program or File node");
    }
    ast = cloneDeep(ast);
  } else {
    // The parser's AST types aren't fully compatible with the types generated
    // by the logic in babel-types.
    // $FlowFixMe
    ast = parser(pluginPasses, options, code);
  }
  return new File(options, {
    code,
    ast,
    inputMap,
  });
}
function parser(
  pluginPasses: PluginPasses,
  { parserOpts, highlightCode = true, filename = "unknown" }: Object,
  code: string,
) {
  try {
    const results = [];
    for (const plugins of pluginPasses) {
      for (const plugin of plugins) {
        const { parserOverride } = plugin;
        if (parserOverride) {
          const ast = parserOverride(code, parserOpts, parse);
          if (ast !== undefined) results.push(ast);
        }
      }
    }
    if (results.length === 0) {
      return parse(code, parserOpts);
    } else if (results.length === 1) {
      if (typeof results[0].then === "function") {
        throw new Error(
          `You appear to be using an async codegen plugin, ` +
            `which your current version of Babel does not support. ` +
            `If you're using a published plugin, you may need to upgrade ` +
            `your @babel/core version.`,
        );
      }
      return results[0];
    }
    throw new Error("More than one plugin attempted to override parsing.");
  } catch (err) {
    if (err.code === "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED") {
      err.message +=
        "\nConsider renaming the file to '.mjs', or setting sourceType:module " +
        "or sourceType:unambiguous in your Babel config for this file.";
    }
    const { loc, missingPlugin } = err;
    if (loc) {
      const codeFrame = codeFrameColumns(
        code,
        {
          start: {
            line: loc.line,
            column: loc.column + 1,
          },
        },
        {
          highlightCode,
        },
      );
      if (missingPlugin) {
        err.message =
          `${filename}: ` +
          generateMissingPluginMessage(missingPlugin[0], loc, codeFrame);
      } else {
        err.message = `${filename}: ${err.message}\n\n` + codeFrame;
      }
      err.code = "BABEL_PARSE_ERROR";
    }
    throw err;
  }
}

// </from> /home/qfox/apps/babel/packages/babel-core/src/transformation/normalize-file.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/transformation/normalize-opts.js

// @flow
import path from "path";
export default function normalizeOptions(config: ResolvedConfig): {} {
  const {
    filename,
    cwd,
    filenameRelative = typeof filename === "string"
      ? path.relative(cwd, filename)
      : "unknown",
    sourceType = "module",
    inputSourceMap,
    sourceMaps = !!inputSourceMap,
    moduleRoot,
    sourceRoot = moduleRoot,
    sourceFileName = path.basename(filenameRelative),
    comments = true,
    compact = "auto",
  } = config.options;
  const opts = config.options;
  const options = {
    ...opts,
    parserOpts: {
      sourceType:
        path.extname(filenameRelative) === ".mjs" ? "module" : sourceType,
      sourceFileName: filename,
      plugins: [],
      ...opts.parserOpts,
    },
    generatorOpts: {
      // General generator flags.
      filename,
      auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
      auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
      retainLines: opts.retainLines,
      comments,
      shouldPrintComment: opts.shouldPrintComment,
      compact,
      minified: opts.minified,
      // Source-map generation flags.
      sourceMaps,
      sourceRoot,
      sourceFileName,
      ...opts.generatorOpts,
    },
  };
  for (const plugins of config.passes) {
    for (const plugin of plugins) {
      if (plugin.manipulateOptions) {
        plugin.manipulateOptions(options, options.parserOpts);
      }
    }
  }
  return options;
}

// </from> /home/qfox/apps/babel/packages/babel-core/src/transformation/normalize-opts.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/transformation/util/missing-plugin-helper.js

// @flow
const pluginNameMap = {
  asyncGenerators: {
    syntax: {
      name: "@babel/plugin-syntax-async-generators",
      url: "https://git.io/vb4SY",
    },
    transform: {
      name: "@babel/plugin-proposal-async-generator-functions",
      url: "https://git.io/vb4yp",
    },
  },
  classProperties: {
    syntax: {
      name: "@babel/plugin-syntax-class-properties",
      url: "https://git.io/vb4yQ",
    },
    transform: {
      name: "@babel/plugin-proposal-class-properties",
      url: "https://git.io/vb4SL",
    },
  },
  decorators: {
    syntax: {
      name: "@babel/plugin-syntax-decorators",
      url: "https://git.io/vb4y9",
    },
    transform: {
      name: "@babel/plugin-proposal-decorators",
      url: "https://git.io/vb4ST",
    },
  },
  doExpressions: {
    syntax: {
      name: "@babel/plugin-syntax-do-expressions",
      url: "https://git.io/vb4yh",
    },
    transform: {
      name: "@babel/plugin-proposal-do-expressions",
      url: "https://git.io/vb4S3",
    },
  },
  dynamicImport: {
    syntax: {
      name: "@babel/plugin-syntax-dynamic-import",
      url: "https://git.io/vb4Sv",
    },
  },
  exportDefaultFrom: {
    syntax: {
      name: "@babel/plugin-syntax-export-default-from",
      url: "https://git.io/vb4SO",
    },
    transform: {
      name: "@babel/plugin-proposal-export-default-from",
      url: "https://git.io/vb4yH",
    },
  },
  exportNamespaceFrom: {
    syntax: {
      name: "@babel/plugin-syntax-export-namespace-from",
      url: "https://git.io/vb4Sf",
    },
    transform: {
      name: "@babel/plugin-proposal-export-namespace-from",
      url: "https://git.io/vb4SG",
    },
  },
  flow: {
    syntax: {
      name: "@babel/plugin-syntax-flow",
      url: "https://git.io/vb4yb",
    },
    transform: {
      name: "@babel/plugin-transform-flow-strip-types",
      url: "https://git.io/vb49g",
    },
  },
  functionBind: {
    syntax: {
      name: "@babel/plugin-syntax-function-bind",
      url: "https://git.io/vb4y7",
    },
    transform: {
      name: "@babel/plugin-proposal-function-bind",
      url: "https://git.io/vb4St",
    },
  },
  functionSent: {
    syntax: {
      name: "@babel/plugin-syntax-function-sent",
      url: "https://git.io/vb4yN",
    },
    transform: {
      name: "@babel/plugin-proposal-function-sent",
      url: "https://git.io/vb4SZ",
    },
  },
  importMeta: {
    syntax: {
      name: "@babel/plugin-syntax-import-meta",
      url: "https://git.io/vbKK6",
    },
  },
  jsx: {
    syntax: {
      name: "@babel/plugin-syntax-jsx",
      url: "https://git.io/vb4yA",
    },
    transform: {
      name: "@babel/plugin-transform-react-jsx",
      url: "https://git.io/vb4yd",
    },
  },
  logicalAssignment: {
    syntax: {
      name: "@babel/plugin-syntax-logical-assignment-operators",
      url: "https://git.io/vAlBp",
    },
    transform: {
      name: "@babel/plugin-proposal-logical-assignment-operators",
      url: "https://git.io/vAlRe",
    },
  },
  nullishCoalescingOperator: {
    syntax: {
      name: "@babel/plugin-syntax-nullish-coalescing-operator",
      url: "https://git.io/vb4yx",
    },
    transform: {
      name: "@babel/plugin-proposal-nullish-coalescing-operator",
      url: "https://git.io/vb4Se",
    },
  },
  numericSeparator: {
    syntax: {
      name: "@babel/plugin-syntax-numeric-separator",
      url: "https://git.io/vb4Sq",
    },
    transform: {
      name: "@babel/plugin-proposal-numeric-separator",
      url: "https://git.io/vb4yS",
    },
  },
  objectRestSpread: {
    syntax: {
      name: "@babel/plugin-syntax-object-rest-spread",
      url: "https://git.io/vb4y5",
    },
    transform: {
      name: "@babel/plugin-proposal-object-rest-spread",
      url: "https://git.io/vb4Ss",
    },
  },
  optionalCatchBinding: {
    syntax: {
      name: "@babel/plugin-syntax-optional-catch-binding",
      url: "https://git.io/vb4Sn",
    },
    transform: {
      name: "@babel/plugin-proposal-optional-catch-binding",
      url: "https://git.io/vb4SI",
    },
  },
  optionalChaining: {
    syntax: {
      name: "@babel/plugin-syntax-optional-chaining",
      url: "https://git.io/vb4Sc",
    },
    transform: {
      name: "@babel/plugin-proposal-optional-chaining",
      url: "https://git.io/vb4Sk",
    },
  },
  pipelineOperator: {
    syntax: {
      name: "@babel/plugin-syntax-pipeline-operator",
      url: "https://git.io/vb4yj",
    },
    transform: {
      name: "@babel/plugin-proposal-pipeline-operator",
      url: "https://git.io/vb4SU",
    },
  },
  throwExpressions: {
    syntax: {
      name: "@babel/plugin-syntax-throw-expressions",
      url: "https://git.io/vb4SJ",
    },
    transform: {
      name: "@babel/plugin-proposal-throw-expressions",
      url: "https://git.io/vb4yF",
    },
  },
  typescript: {
    syntax: {
      name: "@babel/plugin-syntax-typescript",
      url: "https://git.io/vb4SC",
    },
    transform: {
      name: "@babel/plugin-transform-typescript",
      url: "https://git.io/vb4Sm",
    },
  },
};
const getNameURLCombination = ({ name, url }) => `${name} (${url})`;
/*
Returns a string of the format:
Support for the experimental syntax [@babel/parser plugin name] isn't currently enabled ([loc]):
[code frame]
Add [npm package name] ([url]) to the 'plugins' section of your Babel config
to enable [parsing|transformation].
*/
export default function generateMissingPluginMessage(
  missingPluginName: string,
  loc: { line: number, column: number },
  codeFrame: string,
): string {
  let helpMessage =
    `Support for the experimental syntax '${missingPluginName}' isn't currently enabled ` +
    `(${loc.line}:${loc.column + 1}):\n\n` +
    codeFrame;
  const pluginInfo = pluginNameMap[missingPluginName];
  if (pluginInfo) {
    const { syntax: syntaxPlugin, transform: transformPlugin } = pluginInfo;
    if (syntaxPlugin) {
      if (transformPlugin) {
        const transformPluginInfo = getNameURLCombination(transformPlugin);
        helpMessage +=
          `\n\nAdd ${transformPluginInfo} to the 'plugins' section of your Babel config ` +
          `to enable transformation.`;
      } else {
        const syntaxPluginInfo = getNameURLCombination(syntaxPlugin);
        helpMessage +=
          `\n\nAdd ${syntaxPluginInfo} to the 'plugins' section of your Babel config ` +
          `to enable parsing.`;
      }
    }
  }
  return helpMessage;
}

// </from> /home/qfox/apps/babel/packages/babel-core/src/transformation/util/missing-plugin-helper.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/transform-file.js

// @flow
import fs from "fs";
import loadConfig, { type InputOptions } from "./config";
import {
  runSync,
  runAsync,
  type FileResult,
  type FileResultCallback,
} from "./transformation";
type TransformFile = {
  (filename: string, callback: FileResultCallback): void,
  (filename: string, opts: ?InputOptions, callback: FileResultCallback): void,
};
export const transformFile: TransformFile = (function transformFile(
  filename,
  opts,
  callback,
) {
  let options;
  if (typeof opts === "function") {
    callback = opts;
    opts = undefined;
  }
  if (opts == null) {
    options = { filename };
  } else if (opts && typeof opts === "object") {
    options = {
      ...opts,
      filename,
    };
  }
  process.nextTick(() => {
    let cfg;
    try {
      cfg = loadConfig(options);
      if (cfg === null) return callback(null, null);
    } catch (err) {
      return callback(err);
    }
    // Reassignment to keep Flow happy.
    const config = cfg;
    fs.readFile(filename, "utf8", function(err, code: string) {
      if (err) return callback(err, null);
      runAsync(config, code, null, callback);
    });
  });
}: Function);
export function transformFileSync(
  filename: string,
  opts: ?InputOptions,
): FileResult | null {
  let options;
  if (opts == null) {
    options = { filename };
  } else if (opts && typeof opts === "object") {
    options = {
      ...opts,
      filename,
    };
  }
  const config = loadConfig(options);
  if (config === null) return null;
  return runSync(config, fs.readFileSync(filename, "utf8"));
}
export function transformFileAsync(
  filename: string,
  opts: ?InputOptions,
): Promise<FileResult | null> {
  return new Promise((res, rej) => {
    transformFile(filename, opts, (err, result) => {
      if (err == null) res(result);
      else rej(err);
    });
  });
}

// </from> /home/qfox/apps/babel/packages/babel-core/src/transform-file.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/tools/build-external-helpers.js

import * as helpers from "@babel/helpers";
import generator from "@babel/generator";
import template from "@babel/template";
import * as t from "@babel/types";
// Wrapped to avoid wasting time parsing this when almost no-one uses
// build-external-helpers.
const buildUmdWrapper = replacements =>
  template`
    (function (root, factory) {
      if (typeof define === "function" && define.amd) {
        define(AMD_ARGUMENTS, factory);
      } else if (typeof exports === "object") {
        factory(COMMON_ARGUMENTS);
      } else {
        factory(BROWSER_ARGUMENTS);
      }
    })(UMD_ROOT, function (FACTORY_PARAMETERS) {
      FACTORY_BODY
    });
  `(replacements);
function buildGlobal(whitelist) {
  const namespace = t.identifier("babelHelpers");
  const body = [];
  const container = t.functionExpression(
    null,
    [t.identifier("global")],
    t.blockStatement(body),
  );
  const tree = t.program([
    t.expressionStatement(
      t.callExpression(container, [
        // typeof global === "undefined" ? self : global
        t.conditionalExpression(
          t.binaryExpression(
            "===",
            t.unaryExpression("typeof", t.identifier("global")),
            t.stringLiteral("undefined"),
          ),
          t.identifier("self"),
          t.identifier("global"),
        ),
      ]),
    ),
  ]);
  body.push(
    t.variableDeclaration("var", [
      t.variableDeclarator(
        namespace,
        t.assignmentExpression(
          "=",
          t.memberExpression(t.identifier("global"), namespace),
          t.objectExpression([]),
        ),
      ),
    ]),
  );
  buildHelpers(body, namespace, whitelist);
  return tree;
}
function buildModule(whitelist) {
  const body = [];
  const refs = buildHelpers(body, null, whitelist);
  body.unshift(
    t.exportNamedDeclaration(
      null,
      Object.keys(refs).map(name => {
        return t.exportSpecifier(t.cloneNode(refs[name]), t.identifier(name));
      }),
    ),
  );
  return t.program(body, [], "module");
}
function buildUmd(whitelist) {
  const namespace = t.identifier("babelHelpers");
  const body = [];
  body.push(
    t.variableDeclaration("var", [
      t.variableDeclarator(namespace, t.identifier("global")),
    ]),
  );
  buildHelpers(body, namespace, whitelist);
  return t.program([
    buildUmdWrapper({
      FACTORY_PARAMETERS: t.identifier("global"),
      BROWSER_ARGUMENTS: t.assignmentExpression(
        "=",
        t.memberExpression(t.identifier("root"), namespace),
        t.objectExpression([]),
      ),
      COMMON_ARGUMENTS: t.identifier("exports"),
      AMD_ARGUMENTS: t.arrayExpression([t.stringLiteral("exports")]),
      FACTORY_BODY: body,
      UMD_ROOT: t.identifier("this"),
    }),
  ]);
}
function buildVar(whitelist) {
  const namespace = t.identifier("babelHelpers");
  const body = [];
  body.push(
    t.variableDeclaration("var", [
      t.variableDeclarator(namespace, t.objectExpression([])),
    ]),
  );
  const tree = t.program(body);
  buildHelpers(body, namespace, whitelist);
  body.push(t.expressionStatement(namespace));
  return tree;
}
function buildHelpers(body, namespace, whitelist) {
  const getHelperReference = name => {
    return namespace
      ? t.memberExpression(namespace, t.identifier(name))
      : t.identifier(`_${name}`);
  };
  const refs = {};
  helpers.list.forEach(function(name) {
    if (whitelist && whitelist.indexOf(name) < 0) return;
    const ref = (refs[name] = getHelperReference(name));
    const { nodes } = helpers.get(name, getHelperReference, ref);
    body.push(...nodes);
  });
  return refs;
}
export default function(
  whitelist?: Array<string>,
  outputType: "global" | "module" | "umd" | "var" = "global",
) {
  let tree;
  const build = {
    global: buildGlobal,
    module: buildModule,
    umd: buildUmd,
    var: buildVar,
  }[outputType];
  if (build) {
    tree = build(whitelist);
  } else {
    throw new Error(`Unsupported output type ${outputType}`);
  }
  return generator(tree).code;
}

// </from> /home/qfox/apps/babel/packages/babel-core/src/tools/build-external-helpers.js

// <from> /home/qfox/apps/babel/packages/babel-core/src/transform.js

// @flow
import loadConfig, { type InputOptions } from "./config";
import {
  runSync,
  runAsync,
  type FileResult,
  type FileResultCallback,
} from "./transformation";
type Transform = {
  (code: string, callback: FileResultCallback): void,
  (code: string, opts: ?InputOptions, callback: FileResultCallback): void,
  // Here for backward-compatibility. Ideally use ".transformSync" if you want
  // a synchronous API.
  (code: string, opts: ?InputOptions): FileResult | null,
};
export const transform: Transform = (function transform(code, opts, callback) {
  if (typeof opts === "function") {
    callback = opts;
    opts = undefined;
  }
  // For backward-compat with Babel 6, we allow sync transformation when
  // no callback is given. Will be dropped in some future Babel major version.
  if (callback === undefined) return transformSync(code, opts);
  // Reassign to keep Flowtype happy.
  const cb = callback;
  // Just delaying the transform one tick for now to simulate async behavior
  // but more async logic may land here eventually.
  process.nextTick(() => {
    let cfg;
    try {
      cfg = loadConfig(opts);
      if (cfg === null) return cb(null, null);
    } catch (err) {
      return cb(err);
    }
    runAsync(cfg, code, null, cb);
  });
}: Function);
export function transformSync(
  code: string,
  opts: ?InputOptions,
): FileResult | null {
  const config = loadConfig(opts);
  if (config === null) return null;
  return runSync(config, code);
}
export function transformAsync(
  code: string,
  opts: ?InputOptions,
): Promise<FileResult | null> {
  return new Promise((res, rej) => {
    transform(code, opts, (err, result) => {
      if (err == null) res(result);
      else rej(err);
    });
  });
}

// </from> /home/qfox/apps/babel/packages/babel-core/src/transform.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-object-super/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import ReplaceSupers from "@babel/helper-replace-supers";
import { types as t } from "@babel/core";
function replacePropertySuper(path, getObjectRef, file) {
  const replaceSupers = new ReplaceSupers({
    getObjectRef: getObjectRef,
    methodPath: path,
    file: file,
  });
  replaceSupers.replace();
}
export default declare(api => {
  api.assertVersion(7);
  return {
    visitor: {
      ObjectExpression(path, state) {
        let objectRef;
        const getObjectRef = () =>
          (objectRef = objectRef || path.scope.generateUidIdentifier("obj"));
        path.get("properties").forEach(propPath => {
          if (!propPath.isMethod()) return;
          replacePropertySuper(propPath, getObjectRef, state);
        });
        if (objectRef) {
          path.scope.push({ id: t.cloneNode(objectRef) });
          path.replaceWith(
            t.assignmentExpression("=", t.cloneNode(objectRef), path.node),
          );
        }
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-object-super/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-proposal-numeric-separator/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import syntaxNumericSeparator from "@babel/plugin-syntax-numeric-separator";
import { types as t } from "@babel/core";
export default declare(api => {
  api.assertVersion(7);
  function replaceNumberArg({ node }) {
    if (node.callee.name !== "Number") {
      return;
    }
    const arg = node.arguments[0];
    if (!t.isStringLiteral(arg)) {
      return;
    }
    arg.value = arg.value.replace(/_/g, "");
  }
  return {
    inherits: syntaxNumericSeparator,
    visitor: {
      CallExpression: replaceNumberArg,
      NewExpression: replaceNumberArg,
      NumericLiteral({ node }) {
        const { extra } = node;
        if (extra && /_/.test(extra.raw)) {
          extra.raw = extra.raw.replace(/_/g, "");
        }
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-proposal-numeric-separator/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-proto-to-assign/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import pull from "lodash/pull";
import { types as t } from "@babel/core";
export default declare(api => {
  api.assertVersion(7);
  function isProtoKey(node) {
    return t.isLiteral(t.toComputedKey(node, node.key), { value: "__proto__" });
  }
  function isProtoAssignmentExpression(node) {
    const left = node.left;
    return (
      t.isMemberExpression(left) &&
      t.isLiteral(t.toComputedKey(left, left.property), { value: "__proto__" })
    );
  }
  function buildDefaultsCallExpression(expr, ref, file) {
    return t.expressionStatement(
      t.callExpression(file.addHelper("defaults"), [ref, expr.right]),
    );
  }
  return {
    visitor: {
      AssignmentExpression(path, file) {
        if (!isProtoAssignmentExpression(path.node)) return;
        const nodes = [];
        const left = path.node.left.object;
        const temp = path.scope.maybeGenerateMemoised(left);
        if (temp) {
          nodes.push(
            t.expressionStatement(t.assignmentExpression("=", temp, left)),
          );
        }
        nodes.push(
          buildDefaultsCallExpression(
            path.node,
            t.cloneNode(temp || left),
            file,
          ),
        );
        if (temp) nodes.push(t.cloneNode(temp));
        path.replaceWithMultiple(nodes);
      },
      ExpressionStatement(path, file) {
        const expr = path.node.expression;
        if (!t.isAssignmentExpression(expr, { operator: "=" })) return;
        if (isProtoAssignmentExpression(expr)) {
          path.replaceWith(
            buildDefaultsCallExpression(expr, expr.left.object, file),
          );
        }
      },
      ObjectExpression(path, file) {
        let proto;
        const { node } = path;
        for (const prop of (node.properties: Array)) {
          if (isProtoKey(prop)) {
            proto = prop.value;
            pull(node.properties, prop);
          }
        }
        if (proto) {
          const args = [t.objectExpression([]), proto];
          if (node.properties.length) args.push(node);
          path.replaceWith(t.callExpression(file.addHelper("extends"), args));
        }
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-proto-to-assign/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-syntax-bigint/src/index.js

import { declare } from "@babel/helper-plugin-utils";
export default declare(api => {
  api.assertVersion(7);
  return {
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("bigInt");
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-syntax-bigint/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-highlight/src/index.js

import jsTokens, { matchToToken } from "js-tokens";
import esutils from "esutils";
import Chalk from "chalk";
/**
 * Chalk styles for token types.
 */
function getDefs(chalk) {
  return {
    keyword: chalk.cyan,
    capitalized: chalk.yellow,
    jsx_tag: chalk.yellow,
    punctuator: chalk.yellow,
    // bracket:  intentionally omitted.
    number: chalk.magenta,
    string: chalk.green,
    regex: chalk.magenta,
    comment: chalk.grey,
    invalid: chalk.white.bgRed.bold,
  };
}
/**
 * RegExp to test for newlines in terminal.
 */
const NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
/**
 * RegExp to test for what seems to be a JSX tag name.
 */
const JSX_TAG = /^[a-z][\w-]*$/i;
/**
 * RegExp to test for the three types of brackets.
 */
const BRACKET = /^[()[\]{}]$/;
/**
 * Get the type of token, specifying punctuator type.
 */
function getTokenType(match) {
  const [offset, text] = match.slice(-2);
  const token = matchToToken(match);
  if (token.type === "name") {
    if (esutils.keyword.isReservedWordES6(token.value)) {
      return "keyword";
    }
    if (
      JSX_TAG.test(token.value) &&
      (text[offset - 1] === "<" || text.substr(offset - 2, 2) == "</")
    ) {
      return "jsx_tag";
    }
    if (token.value[0] !== token.value[0].toLowerCase()) {
      return "capitalized";
    }
  }
  if (token.type === "punctuator" && BRACKET.test(token.value)) {
    return "bracket";
  }
  if (
    token.type === "invalid" &&
    (token.value === "@" || token.value === "#")
  ) {
    return "punctuator";
  }
  return token.type;
}
/**
 * Highlight `text` using the token definitions in `defs`.
 */
function highlightTokens(defs: Object, text: string) {
  return text.replace(jsTokens, function(...args) {
    const type = getTokenType(args);
    const colorize = defs[type];
    if (colorize) {
      return args[0]
        .split(NEWLINE)
        .map(str => colorize(str))
        .join("\n");
    } else {
      return args[0];
    }
  });
}
type Options = {
  forceColor?: boolean,
};
/**
 * Whether the code should be highlighted given the passed options.
 */
export function shouldHighlight(options: Options): boolean {
  return Chalk.supportsColor || options.forceColor;
}
/**
 * The Chalk instance that should be used given the passed options.
 */
export function getChalk(options: Options) {
  let chalk = Chalk;
  if (options.forceColor) {
    chalk = new Chalk.constructor({ enabled: true, level: 1 });
  }
  return chalk;
}
/**
 * Highlight `code`.
 */
export default function highlight(code: string, options: Options = {}): string {
  if (shouldHighlight(options)) {
    const chalk = getChalk(options);
    const defs = getDefs(chalk);
    return highlightTokens(defs, code);
  } else {
    return code;
  }
}

// </from> /home/qfox/apps/babel/packages/babel-highlight/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-member-expression-literals/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import { types as t } from "@babel/core";
export default declare(api => {
  api.assertVersion(7);
  return {
    visitor: {
      MemberExpression: {
        exit({ node }) {
          const prop = node.property;
          if (
            !node.computed &&
            t.isIdentifier(prop) &&
            !t.isValidES3Identifier(prop.name)
          ) {
            // foo.default -> foo["default"]
            node.property = t.stringLiteral(prop.name);
            node.computed = true;
          }
        },
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-member-expression-literals/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-generator/src/buffer.js

import trimRight from "trim-right";
const SPACES_RE = /^[ \t]+$/;
/**
 * The Buffer class exists to manage the queue of tokens being pushed onto the output string
 * in such a way that the final string buffer is treated as write-only until the final .get()
 * call. This allows V8 to optimize the output efficiently by not requiring it to store the
 * string in contiguous memory.
 */
export default class Buffer {
  constructor(map: ?SourceMap) {
    this._map = map;
  }
  _map: SourceMap = null;
  _buf: Array = [];
  _last: string = "";
  _queue: Array = [];
  _position: Object = {
    line: 1,
    column: 0,
  };
  _sourcePosition: Object = {
    identifierName: null,
    line: null,
    column: null,
    filename: null,
  };
  _disallowedPop: Object | null = null;
  /**
   * Get the final string output from the buffer, along with the sourcemap if one exists.
   */
  get(): Object {
    this._flush();
    const map = this._map;
    const result = {
      // Whatever trim is used here should not execute a regex against the
      // source string since it may be arbitrarily large after all transformations
      code: trimRight(this._buf.join("")),
      map: null,
      rawMappings: map && map.getRawMappings(),
    };
    if (map) {
      // The `.map` property is lazy to allow callers to use the raw mappings
      // without any overhead
      Object.defineProperty(result, "map", {
        configurable: true,
        enumerable: true,
        get() {
          return (this.map = map.get());
        },
        set(value) {
          Object.defineProperty(this, "map", { value, writable: true });
        },
      });
    }
    return result;
  }
  /**
   * Add a string to the buffer that cannot be reverted.
   */
  append(str: string): void {
    this._flush();
    const {
      line,
      column,
      filename,
      identifierName,
      force,
    } = this._sourcePosition;
    this._append(str, line, column, identifierName, filename, force);
  }
  /**
   * Add a string to the buffer than can be reverted.
   */
  queue(str: string): void {
    // Drop trailing spaces when a newline is inserted.
    if (str === "\n") {
      while (this._queue.length > 0 && SPACES_RE.test(this._queue[0][0])) {
        this._queue.shift();
      }
    }
    const {
      line,
      column,
      filename,
      identifierName,
      force,
    } = this._sourcePosition;
    this._queue.unshift([str, line, column, identifierName, filename, force]);
  }
  _flush(): void {
    let item;
    while ((item = this._queue.pop())) this._append(...item);
  }
  _append(
    str: string,
    line: number,
    column: number,
    identifierName: ?string,
    filename: ?string,
    force?: boolean,
  ): void {
    // If there the line is ending, adding a new mapping marker is redundant
    if (this._map && str[0] !== "\n") {
      this._map.mark(
        this._position.line,
        this._position.column,
        line,
        column,
        identifierName,
        filename,
        force,
      );
    }
    this._buf.push(str);
    this._last = str[str.length - 1];
    for (let i = 0; i < str.length; i++) {
      if (str[i] === "\n") {
        this._position.line++;
        this._position.column = 0;
      } else {
        this._position.column++;
      }
    }
  }
  removeTrailingNewline(): void {
    if (this._queue.length > 0 && this._queue[0][0] === "\n") {
      this._queue.shift();
    }
  }
  removeLastSemicolon(): void {
    if (this._queue.length > 0 && this._queue[0][0] === ";") {
      this._queue.shift();
    }
  }
  endsWith(suffix: string): boolean {
    // Fast path to avoid iterating over this._queue.
    if (suffix.length === 1) {
      let last;
      if (this._queue.length > 0) {
        const str = this._queue[0][0];
        last = str[str.length - 1];
      } else {
        last = this._last;
      }
      return last === suffix;
    }
    const end =
      this._last + this._queue.reduce((acc, item) => item[0] + acc, "");
    if (suffix.length <= end.length) {
      return end.slice(-suffix.length) === suffix;
    }
    // We assume that everything being matched is at most a single token plus some whitespace,
    // which everything currently is, but otherwise we'd have to expand _last or check _buf.
    return false;
  }
  hasContent(): boolean {
    return this._queue.length > 0 || !!this._last;
  }
  /**
   * Certain sourcemap usecases expect mappings to be more accurate than
   * Babel's generic sourcemap handling allows. For now, we special-case
   * identifiers to allow for the primary cases to work.
   * The goal of this line is to ensure that the map output from Babel will
   * have an exact range on identifiers in the output code. Without this
   * line, Babel would potentially include some number of trailing tokens
   * that are printed after the identifier, but before another location has
   * been assigned.
   * This allows tooling like Rollup and Webpack to more accurately perform
   * their own transformations. Most importantly, this allows the import/export
   * transformations performed by those tools to loose less information when
   * applying their own transformations on top of the code and map results
   * generated by Babel itself.
   *
   * The primary example of this is the snippet:
   *
   *   import mod from "mod";
   *   mod();
   *
   * With this line, there will be one mapping range over "mod" and another
   * over "();", where previously it would have been a single mapping.
   */
  exactSource(loc: Object, cb: () => void) {
    // In cases where parent expressions start at the same locations as the
    // identifier itself, the current active location could already be the
    // start of this range. We use 'force' here to explicitly start a new
    // mapping range for this new token.
    this.source("start", loc, true /* force */);
    cb();
    // In cases where tokens are printed after this item, we want to
    // ensure that they get the location of the _end_ of the identifier.
    // To accomplish this, we assign the location and explicitly disable
    // the standard Buffer withSource previous-position "reactivation"
    // logic. This means that if another item calls '.source()' to set
    // the location after the identifier, it is fine, but the position won't
    // be automatically replaced with the previous value.
    this.source("end", loc);
    this._disallowPop("start", loc);
  }
  /**
   * Sets a given position as the current source location so generated code after this call
   * will be given this position in the sourcemap.
   */
  source(prop: string, loc: Location, force?: boolean): void {
    if (prop && !loc) return;
    // Since this is called extremly often, we re-use the same _sourcePosition
    // object for the whole lifetime of the buffer.
    this._normalizePosition(prop, loc, this._sourcePosition, force);
  }
  /**
   * Call a callback with a specific source location and restore on completion.
   */
  withSource(prop: string, loc: Location, cb: () => void): void {
    if (!this._map) return cb();
    // Use the call stack to manage a stack of "source location" data because
    // the _sourcePosition object is mutated over the course of code generation,
    // and constantly copying it would be slower.
    const originalLine = this._sourcePosition.line;
    const originalColumn = this._sourcePosition.column;
    const originalFilename = this._sourcePosition.filename;
    const originalIdentifierName = this._sourcePosition.identifierName;
    this.source(prop, loc);
    cb();
    if (
      // If the current active position is forced, we only want to reactivate
      // the old position if it is different from the newest position.
      (!this._sourcePosition.force ||
        this._sourcePosition.line !== originalLine ||
        this._sourcePosition.column !== originalColumn ||
        this._sourcePosition.filename !== originalFilename) &&
      // Verify if reactivating this specific position has been disallowed.
      (!this._disallowedPop ||
        this._disallowedPop.line !== originalLine ||
        this._disallowedPop.column !== originalColumn ||
        this._disallowedPop.filename !== originalFilename)
    ) {
      this._sourcePosition.line = originalLine;
      this._sourcePosition.column = originalColumn;
      this._sourcePosition.filename = originalFilename;
      this._sourcePosition.identifierName = originalIdentifierName;
      this._sourcePosition.force = false;
      this._disallowedPop = null;
    }
  }
  /**
   * Allow printers to disable the default location-reset behavior of the
   * sourcemap output, so that certain printers can be sure that the
   * "end" location that they set is actually treated as the end position.
   */
  _disallowPop(prop: string, loc: Location) {
    if (prop && !loc) return;
    this._disallowedPop = this._normalizePosition(prop, loc);
  }
  _normalizePosition(
    prop: string,
    loc: Object,
    targetObj: Object,
    force?: boolean,
  ) {
    const pos = loc ? loc[prop] : null;
    if (targetObj === undefined) {
      // Initialize with fields so that the object doesn't change shape.
      targetObj = {
        identifierName: null,
        line: null,
        column: null,
        filename: null,
        force: false,
      };
    }
    const origLine = targetObj.line;
    const origColumn = targetObj.column;
    const origFilename = targetObj.filename;
    targetObj.identifierName =
      (prop === "start" && loc && loc.identifierName) || null;
    targetObj.line = pos ? pos.line : null;
    targetObj.column = pos ? pos.column : null;
    targetObj.filename = (loc && loc.filename) || null;
    // We want to skip reassigning `force` if we're re-setting the same position.
    if (
      force ||
      targetObj.line !== origLine ||
      targetObj.column !== origColumn ||
      targetObj.filename !== origFilename
    ) {
      targetObj.force = force;
    }
    return targetObj;
  }
  getCurrentColumn(): number {
    const extra = this._queue.reduce((acc, item) => item[0] + acc, "");
    const lastIndex = extra.lastIndexOf("\n");
    return lastIndex === -1
      ? this._position.column + extra.length
      : extra.length - 1 - lastIndex;
  }
  getCurrentLine(): number {
    const extra = this._queue.reduce((acc, item) => item[0] + acc, "");
    let count = 0;
    for (let i = 0; i < extra.length; i++) {
      if (extra[i] === "\n") count++;
    }
    return this._position.line + count;
  }
}

// </from> /home/qfox/apps/babel/packages/babel-generator/src/buffer.js

// <from> /home/qfox/apps/babel/packages/babel-generator/src/index.js

import SourceMap from "./source-map";
import Printer, { type Format } from "./printer";
/**
 * Babel's code generator, turns an ast into code, maintaining sourcemaps,
 * user preferences, and valid output.
 */
class Generator extends Printer {
  constructor(ast, opts = {}, code) {
    const format = normalizeOptions(code, opts);
    const map = opts.sourceMaps ? new SourceMap(opts, code) : null;
    super(format, map);
    this.ast = ast;
  }
  ast: Object;
  /**
   * Generate code and sourcemap from ast.
   *
   * Appends comments that weren't attached to any node to the end of the generated output.
   */
  generate() {
    return super.generate(this.ast);
  }
}
/**
 * Normalize generator options, setting defaults.
 *
 * - Detects code indentation.
 * - If `opts.compact = "auto"` and the code is over 500KB, `compact` will be set to `true`.
 */
function normalizeOptions(code, opts): Format {
  const format = {
    auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
    auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
    shouldPrintComment: opts.shouldPrintComment,
    retainLines: opts.retainLines,
    retainFunctionParens: opts.retainFunctionParens,
    comments: opts.comments == null || opts.comments,
    compact: opts.compact,
    minified: opts.minified,
    concise: opts.concise,
    jsonCompatibleStrings: opts.jsonCompatibleStrings,
    indent: {
      adjustMultilineComment: true,
      style: "  ",
      base: 0,
    },
    decoratorsBeforeExport: !!opts.decoratorsBeforeExport,
    jsescOption: {
      quotes: "double",
      wrap: true,
      ...opts.jsescOption,
    },
  };
  if (format.minified) {
    format.compact = true;
    format.shouldPrintComment =
      format.shouldPrintComment || (() => format.comments);
  } else {
    format.shouldPrintComment =
      format.shouldPrintComment ||
      (value =>
        format.comments ||
        (value.indexOf("@license") >= 0 || value.indexOf("@preserve") >= 0));
  }
  if (format.compact === "auto") {
    format.compact = code.length > 500_000; // 500KB
    if (format.compact) {
      console.error(
        "[BABEL] Note: The code generator has deoptimised the styling of " +
          `${opts.filename} as it exceeds the max of ${"500KB"}.`,
      );
    }
  }
  if (format.compact) {
    format.indent.adjustMultilineComment = false;
  }
  return format;
}
/**
 * We originally exported the Generator class above, but to make it extra clear that it is a private API,
 * we have moved that to an internal class instance and simplified the interface to the two public methods
 * that we wish to support.
 */
export class CodeGenerator {
  constructor(ast, opts, code) {
    this._generator = new Generator(ast, opts, code);
  }
  generate() {
    return this._generator.generate();
  }
}
export default function(ast: Object, opts: Object, code: string): Object {
  const gen = new Generator(ast, opts, code);
  return gen.generate();
}

// </from> /home/qfox/apps/babel/packages/babel-generator/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-generator/src/generators/expressions.js

import * as t from "@babel/types";
import * as n from "../node";
export function UnaryExpression(node: Object) {
  if (
    node.operator === "void" ||
    node.operator === "delete" ||
    node.operator === "typeof" ||
    // throwExpressions
    node.operator === "throw"
  ) {
    this.word(node.operator);
    this.space();
  } else {
    this.token(node.operator);
  }
  this.print(node.argument, node);
}
export function DoExpression(node: Object) {
  this.word("do");
  this.space();
  this.print(node.body, node);
}
export function ParenthesizedExpression(node: Object) {
  this.token("(");
  this.print(node.expression, node);
  this.token(")");
}
export function UpdateExpression(node: Object) {
  if (node.prefix) {
    this.token(node.operator);
    this.print(node.argument, node);
  } else {
    this.startTerminatorless(true);
    this.print(node.argument, node);
    this.endTerminatorless();
    this.token(node.operator);
  }
}
export function ConditionalExpression(node: Object) {
  this.print(node.test, node);
  this.space();
  this.token("?");
  this.space();
  this.print(node.consequent, node);
  this.space();
  this.token(":");
  this.space();
  this.print(node.alternate, node);
}
export function NewExpression(node: Object, parent: Object) {
  this.word("new");
  this.space();
  this.print(node.callee, node);
  if (
    this.format.minified &&
    node.arguments.length === 0 &&
    !node.optional &&
    !t.isCallExpression(parent, { callee: node }) &&
    !t.isMemberExpression(parent) &&
    !t.isNewExpression(parent)
  ) {
    return;
  }
  this.print(node.typeArguments, node); // Flow
  this.print(node.typeParameters, node); // TS
  if (node.optional) {
    this.token("?.");
  }
  this.token("(");
  this.printList(node.arguments, node);
  this.token(")");
}
export function SequenceExpression(node: Object) {
  this.printList(node.expressions, node);
}
export function ThisExpression() {
  this.word("this");
}
export function Super() {
  this.word("super");
}
export function Decorator(node: Object) {
  this.token("@");
  this.print(node.expression, node);
  this.newline();
}
export function OptionalMemberExpression(node: Object) {
  this.print(node.object, node);
  if (!node.computed && t.isMemberExpression(node.property)) {
    throw new TypeError("Got a MemberExpression for MemberExpression property");
  }
  let computed = node.computed;
  if (t.isLiteral(node.property) && typeof node.property.value === "number") {
    computed = true;
  }
  if (node.optional) {
    this.token("?.");
  }
  if (computed) {
    this.token("[");
    this.print(node.property, node);
    this.token("]");
  } else {
    if (!node.optional) {
      this.token(".");
    }
    this.print(node.property, node);
  }
}
export function OptionalCallExpression(node: Object) {
  this.print(node.callee, node);
  this.print(node.typeArguments, node); // Flow
  this.print(node.typeParameters, node); // TS
  if (node.optional) {
    this.token("?.");
  }
  this.token("(");
  this.printList(node.arguments, node);
  this.token(")");
}
export function CallExpression(node: Object) {
  this.print(node.callee, node);
  this.print(node.typeArguments, node); // Flow
  this.print(node.typeParameters, node); // TS
  this.token("(");
  this.printList(node.arguments, node);
  this.token(")");
}
export function Import() {
  this.word("import");
}
function buildYieldAwait(keyword: string) {
  return function(node: Object) {
    this.word(keyword);
    if (node.delegate) {
      this.token("*");
    }
    if (node.argument) {
      this.space();
      const terminatorState = this.startTerminatorless();
      this.print(node.argument, node);
      this.endTerminatorless(terminatorState);
    }
  };
}
export const YieldExpression = buildYieldAwait("yield");
export const AwaitExpression = buildYieldAwait("await");
export function EmptyStatement() {
  this.semicolon(true /* force */);
}
export function ExpressionStatement(node: Object) {
  this.print(node.expression, node);
  this.semicolon();
}
export function AssignmentPattern(node: Object) {
  this.print(node.left, node);
  if (node.left.optional) this.token("?");
  this.print(node.left.typeAnnotation, node);
  this.space();
  this.token("=");
  this.space();
  this.print(node.right, node);
}
export function AssignmentExpression(node: Object, parent: Object) {
  // Somewhere inside a for statement `init` node but doesn't usually
  // needs a paren except for `in` expressions: `for (a in b ? a : b;;)`
  const parens =
    this.inForStatementInitCounter &&
    node.operator === "in" &&
    !n.needsParens(node, parent);
  if (parens) {
    this.token("(");
  }
  this.print(node.left, node);
  this.space();
  if (node.operator === "in" || node.operator === "instanceof") {
    this.word(node.operator);
  } else {
    this.token(node.operator);
  }
  this.space();
  this.print(node.right, node);
  if (parens) {
    this.token(")");
  }
}
export function BindExpression(node: Object) {
  this.print(node.object, node);
  this.token("::");
  this.print(node.callee, node);
}
export {
  AssignmentExpression as BinaryExpression,
  AssignmentExpression as LogicalExpression,
};
export function MemberExpression(node: Object) {
  this.print(node.object, node);
  if (!node.computed && t.isMemberExpression(node.property)) {
    throw new TypeError("Got a MemberExpression for MemberExpression property");
  }
  let computed = node.computed;
  if (t.isLiteral(node.property) && typeof node.property.value === "number") {
    computed = true;
  }
  if (computed) {
    this.token("[");
    this.print(node.property, node);
    this.token("]");
  } else {
    this.token(".");
    this.print(node.property, node);
  }
}
export function MetaProperty(node: Object) {
  this.print(node.meta, node);
  this.token(".");
  this.print(node.property, node);
}
export function PrivateName(node: Object) {
  this.token("#");
  this.print(node.id, node);
}

// </from> /home/qfox/apps/babel/packages/babel-generator/src/generators/expressions.js

// <from> /home/qfox/apps/babel/packages/babel-generator/src/generators/index.js

export * from "./template-literals";
export * from "./expressions";
export * from "./statements";
export * from "./classes";
export * from "./methods";
export * from "./modules";
export * from "./types";
export * from "./flow";
export * from "./base";
export * from "./jsx";
export * from "./typescript";

// </from> /home/qfox/apps/babel/packages/babel-generator/src/generators/index.js

// <from> /home/qfox/apps/babel/packages/babel-generator/src/generators/methods.js

import * as t from "@babel/types";
export function _params(node: Object) {
  this.print(node.typeParameters, node);
  this.token("(");
  this._parameters(node.params, node);
  this.token(")");
  this.print(node.returnType, node);
}
export function _parameters(parameters, parent) {
  for (let i = 0; i < parameters.length; i++) {
    this._param(parameters[i], parent);
    if (i < parameters.length - 1) {
      this.token(",");
      this.space();
    }
  }
}
export function _param(parameter, parent) {
  this.printJoin(parameter.decorators, parameter);
  this.print(parameter, parent);
  if (parameter.optional) this.token("?"); // TS / flow
  this.print(parameter.typeAnnotation, parameter); // TS / flow
}
export function _methodHead(node: Object) {
  const kind = node.kind;
  const key = node.key;
  if (kind === "get" || kind === "set") {
    this.word(kind);
    this.space();
  }
  if (node.async) {
    this.word("async");
    this.space();
  }
  if (kind === "method" || kind === "init") {
    if (node.generator) {
      this.token("*");
    }
  }
  if (node.computed) {
    this.token("[");
    this.print(key, node);
    this.token("]");
  } else {
    this.print(key, node);
  }
  if (node.optional) {
    // TS
    this.token("?");
  }
  this._params(node);
}
export function _predicate(node: Object) {
  if (node.predicate) {
    if (!node.returnType) {
      this.token(":");
    }
    this.space();
    this.print(node.predicate, node);
  }
}
export function _functionHead(node: Object) {
  if (node.async) {
    this.word("async");
    this.space();
  }
  this.word("function");
  if (node.generator) this.token("*");
  this.space();
  if (node.id) {
    this.print(node.id, node);
  }
  this._params(node);
  this._predicate(node);
}
export function FunctionExpression(node: Object) {
  this._functionHead(node);
  this.space();
  this.print(node.body, node);
}
export { FunctionExpression as FunctionDeclaration };
export function ArrowFunctionExpression(node: Object) {
  if (node.async) {
    this.word("async");
    this.space();
  }
  const firstParam = node.params[0];
  if (
    node.params.length === 1 &&
    t.isIdentifier(firstParam) &&
    !hasTypes(node, firstParam)
  ) {
    this.print(firstParam, node);
  } else {
    this._params(node);
  }
  this._predicate(node);
  this.space();
  this.token("=>");
  this.space();
  this.print(node.body, node);
}
function hasTypes(node, param) {
  return (
    node.typeParameters ||
    node.returnType ||
    param.typeAnnotation ||
    param.optional ||
    param.trailingComments
  );
}

// </from> /home/qfox/apps/babel/packages/babel-generator/src/generators/methods.js

// <from> /home/qfox/apps/babel/packages/babel-generator/src/generators/classes.js

import * as t from "@babel/types";
export function ClassDeclaration(node: Object, parent: Object) {
  if (
    !this.format.decoratorsBeforeExport ||
    (!t.isExportDefaultDeclaration(parent) &&
      !t.isExportNamedDeclaration(parent))
  ) {
    this.printJoin(node.decorators, node);
  }
  if (node.declare) {
    // TS
    this.word("declare");
    this.space();
  }
  if (node.abstract) {
    // TS
    this.word("abstract");
    this.space();
  }
  this.word("class");
  if (node.id) {
    this.space();
    this.print(node.id, node);
  }
  this.print(node.typeParameters, node);
  if (node.superClass) {
    this.space();
    this.word("extends");
    this.space();
    this.print(node.superClass, node);
    this.print(node.superTypeParameters, node);
  }
  if (node.implements) {
    this.space();
    this.word("implements");
    this.space();
    this.printList(node.implements, node);
  }
  this.space();
  this.print(node.body, node);
}
export { ClassDeclaration as ClassExpression };
export function ClassBody(node: Object) {
  this.token("{");
  this.printInnerComments(node);
  if (node.body.length === 0) {
    this.token("}");
  } else {
    this.newline();
    this.indent();
    this.printSequence(node.body, node);
    this.dedent();
    if (!this.endsWith("\n")) this.newline();
    this.rightBrace();
  }
}
export function ClassProperty(node: Object) {
  this.printJoin(node.decorators, node);
  if (node.accessibility) {
    // TS
    this.word(node.accessibility);
    this.space();
  }
  if (node.static) {
    this.word("static");
    this.space();
  }
  if (node.abstract) {
    // TS
    this.word("abstract");
    this.space();
  }
  if (node.readonly) {
    // TS
    this.word("readonly");
    this.space();
  }
  if (node.computed) {
    this.token("[");
    this.print(node.key, node);
    this.token("]");
  } else {
    this._variance(node);
    this.print(node.key, node);
  }
  // TS
  if (node.optional) {
    this.token("?");
  }
  if (node.definite) {
    this.token("!");
  }
  this.print(node.typeAnnotation, node);
  if (node.value) {
    this.space();
    this.token("=");
    this.space();
    this.print(node.value, node);
  }
  this.semicolon();
}
export function ClassPrivateProperty(node: Object) {
  if (node.static) {
    this.word("static");
    this.space();
  }
  this.print(node.key, node);
  this.print(node.typeAnnotation, node);
  if (node.value) {
    this.space();
    this.token("=");
    this.space();
    this.print(node.value, node);
  }
  this.semicolon();
}
export function ClassMethod(node: Object) {
  this._classMethodHead(node);
  this.space();
  this.print(node.body, node);
}
export function _classMethodHead(node) {
  this.printJoin(node.decorators, node);
  if (node.accessibility) {
    // TS
    this.word(node.accessibility);
    this.space();
  }
  if (node.abstract) {
    // TS
    this.word("abstract");
    this.space();
  }
  if (node.static) {
    this.word("static");
    this.space();
  }
  this._methodHead(node);
}

// </from> /home/qfox/apps/babel/packages/babel-generator/src/generators/classes.js

// <from> /home/qfox/apps/babel/packages/babel-generator/src/generators/flow.js

import * as t from "@babel/types";
import { ExportAllDeclaration } from "./modules";
export function AnyTypeAnnotation() {
  this.word("any");
}
export function ArrayTypeAnnotation(node: Object) {
  this.print(node.elementType, node);
  this.token("[");
  this.token("]");
}
export function BooleanTypeAnnotation() {
  this.word("boolean");
}
export function BooleanLiteralTypeAnnotation(node: Object) {
  this.word(node.value ? "true" : "false");
}
export function NullLiteralTypeAnnotation() {
  this.word("null");
}
export function DeclareClass(node: Object, parent: Object) {
  if (!t.isDeclareExportDeclaration(parent)) {
    this.word("declare");
    this.space();
  }
  this.word("class");
  this.space();
  this._interfaceish(node);
}
export function DeclareFunction(node: Object, parent: Object) {
  if (!t.isDeclareExportDeclaration(parent)) {
    this.word("declare");
    this.space();
  }
  this.word("function");
  this.space();
  this.print(node.id, node);
  this.print(node.id.typeAnnotation.typeAnnotation, node);
  if (node.predicate) {
    this.space();
    this.print(node.predicate, node);
  }
  this.semicolon();
}
export function InferredPredicate(/*node: Object*/) {
  this.token("%");
  this.word("checks");
}
export function DeclaredPredicate(node: Object) {
  this.token("%");
  this.word("checks");
  this.token("(");
  this.print(node.value, node);
  this.token(")");
}
export function DeclareInterface(node: Object) {
  this.word("declare");
  this.space();
  this.InterfaceDeclaration(node);
}
export function DeclareModule(node: Object) {
  this.word("declare");
  this.space();
  this.word("module");
  this.space();
  this.print(node.id, node);
  this.space();
  this.print(node.body, node);
}
export function DeclareModuleExports(node: Object) {
  this.word("declare");
  this.space();
  this.word("module");
  this.token(".");
  this.word("exports");
  this.print(node.typeAnnotation, node);
}
export function DeclareTypeAlias(node: Object) {
  this.word("declare");
  this.space();
  this.TypeAlias(node);
}
export function DeclareOpaqueType(node: Object, parent: Object) {
  if (!t.isDeclareExportDeclaration(parent)) {
    this.word("declare");
    this.space();
  }
  this.OpaqueType(node);
}
export function DeclareVariable(node: Object, parent: Object) {
  if (!t.isDeclareExportDeclaration(parent)) {
    this.word("declare");
    this.space();
  }
  this.word("var");
  this.space();
  this.print(node.id, node);
  this.print(node.id.typeAnnotation, node);
  this.semicolon();
}
export function DeclareExportDeclaration(node: Object) {
  this.word("declare");
  this.space();
  this.word("export");
  this.space();
  if (node.default) {
    this.word("default");
    this.space();
  }
  FlowExportDeclaration.apply(this, arguments);
}
export function DeclareExportAllDeclaration(/*node: Object*/) {
  this.word("declare");
  this.space();
  ExportAllDeclaration.apply(this, arguments);
}
function FlowExportDeclaration(node: Object) {
  if (node.declaration) {
    const declar = node.declaration;
    this.print(declar, node);
    if (!t.isStatement(declar)) this.semicolon();
  } else {
    this.token("{");
    if (node.specifiers.length) {
      this.space();
      this.printList(node.specifiers, node);
      this.space();
    }
    this.token("}");
    if (node.source) {
      this.space();
      this.word("from");
      this.space();
      this.print(node.source, node);
    }
    this.semicolon();
  }
}
export function ExistsTypeAnnotation() {
  this.token("*");
}
export function FunctionTypeAnnotation(node: Object, parent: Object) {
  this.print(node.typeParameters, node);
  this.token("(");
  this.printList(node.params, node);
  if (node.rest) {
    if (node.params.length) {
      this.token(",");
      this.space();
    }
    this.token("...");
    this.print(node.rest, node);
  }
  this.token(")");
  // this node type is overloaded, not sure why but it makes it EXTREMELY annoying
  if (
    parent.type === "ObjectTypeCallProperty" ||
    parent.type === "DeclareFunction" ||
    (parent.type === "ObjectTypeProperty" && parent.method)
  ) {
    this.token(":");
  } else {
    this.space();
    this.token("=>");
  }
  this.space();
  this.print(node.returnType, node);
}
export function FunctionTypeParam(node: Object) {
  this.print(node.name, node);
  if (node.optional) this.token("?");
  if (node.name) {
    this.token(":");
    this.space();
  }
  this.print(node.typeAnnotation, node);
}
export function InterfaceExtends(node: Object) {
  this.print(node.id, node);
  this.print(node.typeParameters, node);
}
export {
  InterfaceExtends as ClassImplements,
  InterfaceExtends as GenericTypeAnnotation,
};
export function _interfaceish(node: Object) {
  this.print(node.id, node);
  this.print(node.typeParameters, node);
  if (node.extends.length) {
    this.space();
    this.word("extends");
    this.space();
    this.printList(node.extends, node);
  }
  if (node.mixins && node.mixins.length) {
    this.space();
    this.word("mixins");
    this.space();
    this.printList(node.mixins, node);
  }
  if (node.implements && node.implements.length) {
    this.space();
    this.word("implements");
    this.space();
    this.printList(node.implements, node);
  }
  this.space();
  this.print(node.body, node);
}
export function _variance(node) {
  if (node.variance) {
    if (node.variance.kind === "plus") {
      this.token("+");
    } else if (node.variance.kind === "minus") {
      this.token("-");
    }
  }
}
export function InterfaceDeclaration(node: Object) {
  this.word("interface");
  this.space();
  this._interfaceish(node);
}
function andSeparator() {
  this.space();
  this.token("&");
  this.space();
}
export function InterfaceTypeAnnotation(node: Object) {
  this.word("interface");
  if (node.extends && node.extends.length) {
    this.space();
    this.word("extends");
    this.space();
    this.printList(node.extends, node);
  }
  this.space();
  this.print(node.body, node);
}
export function IntersectionTypeAnnotation(node: Object) {
  this.printJoin(node.types, node, { separator: andSeparator });
}
export function MixedTypeAnnotation() {
  this.word("mixed");
}
export function EmptyTypeAnnotation() {
  this.word("empty");
}
export function NullableTypeAnnotation(node: Object) {
  this.token("?");
  this.print(node.typeAnnotation, node);
}
export {
  NumericLiteral as NumberLiteralTypeAnnotation,
  StringLiteral as StringLiteralTypeAnnotation,
} from "./types";
export function NumberTypeAnnotation() {
  this.word("number");
}
export function StringTypeAnnotation() {
  this.word("string");
}
export function ThisTypeAnnotation() {
  this.word("this");
}
export function TupleTypeAnnotation(node: Object) {
  this.token("[");
  this.printList(node.types, node);
  this.token("]");
}
export function TypeofTypeAnnotation(node: Object) {
  this.word("typeof");
  this.space();
  this.print(node.argument, node);
}
export function TypeAlias(node: Object) {
  this.word("type");
  this.space();
  this.print(node.id, node);
  this.print(node.typeParameters, node);
  this.space();
  this.token("=");
  this.space();
  this.print(node.right, node);
  this.semicolon();
}
export function TypeAnnotation(node) {
  this.token(":");
  this.space();
  if (node.optional) this.token("?");
  this.print(node.typeAnnotation, node);
}
export function TypeParameterInstantiation(node): void {
  this.token("<");
  this.printList(node.params, node, {});
  this.token(">");
}
export { TypeParameterInstantiation as TypeParameterDeclaration };
export function TypeParameter(node) {
  this._variance(node);
  this.word(node.name);
  if (node.bound) {
    this.print(node.bound, node);
  }
  if (node.default) {
    this.space();
    this.token("=");
    this.space();
    this.print(node.default, node);
  }
}
export function OpaqueType(node: Object) {
  this.word("opaque");
  this.space();
  this.word("type");
  this.space();
  this.print(node.id, node);
  this.print(node.typeParameters, node);
  if (node.supertype) {
    this.token(":");
    this.space();
    this.print(node.supertype, node);
  }
  if (node.impltype) {
    this.space();
    this.token("=");
    this.space();
    this.print(node.impltype, node);
  }
  this.semicolon();
}
export function ObjectTypeAnnotation(node: Object) {
  if (node.exact) {
    this.token("{|");
  } else {
    this.token("{");
  }
  // TODO: remove the array fallbacks and instead enforce the types to require an array
  const props = node.properties.concat(
    node.callProperties || [],
    node.indexers || [],
    node.internalSlots || [],
  );
  if (props.length) {
    this.space();
    this.printJoin(props, node, {
      addNewlines(leading) {
        if (leading && !props[0]) return 1;
      },
      indent: true,
      statement: true,
      iterator: () => {
        if (props.length !== 1) {
          this.token(",");
          this.space();
        }
      },
    });
    this.space();
  }
  if (node.exact) {
    this.token("|}");
  } else {
    this.token("}");
  }
}
export function ObjectTypeInternalSlot(node: Object) {
  if (node.static) {
    this.word("static");
    this.space();
  }
  this.token("[");
  this.token("[");
  this.print(node.id, node);
  this.token("]");
  this.token("]");
  if (node.optional) this.token("?");
  if (!node.method) {
    this.token(":");
    this.space();
  }
  this.print(node.value, node);
}
export function ObjectTypeCallProperty(node: Object) {
  if (node.static) {
    this.word("static");
    this.space();
  }
  this.print(node.value, node);
}
export function ObjectTypeIndexer(node: Object) {
  if (node.static) {
    this.word("static");
    this.space();
  }
  this._variance(node);
  this.token("[");
  if (node.id) {
    this.print(node.id, node);
    this.token(":");
    this.space();
  }
  this.print(node.key, node);
  this.token("]");
  this.token(":");
  this.space();
  this.print(node.value, node);
}
export function ObjectTypeProperty(node: Object) {
  if (node.proto) {
    this.word("proto");
    this.space();
  }
  if (node.static) {
    this.word("static");
    this.space();
  }
  this._variance(node);
  this.print(node.key, node);
  if (node.optional) this.token("?");
  if (!node.method) {
    this.token(":");
    this.space();
  }
  this.print(node.value, node);
}
export function ObjectTypeSpreadProperty(node: Object) {
  this.token("...");
  this.print(node.argument, node);
}
export function QualifiedTypeIdentifier(node: Object) {
  this.print(node.qualification, node);
  this.token(".");
  this.print(node.id, node);
}
function orSeparator() {
  this.space();
  this.token("|");
  this.space();
}
export function UnionTypeAnnotation(node: Object) {
  this.printJoin(node.types, node, { separator: orSeparator });
}
export function TypeCastExpression(node: Object) {
  this.token("(");
  this.print(node.expression, node);
  this.print(node.typeAnnotation, node);
  this.token(")");
}
export function Variance(node: Object) {
  if (node.kind === "plus") {
    this.token("+");
  } else {
    this.token("-");
  }
}
export function VoidTypeAnnotation() {
  this.word("void");
}

// </from> /home/qfox/apps/babel/packages/babel-generator/src/generators/flow.js

// <from> /home/qfox/apps/babel/packages/babel-generator/src/generators/template-literals.js

export function TaggedTemplateExpression(node: Object) {
  this.print(node.tag, node);
  this.print(node.typeParameters, node); // TS
  this.print(node.quasi, node);
}
export function TemplateElement(node: Object, parent: Object) {
  const isFirst = parent.quasis[0] === node;
  const isLast = parent.quasis[parent.quasis.length - 1] === node;
  const value = (isFirst ? "`" : "}") + node.value.raw + (isLast ? "`" : "${");
  this.token(value);
}
export function TemplateLiteral(node: Object) {
  const quasis = node.quasis;
  for (let i = 0; i < quasis.length; i++) {
    this.print(quasis[i], node);
    if (i + 1 < quasis.length) {
      this.print(node.expressions[i], node);
    }
  }
}

// </from> /home/qfox/apps/babel/packages/babel-generator/src/generators/template-literals.js

// <from> /home/qfox/apps/babel/packages/babel-generator/src/generators/types.js

import * as t from "@babel/types";
import jsesc from "jsesc";
export function Identifier(node: Object) {
  this.exactSource(node.loc, () => {
    this.word(node.name);
  });
}
export function RestElement(node: Object) {
  this.token("...");
  this.print(node.argument, node);
}
export { RestElement as SpreadElement };
export function ObjectExpression(node: Object) {
  const props = node.properties;
  this.token("{");
  this.printInnerComments(node);
  if (props.length) {
    this.space();
    this.printList(props, node, { indent: true, statement: true });
    this.space();
  }
  this.token("}");
}
export { ObjectExpression as ObjectPattern };
export function ObjectMethod(node: Object) {
  this.printJoin(node.decorators, node);
  this._methodHead(node);
  this.space();
  this.print(node.body, node);
}
export function ObjectProperty(node: Object) {
  this.printJoin(node.decorators, node);
  if (node.computed) {
    this.token("[");
    this.print(node.key, node);
    this.token("]");
  } else {
    // print `({ foo: foo = 5 } = {})` as `({ foo = 5 } = {});`
    if (
      t.isAssignmentPattern(node.value) &&
      t.isIdentifier(node.key) &&
      node.key.name === node.value.left.name
    ) {
      this.print(node.value, node);
      return;
    }
    this.print(node.key, node);
    // shorthand!
    if (
      node.shorthand &&
      (t.isIdentifier(node.key) &&
        t.isIdentifier(node.value) &&
        node.key.name === node.value.name)
    ) {
      return;
    }
  }
  this.token(":");
  this.space();
  this.print(node.value, node);
}
export function ArrayExpression(node: Object) {
  const elems = node.elements;
  const len = elems.length;
  this.token("[");
  this.printInnerComments(node);
  for (let i = 0; i < elems.length; i++) {
    const elem = elems[i];
    if (elem) {
      if (i > 0) this.space();
      this.print(elem, node);
      if (i < len - 1) this.token(",");
    } else {
      // If the array expression ends with a hole, that hole
      // will be ignored by the interpreter, but if it ends with
      // two (or more) holes, we need to write out two (or more)
      // commas so that the resulting code is interpreted with
      // both (all) of the holes.
      this.token(",");
    }
  }
  this.token("]");
}
export { ArrayExpression as ArrayPattern };
export function RegExpLiteral(node: Object) {
  this.word(`/${node.pattern}/${node.flags}`);
}
export function BooleanLiteral(node: Object) {
  this.word(node.value ? "true" : "false");
}
export function NullLiteral() {
  this.word("null");
}
export function NumericLiteral(node: Object) {
  const raw = this.getPossibleRaw(node);
  const value = node.value + "";
  if (raw == null) {
    this.number(value); // normalize
  } else if (this.format.minified) {
    this.number(raw.length < value.length ? raw : value);
  } else {
    this.number(raw);
  }
}
export function StringLiteral(node: Object) {
  const raw = this.getPossibleRaw(node);
  if (!this.format.minified && raw != null) {
    this.token(raw);
    return;
  }
  // ensure the output is ASCII-safe
  const opts = this.format.jsescOption;
  if (this.format.jsonCompatibleStrings) {
    opts.json = true;
  }
  const val = jsesc(node.value, opts);
  return this.token(val);
}
export function BigIntLiteral(node: Object) {
  const raw = this.getPossibleRaw(node);
  if (!this.format.minified && raw != null) {
    this.token(raw);
    return;
  }
  this.token(node.value);
}

// </from> /home/qfox/apps/babel/packages/babel-generator/src/generators/types.js

// <from> /home/qfox/apps/babel/packages/babel-generator/src/generators/typescript.js

export function TSTypeAnnotation(node) {
  this.token(":");
  this.space();
  if (node.optional) this.token("?");
  this.print(node.typeAnnotation, node);
}
export function TSTypeParameterInstantiation(node): void {
  this.token("<");
  this.printList(node.params, node, {});
  this.token(">");
}
export { TSTypeParameterInstantiation as TSTypeParameterDeclaration };
export function TSTypeParameter(node) {
  this.word(node.name);
  if (node.constraint) {
    this.space();
    this.word("extends");
    this.space();
    this.print(node.constraint, node);
  }
  if (node.default) {
    this.space();
    this.token("=");
    this.space();
    this.print(node.default, node);
  }
}
export function TSParameterProperty(node) {
  if (node.accessibility) {
    this.word(node.accessibility);
    this.space();
  }
  if (node.readonly) {
    this.word("readonly");
    this.space();
  }
  this._param(node.parameter);
}
export function TSDeclareFunction(node) {
  if (node.declare) {
    this.word("declare");
    this.space();
  }
  this._functionHead(node);
  this.token(";");
}
export function TSDeclareMethod(node) {
  this._classMethodHead(node);
  this.token(";");
}
export function TSQualifiedName(node) {
  this.print(node.left, node);
  this.token(".");
  this.print(node.right, node);
}
export function TSCallSignatureDeclaration(node) {
  this.tsPrintSignatureDeclarationBase(node);
}
export function TSConstructSignatureDeclaration(node) {
  this.word("new");
  this.space();
  this.tsPrintSignatureDeclarationBase(node);
}
export function TSPropertySignature(node) {
  const { readonly, initializer } = node;
  if (readonly) {
    this.word("readonly");
    this.space();
  }
  this.tsPrintPropertyOrMethodName(node);
  this.print(node.typeAnnotation, node);
  if (initializer) {
    this.space();
    this.token("=");
    this.space();
    this.print(initializer, node);
  }
  this.token(";");
}
export function tsPrintPropertyOrMethodName(node) {
  if (node.computed) {
    this.token("[");
  }
  this.print(node.key, node);
  if (node.computed) {
    this.token("]");
  }
  if (node.optional) {
    this.token("?");
  }
}
export function TSMethodSignature(node) {
  this.tsPrintPropertyOrMethodName(node);
  this.tsPrintSignatureDeclarationBase(node);
  this.token(";");
}
export function TSIndexSignature(node) {
  const { readonly } = node;
  if (readonly) {
    this.word("readonly");
    this.space();
  }
  this.token("[");
  this._parameters(node.parameters, node);
  this.token("]");
  this.print(node.typeAnnotation, node);
  this.token(";");
}
export function TSAnyKeyword() {
  this.word("any");
}
export function TSUnknownKeyword() {
  this.word("unknown");
}
export function TSNumberKeyword() {
  this.word("number");
}
export function TSObjectKeyword() {
  this.word("object");
}
export function TSBooleanKeyword() {
  this.word("boolean");
}
export function TSStringKeyword() {
  this.word("string");
}
export function TSSymbolKeyword() {
  this.word("symbol");
}
export function TSVoidKeyword() {
  this.word("void");
}
export function TSUndefinedKeyword() {
  this.word("undefined");
}
export function TSNullKeyword() {
  this.word("null");
}
export function TSNeverKeyword() {
  this.word("never");
}
export function TSThisType() {
  this.word("this");
}
export function TSFunctionType(node) {
  this.tsPrintFunctionOrConstructorType(node);
}
export function TSConstructorType(node) {
  this.word("new");
  this.space();
  this.tsPrintFunctionOrConstructorType(node);
}
export function tsPrintFunctionOrConstructorType(
  node: FunctionOrConstructorType,
) {
  const { typeParameters, parameters } = node;
  this.print(typeParameters, node);
  this.token("(");
  this._parameters(parameters, node);
  this.token(")");
  this.space();
  this.token("=>");
  this.space();
  this.print(node.typeAnnotation.typeAnnotation, node);
}
export function TSTypeReference(node) {
  this.print(node.typeName, node);
  this.print(node.typeParameters, node);
}
export function TSTypePredicate(node) {
  this.print(node.parameterName);
  this.space();
  this.word("is");
  this.space();
  this.print(node.typeAnnotation.typeAnnotation);
}
export function TSTypeQuery(node) {
  this.word("typeof");
  this.space();
  this.print(node.exprName);
}
export function TSTypeLiteral(node) {
  this.tsPrintTypeLiteralOrInterfaceBody(node.members, node);
}
export function tsPrintTypeLiteralOrInterfaceBody(members, node) {
  this.tsPrintBraced(members, node);
}
export function tsPrintBraced(members, node) {
  this.token("{");
  if (members.length) {
    this.indent();
    this.newline();
    for (const member of members) {
      this.print(member, node);
      //this.token(sep);
      this.newline();
    }
    this.dedent();
    this.rightBrace();
  } else {
    this.token("}");
  }
}
export function TSArrayType(node) {
  this.print(node.elementType);
  this.token("[]");
}
export function TSTupleType(node) {
  this.token("[");
  this.printList(node.elementTypes, node);
  this.token("]");
}
export function TSOptionalType(node) {
  this.print(node.typeAnnotation, node);
  this.token("?");
}
export function TSUnionType(node) {
  this.tsPrintUnionOrIntersectionType(node, "|");
}
export function TSIntersectionType(node) {
  this.tsPrintUnionOrIntersectionType(node, "&");
}
export function tsPrintUnionOrIntersectionType(node, sep) {
  this.printJoin(node.types, node, {
    separator() {
      this.space();
      this.token(sep);
      this.space();
    },
  });
}
export function TSConditionalType(node) {
  this.print(node.checkType);
  this.space();
  this.word("extends");
  this.space();
  this.print(node.extendsType);
  this.space();
  this.token("?");
  this.space();
  this.print(node.trueType);
  this.space();
  this.token(":");
  this.space();
  this.print(node.falseType);
}
export function TSInferType(node) {
  this.token("infer");
  this.space();
  this.print(node.typeParameter);
}
export function TSParenthesizedType(node) {
  this.token("(");
  this.print(node.typeAnnotation, node);
  this.token(")");
}
export function TSTypeOperator(node) {
  this.token(node.operator);
  this.space();
  this.print(node.typeAnnotation, node);
}
export function TSIndexedAccessType(node) {
  this.print(node.objectType, node);
  this.token("[");
  this.print(node.indexType, node);
  this.token("]");
}
export function TSMappedType(node) {
  const { readonly, typeParameter, optional } = node;
  this.token("{");
  this.space();
  if (readonly) {
    tokenIfPlusMinus(this, readonly);
    this.word("readonly");
    this.space();
  }
  this.token("[");
  this.word(typeParameter.name);
  this.space();
  this.word("in");
  this.space();
  this.print(typeParameter.constraint, typeParameter);
  this.token("]");
  if (optional) {
    tokenIfPlusMinus(this, optional);
    this.token("?");
  }
  this.token(":");
  this.space();
  this.print(node.typeAnnotation, node);
  this.space();
  this.token("}");
}
function tokenIfPlusMinus(self, tok) {
  if (tok !== true) {
    self.token(tok);
  }
}
export function TSLiteralType(node) {
  this.print(node.literal, node);
}
export function TSExpressionWithTypeArguments(node) {
  this.print(node.expression, node);
  this.print(node.typeParameters, node);
}
export function TSInterfaceDeclaration(node) {
  const { declare, id, typeParameters, extends: extendz, body } = node;
  if (declare) {
    this.word("declare");
    this.space();
  }
  this.word("interface");
  this.space();
  this.print(id, node);
  this.print(typeParameters, node);
  if (extendz) {
    this.space();
    this.word("extends");
    this.space();
    this.printList(extendz, node);
  }
  this.space();
  this.print(body, node);
}
export function TSInterfaceBody(node) {
  this.tsPrintTypeLiteralOrInterfaceBody(node.body, node);
}
export function TSTypeAliasDeclaration(node) {
  const { declare, id, typeParameters, typeAnnotation } = node;
  if (declare) {
    this.word("declare");
    this.space();
  }
  this.word("type");
  this.space();
  this.print(id, node);
  this.print(typeParameters, node);
  this.space();
  this.token("=");
  this.space();
  this.print(typeAnnotation, node);
  this.token(";");
}
export function TSAsExpression(node) {
  const { expression, typeAnnotation } = node;
  this.print(expression, node);
  this.space();
  this.word("as");
  this.space();
  this.print(typeAnnotation, node);
}
export function TSTypeAssertion(node) {
  const { typeAnnotation, expression } = node;
  this.token("<");
  this.print(typeAnnotation, node);
  this.token(">");
  this.space();
  this.print(expression, node);
}
export function TSEnumDeclaration(node) {
  const { declare, const: isConst, id, members } = node;
  if (declare) {
    this.word("declare");
    this.space();
  }
  if (isConst) {
    this.word("const");
    this.space();
  }
  this.word("enum");
  this.space();
  this.print(id, node);
  this.space();
  this.tsPrintBraced(members, node);
}
export function TSEnumMember(node) {
  const { id, initializer } = node;
  this.print(id, node);
  if (initializer) {
    this.space();
    this.token("=");
    this.space();
    this.print(initializer, node);
  }
  this.token(",");
}
export function TSModuleDeclaration(node) {
  const { declare, id } = node;
  if (declare) {
    this.word("declare");
    this.space();
  }
  if (!node.global) {
    this.word(id.type === "Identifier" ? "namespace" : "module");
    this.space();
  }
  this.print(id, node);
  if (!node.body) {
    this.token(";");
    return;
  }
  let body = node.body;
  while (body.type === "TSModuleDeclaration") {
    this.token(".");
    this.print(body.id, body);
    body = body.body;
  }
  this.space();
  this.print(body, node);
}
export function TSModuleBlock(node) {
  this.tsPrintBraced(node.body, node);
}
export function TSImportEqualsDeclaration(node) {
  const { isExport, id, moduleReference } = node;
  if (isExport) {
    this.word("export");
    this.space();
  }
  this.word("import");
  this.space();
  this.print(id, node);
  this.space();
  this.token("=");
  this.space();
  this.print(moduleReference, node);
  this.token(";");
}
export function TSExternalModuleReference(node) {
  this.token("require(");
  this.print(node.expression, node);
  this.token(")");
}
export function TSNonNullExpression(node) {
  this.print(node.expression, node);
  this.token("!");
}
export function TSExportAssignment(node) {
  this.word("export");
  this.space();
  this.token("=");
  this.space();
  this.print(node.expression, node);
  this.token(";");
}
export function TSNamespaceExportDeclaration(node) {
  this.word("export");
  this.space();
  this.word("as");
  this.space();
  this.word("namespace");
  this.space();
  this.print(node.id, node);
}
export function tsPrintSignatureDeclarationBase(node) {
  const { typeParameters, parameters } = node;
  this.print(typeParameters, node);
  this.token("(");
  this._parameters(parameters, node);
  this.token(")");
  this.print(node.typeAnnotation, node);
}

// </from> /home/qfox/apps/babel/packages/babel-generator/src/generators/typescript.js

// <from> /home/qfox/apps/babel/packages/babel-generator/src/generators/statements.js

import * as t from "@babel/types";
export function WithStatement(node: Object) {
  this.word("with");
  this.space();
  this.token("(");
  this.print(node.object, node);
  this.token(")");
  this.printBlock(node);
}
export function IfStatement(node: Object) {
  this.word("if");
  this.space();
  this.token("(");
  this.print(node.test, node);
  this.token(")");
  this.space();
  const needsBlock =
    node.alternate && t.isIfStatement(getLastStatement(node.consequent));
  if (needsBlock) {
    this.token("{");
    this.newline();
    this.indent();
  }
  this.printAndIndentOnComments(node.consequent, node);
  if (needsBlock) {
    this.dedent();
    this.newline();
    this.token("}");
  }
  if (node.alternate) {
    if (this.endsWith("}")) this.space();
    this.word("else");
    this.space();
    this.printAndIndentOnComments(node.alternate, node);
  }
}
// Recursively get the last statement.
function getLastStatement(statement) {
  if (!t.isStatement(statement.body)) return statement;
  return getLastStatement(statement.body);
}
export function ForStatement(node: Object) {
  this.word("for");
  this.space();
  this.token("(");
  this.inForStatementInitCounter++;
  this.print(node.init, node);
  this.inForStatementInitCounter--;
  this.token(";");
  if (node.test) {
    this.space();
    this.print(node.test, node);
  }
  this.token(";");
  if (node.update) {
    this.space();
    this.print(node.update, node);
  }
  this.token(")");
  this.printBlock(node);
}
export function WhileStatement(node: Object) {
  this.word("while");
  this.space();
  this.token("(");
  this.print(node.test, node);
  this.token(")");
  this.printBlock(node);
}
const buildForXStatement = function(op) {
  return function(node: Object) {
    this.word("for");
    this.space();
    if (op === "of" && node.await) {
      this.word("await");
      this.space();
    }
    this.token("(");
    this.print(node.left, node);
    this.space();
    this.word(op);
    this.space();
    this.print(node.right, node);
    this.token(")");
    this.printBlock(node);
  };
};
export const ForInStatement = buildForXStatement("in");
export const ForOfStatement = buildForXStatement("of");
export function DoWhileStatement(node: Object) {
  this.word("do");
  this.space();
  this.print(node.body, node);
  this.space();
  this.word("while");
  this.space();
  this.token("(");
  this.print(node.test, node);
  this.token(")");
  this.semicolon();
}
function buildLabelStatement(prefix, key = "label") {
  return function(node: Object) {
    this.word(prefix);
    const label = node[key];
    if (label) {
      this.space();
      const isLabel = key == "label";
      const terminatorState = this.startTerminatorless(isLabel);
      this.print(label, node);
      this.endTerminatorless(terminatorState);
    }
    this.semicolon();
  };
}
export const ContinueStatement = buildLabelStatement("continue");
export const ReturnStatement = buildLabelStatement("return", "argument");
export const BreakStatement = buildLabelStatement("break");
export const ThrowStatement = buildLabelStatement("throw", "argument");
export function LabeledStatement(node: Object) {
  this.print(node.label, node);
  this.token(":");
  this.space();
  this.print(node.body, node);
}
export function TryStatement(node: Object) {
  this.word("try");
  this.space();
  this.print(node.block, node);
  this.space();
  // Esprima bug puts the catch clause in a `handlers` array.
  // see https://code.google.com/p/esprima/issues/detail?id=433
  // We run into this from regenerator generated ast.
  if (node.handlers) {
    this.print(node.handlers[0], node);
  } else {
    this.print(node.handler, node);
  }
  if (node.finalizer) {
    this.space();
    this.word("finally");
    this.space();
    this.print(node.finalizer, node);
  }
}
export function CatchClause(node: Object) {
  this.word("catch");
  this.space();
  if (node.param) {
    this.token("(");
    this.print(node.param, node);
    this.token(")");
    this.space();
  }
  this.print(node.body, node);
}
export function SwitchStatement(node: Object) {
  this.word("switch");
  this.space();
  this.token("(");
  this.print(node.discriminant, node);
  this.token(")");
  this.space();
  this.token("{");
  this.printSequence(node.cases, node, {
    indent: true,
    addNewlines(leading, cas) {
      if (!leading && node.cases[node.cases.length - 1] === cas) return -1;
    },
  });
  this.token("}");
}
export function SwitchCase(node: Object) {
  if (node.test) {
    this.word("case");
    this.space();
    this.print(node.test, node);
    this.token(":");
  } else {
    this.word("default");
    this.token(":");
  }
  if (node.consequent.length) {
    this.newline();
    this.printSequence(node.consequent, node, { indent: true });
  }
}
export function DebuggerStatement() {
  this.word("debugger");
  this.semicolon();
}
function variableDeclarationIndent() {
  // "let " or "var " indentation.
  this.token(",");
  this.newline();
  if (this.endsWith("\n")) for (let i = 0; i < 4; i++) this.space(true);
}
function constDeclarationIndent() {
  // "const " indentation.
  this.token(",");
  this.newline();
  if (this.endsWith("\n")) for (let i = 0; i < 6; i++) this.space(true);
}
export function VariableDeclaration(node: Object, parent: Object) {
  if (node.declare) {
    // TS
    this.word("declare");
    this.space();
  }
  this.word(node.kind);
  this.space();
  let hasInits = false;
  // don't add whitespace to loop heads
  if (!t.isFor(parent)) {
    for (const declar of (node.declarations: Array<Object>)) {
      if (declar.init) {
        // has an init so let's split it up over multiple lines
        hasInits = true;
      }
    }
  }
  //
  // use a pretty separator when we aren't in compact mode, have initializers and don't have retainLines on
  // this will format declarations like:
  //
  //   let foo = "bar", bar = "foo";
  //
  // into
  //
  //   let foo = "bar",
  //       bar = "foo";
  //
  let separator;
  if (hasInits) {
    separator =
      node.kind === "const"
        ? constDeclarationIndent
        : variableDeclarationIndent;
  }
  //
  this.printList(node.declarations, node, { separator });
  if (t.isFor(parent)) {
    // don't give semicolons to these nodes since they'll be inserted in the parent generator
    if (parent.left === node || parent.init === node) return;
  }
  this.semicolon();
}
export function VariableDeclarator(node: Object) {
  this.print(node.id, node);
  if (node.definite) this.token("!"); // TS
  this.print(node.id.typeAnnotation, node);
  if (node.init) {
    this.space();
    this.token("=");
    this.space();
    this.print(node.init, node);
  }
}

// </from> /home/qfox/apps/babel/packages/babel-generator/src/generators/statements.js

// <from> /home/qfox/apps/babel/packages/babel-generator/src/generators/jsx.js

export function JSXAttribute(node: Object) {
  this.print(node.name, node);
  if (node.value) {
    this.token("=");
    this.print(node.value, node);
  }
}
export function JSXIdentifier(node: Object) {
  this.word(node.name);
}
export function JSXNamespacedName(node: Object) {
  this.print(node.namespace, node);
  this.token(":");
  this.print(node.name, node);
}
export function JSXMemberExpression(node: Object) {
  this.print(node.object, node);
  this.token(".");
  this.print(node.property, node);
}
export function JSXSpreadAttribute(node: Object) {
  this.token("{");
  this.token("...");
  this.print(node.argument, node);
  this.token("}");
}
export function JSXExpressionContainer(node: Object) {
  this.token("{");
  this.print(node.expression, node);
  this.token("}");
}
export function JSXSpreadChild(node: Object) {
  this.token("{");
  this.token("...");
  this.print(node.expression, node);
  this.token("}");
}
export function JSXText(node: Object) {
  const raw = this.getPossibleRaw(node);
  if (raw != null) {
    this.token(raw);
  } else {
    this.token(node.value);
  }
}
export function JSXElement(node: Object) {
  const open = node.openingElement;
  this.print(open, node);
  if (open.selfClosing) return;
  this.indent();
  for (const child of (node.children: Array<Object>)) {
    this.print(child, node);
  }
  this.dedent();
  this.print(node.closingElement, node);
}
function spaceSeparator() {
  this.space();
}
export function JSXOpeningElement(node: Object) {
  this.token("<");
  this.print(node.name, node);
  this.print(node.typeParameters, node); // TS
  if (node.attributes.length > 0) {
    this.space();
    this.printJoin(node.attributes, node, { separator: spaceSeparator });
  }
  if (node.selfClosing) {
    this.space();
    this.token("/>");
  } else {
    this.token(">");
  }
}
export function JSXClosingElement(node: Object) {
  this.token("</");
  this.print(node.name, node);
  this.token(">");
}
export function JSXEmptyExpression(node: Object) {
  this.printInnerComments(node);
}
export function JSXFragment(node: Object) {
  this.print(node.openingFragment, node);
  this.indent();
  for (const child of (node.children: Array<Object>)) {
    this.print(child, node);
  }
  this.dedent();
  this.print(node.closingFragment, node);
}
export function JSXOpeningFragment() {
  this.token("<");
  this.token(">");
}
export function JSXClosingFragment() {
  this.token("</");
  this.token(">");
}

// </from> /home/qfox/apps/babel/packages/babel-generator/src/generators/jsx.js

// <from> /home/qfox/apps/babel/packages/babel-generator/src/generators/modules.js

import * as t from "@babel/types";
export function ImportSpecifier(node: Object) {
  if (node.importKind === "type" || node.importKind === "typeof") {
    this.word(node.importKind);
    this.space();
  }
  this.print(node.imported, node);
  if (node.local && node.local.name !== node.imported.name) {
    this.space();
    this.word("as");
    this.space();
    this.print(node.local, node);
  }
}
export function ImportDefaultSpecifier(node: Object) {
  this.print(node.local, node);
}
export function ExportDefaultSpecifier(node: Object) {
  this.print(node.exported, node);
}
export function ExportSpecifier(node: Object) {
  this.print(node.local, node);
  if (node.exported && node.local.name !== node.exported.name) {
    this.space();
    this.word("as");
    this.space();
    this.print(node.exported, node);
  }
}
export function ExportNamespaceSpecifier(node: Object) {
  this.token("*");
  this.space();
  this.word("as");
  this.space();
  this.print(node.exported, node);
}
export function ExportAllDeclaration(node: Object) {
  this.word("export");
  this.space();
  if (node.exportKind === "type") {
    this.word("type");
    this.space();
  }
  this.token("*");
  this.space();
  this.word("from");
  this.space();
  this.print(node.source, node);
  this.semicolon();
}
export function ExportNamedDeclaration(node: Object) {
  if (
    this.format.decoratorsBeforeExport &&
    t.isClassDeclaration(node.declaration)
  ) {
    this.printJoin(node.declaration.decorators, node);
  }
  this.word("export");
  this.space();
  ExportDeclaration.apply(this, arguments);
}
export function ExportDefaultDeclaration(node: Object) {
  if (
    this.format.decoratorsBeforeExport &&
    t.isClassDeclaration(node.declaration)
  ) {
    this.printJoin(node.declaration.decorators, node);
  }
  this.word("export");
  this.space();
  this.word("default");
  this.space();
  ExportDeclaration.apply(this, arguments);
}
function ExportDeclaration(node: Object) {
  if (node.declaration) {
    const declar = node.declaration;
    this.print(declar, node);
    if (!t.isStatement(declar)) this.semicolon();
  } else {
    if (node.exportKind === "type") {
      this.word("type");
      this.space();
    }
    const specifiers = node.specifiers.slice(0);
    // print "special" specifiers first
    let hasSpecial = false;
    while (true) {
      const first = specifiers[0];
      if (
        t.isExportDefaultSpecifier(first) ||
        t.isExportNamespaceSpecifier(first)
      ) {
        hasSpecial = true;
        this.print(specifiers.shift(), node);
        if (specifiers.length) {
          this.token(",");
          this.space();
        }
      } else {
        break;
      }
    }
    if (specifiers.length || (!specifiers.length && !hasSpecial)) {
      this.token("{");
      if (specifiers.length) {
        this.space();
        this.printList(specifiers, node);
        this.space();
      }
      this.token("}");
    }
    if (node.source) {
      this.space();
      this.word("from");
      this.space();
      this.print(node.source, node);
    }
    this.semicolon();
  }
}
export function ImportDeclaration(node: Object) {
  this.word("import");
  this.space();
  if (node.importKind === "type" || node.importKind === "typeof") {
    this.word(node.importKind);
    this.space();
  }
  const specifiers = node.specifiers.slice(0);
  if (specifiers && specifiers.length) {
    // print "special" specifiers first
    while (true) {
      const first = specifiers[0];
      if (
        t.isImportDefaultSpecifier(first) ||
        t.isImportNamespaceSpecifier(first)
      ) {
        this.print(specifiers.shift(), node);
        if (specifiers.length) {
          this.token(",");
          this.space();
        }
      } else {
        break;
      }
    }
    if (specifiers.length) {
      this.token("{");
      this.space();
      this.printList(specifiers, node);
      this.space();
      this.token("}");
    }
    this.space();
    this.word("from");
    this.space();
  }
  this.print(node.source, node);
  this.semicolon();
}
export function ImportNamespaceSpecifier(node: Object) {
  this.token("*");
  this.space();
  this.word("as");
  this.space();
  this.print(node.local, node);
}

// </from> /home/qfox/apps/babel/packages/babel-generator/src/generators/modules.js

// <from> /home/qfox/apps/babel/packages/babel-generator/src/generators/base.js

export function File(node: Object) {
  if (node.program) {
    // Print this here to ensure that Program node 'leadingComments' still
    // get printed after the hashbang.
    this.print(node.program.interpreter, node);
  }
  this.print(node.program, node);
}
export function Program(node: Object) {
  this.printInnerComments(node, false);
  this.printSequence(node.directives, node);
  if (node.directives && node.directives.length) this.newline();
  this.printSequence(node.body, node);
}
export function BlockStatement(node: Object) {
  this.token("{");
  this.printInnerComments(node);
  const hasDirectives = node.directives && node.directives.length;
  if (node.body.length || hasDirectives) {
    this.newline();
    this.printSequence(node.directives, node, { indent: true });
    if (hasDirectives) this.newline();
    this.printSequence(node.body, node, { indent: true });
    this.removeTrailingNewline();
    this.source("end", node.loc);
    if (!this.endsWith("\n")) this.newline();
    this.rightBrace();
  } else {
    this.source("end", node.loc);
    this.token("}");
  }
}
export function Noop() {}
export function Directive(node: Object) {
  this.print(node.value, node);
  this.semicolon();
}
export function InterpreterDirective(node: Object) {
  this.token(`#!${node.value}\n`);
}
export { StringLiteral as DirectiveLiteral } from "./types";

// </from> /home/qfox/apps/babel/packages/babel-generator/src/generators/base.js

// <from> /home/qfox/apps/babel/packages/babel-generator/src/printer.js

import isInteger from "lodash/isInteger";
import repeat from "lodash/repeat";
import Buffer from "./buffer";
import * as n from "./node";
import * as t from "@babel/types";
import * as generatorFunctions from "./generators";
const SCIENTIFIC_NOTATION = /e/i;
const ZERO_DECIMAL_INTEGER = /\.0+$/;
const NON_DECIMAL_LITERAL = /^0[box]/;
export type Format = {
  shouldPrintComment: (comment: string) => boolean,
  retainLines: boolean,
  retainFunctionParens: boolean,
  comments: boolean,
  auxiliaryCommentBefore: string,
  auxiliaryCommentAfter: string,
  compact: boolean | "auto",
  minified: boolean,
  concise: boolean,
  indent: {
    adjustMultilineComment: boolean,
    style: string,
    base: number,
  },
  decoratorsBeforeExport: boolean,
};
export default class Printer {
  constructor(format, map) {
    this.format = format || {};
    this._buf = new Buffer(map);
  }
  format: Format;
  inForStatementInitCounter: number = 0;
  _buf: Buffer;
  _printStack: Array<Node> = [];
  _indent: number = 0;
  _insideAux: boolean = false;
  _printedCommentStarts: Object = {};
  _parenPushNewlineState: ?Object = null;
  _noLineTerminator: boolean = false;
  _printAuxAfterOnNextUserNode: boolean = false;
  _printedComments: WeakSet = new WeakSet();
  _endsWithInteger = false;
  _endsWithWord = false;
  generate(ast) {
    this.print(ast);
    this._maybeAddAuxComment();
    return this._buf.get();
  }
  /**
   * Increment indent size.
   */
  indent(): void {
    if (this.format.compact || this.format.concise) return;
    this._indent++;
  }
  /**
   * Decrement indent size.
   */
  dedent(): void {
    if (this.format.compact || this.format.concise) return;
    this._indent--;
  }
  /**
   * Add a semicolon to the buffer.
   */
  semicolon(force: boolean = false): void {
    this._maybeAddAuxComment();
    this._append(";", !force /* queue */);
  }
  /**
   * Add a right brace to the buffer.
   */
  rightBrace(): void {
    if (this.format.minified) {
      this._buf.removeLastSemicolon();
    }
    this.token("}");
  }
  /**
   * Add a space to the buffer unless it is compact.
   */
  space(force: boolean = false): void {
    if (this.format.compact) return;
    if (
      (this._buf.hasContent() && !this.endsWith(" ") && !this.endsWith("\n")) ||
      force
    ) {
      this._space();
    }
  }
  /**
   * Writes a token that can't be safely parsed without taking whitespace into account.
   */
  word(str: string): void {
    // prevent concatenating words and creating // comment out of division and regex
    if (this._endsWithWord || (this.endsWith("/") && str.indexOf("/") === 0)) {
      this._space();
    }
    this._maybeAddAuxComment();
    this._append(str);
    this._endsWithWord = true;
  }
  /**
   * Writes a number token so that we can validate if it is an integer.
   */
  number(str: string): void {
    this.word(str);
    // Integer tokens need special handling because they cannot have '.'s inserted
    // immediately after them.
    this._endsWithInteger =
      isInteger(+str) &&
      !NON_DECIMAL_LITERAL.test(str) &&
      !SCIENTIFIC_NOTATION.test(str) &&
      !ZERO_DECIMAL_INTEGER.test(str) &&
      str[str.length - 1] !== ".";
  }
  /**
   * Writes a simple token.
   */
  token(str: string): void {
    // space is mandatory to avoid outputting <!--
    // http://javascript.spec.whatwg.org/#comment-syntax
    if (
      (str === "--" && this.endsWith("!")) ||
      // Need spaces for operators of the same kind to avoid: `a+++b`
      (str[0] === "+" && this.endsWith("+")) ||
      (str[0] === "-" && this.endsWith("-")) ||
      // Needs spaces to avoid changing '34' to '34.', which would still be a valid number.
      (str[0] === "." && this._endsWithInteger)
    ) {
      this._space();
    }
    this._maybeAddAuxComment();
    this._append(str);
  }
  /**
   * Add a newline (or many newlines), maintaining formatting.
   */
  newline(i?: number): void {
    if (this.format.retainLines || this.format.compact) return;
    if (this.format.concise) {
      this.space();
      return;
    }
    // never allow more than two lines
    if (this.endsWith("\n\n")) return;
    if (typeof i !== "number") i = 1;
    i = Math.min(2, i);
    if (this.endsWith("{\n") || this.endsWith(":\n")) i--;
    if (i <= 0) return;
    for (let j = 0; j < i; j++) {
      this._newline();
    }
  }
  endsWith(str: string): boolean {
    return this._buf.endsWith(str);
  }
  removeTrailingNewline(): void {
    this._buf.removeTrailingNewline();
  }
  exactSource(loc: Object, cb: () => void) {
    this._catchUp("start", loc);
    this._buf.exactSource(loc, cb);
  }
  source(prop: string, loc: Object): void {
    this._catchUp(prop, loc);
    this._buf.source(prop, loc);
  }
  withSource(prop: string, loc: Object, cb: () => void): void {
    this._catchUp(prop, loc);
    this._buf.withSource(prop, loc, cb);
  }
  _space(): void {
    this._append(" ", true /* queue */);
  }
  _newline(): void {
    this._append("\n", true /* queue */);
  }
  _append(str: string, queue: boolean = false) {
    this._maybeAddParen(str);
    this._maybeIndent(str);
    if (queue) this._buf.queue(str);
    else this._buf.append(str);
    this._endsWithWord = false;
    this._endsWithInteger = false;
  }
  _maybeIndent(str: string): void {
    // we've got a newline before us so prepend on the indentation
    if (this._indent && this.endsWith("\n") && str[0] !== "\n") {
      this._buf.queue(this._getIndent());
    }
  }
  _maybeAddParen(str: string): void {
    // see startTerminatorless() instance method
    const parenPushNewlineState = this._parenPushNewlineState;
    if (!parenPushNewlineState) return;
    this._parenPushNewlineState = null;
    let i;
    for (i = 0; i < str.length && str[i] === " "; i++) continue;
    if (i === str.length) return;
    // Check for newline or comment.
    const cha = str[i];
    if (cha !== "\n") {
      if (cha !== "/") return;
      if (i + 1 === str.length) return;
      const chaPost = str[i + 1];
      if (chaPost !== "/" && chaPost !== "*") return;
    }
    this.token("(");
    this.indent();
    parenPushNewlineState.printed = true;
  }
  _catchUp(prop: string, loc: Object) {
    if (!this.format.retainLines) return;
    // catch up to this nodes newline if we're behind
    const pos = loc ? loc[prop] : null;
    if (pos && pos.line !== null) {
      const count = pos.line - this._buf.getCurrentLine();
      for (let i = 0; i < count; i++) {
        this._newline();
      }
    }
  }
  /**
   * Get the current indent.
   */
  _getIndent(): string {
    return repeat(this.format.indent.style, this._indent);
  }
  /**
   * Set some state that will be modified if a newline has been inserted before any
   * non-space characters.
   *
   * This is to prevent breaking semantics for terminatorless separator nodes. eg:
   *
   *   return foo;
   *
   * returns `foo`. But if we do:
   *
   *   return
   *   foo;
   *
   *  `undefined` will be returned and not `foo` due to the terminator.
   */
  startTerminatorless(isLabel: boolean = false): Object {
    if (isLabel) {
      this._noLineTerminator = true;
      return null;
    } else {
      return (this._parenPushNewlineState = {
        printed: false,
      });
    }
  }
  /**
   * Print an ending parentheses if a starting one has been printed.
   */
  endTerminatorless(state: Object) {
    this._noLineTerminator = false;
    if (state && state.printed) {
      this.dedent();
      this.newline();
      this.token(")");
    }
  }
  print(node, parent) {
    if (!node) return;
    const oldConcise = this.format.concise;
    if (node._compact) {
      this.format.concise = true;
    }
    const printMethod = this[node.type];
    if (!printMethod) {
      throw new ReferenceError(
        `unknown node of type ${JSON.stringify(
          node.type,
        )} with constructor ${JSON.stringify(node && node.constructor.name)}`,
      );
    }
    this._printStack.push(node);
    const oldInAux = this._insideAux;
    this._insideAux = !node.loc;
    this._maybeAddAuxComment(this._insideAux && !oldInAux);
    let needsParens = n.needsParens(node, parent, this._printStack);
    if (
      this.format.retainFunctionParens &&
      node.type === "FunctionExpression" &&
      node.extra &&
      node.extra.parenthesized
    ) {
      needsParens = true;
    }
    if (needsParens) this.token("(");
    this._printLeadingComments(node, parent);
    const loc = t.isProgram(node) || t.isFile(node) ? null : node.loc;
    this.withSource("start", loc, () => {
      this[node.type](node, parent);
    });
    this._printTrailingComments(node, parent);
    if (needsParens) this.token(")");
    // end
    this._printStack.pop();
    this.format.concise = oldConcise;
    this._insideAux = oldInAux;
  }
  _maybeAddAuxComment(enteredPositionlessNode) {
    if (enteredPositionlessNode) this._printAuxBeforeComment();
    if (!this._insideAux) this._printAuxAfterComment();
  }
  _printAuxBeforeComment() {
    if (this._printAuxAfterOnNextUserNode) return;
    this._printAuxAfterOnNextUserNode = true;
    const comment = this.format.auxiliaryCommentBefore;
    if (comment) {
      this._printComment({
        type: "CommentBlock",
        value: comment,
      });
    }
  }
  _printAuxAfterComment() {
    if (!this._printAuxAfterOnNextUserNode) return;
    this._printAuxAfterOnNextUserNode = false;
    const comment = this.format.auxiliaryCommentAfter;
    if (comment) {
      this._printComment({
        type: "CommentBlock",
        value: comment,
      });
    }
  }
  getPossibleRaw(node) {
    const extra = node.extra;
    if (
      extra &&
      extra.raw != null &&
      extra.rawValue != null &&
      node.value === extra.rawValue
    ) {
      return extra.raw;
    }
  }
  printJoin(nodes: ?Array, parent: Object, opts = {}) {
    if (!nodes || !nodes.length) return;
    if (opts.indent) this.indent();
    const newlineOpts = {
      addNewlines: opts.addNewlines,
    };
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (!node) continue;
      if (opts.statement) this._printNewline(true, node, parent, newlineOpts);
      this.print(node, parent);
      if (opts.iterator) {
        opts.iterator(node, i);
      }
      if (opts.separator && i < nodes.length - 1) {
        opts.separator.call(this);
      }
      if (opts.statement) this._printNewline(false, node, parent, newlineOpts);
    }
    if (opts.indent) this.dedent();
  }
  printAndIndentOnComments(node, parent) {
    const indent = node.leadingComments && node.leadingComments.length > 0;
    if (indent) this.indent();
    this.print(node, parent);
    if (indent) this.dedent();
  }
  printBlock(parent) {
    const node = parent.body;
    if (!t.isEmptyStatement(node)) {
      this.space();
    }
    this.print(node, parent);
  }
  _printTrailingComments(node, parent) {
    this._printComments(this._getComments(false, node, parent));
  }
  _printLeadingComments(node, parent) {
    this._printComments(this._getComments(true, node, parent));
  }
  printInnerComments(node, indent = true) {
    if (!node.innerComments || !node.innerComments.length) return;
    if (indent) this.indent();
    this._printComments(node.innerComments);
    if (indent) this.dedent();
  }
  printSequence(nodes, parent, opts = {}) {
    opts.statement = true;
    return this.printJoin(nodes, parent, opts);
  }
  printList(items, parent, opts = {}) {
    if (opts.separator == null) {
      opts.separator = commaSeparator;
    }
    return this.printJoin(items, parent, opts);
  }
  _printNewline(leading, node, parent, opts) {
    // Fast path since 'this.newline' does nothing when not tracking lines.
    if (this.format.retainLines || this.format.compact) return;
    // Fast path for concise since 'this.newline' just inserts a space when
    // concise formatting is in use.
    if (this.format.concise) {
      this.space();
      return;
    }
    let lines = 0;
    // don't add newlines at the beginning of the file
    if (this._buf.hasContent()) {
      if (!leading) lines++; // always include at least a single line after
      if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;
      const needs = leading ? n.needsWhitespaceBefore : n.needsWhitespaceAfter;
      if (needs(node, parent)) lines++;
    }
    this.newline(lines);
  }
  _getComments(leading, node) {
    // Note, we use a boolean flag here instead of passing in the attribute name as it is faster
    // because this is called extremely frequently.
    return (
      (node && (leading ? node.leadingComments : node.trailingComments)) || []
    );
  }
  _printComment(comment) {
    if (!this.format.shouldPrintComment(comment.value)) return;
    // Some plugins use this to mark comments as removed using the AST-root 'comments' property,
    // where they can't manually mutate the AST node comment lists.
    if (comment.ignore) return;
    if (this._printedComments.has(comment)) return;
    this._printedComments.add(comment);
    if (comment.start != null) {
      if (this._printedCommentStarts[comment.start]) return;
      this._printedCommentStarts[comment.start] = true;
    }
    const isBlockComment = comment.type === "CommentBlock";
    // Always add a newline before a block comment
    this.newline(
      this._buf.hasContent() && !this._noLineTerminator && isBlockComment
        ? 1
        : 0,
    );
    if (!this.endsWith("[") && !this.endsWith("{")) this.space();
    let val =
      !isBlockComment && !this._noLineTerminator
        ? `//${comment.value}\n`
        : `/*${comment.value}*/`;
    if (isBlockComment && this.format.indent.adjustMultilineComment) {
      const offset = comment.loc && comment.loc.start.column;
      if (offset) {
        const newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
        val = val.replace(newlineRegex, "\n");
      }
      const indentSize = Math.max(
        this._getIndent().length,
        this._buf.getCurrentColumn(),
      );
      val = val.replace(/\n(?!$)/g, `\n${repeat(" ", indentSize)}`);
    }
    // Avoid creating //* comments
    if (this.endsWith("/")) this._space();
    this.withSource("start", comment.loc, () => {
      this._append(val);
    });
    // Always add a newline after a block comment
    this.newline(isBlockComment && !this._noLineTerminator ? 1 : 0);
  }
  _printComments(comments?: Array<Object>) {
    if (!comments || !comments.length) return;
    for (const comment of comments) {
      this._printComment(comment);
    }
  }
}
// Expose the node type functions and helpers on the prototype for easy usage.
Object.assign(Printer.prototype, generatorFunctions);
function commaSeparator() {
  this.token(",");
  this.space();
}

// </from> /home/qfox/apps/babel/packages/babel-generator/src/printer.js

// <from> /home/qfox/apps/babel/packages/babel-generator/src/source-map.js

import sourceMap from "source-map";
/**
 * Build a sourcemap.
 */
export default class SourceMap {
  constructor(opts, code) {
    this._cachedMap = null;
    this._code = code;
    this._opts = opts;
    this._rawMappings = [];
  }
  /**
   * Get the sourcemap.
   */
  get() {
    if (!this._cachedMap) {
      const map = (this._cachedMap = new sourceMap.SourceMapGenerator({
        sourceRoot: this._opts.sourceRoot,
      }));
      const code = this._code;
      if (typeof code === "string") {
        map.setSourceContent(this._opts.sourceFileName, code);
      } else if (typeof code === "object") {
        Object.keys(code).forEach(sourceFileName => {
          map.setSourceContent(sourceFileName, code[sourceFileName]);
        });
      }
      this._rawMappings.forEach(map.addMapping, map);
    }
    return this._cachedMap.toJSON();
  }
  getRawMappings() {
    return this._rawMappings.slice();
  }
  /**
   * Mark the current generated position with a source position. May also be passed null line/column
   * values to insert a mapping to nothing.
   */
  mark(
    generatedLine: number,
    generatedColumn: number,
    line: number,
    column: number,
    identifierName: ?string,
    filename: ?string,
    force?: boolean,
  ) {
    // Adding an empty mapping at the start of a generated line just clutters the map.
    if (this._lastGenLine !== generatedLine && line === null) return;
    // If this mapping points to the same source location as the last one, we can ignore it since
    // the previous one covers it.
    if (
      !force &&
      this._lastGenLine === generatedLine &&
      this._lastSourceLine === line &&
      this._lastSourceColumn === column
    ) {
      return;
    }
    this._cachedMap = null;
    this._lastGenLine = generatedLine;
    this._lastSourceLine = line;
    this._lastSourceColumn = column;
    // We are deliberately not using the `source-map` library here to allow
    // callers to use these mappings without any overhead
    this._rawMappings.push({
      // undefined to allow for more compact json serialization
      name: identifierName || undefined,
      generated: {
        line: generatedLine,
        column: generatedColumn,
      },
      source: line == null ? undefined : filename || this._opts.sourceFileName,
      original:
        line == null
          ? undefined
          : {
              line: line,
              column: column,
            },
    });
  }
}

// </from> /home/qfox/apps/babel/packages/babel-generator/src/source-map.js

// <from> /home/qfox/apps/babel/packages/babel-generator/src/node/index.js

import * as whitespace from "./whitespace";
import * as parens from "./parentheses";
import * as t from "@babel/types";
function expandAliases(obj) {
  const newObj = {};
  function add(type, func) {
    const fn = newObj[type];
    newObj[type] = fn
      ? function(node, parent, stack) {
          const result = fn(node, parent, stack);
          return result == null ? func(node, parent, stack) : result;
        }
      : func;
  }
  for (const type of Object.keys(obj)) {
    const aliases = t.FLIPPED_ALIAS_KEYS[type];
    if (aliases) {
      for (const alias of aliases) {
        add(alias, obj[type]);
      }
    } else {
      add(type, obj[type]);
    }
  }
  return newObj;
}
// Rather than using `t.is` on each object property, we pre-expand any type aliases
// into concrete types so that the 'find' call below can be as fast as possible.
const expandedParens = expandAliases(parens);
const expandedWhitespaceNodes = expandAliases(whitespace.nodes);
const expandedWhitespaceList = expandAliases(whitespace.list);
function find(obj, node, parent, printStack) {
  const fn = obj[node.type];
  return fn ? fn(node, parent, printStack) : null;
}
function isOrHasCallExpression(node) {
  if (t.isCallExpression(node)) {
    return true;
  }
  if (t.isMemberExpression(node)) {
    return (
      isOrHasCallExpression(node.object) ||
      (!node.computed && isOrHasCallExpression(node.property))
    );
  } else {
    return false;
  }
}
export function needsWhitespace(node, parent, type) {
  if (!node) return 0;
  if (t.isExpressionStatement(node)) {
    node = node.expression;
  }
  let linesInfo = find(expandedWhitespaceNodes, node, parent);
  if (!linesInfo) {
    const items = find(expandedWhitespaceList, node, parent);
    if (items) {
      for (let i = 0; i < items.length; i++) {
        linesInfo = needsWhitespace(items[i], node, type);
        if (linesInfo) break;
      }
    }
  }
  if (typeof linesInfo === "object" && linesInfo !== null) {
    return linesInfo[type] || 0;
  }
  return 0;
}
export function needsWhitespaceBefore(node, parent) {
  return needsWhitespace(node, parent, "before");
}
export function needsWhitespaceAfter(node, parent) {
  return needsWhitespace(node, parent, "after");
}
export function needsParens(node, parent, printStack) {
  if (!parent) return false;
  if (t.isNewExpression(parent) && parent.callee === node) {
    if (isOrHasCallExpression(node)) return true;
  }
  return find(expandedParens, node, parent, printStack);
}

// </from> /home/qfox/apps/babel/packages/babel-generator/src/node/index.js

// <from> /home/qfox/apps/babel/packages/babel-generator/src/node/whitespace.js

import * as t from "@babel/types";
type WhitespaceObject = {
  before?: boolean,
  after?: boolean,
};
/**
 * Crawl a node to test if it contains a CallExpression, a Function, or a Helper.
 *
 * @example
 * crawl(node)
 * // { hasCall: false, hasFunction: true, hasHelper: false }
 */
function crawl(node, state = {}) {
  if (t.isMemberExpression(node)) {
    crawl(node.object, state);
    if (node.computed) crawl(node.property, state);
  } else if (t.isBinary(node) || t.isAssignmentExpression(node)) {
    crawl(node.left, state);
    crawl(node.right, state);
  } else if (t.isCallExpression(node)) {
    state.hasCall = true;
    crawl(node.callee, state);
  } else if (t.isFunction(node)) {
    state.hasFunction = true;
  } else if (t.isIdentifier(node)) {
    state.hasHelper = state.hasHelper || isHelper(node.callee);
  }
  return state;
}
/**
 * Test if a node is or has a helper.
 */
function isHelper(node) {
  if (t.isMemberExpression(node)) {
    return isHelper(node.object) || isHelper(node.property);
  } else if (t.isIdentifier(node)) {
    return node.name === "require" || node.name[0] === "_";
  } else if (t.isCallExpression(node)) {
    return isHelper(node.callee);
  } else if (t.isBinary(node) || t.isAssignmentExpression(node)) {
    return (
      (t.isIdentifier(node.left) && isHelper(node.left)) || isHelper(node.right)
    );
  } else {
    return false;
  }
}
function isType(node) {
  return (
    t.isLiteral(node) ||
    t.isObjectExpression(node) ||
    t.isArrayExpression(node) ||
    t.isIdentifier(node) ||
    t.isMemberExpression(node)
  );
}
/**
 * Tests for node types that need whitespace.
 */
export const nodes = {
  /**
   * Test if AssignmentExpression needs whitespace.
   */
  AssignmentExpression(node: Object): ?WhitespaceObject {
    const state = crawl(node.right);
    if ((state.hasCall && state.hasHelper) || state.hasFunction) {
      return {
        before: state.hasFunction,
        after: true,
      };
    }
  },
  /**
   * Test if SwitchCase needs whitespace.
   */
  SwitchCase(node: Object, parent: Object): WhitespaceObject {
    return {
      before: node.consequent.length || parent.cases[0] === node,
      after:
        !node.consequent.length &&
        parent.cases[parent.cases.length - 1] === node,
    };
  },
  /**
   * Test if LogicalExpression needs whitespace.
   */
  LogicalExpression(node: Object): ?WhitespaceObject {
    if (t.isFunction(node.left) || t.isFunction(node.right)) {
      return {
        after: true,
      };
    }
  },
  /**
   * Test if Literal needs whitespace.
   */
  Literal(node: Object): ?WhitespaceObject {
    if (node.value === "use strict") {
      return {
        after: true,
      };
    }
  },
  /**
   * Test if CallExpression needs whitespace.
   */
  CallExpression(node: Object): ?WhitespaceObject {
    if (t.isFunction(node.callee) || isHelper(node)) {
      return {
        before: true,
        after: true,
      };
    }
  },
  /**
   * Test if VariableDeclaration needs whitespace.
   */
  VariableDeclaration(node: Object): ?WhitespaceObject {
    for (let i = 0; i < node.declarations.length; i++) {
      const declar = node.declarations[i];
      let enabled = isHelper(declar.id) && !isType(declar.init);
      if (!enabled) {
        const state = crawl(declar.init);
        enabled = (isHelper(declar.init) && state.hasCall) || state.hasFunction;
      }
      if (enabled) {
        return {
          before: true,
          after: true,
        };
      }
    }
  },
  /**
   * Test if IfStatement needs whitespace.
   */
  IfStatement(node: Object): ?WhitespaceObject {
    if (t.isBlockStatement(node.consequent)) {
      return {
        before: true,
        after: true,
      };
    }
  },
};
/**
 * Test if Property needs whitespace.
 */
nodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function(
  node: Object,
  parent,
): ?WhitespaceObject {
  if (parent.properties[0] === node) {
    return {
      before: true,
    };
  }
};
nodes.ObjectTypeCallProperty = function(
  node: Object,
  parent,
): ?WhitespaceObject {
  if (
    parent.callProperties[0] === node &&
    (!parent.properties || !parent.properties.length)
  ) {
    return {
      before: true,
    };
  }
};
nodes.ObjectTypeIndexer = function(node: Object, parent): ?WhitespaceObject {
  if (
    parent.indexers[0] === node &&
    (!parent.properties || !parent.properties.length) &&
    (!parent.callProperties || !parent.callProperties.length)
  ) {
    return {
      before: true,
    };
  }
};
nodes.ObjectTypeInternalSlot = function(
  node: Object,
  parent,
): ?WhitespaceObject {
  if (
    parent.internalSlots[0] === node &&
    (!parent.properties || !parent.properties.length) &&
    (!parent.callProperties || !parent.callProperties.length) &&
    (!parent.indexers || !parent.indexers.length)
  ) {
    return {
      before: true,
    };
  }
};
/**
 * Returns lists from node types that need whitespace.
 */
export const list = {
  /**
   * Return VariableDeclaration declarations init properties.
   */
  VariableDeclaration(node: Object): Array<Object> {
    return node.declarations.map(decl => decl.init);
  },
  /**
   * Return VariableDeclaration elements.
   */
  ArrayExpression(node: Object): Array<Object> {
    return node.elements;
  },
  /**
   * Return VariableDeclaration properties.
   */
  ObjectExpression(node: Object): Array<Object> {
    return node.properties;
  },
};
/**
 * Add whitespace tests for nodes and their aliases.
 */
[
  ["Function", true],
  ["Class", true],
  ["Loop", true],
  ["LabeledStatement", true],
  ["SwitchStatement", true],
  ["TryStatement", true],
].forEach(function([type, amounts]) {
  if (typeof amounts === "boolean") {
    amounts = { after: amounts, before: amounts };
  }
  [type].concat(t.FLIPPED_ALIAS_KEYS[type] || []).forEach(function(type) {
    nodes[type] = function() {
      return amounts;
    };
  });
});

// </from> /home/qfox/apps/babel/packages/babel-generator/src/node/whitespace.js

// <from> /home/qfox/apps/babel/packages/babel-generator/src/node/parentheses.js

import * as t from "@babel/types";
const PRECEDENCE = {
  "||": 0,
  "&&": 1,
  "|": 2,
  "^": 3,
  "&": 4,
  "==": 5,
  "===": 5,
  "!=": 5,
  "!==": 5,
  "<": 6,
  ">": 6,
  "<=": 6,
  ">=": 6,
  in: 6,
  instanceof: 6,
  ">>": 7,
  "<<": 7,
  ">>>": 7,
  "+": 8,
  "-": 8,
  "*": 9,
  "/": 9,
  "%": 9,
  "**": 10,
};
const isClassExtendsClause = (node: Object, parent: Object): boolean =>
  (t.isClassDeclaration(parent) || t.isClassExpression(parent)) &&
  parent.superClass === node;
export function NullableTypeAnnotation(node: Object, parent: Object): boolean {
  return t.isArrayTypeAnnotation(parent);
}
export { NullableTypeAnnotation as FunctionTypeAnnotation };
export function UpdateExpression(node: Object, parent: Object): boolean {
  return (
    // (foo++).test(), (foo++)[0]
    t.isMemberExpression(parent, { object: node }) ||
    // (foo++)()
    t.isCallExpression(parent, { callee: node }) ||
    // new (foo++)()
    t.isNewExpression(parent, { callee: node }) ||
    isClassExtendsClause(node, parent)
  );
}
export function ObjectExpression(
  node: Object,
  parent: Object,
  printStack: Array<Object>,
): boolean {
  return isFirstInStatement(printStack, { considerArrow: true });
}
export function DoExpression(
  node: Object,
  parent: Object,
  printStack: Array<Object>,
): boolean {
  return isFirstInStatement(printStack);
}
export function Binary(node: Object, parent: Object): boolean {
  if (
    node.operator === "**" &&
    t.isBinaryExpression(parent, { operator: "**" })
  ) {
    return parent.left === node;
  }
  if (isClassExtendsClause(node, parent)) {
    return true;
  }
  if (
    ((t.isCallExpression(parent) || t.isNewExpression(parent)) &&
      parent.callee === node) ||
    t.isUnaryLike(parent) ||
    (t.isMemberExpression(parent) && parent.object === node) ||
    t.isAwaitExpression(parent)
  ) {
    return true;
  }
  if (t.isBinary(parent)) {
    const parentOp = parent.operator;
    const parentPos = PRECEDENCE[parentOp];
    const nodeOp = node.operator;
    const nodePos = PRECEDENCE[nodeOp];
    if (
      // Logical expressions with the same precedence don't need parens.
      (parentPos === nodePos &&
        parent.right === node &&
        !t.isLogicalExpression(parent)) ||
      parentPos > nodePos
    ) {
      return true;
    }
  }
  return false;
}
export function UnionTypeAnnotation(node: Object, parent: Object): boolean {
  return (
    t.isArrayTypeAnnotation(parent) ||
    t.isNullableTypeAnnotation(parent) ||
    t.isIntersectionTypeAnnotation(parent) ||
    t.isUnionTypeAnnotation(parent)
  );
}
export { UnionTypeAnnotation as IntersectionTypeAnnotation };
export function TSAsExpression() {
  return true;
}
export function TSTypeAssertion() {
  return true;
}
export function BinaryExpression(node: Object, parent: Object): boolean {
  // let i = (1 in []);
  // for ((1 in []);;);
  return (
    node.operator === "in" &&
    (t.isVariableDeclarator(parent) || t.isFor(parent))
  );
}
export function SequenceExpression(node: Object, parent: Object): boolean {
  if (
    // Although parentheses wouldn"t hurt around sequence
    // expressions in the head of for loops, traditional style
    // dictates that e.g. i++, j++ should not be wrapped with
    // parentheses.
    t.isForStatement(parent) ||
    t.isThrowStatement(parent) ||
    t.isReturnStatement(parent) ||
    (t.isIfStatement(parent) && parent.test === node) ||
    (t.isWhileStatement(parent) && parent.test === node) ||
    (t.isForInStatement(parent) && parent.right === node) ||
    (t.isSwitchStatement(parent) && parent.discriminant === node) ||
    (t.isExpressionStatement(parent) && parent.expression === node)
  ) {
    return false;
  }
  // Otherwise err on the side of overparenthesization, adding
  // explicit exceptions above if this proves overzealous.
  return true;
}
export function YieldExpression(node: Object, parent: Object): boolean {
  return (
    t.isBinary(parent) ||
    t.isUnaryLike(parent) ||
    t.isCallExpression(parent) ||
    t.isMemberExpression(parent) ||
    t.isNewExpression(parent) ||
    (t.isConditionalExpression(parent) && node === parent.test) ||
    isClassExtendsClause(node, parent)
  );
}
export { YieldExpression as AwaitExpression };
export function ClassExpression(
  node: Object,
  parent: Object,
  printStack: Array<Object>,
): boolean {
  return isFirstInStatement(printStack, { considerDefaultExports: true });
}
export function UnaryLike(node: Object, parent: Object): boolean {
  return (
    t.isMemberExpression(parent, { object: node }) ||
    t.isCallExpression(parent, { callee: node }) ||
    t.isNewExpression(parent, { callee: node }) ||
    t.isBinaryExpression(parent, { operator: "**", left: node }) ||
    isClassExtendsClause(node, parent)
  );
}
export function FunctionExpression(
  node: Object,
  parent: Object,
  printStack: Array<Object>,
): boolean {
  return isFirstInStatement(printStack, { considerDefaultExports: true });
}
export function ArrowFunctionExpression(node: Object, parent: Object): boolean {
  return t.isExportDeclaration(parent) || ConditionalExpression(node, parent);
}
export function ConditionalExpression(node: Object, parent: Object): boolean {
  if (
    t.isUnaryLike(parent) ||
    t.isBinary(parent) ||
    t.isConditionalExpression(parent, { test: node }) ||
    t.isAwaitExpression(parent) ||
    t.isOptionalMemberExpression(parent) ||
    t.isTaggedTemplateExpression(parent) ||
    t.isTSTypeAssertion(parent) ||
    t.isTSAsExpression(parent)
  ) {
    return true;
  }
  return UnaryLike(node, parent);
}
export function OptionalMemberExpression(
  node: Object,
  parent: Object,
): boolean {
  return t.isCallExpression(parent) || t.isMemberExpression(parent);
}
export function AssignmentExpression(node: Object): boolean {
  if (t.isObjectPattern(node.left)) {
    return true;
  } else {
    return ConditionalExpression(...arguments);
  }
}
export function NewExpression(node: Object, parent: Object): boolean {
  return isClassExtendsClause(node, parent);
}
// Walk up the print stack to determine if our node can come first
// in statement.
function isFirstInStatement(
  printStack: Array<Object>,
  { considerArrow = false, considerDefaultExports = false } = {},
): boolean {
  let i = printStack.length - 1;
  let node = printStack[i];
  i--;
  let parent = printStack[i];
  while (i > 0) {
    if (
      t.isExpressionStatement(parent, { expression: node }) ||
      t.isTaggedTemplateExpression(parent) ||
      (considerDefaultExports &&
        t.isExportDefaultDeclaration(parent, { declaration: node })) ||
      (considerArrow && t.isArrowFunctionExpression(parent, { body: node }))
    ) {
      return true;
    }
    if (
      t.isCallExpression(parent, { callee: node }) ||
      (t.isSequenceExpression(parent) && parent.expressions[0] === node) ||
      t.isMemberExpression(parent, { object: node }) ||
      t.isConditional(parent, { test: node }) ||
      t.isBinary(parent, { left: node }) ||
      t.isAssignmentExpression(parent, { left: node })
    ) {
      node = parent;
      i--;
      parent = printStack[i];
    } else {
      return false;
    }
  }
  return false;
}

// </from> /home/qfox/apps/babel/packages/babel-generator/src/node/parentheses.js

// <from> /home/qfox/apps/babel/packages/babel-generator/scripts/generate-typescript-tests.js

/*
Copies tests from the @babel/parser's TypeScript test suite to @babel/generator.
*/
const {
  copySync,
  emptyDirSync,
  existsSync,
  readdirSync,
  readFileSync,
} = require("fs-extra");
const { join } = require("path");
const testsFrom = join(
  __dirname,
  "../../babel-parser/test/fixtures/typescript"
);
const testsTo = join(__dirname, "../test/fixtures/typescript");
emptyDirSync(testsTo);
copySync(join(testsFrom, "options.json"), join(testsTo, "options.json"));
for (const groupName of readdirSync(testsFrom)) {
  if (groupName === "options.json") continue;
  const groupFromDir = join(testsFrom, groupName);
  const testNames = readdirSync(groupFromDir);
  const groupHasOptions = testNames.includes("options.json");
  for (const testName of testNames) {
    if (testName === "options.json") {
      continue;
    }
    const testFromDir = join(groupFromDir, testName);
    const testToDir = join(testsTo, `${groupName}-${testName}`);
    let optionsJsonFrom;
    const ownOptions = join(testFromDir, "options.json");
    if (existsSync(ownOptions)) {
      const options = JSON.parse(readFileSync(ownOptions));
      // Don't include a test that doesn't parse or does not provide babel AST
      if (options.throws || options.plugins.indexOf("estree") >= 0) {
        continue;
      }
      optionsJsonFrom = ownOptions;
    } else if (groupHasOptions) {
      // Copy group options to each individual one, since we don't have groups here.
      optionsJsonFrom = join(groupFromDir, "options.json");
    }
    emptyDirSync(testToDir);
    if (optionsJsonFrom) {
      copySync(optionsJsonFrom, join(testToDir, "options.json"));
    }
    copySync(join(testFromDir, "actual.js"), join(testToDir, "actual.js"));
  }
}

// </from> /home/qfox/apps/babel/packages/babel-generator/scripts/generate-typescript-tests.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-block-scoped-functions/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import { types as t } from "@babel/core";
export default declare(api => {
  api.assertVersion(7);
  function statementList(key, path) {
    const paths: Array = path.get(key);
    for (const path of paths) {
      const func = path.node;
      if (!path.isFunctionDeclaration()) continue;
      const declar = t.variableDeclaration("let", [
        t.variableDeclarator(func.id, t.toExpression(func)),
      ]);
      // hoist it up above everything else
      declar._blockHoist = 2;
      // todo: name this
      func.id = null;
      path.replaceWith(declar);
    }
  }
  return {
    visitor: {
      BlockStatement(path) {
        const { node, parent } = path;
        if (
          t.isFunction(parent, { body: node }) ||
          t.isExportDeclaration(parent)
        ) {
          return;
        }
        statementList("body", path);
      },
      SwitchCase(path) {
        statementList("consequent", path);
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-block-scoped-functions/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-typeof-symbol/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import { types as t } from "@babel/core";
export default declare(api => {
  api.assertVersion(7);
  return {
    visitor: {
      Scope({ scope }) {
        if (!scope.getBinding("Symbol")) {
          return;
        }
        scope.rename("Symbol");
      },
      UnaryExpression(path) {
        const { node, parent } = path;
        if (node.operator !== "typeof") return;
        if (
          path.parentPath.isBinaryExpression() &&
          t.EQUALITY_BINARY_OPERATORS.indexOf(parent.operator) >= 0
        ) {
          // optimise `typeof foo === "string"` since we can determine that they'll never
          // need to handle symbols
          const opposite = path.getOpposite();
          if (
            opposite.isLiteral() &&
            opposite.node.value !== "symbol" &&
            opposite.node.value !== "object"
          ) {
            return;
          }
        }
        const helper = this.addHelper("typeof");
        const isUnderHelper = path.findParent(path => {
          return (
            (path.isVariableDeclarator() && path.node.id === helper) ||
            (path.isFunctionDeclaration() &&
              path.node.id &&
              path.node.id.name === helper.name)
          );
        });
        if (isUnderHelper) {
          return;
        }
        const call = t.callExpression(helper, [node.argument]);
        const arg = path.get("argument");
        if (arg.isIdentifier() && !path.scope.hasBinding(arg.node.name, true)) {
          const unary = t.unaryExpression("typeof", t.cloneNode(node.argument));
          path.replaceWith(
            t.conditionalExpression(
              t.binaryExpression("===", unary, t.stringLiteral("undefined")),
              t.stringLiteral("undefined"),
              call,
            ),
          );
        } else {
          path.replaceWith(call);
        }
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-typeof-symbol/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-property-literals/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import { types as t } from "@babel/core";
export default declare(api => {
  api.assertVersion(7);
  return {
    visitor: {
      ObjectProperty: {
        exit({ node }) {
          const key = node.key;
          if (
            !node.computed &&
            t.isIdentifier(key) &&
            !t.isValidES3Identifier(key.name)
          ) {
            // default: "bar" -> "default": "bar"
            node.key = t.stringLiteral(key.name);
          }
        },
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-property-literals/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-helper-regex/src/index.js

import pull from "lodash/pull";
export function is(node: Object, flag: string): boolean {
  return node.type === "RegExpLiteral" && node.flags.indexOf(flag) >= 0;
}
export function pullFlag(node: Object, flag: string) {
  const flags = node.flags.split("");
  if (node.flags.indexOf(flag) < 0) return;
  pull(flags, flag);
  node.flags = flags.join("");
}

// </from> /home/qfox/apps/babel/packages/babel-helper-regex/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-standalone/src/preset-stage-2.js

import presetStage3 from "./preset-stage-3";
import transformDecorators from "@babel/plugin-proposal-decorators";
import transformFunctionSent from "@babel/plugin-proposal-function-sent";
import transformExportNamespaceFrom from "@babel/plugin-proposal-export-namespace-from";
import transformNumericSeparator from "@babel/plugin-proposal-numeric-separator";
import transformThrowExpressions from "@babel/plugin-proposal-throw-expressions";
export default (_, opts = {}) => {
  const {
    loose = false,
    useBuiltIns = false,
    decoratorsLegacy = false,
    decoratorsBeforeExport,
  } = opts;
  return {
    presets: [[presetStage3, { loose, useBuiltIns }]],
    plugins: [
      [
        transformDecorators,
        { legacy: decoratorsLegacy, decoratorsBeforeExport },
      ],
      transformFunctionSent,
      transformExportNamespaceFrom,
      transformNumericSeparator,
      transformThrowExpressions,
    ],
  };
};

// </from> /home/qfox/apps/babel/packages/babel-standalone/src/preset-stage-2.js

// <from> /home/qfox/apps/babel/packages/babel-standalone/src/index.js

/**
 * Entry point for @babel/standalone. This wraps Babel's API in a version that's
 * friendlier for use in web browers. It removes the automagical detection of
 * plugins, instead explicitly registering all the available plugins and
 * presets, and requiring custom ones to be registered through `registerPlugin`
 * and `registerPreset` respectively.
 */
/* global VERSION */
/* eslint-disable max-len */
import * as Babel from "@babel/core";
import { runScripts } from "./transformScriptTags";
const isArray =
  Array.isArray ||
  (arg => Object.prototype.toString.call(arg) === "[object Array]");
/**
 * Loads the given name (or [name, options] pair) from the given table object
 * holding the available presets or plugins.
 *
 * Returns undefined if the preset or plugin is not available; passes through
 * name unmodified if it (or the first element of the pair) is not a string.
 */
function loadBuiltin(builtinTable, name) {
  if (isArray(name) && typeof name[0] === "string") {
    if (builtinTable.hasOwnProperty(name[0])) {
      return [builtinTable[name[0]]].concat(name.slice(1));
    }
    return;
  } else if (typeof name === "string") {
    return builtinTable[name];
  }
  // Could be an actual preset/plugin module
  return name;
}
/**
 * Parses plugin names and presets from the specified options.
 */
function processOptions(options) {
  // Parse preset names
  const presets = (options.presets || []).map(presetName => {
    const preset = loadBuiltin(availablePresets, presetName);
    if (preset) {
      // workaround for babel issue
      // at some point, babel copies the preset, losing the non-enumerable
      // buildPreset key; convert it into an enumerable key.
      if (
        isArray(preset) &&
        typeof preset[0] === "object" &&
        preset[0].hasOwnProperty("buildPreset")
      ) {
        preset[0] = { ...preset[0], buildPreset: preset[0].buildPreset };
      }
    } else {
      throw new Error(
        `Invalid preset specified in Babel options: "${presetName}"`,
      );
    }
    return preset;
  });
  // Parse plugin names
  const plugins = (options.plugins || []).map(pluginName => {
    const plugin = loadBuiltin(availablePlugins, pluginName);
    if (!plugin) {
      throw new Error(
        `Invalid plugin specified in Babel options: "${pluginName}"`,
      );
    }
    return plugin;
  });
  return {
    babelrc: false,
    ...options,
    presets,
    plugins,
  };
}
export function transform(code, options) {
  return Babel.transform(code, processOptions(options));
}
export function transformFromAst(ast, code, options) {
  return Babel.transformFromAst(ast, code, processOptions(options));
}
export const availablePlugins = {};
export const availablePresets = {};
export const buildExternalHelpers = Babel.buildExternalHelpers;
/**
 * Registers a named plugin for use with Babel.
 */
export function registerPlugin(name, plugin) {
  if (availablePlugins.hasOwnProperty(name)) {
    console.warn(
      `A plugin named "${name}" is already registered, it will be overridden`,
    );
  }
  availablePlugins[name] = plugin;
}
/**
 * Registers multiple plugins for use with Babel. `newPlugins` should be an object where the key
 * is the name of the plugin, and the value is the plugin itself.
 */
export function registerPlugins(newPlugins) {
  Object.keys(newPlugins).forEach(name =>
    registerPlugin(name, newPlugins[name]),
  );
}
/**
 * Registers a named preset for use with Babel.
 */
export function registerPreset(name, preset) {
  if (availablePresets.hasOwnProperty(name)) {
    console.warn(
      `A preset named "${name}" is already registered, it will be overridden`,
    );
  }
  availablePresets[name] = preset;
}
/**
 * Registers multiple presets for use with Babel. `newPresets` should be an object where the key
 * is the name of the preset, and the value is the preset itself.
 */
export function registerPresets(newPresets) {
  Object.keys(newPresets).forEach(name =>
    registerPreset(name, newPresets[name]),
  );
}
// All the plugins we should bundle
// Want to get rid of this long whitelist of plugins?
// Wait! Please read https://github.com/babel/babel/pull/6177 first.
registerPlugins({
  "external-helpers": require("@babel/plugin-external-helpers"),
  "syntax-async-generators": require("@babel/plugin-syntax-async-generators"),
  "syntax-class-properties": require("@babel/plugin-syntax-class-properties"),
  "syntax-decorators": require("@babel/plugin-syntax-decorators"),
  "syntax-do-expressions": require("@babel/plugin-syntax-do-expressions"),
  "syntax-dynamic-import": require("@babel/plugin-syntax-dynamic-import"),
  "syntax-export-default-from": require("@babel/plugin-syntax-export-default-from"),
  "syntax-export-namespace-from": require("@babel/plugin-syntax-export-namespace-from"),
  "syntax-flow": require("@babel/plugin-syntax-flow"),
  "syntax-function-bind": require("@babel/plugin-syntax-function-bind"),
  "syntax-function-sent": require("@babel/plugin-syntax-function-sent"),
  "syntax-import-meta": require("@babel/plugin-syntax-import-meta"),
  "syntax-jsx": require("@babel/plugin-syntax-jsx"),
  "syntax-object-rest-spread": require("@babel/plugin-syntax-object-rest-spread"),
  "syntax-optional-catch-binding": require("@babel/plugin-syntax-optional-catch-binding"),
  "syntax-pipeline-operator": require("@babel/plugin-syntax-pipeline-operator"),
  "syntax-typescript": require("@babel/plugin-syntax-typescript"),
  "transform-async-to-generator": require("@babel/plugin-transform-async-to-generator"),
  "proposal-async-generator-functions": require("@babel/plugin-proposal-async-generator-functions"),
  "proposal-class-properties": require("@babel/plugin-proposal-class-properties"),
  "proposal-decorators": require("@babel/plugin-proposal-decorators"),
  "proposal-do-expressions": require("@babel/plugin-proposal-do-expressions"),
  "proposal-export-default-from": require("@babel/plugin-proposal-export-default-from"),
  "proposal-export-namespace-from": require("@babel/plugin-proposal-export-namespace-from"),
  "proposal-pipeline-operator": require("@babel/plugin-proposal-pipeline-operator"),
  "transform-arrow-functions": require("@babel/plugin-transform-arrow-functions"),
  "transform-block-scoped-functions": require("@babel/plugin-transform-block-scoped-functions"),
  "transform-block-scoping": require("@babel/plugin-transform-block-scoping"),
  "transform-classes": require("@babel/plugin-transform-classes"),
  "transform-computed-properties": require("@babel/plugin-transform-computed-properties"),
  "transform-destructuring": require("@babel/plugin-transform-destructuring"),
  "transform-dotall-regex": require("@babel/plugin-transform-dotall-regex"),
  "transform-duplicate-keys": require("@babel/plugin-transform-duplicate-keys"),
  "transform-for-of": require("@babel/plugin-transform-for-of"),
  "transform-function-name": require("@babel/plugin-transform-function-name"),
  "transform-instanceof": require("@babel/plugin-transform-instanceof"),
  "transform-literals": require("@babel/plugin-transform-literals"),
  "transform-modules-amd": require("@babel/plugin-transform-modules-amd"),
  "transform-modules-commonjs": require("@babel/plugin-transform-modules-commonjs"),
  "transform-modules-systemjs": require("@babel/plugin-transform-modules-systemjs"),
  "transform-modules-umd": require("@babel/plugin-transform-modules-umd"),
  "transform-object-super": require("@babel/plugin-transform-object-super"),
  "transform-parameters": require("@babel/plugin-transform-parameters"),
  "transform-shorthand-properties": require("@babel/plugin-transform-shorthand-properties"),
  "transform-spread": require("@babel/plugin-transform-spread"),
  "transform-sticky-regex": require("@babel/plugin-transform-sticky-regex"),
  "transform-template-literals": require("@babel/plugin-transform-template-literals"),
  "transform-typeof-symbol": require("@babel/plugin-transform-typeof-symbol"),
  "transform-typescript": require("@babel/plugin-transform-typescript"),
  "transform-unicode-regex": require("@babel/plugin-transform-unicode-regex"),
  "transform-member-expression-literals": require("@babel/plugin-transform-member-expression-literals"),
  "transform-property-literals": require("@babel/plugin-transform-property-literals"),
  "transform-property-mutators": require("@babel/plugin-transform-property-mutators"),
  "transform-exponentiation-operator": require("@babel/plugin-transform-exponentiation-operator"),
  "transform-flow-comments": require("@babel/plugin-transform-flow-comments"),
  "transform-flow-strip-types": require("@babel/plugin-transform-flow-strip-types"),
  "proposal-function-bind": require("@babel/plugin-proposal-function-bind"),
  "transform-jscript": require("@babel/plugin-transform-jscript"),
  "transform-new-target": require("@babel/plugin-transform-new-target"),
  "transform-object-assign": require("@babel/plugin-transform-object-assign"),
  "proposal-object-rest-spread": require("@babel/plugin-proposal-object-rest-spread"),
  "transform-object-set-prototype-of-to-assign": require("@babel/plugin-transform-object-set-prototype-of-to-assign"),
  "proposal-optional-catch-binding": require("@babel/plugin-proposal-optional-catch-binding"),
  "transform-proto-to-assign": require("@babel/plugin-transform-proto-to-assign"),
  "transform-react-constant-elements": require("@babel/plugin-transform-react-constant-elements"),
  "transform-react-display-name": require("@babel/plugin-transform-react-display-name"),
  "transform-react-inline-elements": require("@babel/plugin-transform-react-inline-elements"),
  "transform-react-jsx": require("@babel/plugin-transform-react-jsx"),
  "transform-react-jsx-compat": require("@babel/plugin-transform-react-jsx-compat"),
  "transform-react-jsx-self": require("@babel/plugin-transform-react-jsx-self"),
  "transform-react-jsx-source": require("@babel/plugin-transform-react-jsx-source"),
  "transform-regenerator": require("@babel/plugin-transform-regenerator"),
  "transform-runtime": require("@babel/plugin-transform-runtime"),
  "transform-strict-mode": require("@babel/plugin-transform-strict-mode"),
  "proposal-unicode-property-regex": require("@babel/plugin-proposal-unicode-property-regex"),
});
// All the presets we should bundle
// Want to get rid of this whitelist of presets?
// Wait! Please read https://github.com/babel/babel/pull/6177 first.
registerPresets({
  es2015: require("./preset-es2015"),
  es2016: () => {
    return {
      plugins: [availablePlugins["transform-exponentiation-operator"]],
    };
  },
  es2017: () => {
    return {
      plugins: [availablePlugins["transform-async-to-generator"]],
    };
  },
  react: require("@babel/preset-react"),
  "stage-0": require("./preset-stage-0"),
  "stage-1": require("./preset-stage-1"),
  "stage-2": require("./preset-stage-2"),
  "stage-3": require("./preset-stage-3"),
  "es2015-loose": {
    presets: [[require("./preset-es2015"), { loose: true }]],
  },
  // ES2015 preset with es2015-modules-commonjs removed
  "es2015-no-commonjs": {
    presets: [[require("./preset-es2015"), { modules: false }]],
  },
  typescript: require("@babel/preset-typescript"),
  flow: require("@babel/preset-flow"),
});
export const version = VERSION;
function onDOMContentLoaded() {
  transformScriptTags();
}
// Listen for load event if we're in a browser and then kick off finding and
// running of scripts with "text/babel" type.
if (typeof window !== "undefined" && window && window.addEventListener) {
  window.addEventListener("DOMContentLoaded", onDOMContentLoaded, false);
}
/**
 * Transform <script> tags with "text/babel" type.
 * @param {Array} scriptTags specify script tags to transform, transform all in the <head> if not given
 */
export function transformScriptTags(scriptTags) {
  runScripts(transform, scriptTags);
}
/**
 * Disables automatic transformation of <script> tags with "text/babel" type.
 */
export function disableScriptTags() {
  window.removeEventListener("DOMContentLoaded", onDOMContentLoaded);
}

// </from> /home/qfox/apps/babel/packages/babel-standalone/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-standalone/src/preset-stage-3.js

import syntaxDynamicImport from "@babel/plugin-syntax-dynamic-import";
import syntaxImportMeta from "@babel/plugin-syntax-import-meta";
import transformClassProperties from "@babel/plugin-proposal-class-properties";
import transformJsonStrings from "@babel/plugin-proposal-json-strings";
export default (_, opts) => {
  let loose = false;
  if (opts !== undefined) {
    if (opts.loose !== undefined) loose = opts.loose;
  }
  return {
    plugins: [
      syntaxDynamicImport,
      syntaxImportMeta,
      [transformClassProperties, { loose }],
      transformJsonStrings,
    ],
  };
};

// </from> /home/qfox/apps/babel/packages/babel-standalone/src/preset-stage-3.js

// <from> /home/qfox/apps/babel/packages/babel-standalone/src/preset-stage-1.js

import presetStage2 from "./preset-stage-2";
import transformExportDefaultFrom from "@babel/plugin-proposal-export-default-from";
import transformLogicalAssignmentOperators from "@babel/plugin-proposal-logical-assignment-operators";
import transformOptionalChaining from "@babel/plugin-proposal-optional-chaining";
import transformPipelineOperator from "@babel/plugin-proposal-pipeline-operator";
import transformNullishCoalescingOperator from "@babel/plugin-proposal-nullish-coalescing-operator";
import transformDoExpressions from "@babel/plugin-proposal-do-expressions";
export default (_, opts = {}) => {
  const {
    loose = false,
    useBuiltIns = false,
    decoratorsLegacy = false,
    decoratorsBeforeExport,
    pipelineProposal = "minimal",
  } = opts;
  return {
    presets: [
      [
        presetStage2,
        { loose, useBuiltIns, decoratorsLegacy, decoratorsBeforeExport },
      ],
    ],
    plugins: [
      transformExportDefaultFrom,
      transformLogicalAssignmentOperators,
      [transformOptionalChaining, { loose }],
      [transformPipelineOperator, { proposal: pipelineProposal }],
      [transformNullishCoalescingOperator, { loose }],
      transformDoExpressions,
    ],
  };
};

// </from> /home/qfox/apps/babel/packages/babel-standalone/src/preset-stage-1.js

// <from> /home/qfox/apps/babel/packages/babel-standalone/src/preset-stage-0.js

import presetStage1 from "./preset-stage-1";
import transformFunctionBind from "@babel/plugin-proposal-function-bind";
export default (_, opts = {}) => {
  const {
    loose = false,
    useBuiltIns = false,
    decoratorsLegacy = false,
    decoratorsBeforeExport,
    pipelineProposal = "minimal",
  } = opts;
  return {
    presets: [
      [
        presetStage1,
        {
          loose,
          useBuiltIns,
          decoratorsLegacy,
          decoratorsBeforeExport,
          pipelineProposal,
        },
      ],
    ],
    plugins: [transformFunctionBind],
  };
};

// </from> /home/qfox/apps/babel/packages/babel-standalone/src/preset-stage-0.js

// <from> /home/qfox/apps/babel/packages/babel-standalone/src/babel-package-shim.js

/**
 * A shim that replaces Babel's require('package.json') statement.
 * Babel requires the entire package.json file just to get the version number.
 */
/* global BABEL_VERSION */
export const version = BABEL_VERSION;

// </from> /home/qfox/apps/babel/packages/babel-standalone/src/babel-package-shim.js

// <from> /home/qfox/apps/babel/packages/babel-standalone/src/transformScriptTags.js

/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of the React source tree.
 */
const scriptTypes = ["text/jsx", "text/babel"];
let headEl;
let inlineScriptCount = 0;
/**
 * Actually transform the code.
 */
function transformCode(transformFn, script) {
  let source;
  if (script.url != null) {
    source = script.url;
  } else {
    source = "Inline Babel script";
    inlineScriptCount++;
    if (inlineScriptCount > 1) {
      source += " (" + inlineScriptCount + ")";
    }
  }
  return transformFn(script.content, {
    filename: source,
    ...buildBabelOptions(script),
  }).code;
}
/**
 * Builds the Babel options for transforming the specified script, using some
 * sensible default presets and plugins if none were explicitly provided.
 */
function buildBabelOptions(script) {
  return {
    presets: script.presets || ["react", "es2015"],
    plugins: script.plugins || [
      "proposal-class-properties",
      "proposal-object-rest-spread",
      "transform-flow-strip-types",
    ],
    sourceMaps: "inline",
  };
}
/**
 * Appends a script element at the end of the <head> with the content of code,
 * after transforming it.
 */
function run(transformFn, script) {
  const scriptEl = document.createElement("script");
  scriptEl.text = transformCode(transformFn, script);
  headEl.appendChild(scriptEl);
}
/**
 * Load script from the provided url and pass the content to the callback.
 */
function load(url, successCallback, errorCallback) {
  const xhr = new XMLHttpRequest();
  // async, however scripts will be executed in the order they are in the
  // DOM to mirror normal script loading.
  xhr.open("GET", url, true);
  if ("overrideMimeType" in xhr) {
    xhr.overrideMimeType("text/plain");
  }
  xhr.onreadystatechange = function() {
    if (xhr.readyState === 4) {
      if (xhr.status === 0 || xhr.status === 200) {
        successCallback(xhr.responseText);
      } else {
        errorCallback();
        throw new Error("Could not load " + url);
      }
    }
  };
  return xhr.send(null);
}
/**
 * Converts a comma-separated data attribute string into an array of values. If
 * the string is empty, returns an empty array. If the string is not defined,
 * returns null.
 */
function getPluginsOrPresetsFromScript(script, attributeName) {
  const rawValue = script.getAttribute(attributeName);
  if (rawValue === "") {
    // Empty string means to not load ANY presets or plugins
    return [];
  }
  if (!rawValue) {
    // Any other falsy value (null, undefined) means we're not overriding this
    // setting, and should use the default.
    return null;
  }
  return rawValue.split(",").map(item => item.trim());
}
/**
 * Loop over provided script tags and get the content, via innerHTML if an
 * inline script, or by using XHR. Transforms are applied if needed. The scripts
 * are executed in the order they are found on the page.
 */
function loadScripts(transformFn, scripts) {
  const result = [];
  const count = scripts.length;
  function check() {
    let script, i;
    for (i = 0; i < count; i++) {
      script = result[i];
      if (script.loaded && !script.executed) {
        script.executed = true;
        run(transformFn, script);
      } else if (!script.loaded && !script.error && !script.async) {
        break;
      }
    }
  }
  scripts.forEach((script, i) => {
    const scriptData = {
      // script.async is always true for non-JavaScript script tags
      async: script.hasAttribute("async"),
      error: false,
      executed: false,
      plugins: getPluginsOrPresetsFromScript(script, "data-plugins"),
      presets: getPluginsOrPresetsFromScript(script, "data-presets"),
    };
    if (script.src) {
      result[i] = {
        ...scriptData,
        content: null,
        loaded: false,
        url: script.src,
      };
      load(
        script.src,
        content => {
          result[i].loaded = true;
          result[i].content = content;
          check();
        },
        () => {
          result[i].error = true;
          check();
        },
      );
    } else {
      result[i] = {
        ...scriptData,
        content: script.innerHTML,
        loaded: true,
        url: script.getAttribute("data-module") || null,
      };
    }
  });
  check();
}
/**
 * Run script tags with type="text/jsx".
 * @param {Array} scriptTags specify script tags to run, run all in the <head> if not given
 */
export function runScripts(transformFn, scripts) {
  headEl = document.getElementsByTagName("head")[0];
  if (!scripts) {
    scripts = document.getElementsByTagName("script");
  }
  // Array.prototype.slice cannot be used on NodeList on IE8
  const jsxScripts = [];
  for (let i = 0; i < scripts.length; i++) {
    const script = scripts.item(i);
    // Support the old type="text/jsx;harmony=true"
    const type = script.type.split(";")[0];
    if (scriptTypes.indexOf(type) !== -1) {
      jsxScripts.push(script);
    }
  }
  if (jsxScripts.length === 0) {
    return;
  }
  console.warn(
    "You are using the in-browser Babel transformer. Be sure to precompile " +
      "your scripts for production - https://babeljs.io/docs/setup/",
  );
  loadScripts(transformFn, jsxScripts);
}

// </from> /home/qfox/apps/babel/packages/babel-standalone/src/transformScriptTags.js

// <from> /home/qfox/apps/babel/packages/babel-standalone/src/preset-es2015.js

import transformES2015TemplateLiterals from "@babel/plugin-transform-template-literals";
import transformES2015Literals from "@babel/plugin-transform-literals";
import transformES2015FunctionName from "@babel/plugin-transform-function-name";
import transformES2015ArrowFunctions from "@babel/plugin-transform-arrow-functions";
import transformES2015BlockScopedFunctions from "@babel/plugin-transform-block-scoped-functions";
import transformES2015Classes from "@babel/plugin-transform-classes";
import transformES2015ObjectSuper from "@babel/plugin-transform-object-super";
import transformES2015ShorthandProperties from "@babel/plugin-transform-shorthand-properties";
import transformES2015DuplicateKeys from "@babel/plugin-transform-duplicate-keys";
import transformES2015ComputedProperties from "@babel/plugin-transform-computed-properties";
import transformES2015ForOf from "@babel/plugin-transform-for-of";
import transformES2015StickyRegex from "@babel/plugin-transform-sticky-regex";
import transformES2015UnicodeRegex from "@babel/plugin-transform-unicode-regex";
import transformES2015Spread from "@babel/plugin-transform-spread";
import transformES2015Parameters from "@babel/plugin-transform-parameters";
import transformES2015Destructuring from "@babel/plugin-transform-destructuring";
import transformES2015BlockScoping from "@babel/plugin-transform-block-scoping";
import transformES2015TypeofSymbol from "@babel/plugin-transform-typeof-symbol";
import transformES2015ModulesCommonJS from "@babel/plugin-transform-modules-commonjs";
import transformES2015ModulesSystemJS from "@babel/plugin-transform-modules-systemjs";
import transformES2015ModulesAMD from "@babel/plugin-transform-modules-amd";
import transformES2015ModulesUMD from "@babel/plugin-transform-modules-umd";
import transformES2015Instanceof from "@babel/plugin-transform-instanceof";
import transformRegenerator from "@babel/plugin-transform-regenerator";
export default (_, opts) => {
  let loose = false;
  let modules = "commonjs";
  let spec = false;
  if (opts !== undefined) {
    if (opts.loose !== undefined) loose = opts.loose;
    if (opts.modules !== undefined) modules = opts.modules;
    if (opts.spec !== undefined) spec = opts.spec;
  }
  // be DRY
  const optsLoose = { loose };
  return {
    plugins: [
      [transformES2015TemplateLiterals, { loose, spec }],
      transformES2015Literals,
      transformES2015FunctionName,
      [transformES2015ArrowFunctions, { spec }],
      transformES2015BlockScopedFunctions,
      [transformES2015Classes, optsLoose],
      transformES2015ObjectSuper,
      transformES2015ShorthandProperties,
      transformES2015DuplicateKeys,
      [transformES2015ComputedProperties, optsLoose],
      [transformES2015ForOf, optsLoose],
      transformES2015StickyRegex,
      transformES2015UnicodeRegex,
      [transformES2015Spread, optsLoose],
      [transformES2015Parameters, optsLoose],
      [transformES2015Destructuring, optsLoose],
      transformES2015BlockScoping,
      transformES2015TypeofSymbol,
      transformES2015Instanceof,
      (modules === "commonjs" || modules === "cjs") && [
        transformES2015ModulesCommonJS,
        optsLoose,
      ],
      modules === "systemjs" && [transformES2015ModulesSystemJS, optsLoose],
      modules === "amd" && [transformES2015ModulesAMD, optsLoose],
      modules === "umd" && [transformES2015ModulesUMD, optsLoose],
      [transformRegenerator, { async: false, asyncGenerators: false }],
    ].filter(Boolean), // filter out falsy values
  };
};

// </from> /home/qfox/apps/babel/packages/babel-standalone/src/preset-es2015.js

// <from> /home/qfox/apps/babel/packages/babel-standalone/examples/example.js

/* global Babel */
const doStuff = () => {
  const name = "world";
  document.getElementById("output").innerHTML = `Hello ${name}`;
  document.getElementById("version").innerHTML = Babel.version;
};
doStuff();

// </from> /home/qfox/apps/babel/packages/babel-standalone/examples/example.js

// <from> /home/qfox/apps/babel/packages/babel-preset-env/src/defaults.js

const defaultWebIncludes = ["web.timers", "web.immediate", "web.dom.iterable"];
const defaultExcludesForLooseMode = ["transform-typeof-symbol"];
export const getPlatformSpecificDefaultFor = (
  targets: Targets,
): ?Array<string> => {
  const targetNames = Object.keys(targets);
  const isAnyTarget = !targetNames.length;
  const isWebTarget = targetNames.some(name => name !== "node");
  return isAnyTarget || isWebTarget ? defaultWebIncludes : null;
};
export const getOptionSpecificExcludesFor = ({
  loose,
}: {
  loose: boolean,
}): ?Array<string> => {
  if (loose) {
    return defaultExcludesForLooseMode;
  }
  return null;
};

// </from> /home/qfox/apps/babel/packages/babel-preset-env/src/defaults.js

// <from> /home/qfox/apps/babel/packages/babel-preset-env/src/index.js

//@flow
import semver from "semver";
import builtInsList from "../data/built-ins.json";
import { logPlugin } from "./debug";
import {
  getPlatformSpecificDefaultFor,
  getOptionSpecificExcludesFor,
} from "./defaults";
import moduleTransformations from "./module-transformations";
import normalizeOptions from "./normalize-options.js";
import pluginList from "../data/plugins.json";
import {
  builtIns as proposalBuiltIns,
  features as proposalPlugins,
  pluginSyntaxMap,
} from "../data/shipped-proposals.js";
import useBuiltInsEntryPlugin from "./use-built-ins-entry-plugin";
import addUsedBuiltInsPlugin from "./use-built-ins-plugin";
import getTargets from "./targets-parser";
import availablePlugins from "./available-plugins";
import {
  filterStageFromList,
  prettifyTargets,
  semverify,
  isUnreleasedVersion,
} from "./utils";
import { declare } from "@babel/helper-plugin-utils";
const getPlugin = (pluginName: string) => {
  const plugin = availablePlugins[pluginName];
  if (!plugin) {
    throw new Error(
      `Could not find plugin "${pluginName}". Ensure there is an entry in ./available-plugins.js for it.`,
    );
  }
  return plugin;
};
const builtInsListWithoutProposals = filterStageFromList(
  builtInsList,
  proposalBuiltIns,
);
const pluginListWithoutProposals = filterStageFromList(
  pluginList,
  proposalPlugins,
);
export const isPluginRequired = (
  supportedEnvironments: Targets,
  plugin: Targets,
): boolean => {
  const targetEnvironments: Array<string> = Object.keys(supportedEnvironments);
  if (targetEnvironments.length === 0) {
    return true;
  }
  const isRequiredForEnvironments: Array<string> = targetEnvironments.filter(
    environment => {
      // Feature is not implemented in that environment
      if (!plugin[environment]) {
        return true;
      }
      const lowestImplementedVersion: string = plugin[environment];
      const lowestTargetedVersion: string = supportedEnvironments[environment];
      // If targets has unreleased value as a lowest version, then don't require a plugin.
      if (isUnreleasedVersion(lowestTargetedVersion, environment)) {
        return false;
        // Include plugin if it is supported in the unreleased environment, which wasn't specified in targets
      } else if (isUnreleasedVersion(lowestImplementedVersion, environment)) {
        return true;
      }
      if (!semver.valid(lowestTargetedVersion)) {
        throw new Error(
          `Invalid version passed for target "${environment}": "${lowestTargetedVersion}". ` +
            "Versions must be in semver format (major.minor.patch)",
        );
      }
      return semver.gt(
        semverify(lowestImplementedVersion),
        lowestTargetedVersion,
      );
    },
  );
  return isRequiredForEnvironments.length > 0;
};
const getBuiltInTargets = targets => {
  const builtInTargets = {
    ...targets,
  };
  if (builtInTargets.uglify != null) {
    delete builtInTargets.uglify;
  }
  return builtInTargets;
};
export const transformIncludesAndExcludes = (opts: Array<string>): Object => {
  return opts.reduce(
    (result, opt) => {
      const target = opt.match(/^(es\d+|web)\./) ? "builtIns" : "plugins";
      result[target].add(opt);
      return result;
    },
    {
      all: opts,
      plugins: new Set(),
      builtIns: new Set(),
    },
  );
};
const filterItems = (
  list,
  includes,
  excludes,
  targets,
  defaultIncludes,
  defaultExcludes,
): Set<string> => {
  const result = new Set();
  for (const item in list) {
    if (
      !excludes.has(item) &&
      (isPluginRequired(targets, list[item]) || includes.has(item))
    ) {
      result.add(item);
    } else {
      const shippedProposalsSyntax = pluginSyntaxMap.get(item);
      if (shippedProposalsSyntax) {
        result.add(shippedProposalsSyntax);
      }
    }
  }
  if (defaultIncludes) {
    defaultIncludes.forEach(item => !excludes.has(item) && result.add(item));
  }
  if (defaultExcludes) {
    defaultExcludes.forEach(item => !includes.has(item) && result.delete(item));
  }
  return result;
};
function supportsStaticESM(caller) {
  return !!(caller && caller.supportsStaticESM);
}
export default declare((api, opts) => {
  api.assertVersion(7);
  const {
    configPath,
    debug,
    exclude: optionsExclude,
    forceAllTransforms,
    ignoreBrowserslistConfig,
    include: optionsInclude,
    loose,
    modules,
    shippedProposals,
    spec,
    targets: optionsTargets,
    useBuiltIns,
  } = normalizeOptions(opts);
  // TODO: remove this in next major
  let hasUglifyTarget = false;
  if (optionsTargets && optionsTargets.uglify) {
    hasUglifyTarget = true;
    delete optionsTargets.uglify;
    console.log("");
    console.log("The uglify target has been deprecated. Set the top level");
    console.log("option `forceAllTransforms: true` instead.");
    console.log("");
  }
  if (optionsTargets && optionsTargets.esmodules && optionsTargets.browsers) {
    console.log("");
    console.log(
      "@babel/preset-env: esmodules and browsers targets have been specified together.",
    );
    console.log(
      `\`browsers\` target, \`${optionsTargets.browsers}\` will be ignored.`,
    );
    console.log("");
  }
  const targets = getTargets(optionsTargets, {
    ignoreBrowserslistConfig,
    configPath,
  });
  const include = transformIncludesAndExcludes(optionsInclude);
  const exclude = transformIncludesAndExcludes(optionsExclude);
  const transformTargets = forceAllTransforms || hasUglifyTarget ? {} : targets;
  const transformations = filterItems(
    shippedProposals ? pluginList : pluginListWithoutProposals,
    include.plugins,
    exclude.plugins,
    transformTargets,
    null,
    getOptionSpecificExcludesFor({ loose }),
  );
  let polyfills;
  let polyfillTargets;
  if (useBuiltIns) {
    polyfillTargets = getBuiltInTargets(targets);
    polyfills = filterItems(
      shippedProposals ? builtInsList : builtInsListWithoutProposals,
      include.builtIns,
      exclude.builtIns,
      polyfillTargets,
      getPlatformSpecificDefaultFor(polyfillTargets),
    );
  }
  const plugins = [];
  const pluginUseBuiltIns = useBuiltIns !== false;
  if (
    modules !== false &&
    moduleTransformations[modules] &&
    // TODO: Remove the 'api.caller' check eventually. Just here to prevent
    // unnecessary breakage in the short term for users on older betas/RCs.
    (modules !== "auto" || !api.caller || !api.caller(supportsStaticESM))
  ) {
    // NOTE: not giving spec here yet to avoid compatibility issues when
    // transform-modules-commonjs gets its spec mode
    plugins.push([getPlugin(moduleTransformations[modules]), { loose }]);
  }
  transformations.forEach(pluginName =>
    plugins.push([
      getPlugin(pluginName),
      { spec, loose, useBuiltIns: pluginUseBuiltIns },
    ]),
  );
  const regenerator = transformations.has("transform-regenerator");
  if (debug) {
    console.log("@babel/preset-env: `DEBUG` option");
    console.log("\nUsing targets:");
    console.log(JSON.stringify(prettifyTargets(targets), null, 2));
    console.log(`\nUsing modules transform: ${modules.toString()}`);
    console.log("\nUsing plugins:");
    transformations.forEach(transform => {
      logPlugin(transform, targets, pluginList);
    });
    if (!useBuiltIns) {
      console.log(
        "\nUsing polyfills: No polyfills were added, since the `useBuiltIns` option was not set.",
      );
    } else {
      console.log(
        `
Using polyfills with \`${useBuiltIns}\` option:`,
      );
    }
  }
  if (useBuiltIns === "usage" || useBuiltIns === "entry") {
    const pluginOptions = {
      debug,
      polyfills,
      regenerator,
      onDebug: (polyfills, context) => {
        polyfills.forEach(polyfill =>
          logPlugin(polyfill, polyfillTargets, builtInsList, context),
        );
      },
    };
    plugins.push([
      useBuiltIns === "usage" ? addUsedBuiltInsPlugin : useBuiltInsEntryPlugin,
      pluginOptions,
    ]);
  }
  return {
    plugins,
  };
});

// </from> /home/qfox/apps/babel/packages/babel-preset-env/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-preset-env/src/debug.js

/*eslint quotes: ["error", "double", { "avoidEscape": true }]*/
import semver from "semver";
import { isUnreleasedVersion, prettifyVersion, semverify } from "./utils";
const wordEnds = size => {
  return size > 1 ? "s" : "";
};
export const logMessage = (message, context) => {
  const pre = context ? `[${context}] ` : "";
  const logStr = `  ${pre}${message}`;
  console.log(logStr);
};
// Outputs a message that shows which target(s) caused an item to be included:
// transform-foo { "edge":"13", "firefox":"49", "ie":"10" }
export const logPlugin = (item, targetVersions, list, context) => {
  const minVersions = list[item] || {};
  const filteredList = Object.keys(targetVersions).reduce((result, env) => {
    const minVersion = minVersions[env];
    const targetVersion = targetVersions[env];
    if (!minVersion) {
      result[env] = prettifyVersion(targetVersion);
    } else {
      const minIsUnreleased = isUnreleasedVersion(minVersion, env);
      const targetIsUnreleased = isUnreleasedVersion(targetVersion, env);
      if (
        !targetIsUnreleased &&
        (minIsUnreleased || semver.lt(targetVersion, semverify(minVersion)))
      ) {
        result[env] = prettifyVersion(targetVersion);
      }
    }
    return result;
  }, {});
  const formattedTargets = JSON.stringify(filteredList)
    .replace(/,/g, ", ")
    .replace(/^\{"/, '{ "')
    .replace(/"\}$/, '" }');
  logMessage(`${item} ${formattedTargets}`, context);
};
export const logEntryPolyfills = (
  importPolyfillIncluded,
  polyfills,
  filename,
  onDebug,
) => {
  if (!importPolyfillIncluded) {
    console.log(
      `
[${filename}] \`import '@babel/polyfill'\` was not found.`,
    );
    return;
  }
  if (!polyfills.size) {
    console.log(
      `
[${filename}] Based on your targets, none were added.`,
    );
    return;
  }
  console.log(
    `
[${filename}] Replaced \`@babel/polyfill\` with the following polyfill${wordEnds(
      polyfills.size,
    )}:`,
  );
  onDebug(polyfills);
};
export const logUsagePolyfills = (polyfills, filename, onDebug) => {
  if (!polyfills.size) {
    console.log(
      `
[${filename}] Based on your code and targets, none were added.`,
    );
    return;
  }
  console.log(
    `
[${filename}] Added following polyfill${wordEnds(polyfills.size)}:`,
  );
  onDebug(polyfills);
};

// </from> /home/qfox/apps/babel/packages/babel-preset-env/src/debug.js

// <from> /home/qfox/apps/babel/packages/babel-preset-env/src/available-plugins.js

export default {
  "syntax-async-generators": require("@babel/plugin-syntax-async-generators"),
  "syntax-object-rest-spread": require("@babel/plugin-syntax-object-rest-spread"),
  "syntax-optional-catch-binding": require("@babel/plugin-syntax-optional-catch-binding"),
  "transform-async-to-generator": require("@babel/plugin-transform-async-to-generator"),
  "proposal-async-generator-functions": require("@babel/plugin-proposal-async-generator-functions"),
  "proposal-json-strings": require("@babel/plugin-proposal-json-strings"),
  "transform-arrow-functions": require("@babel/plugin-transform-arrow-functions"),
  "transform-block-scoped-functions": require("@babel/plugin-transform-block-scoped-functions"),
  "transform-block-scoping": require("@babel/plugin-transform-block-scoping"),
  "transform-classes": require("@babel/plugin-transform-classes"),
  "transform-computed-properties": require("@babel/plugin-transform-computed-properties"),
  "transform-destructuring": require("@babel/plugin-transform-destructuring"),
  "transform-dotall-regex": require("@babel/plugin-transform-dotall-regex"),
  "transform-duplicate-keys": require("@babel/plugin-transform-duplicate-keys"),
  "transform-for-of": require("@babel/plugin-transform-for-of"),
  "transform-function-name": require("@babel/plugin-transform-function-name"),
  "transform-literals": require("@babel/plugin-transform-literals"),
  "transform-modules-amd": require("@babel/plugin-transform-modules-amd"),
  "transform-modules-commonjs": require("@babel/plugin-transform-modules-commonjs"),
  "transform-modules-systemjs": require("@babel/plugin-transform-modules-systemjs"),
  "transform-modules-umd": require("@babel/plugin-transform-modules-umd"),
  "transform-object-super": require("@babel/plugin-transform-object-super"),
  "transform-parameters": require("@babel/plugin-transform-parameters"),
  "transform-shorthand-properties": require("@babel/plugin-transform-shorthand-properties"),
  "transform-spread": require("@babel/plugin-transform-spread"),
  "transform-sticky-regex": require("@babel/plugin-transform-sticky-regex"),
  "transform-template-literals": require("@babel/plugin-transform-template-literals"),
  "transform-typeof-symbol": require("@babel/plugin-transform-typeof-symbol"),
  "transform-unicode-regex": require("@babel/plugin-transform-unicode-regex"),
  "transform-exponentiation-operator": require("@babel/plugin-transform-exponentiation-operator"),
  "transform-new-target": require("@babel/plugin-transform-new-target"),
  "proposal-object-rest-spread": require("@babel/plugin-proposal-object-rest-spread"),
  "proposal-optional-catch-binding": require("@babel/plugin-proposal-optional-catch-binding"),
  "transform-regenerator": require("@babel/plugin-transform-regenerator"),
  "proposal-unicode-property-regex": require("@babel/plugin-proposal-unicode-property-regex"),
};

// </from> /home/qfox/apps/babel/packages/babel-preset-env/src/available-plugins.js

// <from> /home/qfox/apps/babel/packages/babel-preset-env/src/default-includes.js

export const defaultWebIncludes = [
  "web.timers",
  "web.immediate",
  "web.dom.iterable",
];

// </from> /home/qfox/apps/babel/packages/babel-preset-env/src/default-includes.js

// <from> /home/qfox/apps/babel/packages/babel-preset-env/src/built-in-definitions.js

const ArrayNatureIterators = [
  "es6.object.to-string",
  "es6.array.iterator",
  "web.dom.iterable",
];
const CommonIterators = ["es6.string.iterator"].concat(ArrayNatureIterators);
// TODO: this is the opposite of built-in-features so maybe generate one from the other?
export const definitions = {
  builtins: {
    DataView: "es6.typed.data-view",
    Float32Array: "es6.typed.float32-array",
    Float64Array: "es6.typed.float64-array",
    Int8Array: "es6.typed.int8-array",
    Int16Array: "es6.typed.int16-array",
    Int32Array: "es6.typed.int32-array",
    Map: ["es6.map"].concat(CommonIterators),
    Number: "es6.number.constructor",
    Promise: ["es6.object.to-string", "es6.promise"],
    RegExp: ["es6.regexp.constructor"],
    Set: ["es6.set"].concat(CommonIterators),
    Symbol: ["es6.symbol", "es7.symbol.async-iterator"],
    Uint8Array: "es6.typed.uint8-array",
    Uint8ClampedArray: "es6.typed.uint8-clamped-array",
    Uint16Array: "es6.typed.uint16-array",
    Uint32Array: "es6.typed.uint32-array",
    WeakMap: ["es6.weak-map"].concat(CommonIterators),
    WeakSet: ["es6.weak-set"].concat(CommonIterators),
  },
  instanceMethods: {
    __defineGetter__: ["es7.object.define-getter"],
    __defineSetter__: ["es7.object.define-setter"],
    __lookupGetter__: ["es7.object.lookup-getter"],
    __lookupSetter__: ["es7.object.lookup-setter"],
    anchor: ["es6.string.anchor"],
    big: ["es6.string.big"],
    bind: ["es6.function.bind"],
    blink: ["es6.string.blink"],
    bold: ["es6.string.bold"],
    codePointAt: ["es6.string.code-point-at"],
    copyWithin: ["es6.array.copy-within"],
    endsWith: ["es6.string.ends-with"],
    entries: ArrayNatureIterators,
    every: ["es6.array.is-array"],
    fill: ["es6.array.fill"],
    filter: ["es6.array.filter"],
    finally: ["es7.promise.finally"],
    find: ["es6.array.find"],
    findIndex: ["es6.array.find-index"],
    fixed: ["es6.string.fixed"],
    flags: ["es6.regexp.flags"],
    fontcolor: ["es6.string.fontcolor"],
    fontsize: ["es6.string.fontsize"],
    forEach: ["es6.array.for-each", "web.dom.iterable"],
    includes: ["es6.string.includes", "es7.array.includes"],
    indexOf: ["es6.array.index-of"],
    italics: ["es6.string.italics"],
    keys: ArrayNatureIterators,
    lastIndexOf: ["es6.array.last-index-of"],
    link: ["es6.string.link"],
    map: ["es6.array.map"],
    match: ["es6.regexp.match"],
    name: ["es6.function.name"],
    padStart: ["es7.string.pad-start"],
    padEnd: ["es7.string.pad-end"],
    reduce: ["es6.array.reduce"],
    reduceRight: ["es6.array.reduce-right"],
    repeat: ["es6.string.repeat"],
    replace: ["es6.regexp.replace"],
    search: ["es6.regexp.search"],
    slice: ["es6.array.slice"],
    small: ["es6.string.small"],
    some: ["es6.array.some"],
    sort: ["es6.array.sort"],
    split: ["es6.regexp.split"],
    startsWith: ["es6.string.starts-with"],
    strike: ["es6.string.strike"],
    sub: ["es6.string.sub"],
    sup: ["es6.string.sup"],
    toISOString: ["es6.date.to-iso-string"],
    toJSON: ["es6.date.to-json"],
    toString: [
      "es6.object.to-string",
      "es6.date.to-string",
      "es6.regexp.to-string",
    ],
    trim: ["es6.string.trim"],
    values: ArrayNatureIterators,
  },
  staticMethods: {
    Array: {
      from: ["es6.array.from", "es6.string.iterator"],
      isArray: "es6.array.is-array",
      of: "es6.array.of",
    },
    Date: {
      now: "es6.date.now",
    },
    Object: {
      assign: "es6.object.assign",
      create: "es6.object.create",
      defineProperty: "es6.object.define-property",
      defineProperties: "es6.object.define-properties",
      entries: "es7.object.entries",
      freeze: "es6.object.freeze",
      getOwnPropertyDescriptors: "es7.object.get-own-property-descriptors",
      getOwnPropertySymbols: "es6.object.get-own-property-symbols",
      is: "es6.object.is",
      isExtensible: "es6.object.is-extensible",
      isFrozen: "es6.object.is-frozen",
      isSealed: "es6.object.is-sealed",
      keys: "es6.object.keys",
      preventExtensions: "es6.object.prevent-extensions",
      seal: "es6.object.seal",
      setPrototypeOf: "es6.object.set-prototype-of",
      values: "es7.object.values",
    },
    Math: {
      acosh: "es6.math.acosh",
      asinh: "es6.math.asinh",
      atanh: "es6.math.atanh",
      cbrt: "es6.math.cbrt",
      clz32: "es6.math.clz32",
      cosh: "es6.math.cosh",
      expm1: "es6.math.expm1",
      fround: "es6.math.fround",
      hypot: "es6.math.hypot",
      imul: "es6.math.imul",
      log1p: "es6.math.log1p",
      log10: "es6.math.log10",
      log2: "es6.math.log2",
      sign: "es6.math.sign",
      sinh: "es6.math.sinh",
      tanh: "es6.math.tanh",
      trunc: "es6.math.trunc",
    },
    String: {
      fromCodePoint: "es6.string.from-code-point",
      raw: "es6.string.raw",
    },
    Number: {
      EPSILON: "es6.number.epsilon",
      MIN_SAFE_INTEGER: "es6.number.min-safe-integer",
      MAX_SAFE_INTEGER: "es6.number.max-safe-integer",
      isFinite: "es6.number.is-finite",
      isInteger: "es6.number.is-integer",
      isSafeInteger: "es6.number.is-safe-integer",
      isNaN: "es6.number.is-nan",
      parseFloat: "es6.number.parse-float",
      parseInt: "es6.number.parse-int",
    },
    Promise: {
      all: CommonIterators,
      race: CommonIterators,
    },
    Reflect: {
      apply: "es6.reflect.apply",
      construct: "es6.reflect.construct",
      defineProperty: "es6.reflect.define-property",
      deleteProperty: "es6.reflect.delete-property",
      get: "es6.reflect.get",
      getOwnPropertyDescriptor: "es6.reflect.get-own-property-descriptor",
      getPrototypeOf: "es6.reflect.get-prototype-of",
      has: "es6.reflect.has",
      isExtensible: "es6.reflect.is-extensible",
      ownKeys: "es6.reflect.own-keys",
      preventExtensions: "es6.reflect.prevent-extensions",
      set: "es6.reflect.set",
      setPrototypeOf: "es6.reflect.set-prototype-of",
    },
  },
};

// </from> /home/qfox/apps/babel/packages/babel-preset-env/src/built-in-definitions.js

// <from> /home/qfox/apps/babel/packages/babel-preset-env/src/use-built-ins-plugin.js

// @flow
import { definitions } from "./built-in-definitions";
import { logUsagePolyfills } from "./debug";
import { createImport, isPolyfillSource, isRequire } from "./utils";
type Plugin = {
  visitor: Object,
  pre: Function,
  name: string,
};
// function warnOnInstanceMethod() {
// state.opts.debug &&
//   console.warn(
//     `Adding a polyfill: An instance method may have been used: ${details}`,
//   );
// }
function has(obj: Object, key: string): boolean {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function getType(target: any): string {
  if (Array.isArray(target)) return "array";
  return typeof target;
}
// function getObjectString(node: Object): string {
//   if (node.type === "Identifier") {
//     return node.name;
//   } else if (node.type === "MemberExpression") {
//     return `${getObjectString(node.object)}.${getObjectString(node.property)}`;
//   }
//   return node.name;
// }
export default function({ types: t }: { types: Object }): Plugin {
  function addImport(
    path: Object,
    builtIn: string,
    builtIns: Set<string>,
  ): void {
    if (builtIn && !builtIns.has(builtIn)) {
      builtIns.add(builtIn);
      createImport(path, builtIn);
    }
  }
  function addUnsupported(
    path: Object,
    polyfills: Set<string>,
    builtIn: Array<string> | string,
    builtIns: Set<string>,
  ): void {
    if (Array.isArray(builtIn)) {
      for (const i of builtIn) {
        if (polyfills.has(i)) {
          addImport(path, i, builtIns);
        }
      }
    } else {
      if (polyfills.has(builtIn)) {
        addImport(path, builtIn, builtIns);
      }
    }
  }
  const addAndRemovePolyfillImports = {
    ImportDeclaration(path) {
      if (
        path.node.specifiers.length === 0 &&
        isPolyfillSource(path.node.source.value)
      ) {
        console.warn(
          `
  When setting \`useBuiltIns: 'usage'\`, polyfills are automatically imported when needed.
  Please remove the \`import '@babel/polyfill'\` call or use \`useBuiltIns: 'entry'\` instead.`,
        );
        path.remove();
      }
    },
    Program: {
      enter(path) {
        path.get("body").forEach(bodyPath => {
          if (isRequire(t, bodyPath)) {
            console.warn(
              `
  When setting \`useBuiltIns: 'usage'\`, polyfills are automatically imported when needed.
  Please remove the \`require('@babel/polyfill')\` call or use \`useBuiltIns: 'entry'\` instead.`,
            );
            bodyPath.remove();
          }
        });
      },
    },
    // Symbol()
    // new Promise
    ReferencedIdentifier(path, state) {
      const { node, parent, scope } = path;
      if (t.isMemberExpression(parent)) return;
      if (!has(definitions.builtins, node.name)) return;
      if (scope.getBindingIdentifier(node.name)) return;
      const builtIn = definitions.builtins[node.name];
      addUnsupported(path, state.opts.polyfills, builtIn, this.builtIns);
    },
    // arr[Symbol.iterator]()
    CallExpression(path) {
      // we can't compile this
      if (path.node.arguments.length) return;
      const callee = path.node.callee;
      if (!t.isMemberExpression(callee)) return;
      if (!callee.computed) return;
      if (!path.get("callee.property").matchesPattern("Symbol.iterator")) {
        return;
      }
      addImport(path, "web.dom.iterable", this.builtIns);
    },
    // Symbol.iterator in arr
    BinaryExpression(path) {
      if (path.node.operator !== "in") return;
      if (!path.get("left").matchesPattern("Symbol.iterator")) return;
      addImport(path, "web.dom.iterable", this.builtIns);
    },
    // yield*
    YieldExpression(path) {
      if (!path.node.delegate) return;
      addImport(path, "web.dom.iterable", this.builtIns);
    },
    // Array.from
    MemberExpression: {
      enter(path, state) {
        if (!path.isReferenced()) return;
        const { node } = path;
        const obj = node.object;
        const prop = node.property;
        if (!t.isReferenced(obj, node)) return;
        let instanceType;
        let evaluatedPropType = obj.name;
        let propName = prop.name;
        if (node.computed) {
          if (t.isStringLiteral(prop)) {
            propName = prop.value;
          } else {
            const res = path.get("property").evaluate();
            if (res.confident && res.value) {
              propName = res.value;
            }
          }
        }
        if (path.scope.getBindingIdentifier(obj.name)) {
          const result = path.get("object").evaluate();
          if (result.value) {
            instanceType = getType(result.value);
          } else if (result.deopt && result.deopt.isIdentifier()) {
            evaluatedPropType = result.deopt.node.name;
          }
        }
        if (has(definitions.staticMethods, evaluatedPropType)) {
          const staticMethods = definitions.staticMethods[evaluatedPropType];
          if (has(staticMethods, propName)) {
            const builtIn = staticMethods[propName];
            addUnsupported(path, state.opts.polyfills, builtIn, this.builtIns);
            // if (obj.name === "Array" && prop.name === "from") {
            //   addImport(
            //     path,
            //     "@babel/polyfill/lib/core-js/modules/web.dom.iterable",
            //     this.builtIns,
            //   );
            // }
          }
        }
        if (has(definitions.instanceMethods, propName)) {
          //warnOnInstanceMethod(state, getObjectString(node));
          let builtIn = definitions.instanceMethods[propName];
          if (instanceType) {
            builtIn = builtIn.filter(item => item.includes(instanceType));
          }
          addUnsupported(path, state.opts.polyfills, builtIn, this.builtIns);
        }
      },
      // Symbol.match
      exit(path, state) {
        if (!path.isReferenced()) return;
        const { node } = path;
        const obj = node.object;
        if (!has(definitions.builtins, obj.name)) return;
        if (path.scope.getBindingIdentifier(obj.name)) return;
        const builtIn = definitions.builtins[obj.name];
        addUnsupported(path, state.opts.polyfills, builtIn, this.builtIns);
      },
    },
    // var { repeat, startsWith } = String
    VariableDeclarator(path, state) {
      if (!path.isReferenced()) return;
      const { node } = path;
      const obj = node.init;
      if (!t.isObjectPattern(node.id)) return;
      if (!t.isReferenced(obj, node)) return;
      // doesn't reference the global
      if (obj && path.scope.getBindingIdentifier(obj.name)) return;
      for (let prop of node.id.properties) {
        prop = prop.key;
        if (
          !node.computed &&
          t.isIdentifier(prop) &&
          has(definitions.instanceMethods, prop.name)
        ) {
          // warnOnInstanceMethod(
          //   state,
          //   `${path.parentPath.node.kind} { ${prop.name} } = ${obj.name}`,
          // );
          const builtIn = definitions.instanceMethods[prop.name];
          addUnsupported(path, state.opts.polyfills, builtIn, this.builtIns);
        }
      }
    },
    Function(path, state) {
      if (!this.usesRegenerator && (path.node.generator || path.node.async)) {
        this.usesRegenerator = true;
        if (state.opts.regenerator) {
          addImport(path, "regenerator-runtime", this.builtIns);
        }
      }
    },
  };
  return {
    name: "use-built-ins",
    pre() {
      this.builtIns = new Set();
      this.usesRegenerator = false;
    },
    post() {
      const { debug, onDebug } = this.opts;
      if (debug) {
        logUsagePolyfills(this.builtIns, this.file.opts.filename, onDebug);
      }
    },
    visitor: addAndRemovePolyfillImports,
  };
}

// </from> /home/qfox/apps/babel/packages/babel-preset-env/src/use-built-ins-plugin.js

// <from> /home/qfox/apps/babel/packages/babel-preset-env/src/use-built-ins-entry-plugin.js

// @flow
import { logEntryPolyfills } from "./debug";
import { createImport, isPolyfillSource, isRequire } from "./utils";
type Plugin = {
  visitor: Object,
  pre: Function,
  post: Function,
  name: string,
};
export default function({ types: t }: { types: Object }): Plugin {
  function replaceWithPolyfillImports(
    path: Object,
    polyfills: Array<string> | Set<string>,
    regenerator: boolean,
  ): void {
    if (regenerator) {
      createImport(path, "regenerator-runtime");
    }
    const items = Array.isArray(polyfills) ? new Set(polyfills) : polyfills;
    for (const p of Array.from(items).reverse()) {
      createImport(path, p);
    }
    path.remove();
  }
  const isPolyfillImport = {
    ImportDeclaration(path, state) {
      if (
        path.node.specifiers.length === 0 &&
        isPolyfillSource(path.node.source.value)
      ) {
        this.importPolyfillIncluded = true;
        replaceWithPolyfillImports(
          path,
          state.opts.polyfills,
          state.opts.regenerator,
        );
      }
    },
    Program(path, state) {
      path.get("body").forEach(bodyPath => {
        if (isRequire(t, bodyPath)) {
          replaceWithPolyfillImports(
            bodyPath,
            state.opts.polyfills,
            state.opts.regenerator,
          );
        }
      });
    },
  };
  return {
    name: "transform-polyfill-require",
    visitor: isPolyfillImport,
    pre() {
      this.numPolyfillImports = 0;
      this.importPolyfillIncluded = false;
    },
    post() {
      const { debug, onDebug, polyfills } = this.opts;
      if (debug) {
        logEntryPolyfills(
          this.importPolyfillIncluded,
          polyfills,
          this.file.opts.filename,
          onDebug,
        );
      }
    },
  };
}

// </from> /home/qfox/apps/babel/packages/babel-preset-env/src/use-built-ins-entry-plugin.js

// <from> /home/qfox/apps/babel/packages/babel-preset-env/src/targets-parser.js

// @flow
import browserslist from "browserslist";
import invariant from "invariant";
import semver from "semver";
import {
  semverify,
  isUnreleasedVersion,
  getLowestUnreleased,
  getValues,
  findSuggestion,
} from "./utils";
import { objectToBrowserslist } from "./normalize-options";
import browserModulesData from "../data/built-in-modules.json";
import { TargetNames } from "./options";
const browserslistDefaults = browserslist.defaults;
const validateTargetNames = (validTargets, targets) => {
  for (const target in targets) {
    if (!TargetNames[target]) {
      const validOptions = getValues(TargetNames);
      throw new Error(
        `Invalid Option: '${target}' is not a valid target
        Maybe you meant to use '${findSuggestion(validOptions, target)}'?`,
      );
    }
  }
};
const browserNameMap = {
  android: "android",
  chrome: "chrome",
  and_chr: "chrome",
  edge: "edge",
  firefox: "firefox",
  ie: "ie",
  ios_saf: "ios",
  safari: "safari",
  node: "node",
};
export const isBrowsersQueryValid = (
  browsers: string | Array<string> | Targets,
): boolean => typeof browsers === "string" || Array.isArray(browsers);
const validateBrowsers = browsers => {
  invariant(
    typeof browsers === "undefined" || isBrowsersQueryValid(browsers),
    `Invalid Option: '${browsers}' is not a valid browserslist query`,
  );
  return browsers;
};
export const semverMin = (first: ?string, second: string): string => {
  return first && semver.lt(first, second) ? first : second;
};
const mergeBrowsers = (fromQuery: Targets, fromTarget: Targets) => {
  return Object.keys(fromTarget).reduce((queryObj, targKey) => {
    if (targKey !== TargetNames.browsers) {
      queryObj[targKey] = fromTarget[targKey];
    }
    return queryObj;
  }, fromQuery);
};
const getLowestVersions = (browsers: Array<string>): Targets => {
  return browsers.reduce((all: Object, browser: string): Object => {
    const [browserName, browserVersion] = browser.split(" ");
    const normalizedBrowserName = browserNameMap[browserName];
    if (!normalizedBrowserName) {
      return all;
    }
    try {
      // Browser version can return as "10.0-10.2"
      const splitVersion = browserVersion.split("-")[0].toLowerCase();
      const isSplitUnreleased = isUnreleasedVersion(splitVersion, browserName);
      if (!all[normalizedBrowserName]) {
        all[normalizedBrowserName] = isSplitUnreleased
          ? splitVersion
          : semverify(splitVersion);
        return all;
      }
      const version = all[normalizedBrowserName];
      const isUnreleased = isUnreleasedVersion(version, browserName);
      if (isUnreleased && isSplitUnreleased) {
        all[normalizedBrowserName] = getLowestUnreleased(
          version,
          splitVersion,
          browserName,
        );
      } else if (isUnreleased) {
        all[normalizedBrowserName] = semverify(splitVersion);
      } else if (!isUnreleased && !isSplitUnreleased) {
        const parsedBrowserVersion = semverify(splitVersion);
        all[normalizedBrowserName] = semverMin(version, parsedBrowserVersion);
      }
    } catch (e) {}
    return all;
  }, {});
};
const outputDecimalWarning = (decimalTargets: Array<Object>): void => {
  if (!decimalTargets || !decimalTargets.length) {
    return;
  }
  console.log("Warning, the following targets are using a decimal version:");
  console.log("");
  decimalTargets.forEach(({ target, value }) =>
    console.log(`  ${target}: ${value}`),
  );
  console.log("");
  console.log(
    "We recommend using a string for minor/patch versions to avoid numbers like 6.10",
  );
  console.log("getting parsed as 6.1, which can lead to unexpected behavior.");
  console.log("");
};
const semverifyTarget = (target, value) => {
  try {
    return semverify(value);
  } catch (error) {
    throw new Error(
      `Invalid Option: '${value}' is not a valid value for 'targets.${target}'.`,
    );
  }
};
const targetParserMap = {
  __default: (target, value) => {
    const version = isUnreleasedVersion(value, target)
      ? value.toLowerCase()
      : semverifyTarget(target, value);
    return [target, version];
  },
  // Parse `node: true` and `node: "current"` to version
  node: (target, value) => {
    const parsed =
      value === true || value === "current"
        ? process.versions.node
        : semverifyTarget(target, value);
    return [target, parsed];
  },
};
type ParsedResult = {
  targets: Targets,
  decimalWarnings: Array<Object>,
};
const getTargets = (targets: Object = {}, options: Object = {}): Targets => {
  const targetOpts: Targets = {};
  validateTargetNames(targets);
  // `esmodules` as a target indicates the specific set of browsers supporting ES Modules.
  // These values OVERRIDE the `browsers` field.
  if (targets.esmodules) {
    const supportsESModules = browserModulesData["es6.module"];
    targets.browsers = Object.keys(supportsESModules)
      .map(browser => `${browser} ${supportsESModules[browser]}`)
      .join(", ");
  }
  // Parse browsers target via browserslist
  const browsersquery = validateBrowsers(targets.browsers);
  const shouldParseBrowsers = !!targets.browsers;
  const shouldSearchForConfig =
    !options.ignoreBrowserslistConfig && !Object.keys(targets).length;
  if (shouldParseBrowsers || shouldSearchForConfig) {
    browserslist.defaults = objectToBrowserslist(targets);
    const browsers = browserslist(browsersquery, {
      path: options.configPath,
    });
    const queryBrowsers = getLowestVersions(browsers);
    targets = mergeBrowsers(queryBrowsers, targets);
    // Reset browserslist defaults
    browserslist.defaults = browserslistDefaults;
  }
  // Parse remaining targets
  const parsed = Object.keys(targets)
    .filter(value => value !== TargetNames.esmodules)
    .sort()
    .reduce(
      (results: ParsedResult, target: string): ParsedResult => {
        if (target !== TargetNames.browsers) {
          const value = targets[target];
          // Warn when specifying minor/patch as a decimal
          if (typeof value === "number" && value % 1 !== 0) {
            results.decimalWarnings.push({ target, value });
          }
          // Check if we have a target parser?
          const parser = targetParserMap[target] || targetParserMap.__default;
          const [parsedTarget, parsedValue] = parser(target, value);
          if (parsedValue) {
            // Merge (lowest wins)
            results.targets[parsedTarget] = parsedValue;
          }
        }
        return results;
      },
      {
        targets: targetOpts,
        decimalWarnings: [],
      },
    );
  outputDecimalWarning(parsed.decimalWarnings);
  return parsed.targets;
};
export default getTargets;

// </from> /home/qfox/apps/babel/packages/babel-preset-env/src/targets-parser.js

// <from> /home/qfox/apps/babel/packages/babel-preset-env/src/types.js

//@flow
import { TargetNames, ModulesOption, UseBuiltInsOption } from "./options";
// Targets
export type Target = $Keys<typeof TargetNames>;
export type Targets = {
  [target: Target]: string,
};
// Options
// Use explicit modules to prevent typo errors.
export type ModuleOption = $Values<typeof ModulesOption>;
export type BuiltInsOption = $Values<typeof UseBuiltInsOption>;
export type Options = {
  configPath: string,
  debug: boolean,
  exclude: Array<string | RegExp>,
  forceAllTransforms: boolean,
  ignoreBrowserslistConfig: boolean,
  include: Array<string | RegExp>,
  loose: boolean,
  modules: ModuleOption,
  shippedProposals: boolean,
  spec: boolean,
  targets: Targets,
  useBuiltIns: BuiltInsOption,
};
// Babel
export type Plugin = [Object, Object];

// </from> /home/qfox/apps/babel/packages/babel-preset-env/src/types.js

// <from> /home/qfox/apps/babel/packages/babel-preset-env/src/module-transformations.js

export default {
  auto: "transform-modules-commonjs",
  amd: "transform-modules-amd",
  commonjs: "transform-modules-commonjs",
  cjs: "transform-modules-commonjs",
  systemjs: "transform-modules-systemjs",
  umd: "transform-modules-umd",
};

// </from> /home/qfox/apps/babel/packages/babel-preset-env/src/module-transformations.js

// <from> /home/qfox/apps/babel/packages/babel-preset-env/src/options.js

export const TopLevelOptions = {
  configPath: "configPath",
  debug: "debug",
  exclude: "exclude",
  forceAllTransforms: "forceAllTransforms",
  ignoreBrowserslistConfig: "ignoreBrowserslistConfig",
  include: "include",
  loose: "loose",
  modules: "modules",
  shippedProposals: "shippedProposals",
  spec: "spec",
  targets: "targets",
  useBuiltIns: "useBuiltIns",
};
export const ModulesOption = {
  false: false,
  auto: "auto",
  amd: "amd",
  commonjs: "commonjs",
  cjs: "cjs",
  systemjs: "systemjs",
  umd: "umd",
};
export const UseBuiltInsOption = {
  false: false,
  entry: "entry",
  usage: "usage",
};
export const TargetNames = {
  esmodules: "esmodules",
  node: "node",
  browsers: "browsers",
  chrome: "chrome",
  opera: "opera",
  edge: "edge",
  firefox: "firefox",
  safari: "safari",
  ie: "ie",
  ios: "ios",
  android: "android",
  electron: "electron",
};

// </from> /home/qfox/apps/babel/packages/babel-preset-env/src/options.js

// <from> /home/qfox/apps/babel/packages/babel-preset-env/src/normalize-options.js

//@flow
import invariant from "invariant";
import browserslist from "browserslist";
import builtInsList from "../data/built-ins.json";
import { defaultWebIncludes } from "./default-includes";
import moduleTransformations from "./module-transformations";
import { isBrowsersQueryValid } from "./targets-parser";
import { getValues, findSuggestion } from "./utils";
import pluginsList from "../data/plugins.json";
import { TopLevelOptions, ModulesOption, UseBuiltInsOption } from "./options";
const validateTopLevelOptions = (options: Options) => {
  for (const option in options) {
    if (!TopLevelOptions[option]) {
      const validOptions = getValues(TopLevelOptions);
      throw new Error(
        `Invalid Option: ${option} is not a valid top-level option.
        Maybe you meant to use '${findSuggestion(validOptions, option)}'?`,
      );
    }
  }
};
const validIncludesAndExcludes = new Set([
  ...Object.keys(pluginsList),
  ...Object.keys(moduleTransformations).map(m => moduleTransformations[m]),
  ...Object.keys(builtInsList),
  ...defaultWebIncludes,
]);
const pluginToRegExp = (plugin: any): ?RegExp => {
  if (plugin instanceof RegExp) return plugin;
  try {
    return new RegExp(`^${normalizePluginName(plugin)}$`);
  } catch (e) {
    return null;
  }
};
const selectPlugins = (regexp: ?RegExp): Array<string> =>
  Array.from(validIncludesAndExcludes).filter(
    item => regexp instanceof RegExp && regexp.test(item),
  );
const flatten = array => [].concat(...array);
const expandIncludesAndExcludes = (
  plugins: Array<string | RegExp> = [],
  type: string,
): Array<string> => {
  if (plugins.length === 0) return [];
  const selectedPlugins = plugins.map(plugin =>
    selectPlugins(pluginToRegExp(plugin)),
  );
  const invalidRegExpList = plugins.filter(
    (p, i) => selectedPlugins[i].length === 0,
  );
  invariant(
    invalidRegExpList.length === 0,
    `Invalid Option: The plugins/built-ins '${invalidRegExpList.join(
      ", ",
    )}' passed to the '${type}' option are not
    valid. Please check data/[plugin-features|built-in-features].js in babel-preset-env`,
  );
  return flatten(selectedPlugins);
};
const validBrowserslistTargets = [
  ...Object.keys(browserslist.data),
  ...Object.keys(browserslist.aliases),
];
export const normalizePluginName = (plugin: string): string =>
  plugin.replace(/^babel-plugin-/, "");
export const checkDuplicateIncludeExcludes = (
  include: Array<string> = [],
  exclude: Array<string> = [],
): void => {
  const duplicates = include.filter(opt => exclude.indexOf(opt) >= 0);
  invariant(
    duplicates.length === 0,
    `Invalid Option: The plugins/built-ins '${duplicates.join(
      ", ",
    )}' were found in both the "include" and
    "exclude" options.`,
  );
};
const normalizeTargets = (targets: any): Targets => {
  // TODO: Allow to use only query or strings as a targets from next breaking change.
  if (isBrowsersQueryValid(targets)) {
    return { browsers: targets };
  }
  return {
    ...targets,
  };
};
export const validateConfigPathOption = (
  configPath: string = process.cwd(),
) => {
  invariant(
    typeof configPath === "string",
    `Invalid Option: The configPath option '${configPath}' is invalid, only strings are allowed.`,
  );
  return configPath;
};
export const validateBoolOption = (
  name: string,
  value: ?boolean,
  defaultValue: boolean,
) => {
  if (typeof value === "undefined") {
    value = defaultValue;
  }
  if (typeof value !== "boolean") {
    throw new Error(`Preset env: '${name}' option must be a boolean.`);
  }
  return value;
};
export const validateIgnoreBrowserslistConfig = (
  ignoreBrowserslistConfig: boolean,
) =>
  validateBoolOption(
    TopLevelOptions.ignoreBrowserslistConfig,
    ignoreBrowserslistConfig,
    false,
  );
export const validateModulesOption = (
  modulesOpt: ModuleOption = ModulesOption.auto,
) => {
  invariant(
    ModulesOption[modulesOpt] ||
      ModulesOption[modulesOpt] === ModulesOption.false,
    `Invalid Option: The 'modules' option must be one of \n` +
      ` - 'false' to indicate no module processing\n` +
      ` - a specific module type: 'commonjs', 'amd', 'umd', 'systemjs'` +
      ` - 'auto' (default) which will automatically select 'false' if the current\n` +
      `   process is known to support ES module syntax, or "commonjs" otherwise\n`,
  );
  return modulesOpt;
};
export const objectToBrowserslist = (object: Targets): Array<string> => {
  return Object.keys(object).reduce((list, targetName) => {
    if (validBrowserslistTargets.indexOf(targetName) >= 0) {
      const targetVersion = object[targetName];
      return list.concat(`${targetName} ${targetVersion}`);
    }
    return list;
  }, []);
};
export const validateUseBuiltInsOption = (
  builtInsOpt: BuiltInsOption = false,
): BuiltInsOption => {
  invariant(
    UseBuiltInsOption[builtInsOpt] ||
      UseBuiltInsOption[builtInsOpt] === UseBuiltInsOption.false,
    `Invalid Option: The 'useBuiltIns' option must be either
    'false' (default) to indicate no polyfill,
    '"entry"' to indicate replacing the entry polyfill, or
    '"usage"' to import only used polyfills per file`,
  );
  return builtInsOpt;
};
export default function normalizeOptions(opts: Options) {
  validateTopLevelOptions(opts);
  const include = expandIncludesAndExcludes(
    opts.include,
    TopLevelOptions.include,
  );
  const exclude = expandIncludesAndExcludes(
    opts.exclude,
    TopLevelOptions.exclude,
  );
  checkDuplicateIncludeExcludes(include, exclude);
  return {
    configPath: validateConfigPathOption(opts.configPath),
    debug: validateBoolOption(TopLevelOptions.debug, opts.debug, false),
    include,
    exclude,
    forceAllTransforms: validateBoolOption(
      TopLevelOptions.forceAllTransforms,
      opts.forceAllTransforms,
      false,
    ),
    ignoreBrowserslistConfig: validateIgnoreBrowserslistConfig(
      opts.ignoreBrowserslistConfig,
    ),
    loose: validateBoolOption(TopLevelOptions.loose, opts.loose, false),
    modules: validateModulesOption(opts.modules),
    shippedProposals: validateBoolOption(
      TopLevelOptions.shippedProposals,
      opts.shippedProposals,
      false,
    ),
    spec: validateBoolOption(TopLevelOptions.spec, opts.spec, false),
    targets: normalizeTargets(opts.targets),
    useBuiltIns: validateUseBuiltInsOption(opts.useBuiltIns),
  };
}

// </from> /home/qfox/apps/babel/packages/babel-preset-env/src/normalize-options.js

// <from> /home/qfox/apps/babel/packages/babel-preset-env/src/utils.js

// @flow
import invariant from "invariant";
import semver from "semver";
import levenshtein from "js-levenshtein";
import { addSideEffect } from "@babel/helper-module-imports";
import unreleasedLabels from "../data/unreleased-labels";
import { semverMin } from "./targets-parser";
const versionRegExp = /^(\d+|\d+.\d+)$/;
// Convert version to a semver value.
// 2.5 -> 2.5.0; 1 -> 1.0.0;
export const semverify = (version: string | number): string => {
  if (typeof version === "string" && semver.valid(version)) {
    return version;
  }
  invariant(
    typeof version === "number" ||
      (typeof version === "string" && versionRegExp.test(version)),
    `'${version}' is not a valid version`,
  );
  const split = version.toString().split(".");
  while (split.length < 3) {
    split.push("0");
  }
  return split.join(".");
};
export const getValues = (object: Object): Array<any> =>
  Object.keys(object).map(key => object[key]);
export const findSuggestion = (options: Array<string>, option: string) => {
  let levenshteinValue = Infinity;
  return options.reduce((suggestion, validOption) => {
    const value = levenshtein(validOption, option);
    if (value < levenshteinValue) {
      levenshteinValue = value;
      return validOption;
    }
    return suggestion;
  }, undefined);
};
export const prettifyVersion = (version: string): string => {
  if (typeof version !== "string") {
    return version;
  }
  const parts = [semver.major(version)];
  const minor = semver.minor(version);
  const patch = semver.patch(version);
  if (minor || patch) {
    parts.push(minor);
  }
  if (patch) {
    parts.push(patch);
  }
  return parts.join(".");
};
export const prettifyTargets = (targets: Targets): Object => {
  return Object.keys(targets).reduce((results, target) => {
    let value = targets[target];
    const unreleasedLabel = unreleasedLabels[target];
    if (typeof value === "string" && unreleasedLabel !== value) {
      value = prettifyVersion(value);
    }
    results[target] = value;
    return results;
  }, {});
};
export const isUnreleasedVersion = (version: string, env: string): boolean => {
  const unreleasedLabel = unreleasedLabels[env];
  return (
    !!unreleasedLabel && unreleasedLabel === version.toString().toLowerCase()
  );
};
export const getLowestUnreleased = (
  a: string,
  b: string,
  env: string,
): string => {
  const unreleasedLabel = unreleasedLabels[env];
  const hasUnreleased = [a, b].some(item => item === unreleasedLabel);
  if (hasUnreleased) {
    return a === hasUnreleased ? b : a || b;
  }
  return semverMin(a, b);
};
export const filterStageFromList = (list: any, stageList: any) => {
  return Object.keys(list).reduce((result, item) => {
    if (!stageList[item]) {
      result[item] = list[item];
    }
    return result;
  }, {});
};
export const isPolyfillSource = (source: string): boolean =>
  source === "@babel/polyfill" || source === "core-js";
const modulePathMap = {
  "regenerator-runtime": "regenerator-runtime/runtime",
};
export const getModulePath = (mod: string) =>
  modulePathMap[mod] || `core-js/modules/${mod}`;
export const createImport = (path: Object, mod: string) =>
  addSideEffect(path, getModulePath(mod));
export const isRequire = (t: Object, path: Object): boolean =>
  t.isExpressionStatement(path.node) &&
  t.isCallExpression(path.node.expression) &&
  t.isIdentifier(path.node.expression.callee) &&
  path.node.expression.callee.name === "require" &&
  path.node.expression.arguments.length === 1 &&
  t.isStringLiteral(path.node.expression.arguments[0]) &&
  isPolyfillSource(path.node.expression.arguments[0].value);

// </from> /home/qfox/apps/babel/packages/babel-preset-env/src/utils.js

// <from> /home/qfox/apps/babel/packages/babel-preset-env/scripts/build-modules-support.js

const path = require("path");
const fs = require("fs");
const moduleSupport = require("caniuse-db/features-json/es6-module.json");
const acceptedWithCaveats = {
  safari: true,
  ios_saf: true,
};
const { stats } = moduleSupport;
const allowedBrowsers = {};
Object.keys(stats).forEach(browser => {
  if (browser !== "and_chr") {
    const browserVersions = stats[browser];
    const allowedVersions = Object.keys(browserVersions)
      .filter(value => {
        return acceptedWithCaveats[browser]
          ? browserVersions[value][0] === "a"
          : browserVersions[value] === "y";
      })
      .sort((a, b) => a - b);
    if (allowedVersions[0] !== undefined) {
      // Handle cases where caniuse specifies version as: "11.0-11.2"
      allowedBrowsers[browser] = allowedVersions[0].split("-")[0];
    }
  }
});
const dataPath = path.join(__dirname, "../data/built-in-modules.json");
const data = {
  "es6.module": allowedBrowsers,
};
fs.writeFileSync(dataPath, `${JSON.stringify(data, null, 2)}\n`);

// </from> /home/qfox/apps/babel/packages/babel-preset-env/scripts/build-modules-support.js

// <from> /home/qfox/apps/babel/packages/babel-preset-env/scripts/build-data.js

"use strict";
const fs = require("fs");
const path = require("path");
const semver = require("semver");
const flattenDeep = require("lodash/flattenDeep");
const isEqual = require("lodash/isEqual");
const mapValues = require("lodash/mapValues");
const pickBy = require("lodash/pickBy");
const unreleasedLabels = require("../data/unreleased-labels");
const electronToChromiumVersions = require("electron-to-chromium").versions;
const electronToChromiumKeys = Object.keys(
  electronToChromiumVersions
).reverse();
const chromiumToElectronMap = electronToChromiumKeys.reduce((all, electron) => {
  all[electronToChromiumVersions[electron]] = +electron;
  return all;
}, {});
const chromiumToElectronVersions = Object.keys(chromiumToElectronMap);
const findClosestElectronVersion = targetVersion => {
  const chromiumVersionsLength = chromiumToElectronVersions.length;
  const maxChromium = +chromiumToElectronVersions[chromiumVersionsLength - 1];
  if (targetVersion > maxChromium) return null;
  const closestChrome = chromiumToElectronVersions.find(
    version => targetVersion <= version
  );
  return chromiumToElectronMap[closestChrome];
};
const chromiumToElectron = chromium =>
  chromiumToElectronMap[chromium] || findClosestElectronVersion(chromium);
const renameTests = (tests, getName, category) =>
  tests.map(test =>
    Object.assign({}, test, { name: getName(test.name), category })
  );
// The following is adapted from compat-table:
// https://github.com/kangax/compat-table/blob/gh-pages/build.js
//
// It parses and interpolates data so environments that "equal" other
// environments (node4 and chrome45), as well as familial relationships (edge
// and ie11) can be handled properly.
const envs = require("compat-table/environments");
const byTestSuite = suite => browser => {
  return Array.isArray(browser.test_suites)
    ? browser.test_suites.indexOf(suite) > -1
    : true;
};
const compatSources = ["es5", "es6", "es2016plus", "esnext"].reduce(
  (result, source) => {
    const data = require(`compat-table/data-${source}`);
    data.browsers = pickBy(envs, byTestSuite(source));
    result.push(data);
    return result;
  },
  []
);
const interpolateAllResults = (rawBrowsers, tests) => {
  const interpolateResults = res => {
    let browser;
    let prevBrowser;
    let result;
    let prevResult;
    let prevBid;
    for (const bid in rawBrowsers) {
      // For browsers that are essentially equal to other browsers,
      // copy over the results.
      browser = rawBrowsers[bid];
      if (browser.equals && res[bid] === undefined) {
        result = res[browser.equals];
        res[bid] =
          browser.ignore_flagged && result === "flagged" ? false : result;
        // For each browser, check if the previous browser has the same
        // browser full name (e.g. Firefox) or family name (e.g. Chakra) as this one.
      } else if (
        prevBrowser &&
        (prevBrowser.full.replace(/,.+$/, "") ===
          browser.full.replace(/,.+$/, "") ||
          (browser.family !== undefined &&
            prevBrowser.family === browser.family))
      ) {
        // For each test, check if the previous browser has a result
        // that this browser lacks.
        result = res[bid];
        prevResult = res[prevBid];
        if (prevResult !== undefined && result === undefined) {
          res[bid] = prevResult;
        }
      }
      prevBrowser = browser;
      prevBid = bid;
    }
  };
  // Now print the results.
  tests.forEach(function(t) {
    // Calculate the result totals for tests which consist solely of subtests.
    if ("subtests" in t) {
      t.subtests.forEach(function(e) {
        interpolateResults(e.res);
      });
    } else {
      interpolateResults(t.res);
    }
  });
};
compatSources.forEach(({ browsers, tests }) =>
  interpolateAllResults(browsers, tests)
);
// End of compat-table code adaptation
const environments = [
  "chrome",
  "opera",
  "edge",
  "firefox",
  "safari",
  "node",
  "ie",
  "android",
  "ios",
  "phantom",
];
const compatibilityTests = flattenDeep(
  compatSources.map(data =>
    data.tests.map(test => {
      return test.subtests
        ? [
            test,
            renameTests(
              test.subtests,
              name => test.name + " / " + name,
              test.category
            ),
          ]
        : test;
    })
  )
);
const getLowestImplementedVersion = ({ features }, env) => {
  const tests = compatibilityTests
    .filter(test => {
      return (
        features.indexOf(test.name) >= 0 ||
        // for features === ["DataView"]
        // it covers "DataView (Int8)" and "DataView (UInt8)"
        (features.length === 1 && test.name.indexOf(features[0]) === 0)
      );
    })
    .reduce((result, test) => {
      const isBuiltIn =
        test.category === "built-ins" ||
        test.category === "built-in extensions";
      if (!test.subtests) {
        result.push({
          name: test.name,
          res: test.res,
          isBuiltIn,
        });
      } else {
        test.subtests.forEach(subtest =>
          result.push({
            name: `${test.name}/${subtest.name}`,
            res: subtest.res,
            isBuiltIn,
          })
        );
      }
      return result;
    }, []);
  const unreleasedLabelForEnv = unreleasedLabels[env];
  const envTests = tests.map(({ res: test, isBuiltIn }, i) => {
    // Babel itself doesn't implement the feature correctly,
    // don't count against it
    // only doing this for built-ins atm
    //
    // NOTE: when/if compat-table adds a babel7 key, we'll want to update this
    if (!test.babel6 && isBuiltIn) {
      return "-1";
    }
    return (
      Object.keys(test)
        .filter(t => t.startsWith(env))
        // Babel assumes strict mode
        .filter(
          test => tests[i].res[test] === true || tests[i].res[test] === "strict"
        )
        // normalize some keys and get version from full string.
        .map(test => {
          return test.replace("_", ".").replace(env, "");
        })
        // version must be label from the unreleasedLabels (like tp) or number.
        .filter(
          version =>
            unreleasedLabelForEnv === version || !isNaN(parseFloat(version))
        )
        .shift()
    );
  });
  const envFiltered = envTests.filter(t => t);
  if (envTests.length > envFiltered.length || envTests.length === 0) {
    // envTests.forEach((test, i) => {
    //   if (!test) {
    //     // print unsupported features
    //     if (env === 'node') {
    //       console.log(`ENV(${env}): ${tests[i].name}`);
    //     }
    //   }
    // });
    return null;
  }
  return envTests.map(str => str.replace(env, "")).reduce((a, b) => {
    if (b === unreleasedLabelForEnv) {
      return b;
    }
    return semver.lt(semver.coerce(a), semver.coerce(b)) ? b : a;
  });
};
const generateData = (environments, features) => {
  return mapValues(features, options => {
    if (!options.features) {
      options = {
        features: [options],
      };
    }
    const plugin = {};
    environments.forEach(env => {
      const version = getLowestImplementedVersion(options, env);
      if (version !== null) {
        plugin[env] = version.toString();
      }
    });
    if (plugin.chrome) {
      // add opera
      if (plugin.chrome >= 28) {
        plugin.opera = (plugin.chrome - 13).toString();
      } else if (plugin.chrome === 5) {
        plugin.opera = "12";
      }
      // add electron
      const electronVersion = chromiumToElectron(plugin.chrome);
      if (electronVersion) {
        plugin.electron = electronVersion.toString();
      }
    }
    return plugin;
  });
};
["plugin", "built-in"].forEach(target => {
  const newData = generateData(
    environments,
    require(`../data/${target}-features`)
  );
  const dataPath = path.join(__dirname, `../data/${target}s.json`);
  if (process.argv[2] === "--check") {
    const currentData = require(dataPath);
    if (!isEqual(currentData, newData)) {
      console.error(
        "The newly generated plugin/built-in data does not match the current " +
          "files. Re-run `npm run build-data`."
      );
      process.exit(1);
    }
    process.exit(0);
  }
  fs.writeFileSync(dataPath, `${JSON.stringify(newData, null, 2)}\n`);
});

// </from> /home/qfox/apps/babel/packages/babel-preset-env/scripts/build-data.js

// <from> /home/qfox/apps/babel/packages/babel-preset-env/scripts/smoke-test.js

const fs = require("fs-extra");
const execSync = require("child_process").execSync;
const path = require("path");
const pkg = require("../package.json");
let errorOccurred = false;
const tempFolderPath = path.join(__dirname, "../tmp");
const packPath = path.join(__dirname, `../babel-preset-env-${pkg.version}.tgz`);
try {
  console.log("Creating package");
  execSync("npm pack");
  console.log("Setting up smoke test dependencies");
  fs.ensureDirSync(tempFolderPath);
  process.chdir(tempFolderPath);
  const babelCliVersion = pkg.devDependencies["babel-cli"];
  if (!babelCliVersion) {
    throw new Error("Could not read version of babel-cli from package.json");
  }
  fs.writeFileSync(
    path.join(tempFolderPath, "package.json"),
    `
{
  "name": "babel-preset-env-smoke-test",
  "private": true,
  "version": "1.0.0",
  "scripts": {
    "build": "babel index.js --out-file index.es6"
  },
  "dependencies": {
    "babel-cli": "${babelCliVersion}",
    "babel-preset-env": "${packPath}"
  }
}
`
  );
  execSync("npm install");
  console.log("Setting up 'usage' smoke test");
  fs.writeFileSync(
    path.join(tempFolderPath, ".babelrc"),
    `
{
  "presets": [
    ["env", {
      modules: false,
      useBuiltIns: "usage"
    }]
  ]
}
`
  );
  fs.writeFileSync(
    path.join(tempFolderPath, "index.js"),
    `
const foo = new Promise((resolve) => {
  resolve(new Map());
});
`
  );
  console.log("Running 'usage' smoke test");
  execSync("npm run build");
  console.log("Setting up 'entry' smoke test");
  fs.writeFileSync(
    path.join(tempFolderPath, ".babelrc"),
    `
{
  "presets": [
    ["env", {
      modules: false,
      useBuiltIns: "entry"
    }]
  ]
}
`
  );
  fs.writeFileSync(
    path.join(tempFolderPath, "index.js"),
    `
import "@babel/polyfill";
1 ** 2;
`
  );
  console.log("Running 'entry' smoke test");
  execSync("npm run build");
} catch (e) {
  console.log(e);
  errorOccurred = true;
}
console.log("Cleaning up");
fs.removeSync(tempFolderPath);
fs.removeSync(packPath);
process.exit(errorOccurred ? 1 : 0);

// </from> /home/qfox/apps/babel/packages/babel-preset-env/scripts/smoke-test.js

// <from> /home/qfox/apps/babel/packages/babel-preset-env/data/unreleased-labels.js

module.exports = {
  safari: "tp",
};

// </from> /home/qfox/apps/babel/packages/babel-preset-env/data/unreleased-labels.js

// <from> /home/qfox/apps/babel/packages/babel-preset-env/data/plugin-features.js

const es = {
  "transform-template-literals": {
    features: ["template literals"],
  },
  "transform-literals": {
    features: ["Unicode code point escapes"],
  },
  "transform-function-name": {
    features: ['function "name" property'],
  },
  "transform-arrow-functions": {
    features: ["arrow functions"],
  },
  "transform-block-scoped-functions": {
    features: ["block-level function declaration"],
  },
  "transform-classes": {
    features: ["class", "super"],
  },
  "transform-object-super": {
    features: ["super"],
  },
  "transform-shorthand-properties": {
    features: ["object literal extensions / shorthand properties"],
  },
  "transform-duplicate-keys": {
    features: ["miscellaneous / duplicate property names in strict mode"],
  },
  "transform-computed-properties": {
    features: ["object literal extensions / computed properties"],
  },
  "transform-for-of": {
    features: ["for..of loops"],
  },
  "transform-sticky-regex": {
    features: [
      'RegExp "y" and "u" flags / "y" flag, lastIndex',
      'RegExp "y" and "u" flags / "y" flag',
    ],
  },
  // We want to apply this prior to unicode regex so that "." and "u"
  // are properly handled.
  //
  // Ref: https://github.com/babel/babel/pull/7065#issuecomment-395959112
  "transform-dotall-regex": "s (dotAll) flag for regular expressions",
  "transform-unicode-regex": {
    features: [
      'RegExp "y" and "u" flags / "u" flag, case folding',
      'RegExp "y" and "u" flags / "u" flag, Unicode code point escapes',
      'RegExp "y" and "u" flags / "u" flag',
    ],
  },
  "transform-spread": {
    features: "spread syntax for iterable objects",
  },
  "transform-parameters": {
    features: ["default function parameters", "rest parameters"],
  },
  "transform-destructuring": {
    features: [
      "destructuring, assignment",
      "destructuring, declarations",
      "destructuring, parameters",
    ],
  },
  "transform-block-scoping": {
    features: ["const", "let"],
  },
  "transform-typeof-symbol": {
    features: ["Symbol / typeof support"],
  },
  "transform-new-target": {
    features: ["new.target"],
  },
  "transform-regenerator": {
    features: ["generators"],
  },
  "transform-exponentiation-operator": {
    features: ["exponentiation (**) operator"],
  },
  "transform-async-to-generator": {
    features: ["async functions"],
  },
  "proposal-async-generator-functions": "Asynchronous Iterators",
  "proposal-object-rest-spread": "object rest/spread properties",
  "proposal-unicode-property-regex": "RegExp Unicode Property Escapes",
  "proposal-json-strings": "", // Awaiting mapping in compat-table
  "proposal-optional-catch-binding": "optional catch binding",
};
const proposals = require("./shipped-proposals").features;
module.exports = Object.assign({}, es, proposals);

// </from> /home/qfox/apps/babel/packages/babel-preset-env/data/plugin-features.js

// <from> /home/qfox/apps/babel/packages/babel-preset-env/data/built-in-features.js

const typedArrayMethods = [
  "typed arrays / %TypedArray%.from",
  "typed arrays / %TypedArray%.of",
  "typed arrays / %TypedArray%.prototype.subarray",
  "typed arrays / %TypedArray%.prototype.join",
  "typed arrays / %TypedArray%.prototype.indexOf",
  "typed arrays / %TypedArray%.prototype.lastIndexOf",
  "typed arrays / %TypedArray%.prototype.slice",
  "typed arrays / %TypedArray%.prototype.every",
  "typed arrays / %TypedArray%.prototype.filter",
  "typed arrays / %TypedArray%.prototype.forEach",
  "typed arrays / %TypedArray%.prototype.map",
  "typed arrays / %TypedArray%.prototype.reduce",
  "typed arrays / %TypedArray%.prototype.reduceRight",
  "typed arrays / %TypedArray%.prototype.reverse",
  "typed arrays / %TypedArray%.prototype.some",
  "typed arrays / %TypedArray%.prototype.sort",
  "typed arrays / %TypedArray%.prototype.copyWithin",
  "typed arrays / %TypedArray%.prototype.find",
  "typed arrays / %TypedArray%.prototype.findIndex",
  "typed arrays / %TypedArray%.prototype.fill",
  "typed arrays / %TypedArray%.prototype.keys",
  "typed arrays / %TypedArray%.prototype.values",
  "typed arrays / %TypedArray%.prototype.entries",
  "typed arrays / %TypedArray%.prototype[Symbol.iterator]",
  "typed arrays / %TypedArray%[Symbol.species]",
];
const es = {
  // compat-table missing babel6 mapping
  // "es6.array.concat": {
  //   features: [
  //     "well-known symbols / Symbol.isConcatSpreadable",
  //     "well-known symbols / Symbol.species, Array.prototype.concat",
  //   ]
  // },
  "es6.array.copy-within": "Array.prototype methods / Array.prototype.copyWithin",
  "es6.array.every": "Array methods / Array.prototype.every",
  "es6.array.fill": "Array.prototype methods / Array.prototype.fill",
  "es6.array.filter": {
    features: [
      "Array methods / Array.prototype.filter",
      // compat-table missing babel6 mapping
      // "well-known symbols / Symbol.species, Array.prototype.filter",
    ],
  },
  "es6.array.find": "Array.prototype methods / Array.prototype.find",
  "es6.array.find-index": "Array.prototype methods / Array.prototype.findIndex",
  "es6.array.for-each": "Array methods / Array.prototype.forEach",
  "es6.array.from": "Array static methods / Array.from",
  "es7.array.includes": "Array.prototype.includes",
  "es6.array.index-of": "Array methods / Array.prototype.indexOf",
  "es6.array.is-array": "Array methods / Array.isArray",
  // "es.array.join": "", required tests for that
  "es6.array.iterator": {
    features: [
      "Array.prototype methods / Array.prototype.keys",
      // can use Symbol.iterator, not implemented in many environments
      // "Array.prototype methods / Array.prototype.values",
      "Array.prototype methods / Array.prototype.entries",
    ],
  },
  "es6.array.last-index-of": "Array methods / Array.prototype.lastIndexOf",
  "es6.array.map": {
    features: [
      "Array methods / Array.prototype.map",
      // compat-table missing babel6 mapping
      // "well-known symbols / Symbol.species, Array.prototype.map",
    ],
  },
  "es6.array.of": "Array static methods / Array.of",
  "es6.array.reduce": "Array methods / Array.prototype.reduce",
  "es6.array.reduce-right": "Array methods / Array.prototype.reduceRight",
  // compat-table missing babel6 mapping
  // "es6.array.slice": "well-known symbols / Symbol.species, Array.prototype.slice",
  "es6.array.some": "Array methods / Array.prototype.some",
  "es6.array.sort": "Array methods / Array.prototype.sort",
  "es6.array.species": "Array static methods / Array[Symbol.species]",
  // compat-table missing babel6 mapping
  //"es6.array.splice": "well-known symbols / Symbol.species, Array.prototype.splice",
  "es6.date.now": "Date methods / Date.now",
  "es6.date.to-iso-string": "Date methods / Date.prototype.toISOString",
  "es6.date.to-json": "Date methods / Date.prototype.toJSON",
  "es6.date.to-primitive": "Date.prototype[Symbol.toPrimitive]",
  "es6.date.to-string": "miscellaneous / Invalid Date",
  "es6.function.bind": "Function.prototype.bind",
  "es6.function.has-instance": "well-known symbols / Symbol.hasInstance",
  "es6.function.name": {
    features: [
      "function \"name\" property / function statements",
      "function \"name\" property / function expressions",
    ],
  },
  "es6.map": "Map",
  "es6.math.acosh": "Math methods / Math.acosh",
  "es6.math.asinh": "Math methods / Math.asinh",
  "es6.math.atanh": "Math methods / Math.atanh",
  "es6.math.cbrt": "Math methods / Math.cbrt",
  "es6.math.clz32": "Math methods / Math.clz32",
  "es6.math.cosh": "Math methods / Math.cosh",
  "es6.math.expm1": "Math methods / Math.expm1",
  "es6.math.fround": "Math methods / Math.fround",
  "es6.math.hypot": "Math methods / Math.hypot",
  "es6.math.imul": "Math methods / Math.imul",
  "es6.math.log1p": "Math methods / Math.log1p",
  "es6.math.log10": "Math methods / Math.log10",
  "es6.math.log2": "Math methods / Math.log2",
  "es6.math.sign": "Math methods / Math.sign",
  "es6.math.sinh": "Math methods / Math.sinh",
  "es6.math.tanh": "Math methods / Math.tanh",
  "es6.math.trunc": "Math methods / Math.trunc",
  "es6.number.constructor": {
    features: [
      "octal and binary literals / octal supported by Number()",
      "octal and binary literals / binary supported by Number()",
    ],
  },
  "es6.number.epsilon": "Number properties / Number.EPSILON",
  "es6.number.is-finite": "Number properties / Number.isFinite",
  "es6.number.is-integer": "Number properties / Number.isInteger",
  "es6.number.is-nan": "Number properties / Number.isNaN",
  "es6.number.is-safe-integer": "Number properties / Number.isSafeInteger",
  "es6.number.max-safe-integer": "Number properties / Number.MAX_SAFE_INTEGER",
  "es6.number.min-safe-integer": "Number properties / Number.MIN_SAFE_INTEGER",
  "es6.number.parse-float": "Number properties / Number.parseFloat",
  "es6.number.parse-int": "Number properties / Number.parseInt",
  "es6.object.assign": {
    features: ["Object static methods / Object.assign", "Symbol"],
  },
  "es6.object.create": "Object static methods / Object.create",
  "es7.object.define-getter": {
    features: [
      "Object.prototype getter/setter methods / __defineGetter__",
      "Object.prototype getter/setter methods / __defineGetter__, symbols",
      "Object.prototype getter/setter methods / __defineGetter__, ToObject(this)",
    ],
  },
  "es7.object.define-setter": {
    features: [
      "Object.prototype getter/setter methods / __defineSetter__",
      "Object.prototype getter/setter methods / __defineSetter__, symbols",
      "Object.prototype getter/setter methods / __defineSetter__, ToObject(this)",
    ],
  },
  "es6.object.define-property": "Object static methods / Object.defineProperty",
  "es6.object.define-properties": "Object static methods / Object.defineProperties",
  "es7.object.entries": "Object static methods / Object.entries",
  "es6.object.freeze": "Object static methods accept primitives / Object.freeze",
  "es6.object.get-own-property-descriptor": "Object static methods accept primitives / Object.getOwnPropertyDescriptor",
  "es7.object.get-own-property-descriptors": "Object static methods / Object.getOwnPropertyDescriptors",
  "es6.object.get-own-property-names": "Object static methods accept primitives / Object.getOwnPropertyNames",
  "es6.object.get-prototype-of": "Object static methods accept primitives / Object.getPrototypeOf",
  "es7.object.lookup-getter": {
    features: [
      "Object.prototype getter/setter methods / __lookupGetter__",
      "Object.prototype getter/setter methods / __lookupGetter__, prototype chain",
      "Object.prototype getter/setter methods / __lookupGetter__, symbols",
      "Object.prototype getter/setter methods / __lookupGetter__, ToObject(this)",
      "Object.prototype getter/setter methods / __lookupGetter__, data properties can shadow accessors",
    ],
  },
  "es7.object.lookup-setter": {
    features: [
      "Object.prototype getter/setter methods / __lookupSetter__",
      "Object.prototype getter/setter methods / __lookupSetter__, prototype chain",
      "Object.prototype getter/setter methods / __lookupSetter__, symbols",
      "Object.prototype getter/setter methods / __lookupSetter__, ToObject(this)",
      "Object.prototype getter/setter methods / __lookupSetter__, data properties can shadow accessors",
    ],
  },
  "es6.object.prevent-extensions": "Object static methods accept primitives / Object.preventExtensions",
  "es6.object.is": "Object static methods / Object.is",
  "es6.object.is-frozen": "Object static methods accept primitives / Object.isFrozen",
  "es6.object.is-sealed": "Object static methods accept primitives / Object.isSealed",
  "es6.object.is-extensible": "Object static methods accept primitives / Object.isExtensible",
  "es6.object.keys": "Object static methods accept primitives / Object.keys",
  "es6.object.seal": "Object static methods accept primitives / Object.seal",
  "es6.object.set-prototype-of": "Object static methods / Object.setPrototypeOf",
  "es7.object.values": "Object static methods / Object.values",
  "es6.promise": {
    features: [
      // required unhandled rejection tracking tests
      "Promise",
      "well-known symbols / Symbol.species, Promise.prototype.then",
    ],
  },
  "es7.promise.finally": "Promise.prototype.finally",
  "es6.reflect.apply": "Reflect / Reflect.apply",
  "es6.reflect.construct": "Reflect / Reflect.construct",
  "es6.reflect.define-property": "Reflect / Reflect.defineProperty",
  "es6.reflect.delete-property": "Reflect / Reflect.deleteProperty",
  "es6.reflect.get": "Reflect / Reflect.get",
  "es6.reflect.get-own-property-descriptor": "Reflect / Reflect.getOwnPropertyDescriptor",
  "es6.reflect.get-prototype-of": "Reflect / Reflect.getPrototypeOf",
  "es6.reflect.has": "Reflect / Reflect.has",
  "es6.reflect.is-extensible": "Reflect / Reflect.isExtensible",
  "es6.reflect.own-keys": "Reflect / Reflect.ownKeys",
  "es6.reflect.prevent-extensions": "Reflect / Reflect.preventExtensions",
  "es6.reflect.set": "Reflect / Reflect.set",
  "es6.reflect.set-prototype-of": "Reflect / Reflect.setPrototypeOf",
  "es6.regexp.constructor": {
    features: [
      "miscellaneous / RegExp constructor can alter flags",
      "well-known symbols / Symbol.match, RegExp constructor",
    ],
  },
  "es6.regexp.flags": "RegExp.prototype properties / RegExp.prototype.flags",
  "es6.regexp.match": "RegExp.prototype properties / RegExp.prototype[Symbol.match]",
  "es6.regexp.replace": "RegExp.prototype properties / RegExp.prototype[Symbol.replace]",
  "es6.regexp.split": "RegExp.prototype properties / RegExp.prototype[Symbol.split]",
  "es6.regexp.search": "RegExp.prototype properties / RegExp.prototype[Symbol.search]",
  "es6.regexp.to-string": "miscellaneous / RegExp.prototype.toString generic and uses \"flags\" property",
  // This is explicit due to prevent the stage-1 Set proposals under the
  // category "Set methods" from being included.
  "es6.set": {
    features: [
      "Set / basic functionality",
      "Set / constructor arguments",
      "Set / constructor requires new",
      "Set / constructor accepts null",
      "Set / constructor invokes add",
      "Set / iterator closing",
      "Set / Set.prototype.add returns this",
      "Set / -0 key converts to +0",
      "Set / Set.prototype.size",
      "Set / Set.prototype.delete",
      "Set / Set.prototype.clear",
      "Set / Set.prototype.forEach",
      "Set / Set.prototype.keys",
      "Set / Set.prototype.values",
      "Set / Set.prototype.entries",
      "Set / Set.prototype[Symbol.iterator]",
      "Set / Set.prototype isn't an instance",
      "Set / Set iterator prototype chain",
      "Set / Set[Symbol.species]",
    ],
  },
  "es6.symbol": {
    features: [
      "Symbol",
      "Object static methods / Object.getOwnPropertySymbols",
      "well-known symbols / Symbol.hasInstance",
      "well-known symbols / Symbol.isConcatSpreadable",
      "well-known symbols / Symbol.iterator",
      "well-known symbols / Symbol.match",
      "well-known symbols / Symbol.replace",
      "well-known symbols / Symbol.search",
      "well-known symbols / Symbol.species",
      "well-known symbols / Symbol.split",
      "well-known symbols / Symbol.toPrimitive",
      "well-known symbols / Symbol.toStringTag",
      "well-known symbols / Symbol.unscopables",
    ],
  },
  "es7.symbol.async-iterator": "Asynchronous Iterators",
  "es6.string.anchor": "String.prototype HTML methods",
  "es6.string.big": "String.prototype HTML methods",
  "es6.string.blink": "String.prototype HTML methods",
  "es6.string.bold": "String.prototype HTML methods",
  "es6.string.code-point-at": "String.prototype methods / String.prototype.codePointAt",
  "es6.string.ends-with": "String.prototype methods / String.prototype.endsWith",
  "es6.string.fixed": "String.prototype HTML methods",
  "es6.string.fontcolor": "String.prototype HTML methods",
  "es6.string.fontsize": "String.prototype HTML methods",
  "es6.string.from-code-point": "String static methods / String.fromCodePoint",
  "es6.string.includes": "String.prototype methods / String.prototype.includes",
  "es6.string.italics": "String.prototype HTML methods",
  "es6.string.iterator": "String.prototype methods / String.prototype[Symbol.iterator]",
  "es6.string.link": "String.prototype HTML methods",
  // "String.prototype methods / String.prototype.normalize" not implemented
  "es7.string.pad-start": "String padding / String.prototype.padStart",
  "es7.string.pad-end": "String padding / String.prototype.padEnd",
  "es6.string.raw": "String static methods / String.raw",
  "es6.string.repeat": "String.prototype methods / String.prototype.repeat",
  "es6.string.small": "String.prototype HTML methods",
  "es6.string.starts-with": "String.prototype methods / String.prototype.startsWith",
  "es6.string.strike": "String.prototype HTML methods",
  "es6.string.sub": "String.prototype HTML methods",
  "es6.string.sup": "String.prototype HTML methods",
  "es6.string.trim": "String properties and methods / String.prototype.trim",
  "es6.typed.array-buffer": "typed arrays / ArrayBuffer[Symbol.species]",
  "es6.typed.data-view": "typed arrays / DataView",
  "es6.typed.int8-array": {
    features: ["typed arrays / Int8Array"].concat(typedArrayMethods),
  },
  "es6.typed.uint8-array": {
    features: ["typed arrays / Uint8Array"].concat(typedArrayMethods),
  },
  "es6.typed.uint8-clamped-array": {
    features: ["typed arrays / Uint8ClampedArray"].concat(typedArrayMethods),
  },
  "es6.typed.int16-array": {
    features: ["typed arrays / Int16Array"].concat(typedArrayMethods),
  },
  "es6.typed.uint16-array": {
    features: ["typed arrays / Uint16Array"].concat(typedArrayMethods),
  },
  "es6.typed.int32-array": {
    features: ["typed arrays / Int32Array"].concat(typedArrayMethods),
  },
  "es6.typed.uint32-array": {
    features: ["typed arrays / Uint32Array"].concat(typedArrayMethods),
  },
  "es6.typed.float32-array": {
    features: ["typed arrays / Float32Array"].concat(typedArrayMethods),
  },
  "es6.typed.float64-array": {
    features: ["typed arrays / Float64Array"].concat(typedArrayMethods),
  },
  "es6.weak-map": "WeakMap",
  "es6.weak-set": "WeakSet",
};
const proposals = require("./shipped-proposals").builtIns;
module.exports = Object.assign({}, es, proposals);

// </from> /home/qfox/apps/babel/packages/babel-preset-env/data/built-in-features.js

// <from> /home/qfox/apps/babel/packages/babel-preset-env/data/shipped-proposals.js

// These mappings represent the builtin/feature proposals that have been
// shipped by browsers, and are enabled by the `shippedProposals` option.
const builtIns = {
  "es7.array.flat-map": "Array.prototype.{flat, flatMap} / Array.prototype.flatMap"
};
const features = {};
const pluginSyntaxMap = new Map([
  ["proposal-async-generator-functions", "syntax-async-generators"],
  ["proposal-object-rest-spread", "syntax-object-rest-spread"],
  ["proposal-optional-catch-binding", "syntax-optional-catch-binding"],
  ["proposal-unicode-property-regex", null],
  ["proposal-json-strings", "syntax-json-strings"],
]);
module.exports = { builtIns, features, pluginSyntaxMap };

// </from> /home/qfox/apps/babel/packages/babel-preset-env/data/shipped-proposals.js

// <from> /home/qfox/apps/babel/packages/babel-helper-replace-supers/src/index.js

import traverse from "@babel/traverse";
import memberExpressionToFunctions from "@babel/helper-member-expression-to-functions";
import optimiseCall from "@babel/helper-optimise-call-expression";
import * as t from "@babel/types";
/**
 * Creates an expression which result is the proto of objectRef.
 *
 * @example <caption>isStatic === true</caption>
 *
 *   helpers.getPrototypeOf(CLASS)
 *
 * @example <caption>isStatic === false</caption>
 *
 *   helpers.getPrototypeOf(CLASS.prototype)
 */
function getPrototypeOfExpression(objectRef, isStatic, file) {
  objectRef = t.cloneNode(objectRef);
  const targetRef = isStatic
    ? objectRef
    : t.memberExpression(objectRef, t.identifier("prototype"));
  return t.callExpression(file.addHelper("getPrototypeOf"), [targetRef]);
}
function skipAllButComputedKey(path) {
  // If the path isn't computed, just skip everything.
  if (!path.node.computed) {
    path.skip();
    return;
  }
  // So it's got a computed key. Make sure to skip every other key the
  // traversal would visit.
  const keys = t.VISITOR_KEYS[path.type];
  for (const key of keys) {
    if (key !== "key") path.skipKey(key);
  }
}
export const environmentVisitor = {
  Function(path) {
    // Methods will be handled by the Method visit
    if (path.isMethod()) return;
    // Arrow functions inherit their parent's environment
    if (path.isArrowFunctionExpression()) return;
    path.skip();
  },
  Method(path) {
    skipAllButComputedKey(path);
  },
  "ClassProperty|ClassPrivateProperty"(path) {
    // If the property is computed, we need to visit everything.
    if (path.node.static) return;
    skipAllButComputedKey(path);
  },
};
const visitor = traverse.visitors.merge([
  environmentVisitor,
  {
    Super(path, state) {
      const { node, parentPath } = path;
      if (!parentPath.isMemberExpression({ object: node })) return;
      state.handle(parentPath);
    },
  },
]);
const specHandlers = {
  memoise(superMember, count) {
    const { scope, node } = superMember;
    const { computed, property } = node;
    if (!computed) {
      return;
    }
    const memo = scope.maybeGenerateMemoised(property);
    if (!memo) {
      return;
    }
    this.memoiser.set(property, memo, count);
  },
  prop(superMember) {
    const { computed, property } = superMember.node;
    if (this.memoiser.has(property)) {
      return t.cloneNode(this.memoiser.get(property));
    }
    if (computed) {
      return t.cloneNode(property);
    }
    return t.stringLiteral(property.name);
  },
  get(superMember) {
    return t.callExpression(this.file.addHelper("get"), [
      getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file),
      this.prop(superMember),
      t.thisExpression(),
    ]);
  },
  set(superMember, value) {
    return t.callExpression(this.file.addHelper("set"), [
      getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file),
      this.prop(superMember),
      value,
      t.thisExpression(),
      t.booleanLiteral(superMember.isInStrictMode()),
    ]);
  },
  call(superMember, args) {
    return optimiseCall(this.get(superMember), t.thisExpression(), args);
  },
};
const looseHandlers = {
  ...specHandlers,
  prop(superMember) {
    const { property } = superMember.node;
    if (this.memoiser.has(property)) {
      return t.cloneNode(this.memoiser.get(property));
    }
    return t.cloneNode(property);
  },
  get(superMember) {
    const { isStatic, superRef } = this;
    const { computed } = superMember.node;
    const prop = this.prop(superMember);
    let object;
    if (isStatic) {
      object = superRef
        ? t.cloneNode(superRef)
        : t.memberExpression(
            t.identifier("Function"),
            t.identifier("prototype"),
          );
    } else {
      object = superRef
        ? t.memberExpression(t.cloneNode(superRef), t.identifier("prototype"))
        : t.memberExpression(t.identifier("Object"), t.identifier("prototype"));
    }
    return t.memberExpression(object, prop, computed);
  },
  set(superMember, value) {
    const { computed } = superMember.node;
    const prop = this.prop(superMember);
    return t.assignmentExpression(
      "=",
      t.memberExpression(t.thisExpression(), prop, computed),
      value,
    );
  },
};
export default class ReplaceSupers {
  constructor(opts: Object) {
    const path = opts.methodPath;
    this.methodPath = path;
    this.isStatic =
      path.isClassMethod({ static: true }) || path.isObjectMethod();
    this.file = opts.file;
    this.superRef = opts.superRef;
    this.isLoose = opts.isLoose;
    this.opts = opts;
  }
  methodPath: NodePath;
  superRef: Object;
  isStatic: boolean;
  isLoose: boolean;
  file;
  opts: {
    getObjetRef: Function,
    methodPath: NodePath,
    superRef: Object,
    isLoose: boolean,
    file: any,
  };
  getObjectRef() {
    return t.cloneNode(this.opts.objectRef || this.opts.getObjectRef());
  }
  replace() {
    const handler = this.isLoose ? looseHandlers : specHandlers;
    memberExpressionToFunctions(this.methodPath, visitor, {
      file: this.file,
      isStatic: this.isStatic,
      getObjectRef: this.getObjectRef.bind(this),
      superRef: this.superRef,
      ...handler,
    });
  }
}

// </from> /home/qfox/apps/babel/packages/babel-helper-replace-supers/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-helper-annotate-as-pure/src/index.js

import * as t from "@babel/types";
const PURE_ANNOTATION = "#__PURE__";
const isPureAnnotated = ({ leadingComments }) =>
  !!leadingComments &&
  leadingComments.some(comment => /[@#]__PURE__/.test(comment.value));
export default function annotateAsPure(pathOrNode) {
  const node = pathOrNode.node || pathOrNode;
  if (isPureAnnotated(node)) {
    return;
  }
  t.addComment(node, "leading", PURE_ANNOTATION);
}

// </from> /home/qfox/apps/babel/packages/babel-helper-annotate-as-pure/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-react-jsx-compat/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import helper from "@babel/helper-builder-react-jsx";
import { types as t } from "@babel/core";
export default declare(api => {
  api.assertVersion(7);
  return {
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("jsx");
    },
    visitor: helper({
      pre(state) {
        state.callee = state.tagExpr;
      },
      post(state) {
        if (t.react.isCompatTag(state.tagName)) {
          state.call = t.callExpression(
            t.memberExpression(
              t.memberExpression(t.identifier("React"), t.identifier("DOM")),
              state.tagExpr,
              t.isLiteral(state.tagExpr),
            ),
            state.args,
          );
        }
      },
      compat: true,
    }),
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-react-jsx-compat/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-proposal-async-generator-functions/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import remapAsyncToGenerator from "@babel/helper-remap-async-to-generator";
import syntaxAsyncGenerators from "@babel/plugin-syntax-async-generators";
import { types as t } from "@babel/core";
import rewriteForAwait from "./for-await";
export default declare(api => {
  api.assertVersion(7);
  const yieldStarVisitor = {
    Function(path) {
      path.skip();
    },
    YieldExpression({ node }, state) {
      if (!node.delegate) return;
      const callee = state.addHelper("asyncGeneratorDelegate");
      node.argument = t.callExpression(callee, [
        t.callExpression(state.addHelper("asyncIterator"), [node.argument]),
        state.addHelper("awaitAsyncGenerator"),
      ]);
    },
  };
  const forAwaitVisitor = {
    Function(path) {
      path.skip();
    },
    ForOfStatement(path, { file }) {
      const { node } = path;
      if (!node.await) return;
      const build = rewriteForAwait(path, {
        getAsyncIterator: file.addHelper("asyncIterator"),
      });
      const { declar, loop } = build;
      const block = loop.body;
      // ensure that it's a block so we can take all its statements
      path.ensureBlock();
      // add the value declaration to the new loop body
      if (declar) {
        block.body.push(declar);
      }
      // push the rest of the original loop body onto our new body
      block.body = block.body.concat(node.body.body);
      t.inherits(loop, node);
      t.inherits(loop.body, node.body);
      if (build.replaceParent) {
        path.parentPath.replaceWithMultiple(build.node);
      } else {
        path.replaceWithMultiple(build.node);
      }
    },
  };
  const visitor = {
    Function(path, state) {
      if (!path.node.async) return;
      path.traverse(forAwaitVisitor, state);
      if (!path.node.generator) return;
      path.traverse(yieldStarVisitor, state);
      remapAsyncToGenerator(path, {
        wrapAsync: state.addHelper("wrapAsyncGenerator"),
        wrapAwait: state.addHelper("awaitAsyncGenerator"),
      });
    },
  };
  return {
    inherits: syntaxAsyncGenerators,
    visitor: {
      Program(path, state) {
        // We need to traverse the ast here (instead of just vising Function
        // in the top level visitor) because for-await needs to run before the
        // async-to-generator plugin. This is because for-await is transpiled
        // using "await" expressions, which are then converted to "yield".
        //
        // This is bad for performance, but plugin ordering will allow as to
        // directly visit Function in the top level visitor.
        path.traverse(visitor, state);
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-proposal-async-generator-functions/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-proposal-async-generator-functions/src/for-await.js

import { types as t, template } from "@babel/core";
const buildForAwait = template(`
  async function wrapper() {
    var ITERATOR_COMPLETION = true;
    var ITERATOR_HAD_ERROR_KEY = false;
    var ITERATOR_ERROR_KEY;
    try {
      for (
        var ITERATOR_KEY = GET_ITERATOR(OBJECT), STEP_KEY, STEP_VALUE;
        (
          STEP_KEY = await ITERATOR_KEY.next(),
          ITERATOR_COMPLETION = STEP_KEY.done,
          STEP_VALUE = await STEP_KEY.value,
          !ITERATOR_COMPLETION
        );
        ITERATOR_COMPLETION = true) {
      }
    } catch (err) {
      ITERATOR_HAD_ERROR_KEY = true;
      ITERATOR_ERROR_KEY = err;
    } finally {
      try {
        if (!ITERATOR_COMPLETION && ITERATOR_KEY.return != null) {
          await ITERATOR_KEY.return();
        }
      } finally {
        if (ITERATOR_HAD_ERROR_KEY) {
          throw ITERATOR_ERROR_KEY;
        }
      }
    }
  }
`);
export default function(path, { getAsyncIterator }) {
  const { node, scope, parent } = path;
  const stepKey = scope.generateUidIdentifier("step");
  const stepValue = scope.generateUidIdentifier("value");
  const left = node.left;
  let declar;
  if (t.isIdentifier(left) || t.isPattern(left) || t.isMemberExpression(left)) {
    // for await (i of test), for await ({ i } of test)
    declar = t.expressionStatement(
      t.assignmentExpression("=", left, stepValue),
    );
  } else if (t.isVariableDeclaration(left)) {
    // for await (let i of test)
    declar = t.variableDeclaration(left.kind, [
      t.variableDeclarator(left.declarations[0].id, stepValue),
    ]);
  }
  let template = buildForAwait({
    ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier("didIteratorError"),
    ITERATOR_COMPLETION: scope.generateUidIdentifier(
      "iteratorNormalCompletion",
    ),
    ITERATOR_ERROR_KEY: scope.generateUidIdentifier("iteratorError"),
    ITERATOR_KEY: scope.generateUidIdentifier("iterator"),
    GET_ITERATOR: getAsyncIterator,
    OBJECT: node.right,
    STEP_VALUE: stepValue,
    STEP_KEY: stepKey,
  });
  // remove async function wrapper
  template = template.body.body;
  const isLabeledParent = t.isLabeledStatement(parent);
  const tryBody = template[3].block.body;
  const loop = tryBody[0];
  if (isLabeledParent) {
    tryBody[0] = t.labeledStatement(parent.label, loop);
  }
  return {
    replaceParent: isLabeledParent,
    node: template,
    declar,
    loop,
  };
}

// </from> /home/qfox/apps/babel/packages/babel-plugin-proposal-async-generator-functions/src/for-await.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-react-inline-elements/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import helper from "@babel/helper-builder-react-jsx";
import { types as t } from "@babel/core";
export default declare(api => {
  api.assertVersion(7);
  function hasRefOrSpread(attrs) {
    for (let i = 0; i < attrs.length; i++) {
      const attr = attrs[i];
      if (t.isJSXSpreadAttribute(attr)) return true;
      if (isJSXAttributeOfName(attr, "ref")) return true;
    }
    return false;
  }
  function isJSXAttributeOfName(attr, name) {
    return (
      t.isJSXAttribute(attr) && t.isJSXIdentifier(attr.name, { name: name })
    );
  }
  const visitor = helper({
    filter(node) {
      return (
        // Regular JSX nodes have an `openingElement`. JSX fragments, however, don't have an
        // `openingElement` which causes `node.openingElement.attributes` to throw.
        node.openingElement && !hasRefOrSpread(node.openingElement.attributes)
      );
    },
    pre(state) {
      const tagName = state.tagName;
      const args = state.args;
      if (t.react.isCompatTag(tagName)) {
        args.push(t.stringLiteral(tagName));
      } else {
        args.push(state.tagExpr);
      }
    },
    post(state, pass) {
      state.callee = pass.addHelper("jsx");
      // NOTE: The arguments passed to the "jsx" helper are:
      //   (element, props, key, ...children) or (element, props)
      // The argument generated by the helper are:
      //   (element, { ...props, key }, ...children)
      const props = state.args[1];
      let hasKey = false;
      if (t.isObjectExpression(props)) {
        const keyIndex = props.properties.findIndex(prop =>
          t.isIdentifier(prop.key, { name: "key" }),
        );
        if (keyIndex > -1) {
          state.args.splice(2, 0, props.properties[keyIndex].value);
          props.properties.splice(keyIndex, 1);
          hasKey = true;
        }
      } else if (t.isNullLiteral(props)) {
        state.args.splice(1, 1, t.objectExpression([]));
      }
      if (!hasKey && state.args.length > 2) {
        state.args.splice(2, 0, t.unaryExpression("void", t.numericLiteral(0)));
      }
    },
  });
  return { visitor };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-react-inline-elements/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-parameters/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import convertFunctionParams from "./params";
import convertFunctionRest from "./rest";
export default declare((api, options) => {
  api.assertVersion(7);
  const { loose } = options;
  return {
    visitor: {
      Function(path) {
        if (
          path.isArrowFunctionExpression() &&
          path
            .get("params")
            .some(param => param.isRestElement() || param.isAssignmentPattern())
        ) {
          // default/rest visitors require access to `arguments`, so it cannot be an arrow
          path.arrowFunctionToExpression();
        }
        const convertedRest = convertFunctionRest(path);
        const convertedParams = convertFunctionParams(path, loose);
        if (convertedRest || convertedParams) {
          // Manually reprocess this scope to ensure that the moved params are updated.
          path.scope.crawl();
        }
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-parameters/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-parameters/src/params.js

import callDelegate from "@babel/helper-call-delegate";
import { template, types as t } from "@babel/core";
const buildDefaultParam = template(`
  let VARIABLE_NAME =
    arguments.length > ARGUMENT_KEY && arguments[ARGUMENT_KEY] !== undefined ?
      arguments[ARGUMENT_KEY]
    :
      DEFAULT_VALUE;
`);
const buildLooseDefaultParam = template(`
  if (ASSIGNMENT_IDENTIFIER === UNDEFINED) {
    ASSIGNMENT_IDENTIFIER = DEFAULT_VALUE;
  }
`);
const buildLooseDestructuredDefaultParam = template(`
  let ASSIGNMENT_IDENTIFIER = PARAMETER_NAME === UNDEFINED ? DEFAULT_VALUE : PARAMETER_NAME ;
`);
const buildSafeArgumentsAccess = template(`
  let $0 = arguments.length > $1 ? arguments[$1] : undefined;
`);
function isSafeBinding(scope, node) {
  if (!scope.hasOwnBinding(node.name)) return true;
  const { kind } = scope.getOwnBinding(node.name);
  return kind === "param" || kind === "local";
}
const iifeVisitor = {
  ReferencedIdentifier(path, state) {
    const { scope, node } = path;
    if (node.name === "eval" || !isSafeBinding(scope, node)) {
      state.iife = true;
      path.stop();
    }
  },
  Scope(path) {
    // different bindings
    path.skip();
  },
};
export default function convertFunctionParams(path, loose) {
  const { node, scope } = path;
  const state = {
    iife: false,
    scope: scope,
  };
  const body = [];
  const params = path.get("params");
  let firstOptionalIndex = null;
  for (let i = 0; i < params.length; i++) {
    const param = params[i];
    const paramIsAssignmentPattern = param.isAssignmentPattern();
    if (paramIsAssignmentPattern && (loose || node.kind === "set")) {
      const left = param.get("left");
      const right = param.get("right");
      const undefinedNode = scope.buildUndefinedNode();
      if (left.isIdentifier()) {
        body.push(
          buildLooseDefaultParam({
            ASSIGNMENT_IDENTIFIER: t.cloneNode(left.node),
            DEFAULT_VALUE: right.node,
            UNDEFINED: undefinedNode,
          }),
        );
        param.replaceWith(left.node);
      } else if (left.isObjectPattern() || left.isArrayPattern()) {
        const paramName = scope.generateUidIdentifier();
        body.push(
          buildLooseDestructuredDefaultParam({
            ASSIGNMENT_IDENTIFIER: left.node,
            DEFAULT_VALUE: right.node,
            PARAMETER_NAME: t.cloneNode(paramName),
            UNDEFINED: undefinedNode,
          }),
        );
        param.replaceWith(paramName);
      }
    } else if (paramIsAssignmentPattern) {
      if (firstOptionalIndex === null) firstOptionalIndex = i;
      const left = param.get("left");
      const right = param.get("right");
      if (!state.iife) {
        if (right.isIdentifier() && !isSafeBinding(scope, right.node)) {
          // the right hand side references a parameter
          state.iife = true;
        } else {
          right.traverse(iifeVisitor, state);
        }
      }
      const defNode = buildDefaultParam({
        VARIABLE_NAME: left.node,
        DEFAULT_VALUE: right.node,
        ARGUMENT_KEY: t.numericLiteral(i),
      });
      body.push(defNode);
    } else if (firstOptionalIndex !== null) {
      const defNode = buildSafeArgumentsAccess([
        param.node,
        t.numericLiteral(i),
      ]);
      body.push(defNode);
    } else if (param.isObjectPattern() || param.isArrayPattern()) {
      const uid = path.scope.generateUidIdentifier("ref");
      const defNode = t.variableDeclaration("let", [
        t.variableDeclarator(param.node, uid),
      ]);
      body.push(defNode);
      param.replaceWith(t.cloneNode(uid));
    }
    if (!state.iife && !param.isIdentifier()) {
      param.traverse(iifeVisitor, state);
    }
  }
  if (body.length === 0) return false;
  // we need to cut off all trailing parameters
  if (firstOptionalIndex !== null) {
    node.params = node.params.slice(0, firstOptionalIndex);
  }
  // ensure it's a block, useful for arrow functions
  path.ensureBlock();
  if (state.iife) {
    body.push(callDelegate(path, scope));
    path.set("body", t.blockStatement(body));
  } else {
    path.get("body").unshiftContainer("body", body);
  }
  return true;
}

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-parameters/src/params.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-parameters/src/rest.js

import { template, types as t } from "@babel/core";
const buildRest = template(`
  for (var LEN = ARGUMENTS.length,
           ARRAY = new Array(ARRAY_LEN),
           KEY = START;
       KEY < LEN;
       KEY++) {
    ARRAY[ARRAY_KEY] = ARGUMENTS[KEY];
  }
`);
const restIndex = template(`
  (INDEX < OFFSET || ARGUMENTS.length <= INDEX) ? undefined : ARGUMENTS[INDEX]
`);
const restIndexImpure = template(`
  REF = INDEX, (REF < OFFSET || ARGUMENTS.length <= REF) ? undefined : ARGUMENTS[REF]
`);
const restLength = template(`
  ARGUMENTS.length <= OFFSET ? 0 : ARGUMENTS.length - OFFSET
`);
function referencesRest(path, state) {
  if (path.node.name === state.name) {
    // Check rest parameter is not shadowed by a binding in another scope.
    return path.scope.bindingIdentifierEquals(state.name, state.outerBinding);
  }
  return false;
}
const memberExpressionOptimisationVisitor = {
  Scope(path, state) {
    // check if this scope has a local binding that will shadow the rest parameter
    if (!path.scope.bindingIdentifierEquals(state.name, state.outerBinding)) {
      path.skip();
    }
  },
  Flow(path) {
    // Do not skip TypeCastExpressions as the contain valid non flow code
    if (path.isTypeCastExpression()) return;
    // don't touch reference in type annotations
    path.skip();
  },
  Function(path, state) {
    // Detect whether any reference to rest is contained in nested functions to
    // determine if deopt is necessary.
    const oldNoOptimise = state.noOptimise;
    state.noOptimise = true;
    path.traverse(memberExpressionOptimisationVisitor, state);
    state.noOptimise = oldNoOptimise;
    // Skip because optimizing references to rest would refer to the `arguments`
    // of the nested function.
    path.skip();
  },
  ReferencedIdentifier(path, state) {
    const { node } = path;
    // we can't guarantee the purity of arguments
    if (node.name === "arguments") {
      state.deopted = true;
    }
    // is this a referenced identifier and is it referencing the rest parameter?
    if (!referencesRest(path, state)) return;
    if (state.noOptimise) {
      state.deopted = true;
    } else {
      const { parentPath } = path;
      // Is this identifier the right hand side of a default parameter?
      if (parentPath.listKey === "params" && parentPath.key < state.offset) {
        return;
      }
      // ex: `args[0]`
      // ex: `args.whatever`
      if (parentPath.isMemberExpression({ object: node })) {
        const grandparentPath = parentPath.parentPath;
        const argsOptEligible =
          !state.deopted &&
          !// ex: `args[0] = "whatever"`
          (
            (grandparentPath.isAssignmentExpression() &&
              parentPath.node === grandparentPath.node.left) ||
            // ex: `[args[0]] = ["whatever"]`
            grandparentPath.isLVal() ||
            // ex: `for (rest[0] in this)`
            // ex: `for (rest[0] of this)`
            grandparentPath.isForXStatement() ||
            // ex: `++args[0]`
            // ex: `args[0]--`
            grandparentPath.isUpdateExpression() ||
            // ex: `delete args[0]`
            grandparentPath.isUnaryExpression({ operator: "delete" }) ||
            // ex: `args[0]()`
            // ex: `new args[0]()`
            // ex: `new args[0]`
            ((grandparentPath.isCallExpression() ||
              grandparentPath.isNewExpression()) &&
              parentPath.node === grandparentPath.node.callee)
          );
        if (argsOptEligible) {
          if (parentPath.node.computed) {
            // if we know that this member expression is referencing a number then
            // we can safely optimise it
            if (parentPath.get("property").isBaseType("number")) {
              state.candidates.push({ cause: "indexGetter", path });
              return;
            }
          } else if (parentPath.node.property.name === "length") {
            // args.length
            state.candidates.push({ cause: "lengthGetter", path });
            return;
          }
        }
      }
      // we can only do these optimizations if the rest variable would match
      // the arguments exactly
      // optimise single spread args in calls
      // ex: fn(...args)
      if (state.offset === 0 && parentPath.isSpreadElement()) {
        const call = parentPath.parentPath;
        if (call.isCallExpression() && call.node.arguments.length === 1) {
          state.candidates.push({ cause: "argSpread", path });
          return;
        }
      }
      state.references.push(path);
    }
  },
  /**
   * Deopt on use of a binding identifier with the same name as our rest param.
   *
   * See https://github.com/babel/babel/issues/2091
   */
  BindingIdentifier(path, state) {
    if (referencesRest(path, state)) {
      state.deopted = true;
    }
  },
};
function hasRest(node) {
  const length = node.params.length;
  return length > 0 && t.isRestElement(node.params[length - 1]);
}
function optimiseIndexGetter(path, argsId, offset) {
  const offsetLiteral = t.numericLiteral(offset);
  let index;
  if (t.isNumericLiteral(path.parent.property)) {
    index = t.numericLiteral(path.parent.property.value + offset);
  } else if (offset === 0) {
    // Avoid unnecessary '+ 0'
    index = path.parent.property;
  } else {
    index = t.binaryExpression(
      "+",
      path.parent.property,
      t.cloneNode(offsetLiteral),
    );
  }
  const { scope } = path;
  if (!scope.isPure(index)) {
    const temp = scope.generateUidIdentifierBasedOnNode(index);
    scope.push({ id: temp, kind: "var" });
    path.parentPath.replaceWith(
      restIndexImpure({
        ARGUMENTS: argsId,
        OFFSET: offsetLiteral,
        INDEX: index,
        REF: t.cloneNode(temp),
      }),
    );
  } else {
    const parentPath = path.parentPath;
    parentPath.replaceWith(
      restIndex({
        ARGUMENTS: argsId,
        OFFSET: offsetLiteral,
        INDEX: index,
      }),
    );
    // See if we can statically evaluate the first test (i.e. index < offset)
    // and optimize the AST accordingly.
    const offsetTestPath = parentPath.get("test").get("left");
    const valRes = offsetTestPath.evaluate();
    if (valRes.confident) {
      if (valRes.value === true) {
        parentPath.replaceWith(parentPath.scope.buildUndefinedNode());
      } else {
        parentPath.get("test").replaceWith(parentPath.get("test").get("right"));
      }
    }
  }
}
function optimiseLengthGetter(path, argsId, offset) {
  if (offset) {
    path.parentPath.replaceWith(
      restLength({
        ARGUMENTS: argsId,
        OFFSET: t.numericLiteral(offset),
      }),
    );
  } else {
    path.replaceWith(argsId);
  }
}
export default function convertFunctionRest(path) {
  const { node, scope } = path;
  if (!hasRest(node)) return false;
  let rest = node.params.pop().argument;
  const argsId = t.identifier("arguments");
  if (t.isPattern(rest)) {
    const pattern = rest;
    rest = scope.generateUidIdentifier("ref");
    const declar = t.variableDeclaration("let", [
      t.variableDeclarator(pattern, rest),
    ]);
    node.body.body.unshift(declar);
  }
  // check and optimise for extremely common cases
  const state = {
    references: [],
    offset: node.params.length,
    argumentsNode: argsId,
    outerBinding: scope.getBindingIdentifier(rest.name),
    // candidate member expressions we could optimise if there are no other references
    candidates: [],
    // local rest binding name
    name: rest.name,
    /*
    It may be possible to optimize the output code in certain ways, such as
    not generating code to initialize an array (perhaps substituting direct
    references to arguments[i] or arguments.length for reads of the
    corresponding rest parameter property) or positioning the initialization
    code so that it may not have to execute depending on runtime conditions.
    This property tracks eligibility for optimization. "deopted" means give up
    and don't perform optimization. For example, when any of rest's elements /
    properties is assigned to at the top level, or referenced at all in a
    nested function.
    */
    deopted: false,
  };
  path.traverse(memberExpressionOptimisationVisitor, state);
  // There are only "shorthand" references
  if (!state.deopted && !state.references.length) {
    for (const { path, cause } of (state.candidates: Array)) {
      const clonedArgsId = t.cloneNode(argsId);
      switch (cause) {
        case "indexGetter":
          optimiseIndexGetter(path, clonedArgsId, state.offset);
          break;
        case "lengthGetter":
          optimiseLengthGetter(path, clonedArgsId, state.offset);
          break;
        default:
          path.replaceWith(clonedArgsId);
      }
    }
    return true;
  }
  state.references = state.references.concat(
    state.candidates.map(({ path }) => path),
  );
  const start = t.numericLiteral(node.params.length);
  const key = scope.generateUidIdentifier("key");
  const len = scope.generateUidIdentifier("len");
  let arrKey, arrLen;
  if (node.params.length) {
    // this method has additional params, so we need to subtract
    // the index of the current argument position from the
    // position in the array that we want to populate
    arrKey = t.binaryExpression("-", t.cloneNode(key), t.cloneNode(start));
    // we need to work out the size of the array that we're
    // going to store all the rest parameters
    //
    // we need to add a check to avoid constructing the array
    // with <0 if there are less arguments than params as it'll
    // cause an error
    arrLen = t.conditionalExpression(
      t.binaryExpression(">", t.cloneNode(len), t.cloneNode(start)),
      t.binaryExpression("-", t.cloneNode(len), t.cloneNode(start)),
      t.numericLiteral(0),
    );
  } else {
    arrKey = t.identifier(key.name);
    arrLen = t.identifier(len.name);
  }
  const loop = buildRest({
    ARGUMENTS: argsId,
    ARRAY_KEY: arrKey,
    ARRAY_LEN: arrLen,
    START: start,
    ARRAY: rest,
    KEY: key,
    LEN: len,
  });
  if (state.deopted) {
    node.body.body.unshift(loop);
  } else {
    let target = path
      .getEarliestCommonAncestorFrom(state.references)
      .getStatementParent();
    // don't perform the allocation inside a loop
    target.findParent(path => {
      if (path.isLoop()) {
        target = path;
      } else {
        // Stop crawling up if this is a function.
        return path.isFunction();
      }
    });
    target.insertBefore(loop);
  }
  return true;
}

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-parameters/src/rest.js

// <from> /home/qfox/apps/babel/packages/babel-helper-optimise-call-expression/src/index.js

import * as t from "@babel/types";
export default function(callee, thisNode, args) {
  if (
    args.length === 1 &&
    t.isSpreadElement(args[0]) &&
    t.isIdentifier(args[0].argument, { name: "arguments" })
  ) {
    // eg. super(...arguments);
    return t.callExpression(t.memberExpression(callee, t.identifier("apply")), [
      thisNode,
      args[0].argument,
    ]);
  } else {
    return t.callExpression(t.memberExpression(callee, t.identifier("call")), [
      thisNode,
      ...args,
    ]);
  }
}

// </from> /home/qfox/apps/babel/packages/babel-helper-optimise-call-expression/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-modules-commonjs/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import {
  isModule,
  rewriteModuleStatementsAndPrepareHeader,
  isSideEffectImport,
  buildNamespaceInitStatements,
  ensureStatementsHoisted,
  wrapInterop,
} from "@babel/helper-module-transforms";
import simplifyAccess from "@babel/helper-simple-access";
import { template, types as t } from "@babel/core";
export default declare((api, options) => {
  api.assertVersion(7);
  const {
    loose,
    // 'true' for non-mjs files to strictly have .default, instead of having
    // destructuring-like behavior for their properties.
    strictNamespace = false,
    // 'true' for mjs files to strictly have .default, instead of having
    // destructuring-like behavior for their properties.
    mjsStrictNamespace = true,
    allowTopLevelThis,
    strict,
    strictMode,
    noInterop,
    lazy = false,
    // Defaulting to 'true' for now. May change before 7.x major.
    allowCommonJSExports = true,
  } = options;
  if (
    typeof lazy !== "boolean" &&
    typeof lazy !== "function" &&
    (!Array.isArray(lazy) || !lazy.every(item => typeof item === "string"))
  ) {
    throw new Error(`.lazy must be a boolean, array of strings, or a function`);
  }
  if (typeof strictNamespace !== "boolean") {
    throw new Error(`.strictNamespace must be a boolean, or undefined`);
  }
  if (typeof mjsStrictNamespace !== "boolean") {
    throw new Error(`.mjsStrictNamespace must be a boolean, or undefined`);
  }
  const getAssertion = localName => template.expression.ast`
    (function(){
      throw new Error(
        "The CommonJS '" + "${localName}" + "' variable is not available in ES6 modules." +
        "Consider setting setting sourceType:script or sourceType:unambiguous in your " +
        "Babel config for this file.");
    })()
  `;
  const moduleExportsVisitor = {
    ReferencedIdentifier(path) {
      const localName = path.node.name;
      if (localName !== "module" && localName !== "exports") return;
      const localBinding = path.scope.getBinding(localName);
      const rootBinding = this.scope.getBinding(localName);
      if (
        // redeclared in this scope
        rootBinding !== localBinding ||
        (path.parentPath.isObjectProperty({ value: path.node }) &&
          path.parentPath.parentPath.isObjectPattern()) ||
        path.parentPath.isAssignmentExpression({ left: path.node }) ||
        path.isAssignmentExpression({ left: path.node })
      ) {
        return;
      }
      path.replaceWith(getAssertion(localName));
    },
    AssignmentExpression(path) {
      const left = path.get("left");
      if (left.isIdentifier()) {
        const localName = path.node.name;
        if (localName !== "module" && localName !== "exports") return;
        const localBinding = path.scope.getBinding(localName);
        const rootBinding = this.scope.getBinding(localName);
        // redeclared in this scope
        if (rootBinding !== localBinding) return;
        const right = path.get("right");
        right.replaceWith(
          t.sequenceExpression([right.node, getAssertion(localName)]),
        );
      } else if (left.isPattern()) {
        const ids = left.getOuterBindingIdentifiers();
        const localName = Object.keys(ids).filter(localName => {
          if (localName !== "module" && localName !== "exports") return false;
          return (
            this.scope.getBinding(localName) ===
            path.scope.getBinding(localName)
          );
        })[0];
        if (localName) {
          const right = path.get("right");
          right.replaceWith(
            t.sequenceExpression([right.node, getAssertion(localName)]),
          );
        }
      }
    },
  };
  return {
    visitor: {
      Program: {
        exit(path, state) {
          if (!isModule(path)) return;
          // Rename the bindings auto-injected into the scope so there is no
          // risk of conflict between the bindings.
          path.scope.rename("exports");
          path.scope.rename("module");
          path.scope.rename("require");
          path.scope.rename("__filename");
          path.scope.rename("__dirname");
          // Rewrite references to 'module' and 'exports' to throw exceptions.
          // These objects are specific to CommonJS and are not available in
          // real ES6 implementations.
          if (!allowCommonJSExports) {
            simplifyAccess(path, new Set(["module", "exports"]));
            path.traverse(moduleExportsVisitor, {
              scope: path.scope,
            });
          }
          let moduleName = this.getModuleName();
          if (moduleName) moduleName = t.stringLiteral(moduleName);
          const { meta, headers } = rewriteModuleStatementsAndPrepareHeader(
            path,
            {
              exportName: "exports",
              loose,
              strict,
              strictMode,
              allowTopLevelThis,
              noInterop,
              lazy,
              esNamespaceOnly:
                typeof state.filename === "string" &&
                /\.mjs$/.test(state.filename)
                  ? mjsStrictNamespace
                  : strictNamespace,
            },
          );
          for (const [source, metadata] of meta.source) {
            const loadExpr = t.callExpression(t.identifier("require"), [
              t.stringLiteral(source),
            ]);
            let header;
            if (isSideEffectImport(metadata)) {
              if (metadata.lazy) throw new Error("Assertion failure");
              header = t.expressionStatement(loadExpr);
            } else {
              const init =
                wrapInterop(path, loadExpr, metadata.interop) || loadExpr;
              if (metadata.lazy) {
                header = template.ast`
                  function ${metadata.name}() {
                    const data = ${init};
                    ${metadata.name} = function(){ return data; };
                    return data;
                  }
                `;
              } else {
                header = template.ast`
                  var ${metadata.name} = ${init};
                `;
              }
            }
            header.loc = metadata.loc;
            headers.push(header);
            headers.push(
              ...buildNamespaceInitStatements(meta, metadata, loose),
            );
          }
          ensureStatementsHoisted(headers);
          path.unshiftContainer("body", headers);
        },
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-modules-commonjs/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-proposal-throw-expressions/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import syntaxThrowExpressions from "@babel/plugin-syntax-throw-expressions";
import { types as t } from "@babel/core";
export default declare(api => {
  api.assertVersion(7);
  return {
    inherits: syntaxThrowExpressions,
    visitor: {
      UnaryExpression(path) {
        const { operator, argument } = path.node;
        if (operator !== "throw") return;
        const arrow = t.functionExpression(
          null,
          [t.identifier("e")],
          t.blockStatement([t.throwStatement(t.identifier("e"))]),
        );
        path.replaceWith(t.callExpression(arrow, [argument]));
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-proposal-throw-expressions/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-polyfill/src/index.js

// Cover all standardized ES6 APIs.
import "core-js/es6";
// Standard now
import "core-js/fn/array/includes";
import "core-js/fn/string/pad-start";
import "core-js/fn/string/pad-end";
import "core-js/fn/symbol/async-iterator";
import "core-js/fn/object/get-own-property-descriptors";
import "core-js/fn/object/values";
import "core-js/fn/object/entries";
import "core-js/fn/promise/finally";
// Ensure that we polyfill ES6 compat for anything web-related, if it exists.
import "core-js/web";
import "regenerator-runtime/runtime";
if (global._babelPolyfill && typeof console !== "undefined" && console.warn) {
  console.warn(
    "@babel/polyfill is loaded more than once on this page. This is probably not desirable/intended " +
      "and may have consequences if different versions of the polyfills are applied sequentially. " +
      "If you do need to load the polyfill more than once, use @babel/polyfill/noConflict " +
      "instead to bypass the warning.",
  );
}
global._babelPolyfill = true;

// </from> /home/qfox/apps/babel/packages/babel-polyfill/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-polyfill/src/noConflict.js

// Cover all standardized ES6 APIs.
import "core-js/es6";
// Standard now
import "core-js/fn/array/includes";
import "core-js/fn/string/pad-start";
import "core-js/fn/string/pad-end";
import "core-js/fn/symbol/async-iterator";
import "core-js/fn/object/get-own-property-descriptors";
import "core-js/fn/object/values";
import "core-js/fn/object/entries";
import "core-js/fn/promise/finally";
// Ensure that we polyfill ES6 compat for anything web-related, if it exists.
import "core-js/web";
import "regenerator-runtime/runtime";

// </from> /home/qfox/apps/babel/packages/babel-polyfill/src/noConflict.js

// <from> /home/qfox/apps/babel/packages/babel-polyfill/noConflict.js

require("./lib/noConflict");

// </from> /home/qfox/apps/babel/packages/babel-polyfill/noConflict.js

// <from> /home/qfox/apps/babel/packages/babel-polyfill/scripts/postpublish.js

"use strict";
const fs = require("fs");
const path = require("path");
try {
  fs.unlinkSync(path.join(__dirname, "../browser.js"));
} catch (err) {}

// </from> /home/qfox/apps/babel/packages/babel-polyfill/scripts/postpublish.js

// <from> /home/qfox/apps/babel/packages/babel-polyfill/scripts/prepublish.js

"use strict";
const fs = require("fs");
const path = require("path");
function relative(loc) {
  return path.join(__dirname, "..", loc);
}
fs.writeFileSync(
  relative("browser.js"),
  fs.readFileSync(relative("dist/polyfill.min.js"))
);

// </from> /home/qfox/apps/babel/packages/babel-polyfill/scripts/prepublish.js

// <from> /home/qfox/apps/babel/packages/babel-plugin-transform-object-set-prototype-of-to-assign/src/index.js

import { declare } from "@babel/helper-plugin-utils";
export default declare(api => {
  api.assertVersion(7);
  return {
    visitor: {
      CallExpression(path, file) {
        if (path.get("callee").matchesPattern("Object.setPrototypeOf")) {
          path.node.callee = file.addHelper("defaults");
        }
      },
    },
  };
});

// </from> /home/qfox/apps/babel/packages/babel-plugin-transform-object-set-prototype-of-to-assign/src/index.js

// <from> /home/qfox/apps/babel/packages/babel-preset-flow/src/index.js

import { declare } from "@babel/helper-plugin-utils";
import transformFlowStripTypes from "@babel/plugin-transform-flow-strip-types";
export default declare((api, { all }) => {
  api.assertVersion(7);
  return {
    plugins: [[transformFlowStripTypes, { all }]],
  };
});

// </from> /home/qfox/apps/babel/packages/babel-preset-flow/src/index.js

// <from> /home/qfox/apps/babel/codemods/babel-plugin-codemod-object-assign-to-object-spread/src/index.js

import syntaxObjectRestSpread from "@babel/plugin-syntax-object-rest-spread";
export default function({ types: t }) {
  return {
    inherits: syntaxObjectRestSpread,
    visitor: {
      CallExpression(path) {
        if (!path.get("callee").matchesPattern("Object.assign")) return;
        const args = path.get("arguments");
        if (args.length === 0) return;
        const [objPath] = args;
        if (!objPath.isObjectExpression()) return;
        const obj = objPath.node;
        const { properties } = obj;
        for (let i = 1; i < args.length; i++) {
          const arg = args[i];
          const { node } = arg;
          if (arg.isObjectExpression()) {
            properties.push(...node.properties);
          } else {
            properties.push(t.spreadElement(node));
          }
        }
        path.replaceWith(obj);
      },
    },
  };
}

// </from> /home/qfox/apps/babel/codemods/babel-plugin-codemod-object-assign-to-object-spread/src/index.js

// <from> /home/qfox/apps/babel/codemods/babel-plugin-codemod-optional-catch-binding/src/index.js

import syntaxOptionalCatchBinding from "@babel/plugin-syntax-optional-catch-binding";
export default function({ types: t }) {
  return {
    inherits: syntaxOptionalCatchBinding,
    visitor: {
      CatchClause(path) {
        if (path.node.param === null || !t.isIdentifier(path.node.param)) {
          return;
        }
        const binding = path.scope.getOwnBinding(path.node.param.name);
        if (binding.constantViolations.length > 0) {
          return;
        }
        if (!binding.referenced) {
          const paramPath = path.get("param");
          paramPath.remove();
        }
      },
    },
  };
}

// </from> /home/qfox/apps/babel/codemods/babel-plugin-codemod-optional-catch-binding/src/index.js

// <from> /home/qfox/apps/babel/scripts/generators/readmes.js

/**
 * Since we moved our documentation to our website repo, we want to point to the
 * website from the docs in this repo
 *
 * This script write the link to the website in every READMEs.
 */
const { join } = require("path");
const { readdirSync, writeFileSync } = require("fs");
const cwd = process.cwd();
const packageDir = join(cwd, "packages");
const packages = readdirSync(packageDir);
const getWebsiteLink = n => `https://babeljs.io/docs/en/next/${n}.html`;
const getPackageJson = pkg => require(join(packageDir, pkg, "package.json"));
const getIssueLabelLink = l =>
  `https://github.com/babel/babel/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3A%22${encodeURIComponent(
    l
  )}%22+is%3Aopen`;
const labels = {
  "babel-preset-flow": getIssueLabelLink("area: flow"),
  "babel-preset-node": getIssueLabelLink("area: node"),
  "babel-preset-react": getIssueLabelLink("area: react"),
  "babel-preset-typescript": getIssueLabelLink("area: typescript"),
  "babel-parser": getIssueLabelLink("pkg: babylon"),
  "babel-cli": getIssueLabelLink("pkg: cli"),
  "babel-core": getIssueLabelLink("pkg: core"),
  "babel-generator": getIssueLabelLink("pkg: generator"),
  "babel-polyfill": getIssueLabelLink("pkg: polyfill"),
  "babel-preset-env": getIssueLabelLink("pkg: preset-env"),
  "babel-register": getIssueLabelLink("pkg: register"),
  "babel-template": getIssueLabelLink("pkg: template"),
  "babel-traverse": getIssueLabelLink("pkg: traverse"),
  "babel-types": getIssueLabelLink("pkg: types"),
  "babel-standalone": getIssueLabelLink("pkg: standalone"),
};
const generateReadme = ({ websiteLink, issuesLink, name, description }) =>
  `# ${name}
> ${description}
See our website [${name}](${websiteLink}) for more information${
    issuesLink
      ? ` or the [issues](${issuesLink}) associated with this package`
      : ""
  }.
## Install
Using npm:
\`\`\`sh
npm install --save-dev ${name}
\`\`\`
or using yarn:
\`\`\`sh
yarn add ${name} --dev
\`\`\`
`;
packages
  .filter(x => x !== "README.md") // ignore root readme
  .filter(x => x.indexOf("babel-preset-stage-") === -1) // ignore stages
  .forEach(id => {
    const { name, description } = getPackageJson(id);
    const readmePath = join(packageDir, id, "README.md");
    // generate
    const websiteLink = getWebsiteLink(id);
    const issuesLink = labels[id];
    const readme = generateReadme({
      websiteLink,
      issuesLink,
      name,
      description,
    });
    // write
    writeFileSync(readmePath, readme);
    console.log("OK", id);
  });

// </from> /home/qfox/apps/babel/scripts/generators/readmes.js

// <from> /home/qfox/apps/babel/scripts/generators/flow.js

"use strict";
const t = require("../../packages/babel-types");
const utils = require("./utils");
const NODE_PREFIX = "BabelNode";
let code = `// NOTE: This file is autogenerated. Do not modify.
// See scripts/generators/flow.js for script used.
declare class ${NODE_PREFIX}Comment {
  value: string;
  start: number;
  end: number;
  loc: ${NODE_PREFIX}SourceLocation;
}
declare class ${NODE_PREFIX}BlockComment extends ${NODE_PREFIX}Comment {
  type: "BlockComment";
}
declare class ${NODE_PREFIX}LineComment extends ${NODE_PREFIX}Comment {
  type: "LineComment";
}
declare class ${NODE_PREFIX}SourceLocation {
  start: {
    line: number;
    column: number;
  };
  end: {
    line: number;
    column: number;
  };
}
declare class ${NODE_PREFIX} {
  leadingComments?: Array<${NODE_PREFIX}Comment>;
  innerComments?: Array<${NODE_PREFIX}Comment>;
  trailingComments?: Array<${NODE_PREFIX}Comment>;
  start: ?number;
  end: ?number;
  loc: ?${NODE_PREFIX}SourceLocation;
}\n\n`;
//
const lines = [];
for (const type in t.NODE_FIELDS) {
  const fields = t.NODE_FIELDS[type];
  const struct = ['type: "' + type + '";'];
  const args = [];
  Object.keys(t.NODE_FIELDS[type])
    .sort((fieldA, fieldB) => {
      const indexA = t.BUILDER_KEYS[type].indexOf(fieldA);
      const indexB = t.BUILDER_KEYS[type].indexOf(fieldB);
      if (indexA === indexB) return fieldA < fieldB ? -1 : 1;
      if (indexA === -1) return 1;
      if (indexB === -1) return -1;
      return indexA - indexB;
    })
    .forEach(fieldName => {
      const field = fields[fieldName];
      let suffix = "";
      if (field.optional || field.default != null) suffix += "?";
      let typeAnnotation = "any";
      const validate = field.validate;
      if (validate) {
        typeAnnotation = utils.stringifyValidator(validate, NODE_PREFIX);
      }
      if (typeAnnotation) {
        suffix += ": " + typeAnnotation;
      }
      args.push(t.toBindingIdentifierName(fieldName) + suffix);
      if (t.isValidIdentifier(fieldName)) {
        struct.push(fieldName + suffix + ";");
      }
    });
  code += `declare class ${NODE_PREFIX}${type} extends ${NODE_PREFIX} {
  ${struct.join("\n  ").trim()}
}\n\n`;
  // Flow chokes on super() and import() :/
  if (type !== "Super" && type !== "Import") {
    lines.push(
      `declare function ${utils.toFunctionName(type)}(${args.join(
        ", "
      )}): ${NODE_PREFIX}${type};`
    );
  }
}
for (let i = 0; i < t.TYPES.length; i++) {
  let decl = `declare function is${
    t.TYPES[i]
  }(node: Object, opts?: ?Object): boolean`;
  if (t.NODE_FIELDS[t.TYPES[i]]) {
    decl += ` %checks (node instanceof ${NODE_PREFIX}${t.TYPES[i]})`;
  }
  lines.push(decl);
}
lines.push(
  `declare function validate(n: BabelNode, key: string, value: mixed): void;`,
  `declare function clone<T>(n: T): T;`,
  `declare function cloneDeep<T>(n: T): T;`,
  `declare function removeProperties<T>(n: T, opts: ?{}): void;`,
  `declare function removePropertiesDeep<T>(n: T, opts: ?{}): T;`,
  `declare type TraversalAncestors = Array<{
    node: BabelNode,
    key: string,
    index?: number,
  }>;
  declare type TraversalHandler<T> = (BabelNode, TraversalAncestors, T) => void;
  declare type TraversalHandlers<T> = {
    enter?: TraversalHandler<T>,
    exit?: TraversalHandler<T>,
  };`.replace(/(^|\n) {2}/g, "$1"),
  // eslint-disable-next-line
  `declare function traverse<T>(n: BabelNode, TraversalHandler<T> | TraversalHandlers<T>, state?: T): void;`
);
for (const type in t.FLIPPED_ALIAS_KEYS) {
  const types = t.FLIPPED_ALIAS_KEYS[type];
  code += `type ${NODE_PREFIX}${type} = ${types
    .map(type => `${NODE_PREFIX}${type}`)
    .join(" | ")};\n`;
}
code += `\ndeclare module "@babel/types" {
  ${lines
    .join("\n")
    .replace(/\n/g, "\n  ")
    .trim()}
}\n`;
//
process.stdout.write(code);

// </from> /home/qfox/apps/babel/scripts/generators/flow.js

// <from> /home/qfox/apps/babel/scripts/generators/typescript.js

"use strict";
const t = require("../../packages/babel-types");
const utils = require("./utils");
let code = `// NOTE: This file is autogenerated. Do not modify.
// See scripts/generators/typescript.js for script used.
interface BaseComment {
  value: string;
  start: number;
  end: number;
  loc: SourceLocation;
  type: "BlockComment" | "LineComment";
}
export interface BlockComment extends BaseComment {
  type: "BlockComment";
}
export interface LineComment extends BaseComment {
  type: "LineComment";
}
export type Comment = BlockComment | LineComment;
export interface SourceLocation {
  start: {
    line: number;
    column: number;
  };
  end: {
    line: number;
    column: number;
  };
}
interface BaseNode {
  leadingComments: ReadonlyArray<Comment> | null;
  innerComments: ReadonlyArray<Comment> | null;
  trailingComments: ReadonlyArray<Comment> | null;
  start: number | null;
  end: number | null;
  loc: SourceLocation | null;
  type: Node["type"];
}
export type Node = ${t.TYPES.sort().join(" | ")};\n\n`;
//
const lines = [];
for (const type in t.NODE_FIELDS) {
  const fields = t.NODE_FIELDS[type];
  const fieldNames = sortFieldNames(Object.keys(t.NODE_FIELDS[type]), type);
  const struct = ['type: "' + type + '";'];
  const args = [];
  fieldNames.forEach(fieldName => {
    const field = fields[fieldName];
    let typeAnnotation = utils.stringifyValidator(field.validate, "");
    if (isNullable(field) && !hasDefault(field)) {
      typeAnnotation += " | null";
    }
    if (areAllRemainingFieldsNullable(fieldName, fieldNames, fields)) {
      args.push(
        `${t.toBindingIdentifierName(fieldName)}${
          isNullable(field) ? "?:" : ":"
        } ${typeAnnotation}`
      );
    } else {
      args.push(
        `${t.toBindingIdentifierName(fieldName)}: ${typeAnnotation}${
          isNullable(field) ? " | undefined" : ""
        }`
      );
    }
    const alphaNumeric = /^\w+$/;
    if (t.isValidIdentifier(fieldName) || alphaNumeric.test(fieldName)) {
      struct.push(`${fieldName}: ${typeAnnotation};`);
    } else {
      struct.push(`"${fieldName}": ${typeAnnotation};`);
    }
  });
  code += `export interface ${type} extends BaseNode {
  ${struct.join("\n  ").trim()}
}\n\n`;
  // super and import are reserved words in JavaScript
  if (type !== "Super" && type !== "Import") {
    lines.push(
      `export function ${utils.toFunctionName(type)}(${args.join(
        ", "
      )}): ${type};`
    );
  }
}
for (let i = 0; i < t.TYPES.length; i++) {
  let decl = `export function is${
    t.TYPES[i]
  }(node: object, opts?: object | null): `;
  if (t.NODE_FIELDS[t.TYPES[i]]) {
    decl += `node is ${t.TYPES[i]};`;
  } else {
    decl += `boolean;`;
  }
  lines.push(decl);
}
lines.push(
  `export function validate(n: Node, key: string, value: any): void;`,
  `export function clone<T extends Node>(n: T): T;`,
  `export function cloneDeep<T extends Node>(n: T): T;`,
  `export function removeProperties(
  n: Node,
  opts?: { preserveComments: boolean } | null
): void;`,
  `export function removePropertiesDeep<T extends Node>(
  n: T,
  opts?: { preserveComments: boolean } | null
): T;`,
  `export type TraversalAncestors = ReadonlyArray<{
    node: Node,
    key: string,
    index?: number,
  }>;
  export type TraversalHandler<T> = (node: Node, parent: TraversalAncestors, type: T) => void;
  export type TraversalHandlers<T> = {
    enter?: TraversalHandler<T>,
    exit?: TraversalHandler<T>,
  };`.replace(/(^|\n) {2}/g, "$1"),
  // eslint-disable-next-line
  `export function traverse<T>(n: Node, h: TraversalHandler<T> | TraversalHandlers<T>, state?: T): void;`
);
for (const type in t.DEPRECATED_KEYS) {
  code += `/**
 * @deprecated Use \`${t.DEPRECATED_KEYS[type]}\`
 */
export type ${type} = ${t.DEPRECATED_KEYS[type]};\n
`;
}
for (const type in t.FLIPPED_ALIAS_KEYS) {
  const types = t.FLIPPED_ALIAS_KEYS[type];
  code += `export type ${type} = ${types
    .map(type => `${type}`)
    .join(" | ")};\n`;
}
code += lines.join("\n") + "\n";
//
process.stdout.write(code);
//
function areAllRemainingFieldsNullable(fieldName, fieldNames, fields) {
  const index = fieldNames.indexOf(fieldName);
  return fieldNames.slice(index).every(_ => isNullable(fields[_]));
}
function hasDefault(field) {
  return field.default != null;
}
function isNullable(field) {
  return field.optional || hasDefault(field);
}
function sortFieldNames(fields, type) {
  return fields.sort((fieldA, fieldB) => {
    const indexA = t.BUILDER_KEYS[type].indexOf(fieldA);
    const indexB = t.BUILDER_KEYS[type].indexOf(fieldB);
    if (indexA === indexB) return fieldA < fieldB ? -1 : 1;
    if (indexA === -1) return 1;
    if (indexB === -1) return -1;
    return indexA - indexB;
  });
}

// </from> /home/qfox/apps/babel/scripts/generators/typescript.js

// <from> /home/qfox/apps/babel/scripts/generators/docs.js

"use strict";
const util = require("util");
const utils = require("./utils");
const types = require("../../packages/babel-types");
const readme = [
  `# @babel/types
> This module contains methods for building ASTs manually and for checking the types of AST nodes.
## Install
\`\`\`sh
npm install --save-dev @babel/types
\`\`\`
## API`,
];
const customTypes = {
  ClassMethod: {
    key: "if computed then `Expression` else `Identifier | Literal`",
  },
  Identifier: {
    name: "`string`",
  },
  MemberExpression: {
    property: "if computed then `Expression` else `Identifier`",
  },
  ObjectMethod: {
    key: "if computed then `Expression` else `Identifier | Literal`",
  },
  ObjectProperty: {
    key: "if computed then `Expression` else `Identifier | Literal`",
  },
};
Object.keys(types.BUILDER_KEYS)
  .sort()
  .forEach(function(key) {
    readme.push("### " + key[0].toLowerCase() + key.substr(1));
    readme.push("```javascript");
    readme.push(
      "t." +
        utils.toFunctionName(key) +
        "(" +
        types.BUILDER_KEYS[key].join(", ") +
        ")"
    );
    readme.push("```");
    readme.push("");
    readme.push(
      "See also `t.is" +
        key +
        "(node, opts)` and `t.assert" +
        key +
        "(node, opts)`."
    );
    readme.push("");
    if (types.ALIAS_KEYS[key] && types.ALIAS_KEYS[key].length) {
      readme.push(
        "Aliases: " +
          types.ALIAS_KEYS[key]
            .map(function(key) {
              return "`" + key + "`";
            })
            .join(", ")
      );
      readme.push("");
    }
    Object.keys(types.NODE_FIELDS[key])
      .sort(function(fieldA, fieldB) {
        const indexA = types.BUILDER_KEYS[key].indexOf(fieldA);
        const indexB = types.BUILDER_KEYS[key].indexOf(fieldB);
        if (indexA === indexB) return fieldA < fieldB ? -1 : 1;
        if (indexA === -1) return 1;
        if (indexB === -1) return -1;
        return indexA - indexB;
      })
      .forEach(function(field) {
        const defaultValue = types.NODE_FIELDS[key][field].default;
        const fieldDescription = ["`" + field + "`"];
        const validator = types.NODE_FIELDS[key][field].validate;
        if (customTypes[key] && customTypes[key][field]) {
          fieldDescription.push(`: ${customTypes[key][field]}`);
        } else if (validator) {
          try {
            fieldDescription.push(
              ": `" + utils.stringifyValidator(validator, "") + "`"
            );
          } catch (ex) {
            if (ex.code === "UNEXPECTED_VALIDATOR_TYPE") {
              console.log(
                "Unrecognised validator type for " + key + "." + field
              );
              console.dir(ex.validator, { depth: 10, colors: true });
            }
          }
        }
        if (defaultValue !== null || types.NODE_FIELDS[key][field].optional) {
          fieldDescription.push(
            " (default: `" + util.inspect(defaultValue) + "`)"
          );
        } else {
          fieldDescription.push(" (required)");
        }
        readme.push(" - " + fieldDescription.join(""));
      });
    readme.push("");
    readme.push("---");
    readme.push("");
  });
process.stdout.write(readme.join("\n"));

// </from> /home/qfox/apps/babel/scripts/generators/docs.js

// <from> /home/qfox/apps/babel/scripts/generators/utils.js

exports.stringifyValidator = function stringifyValidator(
  validator,
  nodePrefix
) {
  if (validator === undefined) {
    return "any";
  }
  if (validator.each) {
    return `Array<${stringifyValidator(validator.each, nodePrefix)}>`;
  }
  if (validator.chainOf) {
    return stringifyValidator(validator.chainOf[1], nodePrefix);
  }
  if (validator.oneOf) {
    return validator.oneOf.map(JSON.stringify).join(" | ");
  }
  if (validator.oneOfNodeTypes) {
    return validator.oneOfNodeTypes.map(_ => nodePrefix + _).join(" | ");
  }
  if (validator.oneOfNodeOrValueTypes) {
    return validator.oneOfNodeOrValueTypes
      .map(_ => {
        return isValueType(_) ? _ : nodePrefix + _;
      })
      .join(" | ");
  }
  if (validator.type) {
    return validator.type;
  }
  return ["any"];
};
exports.toFunctionName = function toFunctionName(typeName) {
  const _ = typeName.replace(/^TS/, "ts").replace(/^JSX/, "jsx");
  return _.slice(0, 1).toLowerCase() + _.slice(1);
};
/**
 * Heuristic to decide whether or not the given type is a value type (eg. "null")
 * or a Node type (eg. "Expression").
 */
function isValueType(type) {
  return type.charAt(0).toLowerCase() === type.charAt(0);
}

// </from> /home/qfox/apps/babel/scripts/generators/utils.js

// <from> /home/qfox/apps/babel/scripts/eslint_rules/no-undefined-identifier.js

"use strict";
function argumentsIsUndefinedString(argumentsArray) {
  return (
    argumentsArray.length === 1 &&
    argumentsArray[0].type === "Literal" &&
    argumentsArray[0].value === "undefined"
  );
}
module.exports = {
  meta: {
    schema: [],
  },
  create: function(context) {
    if (context.getFilename().indexOf("packages/babel-plugin-") === -1) {
      return {};
    }
    return {
      CallExpression: function(node) {
        const callee = node.callee;
        if (
          callee.type === "MemberExpression" &&
          argumentsIsUndefinedString(node.arguments)
        ) {
          const object = callee.object,
            property = callee.property;
          if (
            object.type === "Identifier" &&
            object.name === "t" &&
            property.type === "Identifier" &&
            property.name === "identifier"
          ) {
            context.report(
              node,
              "Use path.scope.buildUndefinedNode() to create an undefined identifier directly."
            );
          }
        }
      },
    };
  },
};

// </from> /home/qfox/apps/babel/scripts/eslint_rules/no-undefined-identifier.js

// <from> /home/qfox/apps/babel/scripts/eslint_rules/no-deprecated-clone.js

// @flow
"use strict";
function getVariableDefinition(name /*: string */, scope /*: Scope */) {
  let currentScope = scope;
  do {
    const variable = currentScope.set.get(name);
    if (variable && variable.defs[0]) {
      return { scope: currentScope, definition: variable.defs[0] };
    }
  } while ((currentScope = currentScope.upper));
}
/*::
type ReferenceOriginImport = { kind: "import", source: string, name: string };
type ReferenceOriginParam = {
  kind: "export param",
  exportName: string,
  index: number,
};
type ReferenceOrigin =
  | ReferenceOriginImport
  | ReferenceOriginParam
  | { kind: "import *", source: string }
  | {
      kind: "property",
      base: ReferenceOriginImport | ReferenceOriginParam,
      path: string,
    };
*/
// Given a node and a context, returns a description of where its value comes
// from.
// It resolves imports, parameters of exported functions and property accesses.
// See the ReferenceOrigin type for more informations.
function getReferenceOrigin(
  node /*: Node */,
  scope /*: Scope */
) /*: ?ReferenceOrigin */ {
  if (node.type === "Identifier") {
    const variable = getVariableDefinition(node.name, scope);
    if (!variable) return null;
    const definition = variable.definition;
    const defNode = definition.node;
    if (definition.type === "ImportBinding") {
      if (defNode.type === "ImportSpecifier") {
        return {
          kind: "import",
          source: definition.parent.source.value,
          name: defNode.imported.name,
        };
      }
      if (defNode.type === "ImportNamespaceSpecifier") {
        return {
          kind: "import *",
          source: definition.parent.source.value,
        };
      }
    }
    if (definition.type === "Variable" && defNode.init) {
      const origin = getReferenceOrigin(defNode.init, variable.scope);
      return origin && patternToProperty(definition.name, origin);
    }
    if (definition.type === "Parameter") {
      const parent = defNode.parent;
      let exportName /*: string */;
      if (parent.type === "ExportDefaultDeclaration") {
        exportName = "default";
      } else if (parent.type === "ExportNamedDeclaration") {
        exportName = defNode.id.name;
      } else if (
        parent.type === "AssignmentExpression" &&
        parent.left.type === "MemberExpression" &&
        parent.left.object.type === "Identifier" &&
        parent.left.object.name === "module" &&
        parent.left.property.type === "Identifier" &&
        parent.left.property.name === "exports"
      ) {
        exportName = "module.exports";
      } else {
        return null;
      }
      return patternToProperty(definition.name, {
        kind: "export param",
        exportName,
        index: definition.index,
      });
    }
  }
  if (node.type === "MemberExpression" && !node.computed) {
    const origin = getReferenceOrigin(node.object, scope);
    return origin && addProperty(origin, node.property.name);
  }
  return null;
}
function patternToProperty(
  id /*: Node */,
  base /*: ReferenceOrigin */
) /*: ?ReferenceOrigin */ {
  const path = getPatternPath(id);
  return path && path.reduce(addProperty, base);
}
// Adds a property to a given origin. If it was a namespace import it becomes
// a named import, so that `import * as x from "foo"; x.bar` and
// `import { bar } from "foo"` have the same origin.
function addProperty(
  origin /*: ReferenceOrigin */,
  name /*: string */
) /* ReferenceOrigin */ {
  if (origin.kind === "import *") {
    return {
      kind: "import",
      source: origin.source,
      name,
    };
  }
  if (origin.kind === "property") {
    return {
      kind: "property",
      base: origin.base,
      path: origin.path + "." + name,
    };
  }
  return {
    kind: "property",
    base: origin,
    path: name,
  };
}
// if "node" is c of { a: { b: c } }, the result is ["a","b"]
function getPatternPath(node /*: Node */) /*: ?string[] */ {
  let current = node;
  const path = [];
  // Unshift keys to path while going up
  do {
    const property = current.parent;
    if (
      property.type === "ArrayPattern" ||
      property.type === "AssignmentPattern" ||
      property.computed
    ) {
      // These nodes are not supported.
      return null;
    }
    if (property.type === "Property") {
      path.unshift(property.key.name);
    } else {
      // The destructuring pattern is finished
      break;
    }
  } while ((current = current.parent.parent));
  return path;
}
function reportError(context /*: Context */, node /*: Node */) {
  const isMemberExpression = node.type === "MemberExpression";
  const id = isMemberExpression ? node.property : node;
  context.report({
    node: id,
    message: `t.${id.name}() is deprecated. Use t.cloneNode() instead.`,
    fix(fixer) {
      if (isMemberExpression) {
        return fixer.replaceText(id, "cloneNode");
      }
    },
  });
}
module.exports = {
  meta: {
    schema: [],
    fixable: "code",
  },
  create(context /*: Context */) {
    return {
      CallExpression(node /*: Node */) {
        const origin = getReferenceOrigin(node.callee, context.getScope());
        if (!origin) return;
        if (
          origin.kind === "import" &&
          (origin.name === "clone" || origin.name === "cloneDeep") &&
          origin.source === "@babel/types"
        ) {
          // imported from @babel/types
          return reportError(context, node.callee);
        }
        if (
          origin.kind === "property" &&
          (origin.path === "clone" || origin.path === "cloneDeep") &&
          origin.base.kind === "import" &&
          origin.base.name === "types" &&
          origin.base.source === "@babel/core"
        ) {
          // imported from @babel/core
          return reportError(context, node.callee);
        }
        if (
          origin.kind === "property" &&
          (origin.path === "types.clone" ||
            origin.path === "types.cloneDeep") &&
          origin.base.kind === "export param" &&
          (origin.base.exportName === "default" ||
            origin.base.exportName === "module.exports") &&
          origin.base.index === 0
        ) {
          // export default function ({ types: t }) {}
          // module.exports = function ({ types: t }) {}
          return reportError(context, node.callee);
        }
      },
    };
  },
};
/*:: // ESLint types
type Node = { type: string, [string]: any };
type Definition = {
  type: "ImportedBinding",
  name: Node,
  node: Node,
  parent: Node,
};
type Variable = {
  defs: Definition[],
};
type Scope = {
  set: Map<string, Variable>,
  upper: ?Scope,
};
type Context = {
  report(options: {
    node: Node,
    message: string,
    fix?: (fixer: Fixer) => ?Fixer,
  }): void,
  getScope(): Scope,
};
type Fixer = {
  replaceText(node: Node, replacement: string): Fixer,
};
*/

// </from> /home/qfox/apps/babel/scripts/eslint_rules/no-deprecated-clone.js

// <from> /home/qfox/apps/babel/scripts/gulp-tasks.js

"use strict";
/**
 * This file contains the Gulp tasks for babel-standalone. Note that
 * babel-standalone is compiled using Webpack, and performs its own Babel
 * compilation of all the JavaScript files. This is because it targets web
 * browsers, so more transforms are needed than the regular Babel builds that
 * only target Node.js.
 *
 * The tasks in this file are designed to be reusable, so that they can be used
 * to make standalone builds of other Babel plugins/presets (such as babel-minify)
 */
const path = require("path");
const pump = require("pump");
const rename = require("gulp-rename");
const RootMostResolvePlugin = require("webpack-dependency-suite")
  .RootMostResolvePlugin;
const webpack = require("webpack");
const webpackStream = require("webpack-stream");
const uglify = require("gulp-uglify");
function webpackBuild(opts) {
  const plugins = opts.plugins || [];
  let babelVersion = require("../packages/babel-core/package.json").version;
  let version = opts.version || babelVersion;
  // If this build is part of a pull request, include the pull request number in
  // the version number.
  if (process.env.CIRCLE_PR_NUMBER) {
    const prVersion = "+pr." + process.env.CIRCLE_PR_NUMBER;
    babelVersion += prVersion;
    version += prVersion;
  }
  const config = {
    module: {
      rules: [
        {
          test: /\.js$/,
          loader: "babel-loader",
          options: {
            // Use the bundled config so that module syntax is passed through
            // for Webpack.
            envName: "standalone",
          },
        },
      ],
    },
    node: {
      // Mock Node.js modules that Babel require()s but that we don't
      // particularly care about.
      fs: "empty",
      module: "empty",
      net: "empty",
    },
    output: {
      filename: opts.filename,
      library: opts.library,
      libraryTarget: "umd",
    },
    plugins: [
      new webpack.DefinePlugin({
        "process.env.NODE_ENV": '"production"',
        "process.env": JSON.stringify({ NODE_ENV: "production" }),
        BABEL_VERSION: JSON.stringify(babelVersion),
        VERSION: JSON.stringify(version),
      }),
      /*new webpack.NormalModuleReplacementPlugin(
        /..\/..\/package/,
        "../../../../src/babel-package-shim"
      ),*/
      new webpack.optimize.ModuleConcatenationPlugin(),
    ].concat(plugins),
    resolve: {
      plugins: [
        // Dedupe packages that are used across multiple plugins.
        // This replaces DedupePlugin from Webpack 1.x
        new RootMostResolvePlugin(__dirname, true),
      ],
    },
  };
  if (opts.library !== "Babel") {
    config.externals = {
      "@babel/standalone": "Babel",
    };
  }
  return webpackStream(config, webpack);
  // To write JSON for debugging:
  /*return webpackStream(config, webpack, (err, stats) => {
    require('gulp-util').log(stats.toString({colors: true}));
    require('fs').writeFileSync('webpack-debug.json', JSON.stringify(stats.toJson()));
  });*/
}
function registerStandalonePackageTask(
  gulp,
  name,
  exportName,
  pathname,
  version,
  plugins
) {
  const standaloneName = name + "-standalone";
  const standalonePath = path.join(pathname, standaloneName);
  gulp.task("build-" + standaloneName, cb => {
    pump(
      [
        gulp.src(path.join(standalonePath, "src/index.js")),
        webpackBuild({
          filename: name + ".js",
          library: exportName,
          version,
          plugins,
        }),
        gulp.dest(standalonePath),
      ].concat(
        // Minification is super slow, so we skip it in CI.
        process.env.CI ? [] : uglify(),
        rename({ extname: ".min.js" }),
        gulp.dest(standalonePath)
      ),
      cb
    );
  });
}
module.exports = {
  webpackBuild: webpackBuild,
  registerStandalonePackageTask: registerStandalonePackageTask,
};

// </from> /home/qfox/apps/babel/scripts/gulp-tasks.js

// <from> /home/qfox/apps/babel/scripts/tests/test262/run_babel_parser_test262.js

"use strict";
const path = require("path");
const chalk = require("chalk");
const utils = require("./run_babel_parser_test262_utils");
const testDir = path.join(__dirname, "../../../build/test262");
const whitelistFile = path.join(__dirname, "test262_whitelist.txt");
const shouldUpdate = process.argv.indexOf("--update-whitelist") > -1;
Promise.all([utils.getTests(testDir), utils.getWhitelist(whitelistFile)])
  .then(function([tests, whitelist]) {
    const total = tests.length;
    const reportInc = Math.floor(total / 20);
    console.log(`Now running ${total} tests...`);
    const results = tests.map(function(test, idx) {
      if (idx % reportInc === 0) {
        console.log(`> ${Math.round((100 * idx) / total)}% complete`);
      }
      return utils.runTest(test);
    });
    return utils.interpret(results, whitelist);
  })
  .then(function(summary) {
    const goodnews = [
      summary.allowed.success.length + " valid programs parsed without error",
      summary.allowed.failure.length +
        " invalid programs produced a parsing error",
      summary.allowed.falsePositive.length +
        " invalid programs did not produce a parsing error" +
        " (and allowed by the whitelist file)",
      summary.allowed.falseNegative.length +
        " valid programs produced a parsing error" +
        " (and allowed by the whitelist file)",
    ];
    const badnews = [];
    const badnewsDetails = [];
    void [
      {
        tests: summary.disallowed.success,
        label:
          "valid programs parsed without error" +
          " (in violation of the whitelist file)",
      },
      {
        tests: summary.disallowed.failure,
        label:
          "invalid programs produced a parsing error" +
          " (in violation of the whitelist file)",
      },
      {
        tests: summary.disallowed.falsePositive,
        label:
          "invalid programs did not produce a parsing error" +
          " (without a corresponding entry in the whitelist file)",
      },
      {
        tests: summary.disallowed.falseNegative,
        label:
          "valid programs produced a parsing error" +
          " (without a corresponding entry in the whitelist file)",
      },
      {
        tests: summary.unrecognized,
        label: "non-existent programs specified in the whitelist file",
      },
    ].forEach(function({ tests, label }) {
      if (!tests.length) {
        return;
      }
      const desc = tests.length + " " + label;
      badnews.push(desc);
      badnewsDetails.push(desc + ":");
      badnewsDetails.push(
        ...tests.map(function(test) {
          return test.id || test;
        })
      );
    });
    console.log("Testing complete.");
    console.log("Summary:");
    console.log(chalk.green(goodnews.join("\n").replace(/^/gm, "  ")));
    if (!summary.passed) {
      console.log("");
      console.log(chalk.red(badnews.join("\n").replace(/^/gm, "  ")));
      console.log("");
      console.log("Details:");
      console.log(badnewsDetails.join("\n").replace(/^/gm, "   "));
    }
    if (shouldUpdate) {
      return utils.updateWhitelist(whitelistFile, summary).then(function() {
        console.log("");
        console.log("Whitelist file updated.");
      });
    } else {
      process.exitCode = summary.passed ? 0 : 1;
    }
  })
  .catch(function(err) {
    console.error(err);
    process.exitCode = 1;
  });

// </from> /home/qfox/apps/babel/scripts/tests/test262/run_babel_parser_test262.js

// <from> /home/qfox/apps/babel/scripts/tests/test262/run_babel_parser_test262_utils.js

"use strict";
const fs = require("graceful-fs");
const promisify = require("util").promisify;
const TestStream = require("test262-stream");
const pfs = {
  readFile: promisify(fs.readFile),
  writeFile: promisify(fs.writeFile),
  readdir: promisify(fs.readdir),
  stat: promisify(fs.stat),
};
const parse = require("../../../packages/babel-parser").parse;
const featuresToPlugins = {
  "async-iteration": "asyncGenerators",
  BigInt: "bigInt",
  "class-fields-private": "classPrivateProperties",
  "class-fields-public": "classProperties",
  "export-star-as-namespace-from-module": "exportNamespaceFrom",
  "numeric-separator-literal": "numericSeparator",
  "object-rest": "objectRestSpread",
  "object-spread": "objectRestSpread",
  "optional-catch-binding": "optionalCatchBinding",
};
function getPlugins(features) {
  return features && features.map(f => featuresToPlugins[f]).filter(Boolean);
}
exports.getTests = function(testDir) {
  const stream = new TestStream(testDir, {
    omitRuntime: true,
  });
  const tests = [];
  stream.on("data", test => {
    // strip test/
    const fileName = test.file.substr(5);
    tests.push({
      contents: test.contents,
      fileName,
      id: `${fileName}(${test.scenario})`,
      sourceType: test.attrs.flags.module ? "module" : "script",
      plugins: getPlugins(test.attrs.features),
      expectedError:
        !!test.attrs.negative &&
        (test.attrs.negative.phase === "parse" ||
          test.attrs.negative.phase === "early"),
    });
  });
  return new Promise((resolve, reject) => {
    stream.on("end", () => resolve(tests));
    stream.on("error", reject);
  });
};
exports.runTest = function(test) {
  try {
    parse(test.contents, {
      sourceType: test.sourceType,
      plugins: test.plugins,
    });
    test.actualError = false;
  } catch (err) {
    test.actualError = true;
  }
  test.result = test.expectedError !== test.actualError ? "fail" : "pass";
  return test;
};
exports.getWhitelist = function(filename) {
  return pfs.readFile(filename, "utf-8").then(function(contents) {
    return contents
      .split("\n")
      .map(function(line) {
        return line.replace(/#.*$/, "").trim();
      })
      .filter(function(line) {
        return line.length > 0;
      })
      .reduce(function(table, filename) {
        table[filename] = true;
        return table;
      }, Object.create(null));
  });
};
exports.updateWhitelist = function(filename, summary) {
  return pfs.readFile(filename, "utf-8").then(function(contents) {
    const toRemove = summary.disallowed.success
      .concat(summary.disallowed.failure)
      .map(function(test) {
        return test.id;
      });
    const toAdd = summary.disallowed.falsePositive
      .concat(summary.disallowed.falseNegative)
      .map(function(test) {
        return test.id;
      });
    const newContents = contents
      .split("\n")
      .map(function(line) {
        const testId = line.replace(/#.*$/, "").trim();
        if (toRemove.indexOf(testId) > -1) {
          return null;
        }
        return line;
      })
      .filter(function(line) {
        return line !== null;
      })
      .concat(toAdd)
      .join("\n");
    return pfs.writeFile(filename, newContents, "utf-8");
  });
};
exports.interpret = function(results, whitelist) {
  const summary = {
    passed: true,
    allowed: {
      success: [],
      failure: [],
      falsePositive: [],
      falseNegative: [],
    },
    disallowed: {
      success: [],
      failure: [],
      falsePositive: [],
      falseNegative: [],
    },
    unrecognized: null,
  };
  results.forEach(function(result) {
    let classification, isAllowed;
    const inWhitelist = result.id in whitelist;
    delete whitelist[result.id];
    if (!result.expectedError) {
      if (!result.actualError) {
        classification = "success";
        isAllowed = !inWhitelist;
      } else {
        classification = "falseNegative";
        isAllowed = inWhitelist;
      }
    } else {
      if (!result.actualError) {
        classification = "falsePositive";
        isAllowed = inWhitelist;
      } else {
        classification = "failure";
        isAllowed = !inWhitelist;
      }
    }
    summary.passed &= isAllowed;
    summary[isAllowed ? "allowed" : "disallowed"][classification].push(result);
  });
  summary.unrecognized = Object.keys(whitelist);
  summary.passed = !!summary.passed && summary.unrecognized.length === 0;
  return summary;
};

// </from> /home/qfox/apps/babel/scripts/tests/test262/run_babel_parser_test262_utils.js

// <from> /home/qfox/apps/babel/scripts/tests/flow/run_babel_parser_flow_tests.js

"use strict";
const path = require("path");
const fs = require("fs");
const chalk = require("chalk");
const parse = require("../../../packages/babel-parser").parse;
const TESTS_FOLDER = path.join(
  __dirname,
  "../../../build/flow/src/parser/test/flow"
);
const WHITELIST_PATH = path.join(__dirname, "./flow_tests_whitelist.txt");
const shouldUpdateWhitelist = process.argv.indexOf("--update-whitelist") > 0;
function map_get_default(map, key, defaultConstructor) {
  if (map.has(key)) {
    return map.get(key);
  }
  const value = new defaultConstructor();
  map.set(key, value);
  return value;
}
function get_whitelist(filename) {
  return fs
    .readFileSync(filename, "utf8")
    .split("\n")
    .map(line => line.replace(/#.*$/, "").trim())
    .filter(Boolean);
}
function list_files(root, dir) {
  const files = fs.readdirSync(dir ? path.join(root, dir) : root);
  let result = [];
  for (let i = 0; i < files.length; i++) {
    const file = dir ? path.join(dir, files[i]) : files[i];
    const stats = fs.statSync(path.join(root, file));
    if (stats.isDirectory()) {
      result = result.concat(list_files(root, file));
    } else {
      result.push(file);
    }
  }
  return result.sort();
}
function get_tests(root_dir) {
  const files = list_files(root_dir);
  const tests = new Map();
  for (let i = 0; i < files.length; i++) {
    const file = files[i];
    const test_name = path.dirname(file);
    const case_parts = path.basename(file).split(".");
    const case_name = case_parts[0];
    // Hack to ignore hidden files.
    if (case_name === "") {
      continue;
    }
    const cases = map_get_default(tests, test_name, Map);
    const case_ = map_get_default(cases, case_name, Object);
    const content = fs.readFileSync(path.join(root_dir, file), "utf8");
    const ext = case_parts[case_parts.length - 1];
    const kind =
      case_parts.length > 2 ? case_parts[case_parts.length - 2] : null;
    if (ext === "js") {
      case_.file = file;
      case_.content = content;
    } else if (ext === "json" && kind === "tree") {
      case_.expected_ast = JSON.parse(content);
    } else if (ext === "json" && kind === "options") {
      case_.options = JSON.parse(content);
    }
  }
  return tests;
}
function update_whitelist(summary) {
  const contains = (tests, file) =>
    tests.some(({ test }) => test.file === file);
  const disallowed = summary.disallowed.success.concat(
    summary.disallowed.failure
  );
  const oldLines = fs
    .readFileSync(WHITELIST_PATH, "utf8")
    .trim()
    .split("\n")
    .filter(line => {
      const file = line.replace(/#.*$/, "").trim();
      return (
        !contains(disallowed, file) && summary.unrecognized.indexOf(file) === -1
      );
    });
  const newLines = disallowed
    .map(({ test }) => test.file)
    .filter(test => oldLines.indexOf(test) === -1);
  const result = oldLines.concat(newLines).join("\n") + "\n";
  fs.writeFileSync(WHITELIST_PATH, result);
}
const options = {
  plugins: [
    "asyncGenerators",
    "dynamicImport",
    ["flow", { all: true }],
    "flowComments",
    "jsx",
    "objectRestSpread",
    "classPrivateProperties",
  ],
  sourceType: "module",
  ranges: true,
};
const flowOptionsMapping = {
  esproposal_class_instance_fields: "classProperties",
  esproposal_class_static_fields: "classProperties",
  esproposal_export_star_as: "exportNamespaceFrom",
  esproposal_decorators: "decorators-legacy",
  esproposal_nullish_coalescing: "nullishCoalescingOperator",
  esproposal_optional_chaining: "optionalChaining",
  types: "flowComments",
};
const summary = {
  passed: true,
  allowed: {
    success: [],
    failure: [],
  },
  disallowed: {
    success: [],
    failure: [],
  },
  unrecognized: [],
};
const tests = get_tests(TESTS_FOLDER);
const whitelist = get_whitelist(WHITELIST_PATH);
const unrecognized = new Set(whitelist);
tests.forEach(section => {
  section.forEach(test => {
    const shouldSuccess =
      test.expected_ast &&
      (!Array.isArray(test.expected_ast.errors) ||
        test.expected_ast.errors.length === 0);
    const inWhitelist = whitelist.indexOf(test.file) > -1;
    const babelParserOptions = Object.assign({}, options);
    babelParserOptions.plugins = babelParserOptions.plugins.slice();
    if (test.options) {
      Object.keys(test.options).forEach(option => {
        if (!test.options[option]) {
          const idx = babelParserOptions.plugins.indexOf(
            flowOptionsMapping[option]
          );
          if (idx) {
            babelParserOptions.plugins.splice(idx, 1);
          }
          return;
        }
        if (!flowOptionsMapping[option]) {
          throw new Error("Parser options not mapped " + option);
        }
        babelParserOptions.plugins.push(flowOptionsMapping[option]);
      });
    }
    let failed = false;
    let exception = null;
    try {
      parse(test.content, babelParserOptions);
    } catch (e) {
      exception = e;
      failed = true;
      // lets retry in script mode
      if (shouldSuccess) {
        try {
          parse(
            test.content,
            Object.assign({}, babelParserOptions, { sourceType: "script" })
          );
          exception = null;
          failed = false;
        } catch (e) {}
      }
    }
    const isSuccess = shouldSuccess !== failed;
    const isAllowed = isSuccess !== inWhitelist;
    summary[isAllowed ? "allowed" : "disallowed"][
      isSuccess ? "success" : "failure"
    ].push({ test, exception, shouldSuccess, babelParserOptions });
    summary.passed &= isAllowed;
    unrecognized.delete(test.file);
    process.stdout.write(chalk.gray("."));
  });
});
summary.unrecognized = Array.from(unrecognized);
summary.passed &= summary.unrecognized.length === 0;
// This is needed because, after the dots written using
// `process.stdout.write(".")` there is no final newline
console.log();
if (summary.disallowed.failure.length || summary.disallowed.success.length) {
  console.log("\n-- FAILED TESTS --");
  summary.disallowed.failure.forEach(
    ({ test, shouldSuccess, exception, babelParserOptions }) => {
      console.log(chalk.red(` ${test.file}`));
      if (shouldSuccess) {
        console.log(chalk.yellow("  Should parse successfully, but did not"));
        console.log(chalk.yellow(`  Failed with: \`${exception.message}\``));
      } else {
        console.log(chalk.yellow("  Should fail parsing, but did not"));
      }
      console.log(
        chalk.yellow(
          `  Active plugins: ${JSON.stringify(babelParserOptions.plugins)}`
        )
      );
    }
  );
  summary.disallowed.success.forEach(
    ({ test, shouldSuccess, babelParserOptions }) => {
      console.log(chalk.red(` ${test.file}`));
      if (shouldSuccess) {
        console.log(
          chalk.yellow(
            "  Correctly parsed successfully, but" +
              " was disallowed by the whitelist"
          )
        );
      } else {
        console.log(
          chalk.yellow(
            "  Correctly failed parsing, but" +
              " was disallowed by the whitelist"
          )
        );
      }
      console.log(
        chalk.yellow(
          `  Active plugins: ${JSON.stringify(babelParserOptions.plugins)}`
        )
      );
    }
  );
}
console.log("-- SUMMARY --");
console.log(
  chalk.green(" " + summary.allowed.success.length + " tests passed")
);
console.log(
  chalk.green(
    " " +
      summary.allowed.failure.length +
      " tests failed but were allowed in the whitelist"
  )
);
console.log(
  chalk.red(" " + summary.disallowed.failure.length + " tests failed")
);
console.log(
  chalk.red(
    " " +
      summary.disallowed.success.length +
      " tests passed but were disallowed in the whitelist"
  )
);
console.log(
  chalk.red(
    " " +
      summary.unrecognized.length +
      " tests specified in the whitelist were not found"
  )
);
// Some padding to separate the output from the message `make`
// adds at the end of failing scripts
console.log();
if (shouldUpdateWhitelist) {
  update_whitelist(summary);
  console.log("\nWhitelist updated");
} else {
  process.exit(summary.passed ? 0 : 1);
}

// </from> /home/qfox/apps/babel/scripts/tests/flow/run_babel_parser_flow_tests.js

// <from> /home/qfox/apps/babel/lib/parser.js

type BabelParserOptions = {
  sourceFilename?: string;
  sourceType?: "module" | "script";
  plugins?: Array<Object>;
};

// </from> /home/qfox/apps/babel/lib/parser.js

// <from> /home/qfox/apps/babel/lib/file.js

type BabelFileModulesMetadata = {
  imports: Array<Object>,
  exports: {
    exported: Array<Object>,
    specifiers: Array<Object>
  }
};
type BabelFileMetadata = {
  usedHelpers: Array<string>;
  marked: Array<{
    type: string;
    message: string;
    loc: Object;
  }>;
  modules: BabelFileModulesMetadata
};
type BabelFileResult = {
  ast?: ?Object;
  code?: ?string;
  map?: ?Object;
  ignored?: ?boolean;
  metadata?: ?BabelFileMetadata;
};

// </from> /home/qfox/apps/babel/lib/file.js

// <from> /home/qfox/apps/babel/Gulpfile.js

"use strict";
const plumber = require("gulp-plumber");
const through = require("through2");
const chalk = require("chalk");
const newer = require("gulp-newer");
const babel = require("gulp-babel");
const gulpWatch = require("gulp-watch");
const gutil = require("gulp-util");
const filter = require("gulp-filter");
const gulp = require("gulp");
const path = require("path");
const webpack = require("webpack");
const merge = require("merge-stream");
const rollup = require("rollup-stream");
const source = require("vinyl-source-stream");
const buffer = require("vinyl-buffer");
const rollupBabel = require("rollup-plugin-babel");
const rollupNodeResolve = require("rollup-plugin-node-resolve");
const registerStandalonePackageTask = require("./scripts/gulp-tasks")
  .registerStandalonePackageTask;
const sources = ["codemods", "packages"];
function swapSrcWithLib(srcPath) {
  const parts = srcPath.split(path.sep);
  parts[1] = "lib";
  return parts.join(path.sep);
}
function getGlobFromSource(source) {
  return `./${source}/*/src/**/*.js`;
}
function getIndexFromPackage(name) {
  return `${name}/src/index.js`;
}
function compilationLogger(rollup) {
  return through.obj(function(file, enc, callback) {
    gutil.log(
      `Compiling '${chalk.cyan(file.relative)}'${
        rollup ? " with rollup " : ""
      }...`
    );
    callback(null, file);
  });
}
function errorsLogger() {
  return plumber({
    errorHandler(err) {
      gutil.log(err.stack);
    },
  });
}
function rename(fn) {
  return through.obj(function(file, enc, callback) {
    file.path = fn(file);
    callback(null, file);
  });
}
function buildBabel(exclude) {
  return merge(
    sources.map(source => {
      const base = path.join(__dirname, source);
      let stream = gulp.src(getGlobFromSource(source), { base: base });
      if (exclude) {
        const filters = exclude.map(p => `!**/${p}/**`);
        filters.unshift("**");
        stream = stream.pipe(filter(filters));
      }
      return stream
        .pipe(errorsLogger())
        .pipe(newer({ dest: base, map: swapSrcWithLib }))
        .pipe(compilationLogger())
        .pipe(babel())
        .pipe(
          // Passing 'file.relative' because newer() above uses a relative
          // path and this keeps it consistent.
          rename(file => path.resolve(file.base, swapSrcWithLib(file.relative)))
        )
        .pipe(gulp.dest(base));
    })
  );
}
function buildRollup(packages) {
  return merge(
    packages.map(pkg => {
      return rollup({
        input: getIndexFromPackage(pkg),
        format: "cjs",
        plugins: [
          rollupBabel({
            envName: "babel-parser",
          }),
          rollupNodeResolve(),
        ],
      })
        .pipe(source("index.js"))
        .pipe(buffer())
        .pipe(errorsLogger())
        .pipe(compilationLogger(/* rollup */ true))
        .pipe(gulp.dest(path.join(pkg, "lib")));
    })
  );
}
gulp.task("build", function() {
  const bundles = ["packages/babel-parser"];
  return merge([buildBabel(/* exclude */ bundles), buildRollup(bundles)]);
});
gulp.task("default", gulp.series("build"));
gulp.task("build-no-bundle", () => buildBabel());
gulp.task(
  "watch",
  gulp.series("build-no-bundle", function watch() {
    gulpWatch(
      sources.map(getGlobFromSource),
      { debounceDelay: 200 },
      gulp.task("build-no-bundle")
    );
  })
);
registerStandalonePackageTask(
  gulp,
  "babel",
  "Babel",
  path.join(__dirname, "packages"),
  require("./packages/babel-core/package.json").version
);
const presetEnvWebpackPlugins = [
  new webpack.NormalModuleReplacementPlugin(
    /\.\/available-plugins/,
    require.resolve(
      path.join(
        __dirname,
        "./packages/babel-preset-env-standalone/src/available-plugins"
      )
    )
  ),
  new webpack.NormalModuleReplacementPlugin(
    /caniuse-lite\/data\/regions\/.+/,
    require.resolve(
      path.join(
        __dirname,
        "./packages/babel-preset-env-standalone/src/caniuse-lite-regions"
      )
    )
  ),
];
registerStandalonePackageTask(
  gulp,
  "babel-preset-env",
  "babelPresetEnv",
  path.join(__dirname, "packages"),
  require("./packages/babel-preset-env/package.json").version,
  presetEnvWebpackPlugins
);

// </from> /home/qfox/apps/babel/Gulpfile.js

