/**
 * @generated This file is auto-regenerated by the test runner, and auto-formatted by Prettier
 * @format
 **/
import {
  $ASI,
  $COMMENT,
  $COMMENT_HTML,
  $COMMENT_SINGLE,
  $COMMENT_MULTI,
  $CRLF,
  $EOF,
  $ERROR,
  $IDENT,
  $NL,
  $NUMBER,
  $NUMBER_HEX,
  $NUMBER_DEC,
  $NUMBER_BIN,
  $NUMBER_OCT,
  $NUMBER_OLD,
  $PUNCTUATOR,
  $REGEX,
  $REGEXU,
  $SPACE,
  $STRING,
  $STRING_DOUBLE,
  $STRING_SINGLE,
  $TAB,
  $TICK,
  $TICK_BAD_ESCAPE,
  $TICK_BODY,
  $TICK_HEAD,
  $TICK_PURE,
  $TICK_TAIL,
  $WHITE,
} from '../../../src/zetokenizer.mjs';
export default (describe, test) =>
  describe('arrays', _ => {
    describe('literal', _ => {
      test('empty array', {
        code: '[]',
        ast: {
          type: 'Program',
          body: [
            {
              type: 'ExpressionStatement',
              expression: {
                type: 'ArrayExpression',
                elements: [],
              },
            },
          ],
        },
        tokens: [$PUNCTUATOR, $PUNCTUATOR, $ASI],
      });
      test('simple array', {
        code: '[x]',
        ast: {
          type: 'Program',
          body: [
            {
              type: 'ExpressionStatement',
              expression: {
                type: 'ArrayExpression',
                elements: [
                  {
                    type: 'Identifier',
                    name: 'x',
                  },
                ],
              },
            },
          ],
        },
        tokens: [$PUNCTUATOR, $IDENT, $PUNCTUATOR, $ASI],
      });
      test('array empty 1 elision', {
        code: `[,]`,
        ast: {
          type: 'Program',
          body: [
            {
              type: 'ExpressionStatement',
              expression: {
                type: 'ArrayExpression',
                elements: [null],
              },
            },
          ],
        },
        tokens: [$PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $ASI],
      });
      test('array empty 2 elisions', {
        code: `[,,]`,
        ast: {
          type: 'Program',
          body: [
            {
              type: 'ExpressionStatement',
              expression: {
                type: 'ArrayExpression',
                elements: [null, null],
              },
            },
          ],
        },
        tokens: [$PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $ASI],
      });
      test('array empty 3 elisions', {
        code: `[,,,]`,
        ast: {
          type: 'Program',
          body: [
            {
              type: 'ExpressionStatement',
              expression: {
                type: 'ArrayExpression',
                elements: [null, null, null],
              },
            },
          ],
        },
        tokens: [$PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $ASI],
      });
      test('array with x and trailing comma', {
        code: `[x,]`,
        ast: {
          type: 'Program',
          body: [
            {
              type: 'ExpressionStatement',
              expression: {
                type: 'ArrayExpression',
                elements: [
                  {
                    type: 'Identifier',
                    name: 'x',
                  },
                ],
              },
            },
          ],
        },
        tokens: [$PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $ASI],
      });
      test('array with x and elisions', {
        code: `[x,,,]`,
        ast: {
          type: 'Program',
          body: [
            {
              type: 'ExpressionStatement',
              expression: {
                type: 'ArrayExpression',
                elements: [
                  {
                    type: 'Identifier',
                    name: 'x',
                  },
                  null,
                  null,
                ],
              },
            },
          ],
        },
        tokens: [$PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $ASI],
      });
      test('array with x and leading comma', {
        code: `[,x]`,
        ast: {
          type: 'Program',
          body: [
            {
              type: 'ExpressionStatement',
              expression: {
                type: 'ArrayExpression',
                elements: [
                  null,
                  {
                    type: 'Identifier',
                    name: 'x',
                  },
                ],
              },
            },
          ],
        },
        tokens: [$PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $ASI],
      });
      test('array with x and two leading commas', {
        code: `[,,x]`,
        ast: {
          type: 'Program',
          body: [
            {
              type: 'ExpressionStatement',
              expression: {
                type: 'ArrayExpression',
                elements: [
                  null,
                  null,
                  {
                    type: 'Identifier',
                    name: 'x',
                  },
                ],
              },
            },
          ],
        },
        tokens: [$PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $ASI],
      });
      test('array with middle elisions', {
        code: `[x,,y]`,
        ast: {
          type: 'Program',
          body: [
            {
              type: 'ExpressionStatement',
              expression: {
                type: 'ArrayExpression',
                elements: [
                  {
                    type: 'Identifier',
                    name: 'x',
                  },
                  null,
                  {
                    type: 'Identifier',
                    name: 'y',
                  },
                ],
              },
            },
          ],
        },
        tokens: [$PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $ASI],
      });
      test('can contain this', {
        code: '[this];',
        desc: 'assert that the keyword is a ThisExpression in the ast... (regression)',
        ast: {
          type: 'Program',
          body: [
            {
              type: 'ExpressionStatement',
              expression: {
                type: 'ArrayExpression',
                elements: [
                  {
                    type: 'ThisExpression',
                  },
                ],
              },
            },
          ],
        },
        tokens: [$PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR],
      });
      describe('spread', _ => {
        // https://tc39.github.io/ecma262/#prod-SpreadElement
        // ...AssignmentExpression[+In, ?Yield, ?Await]
        // (in other words; any expression is fair game here)
        test('splat another value', {
          code: '[x, y, ...z]',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'ArrayExpression',
                  elements: [
                    {
                      type: 'Identifier',
                      name: 'x',
                    },
                    {
                      type: 'Identifier',
                      name: 'y',
                    },
                    {
                      type: 'SpreadElement',
                      argument: {
                        type: 'Identifier',
                        name: 'z',
                      },
                    },
                  ],
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $ASI],
        });
        test('can splat in the middle', {
          code: '[x, ...y, z]',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'ArrayExpression',
                  elements: [
                    {
                      type: 'Identifier',
                      name: 'x',
                    },
                    {
                      type: 'SpreadElement',
                      argument: {
                        type: 'Identifier',
                        name: 'y',
                      },
                    },
                    {
                      type: 'Identifier',
                      name: 'z',
                    },
                  ],
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $ASI],
        });
        test('can splat an assignment at the end 1', {
          code: '[x, y, ...z = arr]',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'ArrayExpression',
                  elements: [
                    {
                      type: 'Identifier',
                      name: 'x',
                    },
                    {
                      type: 'Identifier',
                      name: 'y',
                    },
                    {
                      type: 'SpreadElement',
                      argument: {
                        type: 'AssignmentExpression',
                        left: {
                          type: 'Identifier',
                          name: 'z',
                        },
                        operator: '=',
                        right: {
                          type: 'Identifier',
                          name: 'arr',
                        },
                      },
                    },
                  ],
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $ASI],
        });
        test('cant rest an assignment at the end', {
          code: '[x, y, ...z = arr] = x',
          throws: true,
        });
        test('can splat a call at the end 1', {
          code: '[x, y, ...z()]',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'ArrayExpression',
                  elements: [
                    {
                      type: 'Identifier',
                      name: 'x',
                    },
                    {
                      type: 'Identifier',
                      name: 'y',
                    },
                    {
                      type: 'SpreadElement',
                      argument: {
                        type: 'CallExpression',
                        callee: {
                          type: 'Identifier',
                          name: 'z',
                        },
                        arguments: [],
                      },
                    },
                  ],
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $ASI],
        });
        test('can splat an expression at the end 1', {
          code: '[x, y, ...z + arr]',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'ArrayExpression',
                  elements: [
                    {
                      type: 'Identifier',
                      name: 'x',
                    },
                    {
                      type: 'Identifier',
                      name: 'y',
                    },
                    {
                      type: 'SpreadElement',
                      argument: {
                        type: 'BinaryExpression',
                        left: {
                          type: 'Identifier',
                          name: 'z',
                        },
                        operator: '+',
                        right: {
                          type: 'Identifier',
                          name: 'arr',
                        },
                      },
                    },
                  ],
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $ASI],
        });
        test('can splat an assignment at the end 2', {
          code: '[x, ...z = arr, y]',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'ArrayExpression',
                  elements: [
                    {
                      type: 'Identifier',
                      name: 'x',
                    },
                    {
                      type: 'SpreadElement',
                      argument: {
                        type: 'AssignmentExpression',
                        left: {
                          type: 'Identifier',
                          name: 'z',
                        },
                        operator: '=',
                        right: {
                          type: 'Identifier',
                          name: 'arr',
                        },
                      },
                    },
                    {
                      type: 'Identifier',
                      name: 'y',
                    },
                  ],
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $ASI],
        });
        test('can splat a call at the end 2', {
          code: '[x, ...z(), y]',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'ArrayExpression',
                  elements: [
                    {
                      type: 'Identifier',
                      name: 'x',
                    },
                    {
                      type: 'SpreadElement',
                      argument: {
                        type: 'CallExpression',
                        callee: {
                          type: 'Identifier',
                          name: 'z',
                        },
                        arguments: [],
                      },
                    },
                    {
                      type: 'Identifier',
                      name: 'y',
                    },
                  ],
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $ASI],
        });
        test('can splat an expression at the end 2', {
          code: '[x, ...z + arr, y]',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'ArrayExpression',
                  elements: [
                    {
                      type: 'Identifier',
                      name: 'x',
                    },
                    {
                      type: 'SpreadElement',
                      argument: {
                        type: 'BinaryExpression',
                        left: {
                          type: 'Identifier',
                          name: 'z',
                        },
                        operator: '+',
                        right: {
                          type: 'Identifier',
                          name: 'arr',
                        },
                      },
                    },
                    {
                      type: 'Identifier',
                      name: 'y',
                    },
                  ],
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $ASI],
        });
        test('can splat this', {
          code: '[...this];',
          ast: true,
          tokens: true,
        });
        test.fail('spread on string assignment', {
          code: '[..."foo"=x]',
        });
        test.pass('spread on string property assignment', {
          code: '[..."foo".foo=x]',
        });
        test('array spread with comma', {
          code: '[...(x), y]',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'ArrayExpression',
                  elements: [
                    {
                      type: 'SpreadElement',
                      argument: {
                        type: 'Identifier',
                        name: 'x',
                      },
                    },
                    {
                      type: 'Identifier',
                      name: 'y',
                    },
                  ],
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $ASI],
        });
      });
    });
    describe('destructuring', _ => {
      test('one var, no init, semi', {
        code: '[foo] = arr;',
        ast: {
          type: 'Program',
          body: [
            {
              type: 'ExpressionStatement',
              expression: {
                type: 'AssignmentExpression',
                left: {
                  type: 'ArrayPattern',
                  elements: [
                    {
                      type: 'Identifier',
                      name: 'foo',
                    },
                  ],
                },
                operator: '=',
                right: {
                  type: 'Identifier',
                  name: 'arr',
                },
              },
            },
          ],
        },
        tokens: [$PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR],
      });
      test('one var, with init, semi', {
        code: '[foo = A] = arr;',
        ast: {
          type: 'Program',
          body: [
            {
              type: 'ExpressionStatement',
              expression: {
                type: 'AssignmentExpression',
                left: {
                  type: 'ArrayPattern',
                  elements: [
                    {
                      type: 'AssignmentPattern',
                      left: {
                        type: 'Identifier',
                        name: 'foo',
                      },
                      right: {
                        type: 'Identifier',
                        name: 'A',
                      },
                    },
                  ],
                },
                operator: '=',
                right: {
                  type: 'Identifier',
                  name: 'arr',
                },
              },
            },
          ],
        },
        tokens: [$PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR],
      });
      test('two vars, no init, semi', {
        code: '[foo, bar] = arr;',
        ast: {
          type: 'Program',
          body: [
            {
              type: 'ExpressionStatement',
              expression: {
                type: 'AssignmentExpression',
                left: {
                  type: 'ArrayPattern',
                  elements: [
                    {
                      type: 'Identifier',
                      name: 'foo',
                    },
                    {
                      type: 'Identifier',
                      name: 'bar',
                    },
                  ],
                },
                operator: '=',
                right: {
                  type: 'Identifier',
                  name: 'arr',
                },
              },
            },
          ],
        },
        tokens: [$PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR],
      });
      test('two vars, both init, semi', {
        code: '[foo = A, bar = B] = arr;',
        ast: {
          type: 'Program',
          body: [
            {
              type: 'ExpressionStatement',
              expression: {
                type: 'AssignmentExpression',
                left: {
                  type: 'ArrayPattern',
                  elements: [
                    {
                      type: 'AssignmentPattern',
                      left: {
                        type: 'Identifier',
                        name: 'foo',
                      },

                      /*operator: '=',*/
                      right: {
                        type: 'Identifier',
                        name: 'A',
                      },
                    },
                    {
                      type: 'AssignmentPattern',
                      left: {
                        type: 'Identifier',
                        name: 'bar',
                      },

                      /*operator: '=',*/
                      right: {
                        type: 'Identifier',
                        name: 'B',
                      },
                    },
                  ],
                },
                operator: '=',
                right: {
                  type: 'Identifier',
                  name: 'arr',
                },
              },
            },
          ],
        },
        tokens: [$PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR],
      });
      test('let, nested array pattern', {
        code: '[foo, [x,y,z], bar = B] = arr;',
        ast: {
          type: 'Program',
          body: [
            {
              type: 'ExpressionStatement',
              expression: {
                type: 'AssignmentExpression',
                left: {
                  type: 'ArrayPattern',
                  elements: [
                    {
                      type: 'Identifier',
                      name: 'foo',
                    },
                    {
                      type: 'ArrayPattern',
                      elements: [
                        {
                          type: 'Identifier',
                          name: 'x',
                        },
                        {
                          type: 'Identifier',
                          name: 'y',
                        },
                        {
                          type: 'Identifier',
                          name: 'z',
                        },
                      ],
                    },
                    {
                      type: 'AssignmentPattern',
                      left: {
                        type: 'Identifier',
                        name: 'bar',
                      },

                      /*operator: '=',*/
                      right: {
                        type: 'Identifier',
                        name: 'B',
                      },
                    },
                  ],
                },
                operator: '=',
                right: {
                  type: 'Identifier',
                  name: 'arr',
                },
              },
            },
          ],
        },
        tokens: [$PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR],
      });
      test('let, super nested array pattern to make sure that isnt hardcoded', {
        code: '[foo, [[[[[[[[[[[[[x,y,z]]]]]]]]]]]]], bar = B] = arr;',
        ast: {
          type: 'Program',
          body: [
            {
              type: 'ExpressionStatement',
              expression: {
                type: 'AssignmentExpression',
                left: {
                  type: 'ArrayPattern',
                  elements: [
                    {
                      type: 'Identifier',
                      name: 'foo',
                    },
                    {
                      type: 'ArrayPattern',
                      elements: [
                        {
                          type: 'ArrayPattern',
                          elements: [
                            {
                              type: 'ArrayPattern',
                              elements: [
                                {
                                  type: 'ArrayPattern',
                                  elements: [
                                    {
                                      type: 'ArrayPattern',
                                      elements: [
                                        {
                                          type: 'ArrayPattern',
                                          elements: [
                                            {
                                              type: 'ArrayPattern',
                                              elements: [
                                                {
                                                  type: 'ArrayPattern',
                                                  elements: [
                                                    {
                                                      type: 'ArrayPattern',
                                                      elements: [
                                                        {
                                                          type: 'ArrayPattern',
                                                          elements: [
                                                            {
                                                              type: 'ArrayPattern',
                                                              elements: [
                                                                {
                                                                  type: 'ArrayPattern',
                                                                  elements: [
                                                                    {
                                                                      type: 'ArrayPattern',
                                                                      elements: [
                                                                        {
                                                                          type: 'Identifier',
                                                                          name: 'x',
                                                                        },
                                                                        {
                                                                          type: 'Identifier',
                                                                          name: 'y',
                                                                        },
                                                                        {
                                                                          type: 'Identifier',
                                                                          name: 'z',
                                                                        },
                                                                      ],
                                                                    },
                                                                  ],
                                                                },
                                                              ],
                                                            },
                                                          ],
                                                        },
                                                      ],
                                                    },
                                                  ],
                                                },
                                              ],
                                            },
                                          ],
                                        },
                                      ],
                                    },
                                  ],
                                },
                              ],
                            },
                          ],
                        },
                      ],
                    },
                    {
                      type: 'AssignmentPattern',
                      left: {
                        type: 'Identifier',
                        name: 'bar',
                      },

                      /*operator: '=',*/
                      right: {
                        type: 'Identifier',
                        name: 'B',
                      },
                    },
                  ],
                },
                operator: '=',
                right: {
                  type: 'Identifier',
                  name: 'arr',
                },
              },
            },
          ],
        },
        tokens: [
          $PUNCTUATOR,
          $IDENT,
          $PUNCTUATOR,
          $PUNCTUATOR,
          $PUNCTUATOR,
          $PUNCTUATOR,
          $PUNCTUATOR,
          $PUNCTUATOR,
          $PUNCTUATOR,
          $PUNCTUATOR,
          $PUNCTUATOR,
          $PUNCTUATOR,
          $PUNCTUATOR,
          $PUNCTUATOR,
          $PUNCTUATOR,
          $PUNCTUATOR,
          $IDENT,
          $PUNCTUATOR,
          $IDENT,
          $PUNCTUATOR,
          $IDENT,
          $PUNCTUATOR,
          $PUNCTUATOR,
          $PUNCTUATOR,
          $PUNCTUATOR,
          $PUNCTUATOR,
          $PUNCTUATOR,
          $PUNCTUATOR,
          $PUNCTUATOR,
          $PUNCTUATOR,
          $PUNCTUATOR,
          $PUNCTUATOR,
          $PUNCTUATOR,
          $PUNCTUATOR,
          $PUNCTUATOR,
          $IDENT,
          $PUNCTUATOR,
          $IDENT,
          $PUNCTUATOR,
          $PUNCTUATOR,
          $IDENT,
          $PUNCTUATOR,
        ],
      });
      test('let, nested array pattern with inner init and outer init', {
        code: '[foo, [x,y = 20,z], bar = B] = arr;',
        ast: {
          type: 'Program',
          body: [
            {
              type: 'ExpressionStatement',
              expression: {
                type: 'AssignmentExpression',
                left: {
                  type: 'ArrayPattern',
                  elements: [
                    {
                      type: 'Identifier',
                      name: 'foo',
                    },
                    {
                      type: 'ArrayPattern',
                      elements: [
                        {
                          type: 'Identifier',
                          name: 'x',
                        },
                        {
                          type: 'AssignmentPattern',
                          left: {
                            type: 'Identifier',
                            name: 'y',
                          },
                          right: {
                            type: 'Literal',
                            value: 20,
                            raw: '20',
                          },
                        },
                        {
                          type: 'Identifier',
                          name: 'z',
                        },
                      ],
                    },
                    {
                      type: 'AssignmentPattern',
                      left: {
                        type: 'Identifier',
                        name: 'bar',
                      },
                      right: {
                        type: 'Identifier',
                        name: 'B',
                      },
                    },
                  ],
                },
                operator: '=',
                right: {
                  type: 'Identifier',
                  name: 'arr',
                },
              },
            },
          ],
        },
        tokens: [$PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $NUMBER_DEC, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR],
      });
      test('destructuring array as call arg', {
        code: 'foo([a, b] = arr);',
        ast: {
          type: 'Program',
          body: [
            {
              type: 'ExpressionStatement',
              expression: {
                type: 'CallExpression',
                callee: {
                  type: 'Identifier',
                  name: 'foo',
                },
                arguments: [
                  {
                    type: 'AssignmentExpression',
                    left: {
                      type: 'ArrayPattern',
                      elements: [
                        {
                          type: 'Identifier',
                          name: 'a',
                        },
                        {
                          type: 'Identifier',
                          name: 'b',
                        },
                      ],
                    },
                    operator: '=',
                    right: {
                      type: 'Identifier',
                      name: 'arr',
                    },
                  },
                ],
              },
            },
          ],
        },
        tokens: [$IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR],
      });
      test.fail('can not wrap the whole lhs pattern in parens when assignment destructuring', {
        code: '([foo]) = arr;',
      });
      test('spread with ident with tail is ok', {
        code: '[...x.list];',
        ast: {
          type: 'Program',
          body: [
            {
              type: 'ExpressionStatement',
              expression: {
                type: 'ArrayExpression',
                elements: [
                  {
                    type: 'SpreadElement',
                    argument: {
                      type: 'MemberExpression',
                      object: {
                        type: 'Identifier',
                        name: 'x',
                      },
                      property: {
                        type: 'Identifier',
                        name: 'list',
                      },
                      computed: false,
                    },
                  },
                ],
              },
            },
          ],
        },
        tokens: [$PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR],
      });
      test('rest with member expression is destructible', {
        code: '[...x.list] = a;',
        ast: {
          type: 'Program',
          body: [
            {
              type: 'ExpressionStatement',
              expression: {
                type: 'AssignmentExpression',
                left: {
                  type: 'ArrayPattern',
                  elements: [
                    {
                      type: 'RestElement',
                      argument: {
                        type: 'MemberExpression',
                        object: {
                          type: 'Identifier',
                          name: 'x',
                        },
                        property: {
                          type: 'Identifier',
                          name: 'list',
                        },
                        computed: false,
                      },
                    },
                  ],
                },
                operator: '=',
                right: {
                  type: 'Identifier',
                  name: 'a',
                },
              },
            },
          ],
        },
        tokens: [$PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR],
      });
      test('spread with ident is ok', {
        code: '[...x = y];',
        ast: {
          type: 'Program',
          body: [
            {
              type: 'ExpressionStatement',
              expression: {
                type: 'ArrayExpression',
                elements: [
                  {
                    type: 'SpreadElement',
                    argument: {
                      type: 'AssignmentExpression',
                      left: {
                        type: 'Identifier',
                        name: 'x',
                      },
                      operator: '=',
                      right: {
                        type: 'Identifier',
                        name: 'y',
                      },
                    },
                  },
                ],
              },
            },
          ],
        },
        tokens: [$PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR],
      });
      test('spread with ident and assignment throws', {
        code: '[...x = y] = a;',
        throws: true,
      });
      test('spread with ident and compound assignment is ok', {
        code: '[...x += y];',
        ast: {
          type: 'Program',
          body: [
            {
              type: 'ExpressionStatement',
              expression: {
                type: 'ArrayExpression',
                elements: [
                  {
                    type: 'SpreadElement',
                    argument: {
                      type: 'AssignmentExpression',
                      left: {
                        type: 'Identifier',
                        name: 'x',
                      },
                      operator: '+=',
                      right: {
                        type: 'Identifier',
                        name: 'y',
                      },
                    },
                  },
                ],
              },
            },
          ],
        },
        tokens: [$PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR],
      });
      test('spread with ident and compound assignment is not destructible', {
        code: '[...x += y] = a;',
        throws: true,
      });
      test('spread with array with tail is ok', {
        code: '[...[x].map(y, z)];',
        ast: {
          type: 'Program',
          body: [
            {
              type: 'ExpressionStatement',
              expression: {
                type: 'ArrayExpression',
                elements: [
                  {
                    type: 'SpreadElement',
                    argument: {
                      type: 'CallExpression',
                      callee: {
                        type: 'MemberExpression',
                        object: {
                          type: 'ArrayExpression',
                          elements: [
                            {
                              type: 'Identifier',
                              name: 'x',
                            },
                          ],
                        },
                        property: {
                          type: 'Identifier',
                          name: 'map',
                        },
                        computed: false,
                      },
                      arguments: [
                        {
                          type: 'Identifier',
                          name: 'y',
                        },
                        {
                          type: 'Identifier',
                          name: 'z',
                        },
                      ],
                    },
                  },
                ],
              },
            },
          ],
        },
        tokens: [$PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR],
      });
      test('spread with array with tail is not destructible', {
        code: '[...[x].map(y, z)] = a;',
        throws: true,
      });
      test('spread with array with member tail is destructible', {
        code: '[...[x].map(y, z)[x]] = a;',
        ast: {
          type: 'Program',
          body: [
            {
              type: 'ExpressionStatement',
              expression: {
                type: 'AssignmentExpression',
                left: {
                  type: 'ArrayPattern',
                  elements: [
                    {
                      type: 'RestElement',
                      argument: {
                        type: 'MemberExpression',
                        object: {
                          type: 'CallExpression',
                          callee: {
                            type: 'MemberExpression',
                            object: {
                              type: 'ArrayExpression',
                              elements: [
                                {
                                  type: 'Identifier',
                                  name: 'x',
                                },
                              ],
                            },
                            property: {
                              type: 'Identifier',
                              name: 'map',
                            },
                            computed: false,
                          },
                          arguments: [
                            {
                              type: 'Identifier',
                              name: 'y',
                            },
                            {
                              type: 'Identifier',
                              name: 'z',
                            },
                          ],
                        },
                        property: {
                          type: 'Identifier',
                          name: 'x',
                        },
                        computed: true,
                      },
                    },
                  ],
                },
                operator: '=',
                right: {
                  type: 'Identifier',
                  name: 'a',
                },
              },
            },
          ],
        },
        tokens: [$PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR],
      });
      test('in comma expr', {
        code: 'x, [foo, bar] = doo',
        ast: {
          type: 'Program',
          body: [
            {
              type: 'ExpressionStatement',
              expression: {
                type: 'SequenceExpression',
                expressions: [
                  {
                    type: 'Identifier',
                    name: 'x',
                  },
                  {
                    type: 'AssignmentExpression',
                    left: {
                      type: 'ArrayPattern',
                      elements: [
                        {
                          type: 'Identifier',
                          name: 'foo',
                        },
                        {
                          type: 'Identifier',
                          name: 'bar',
                        },
                      ],
                    },
                    operator: '=',
                    right: {
                      type: 'Identifier',
                      name: 'doo',
                    },
                  },
                ],
              },
            },
          ],
        },
        tokens: [$IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $ASI],
      });
      test('with default in comma expr', {
        code: 'x, [foo = y, bar] = doo',
        ast: {
          type: 'Program',
          body: [
            {
              type: 'ExpressionStatement',
              expression: {
                type: 'SequenceExpression',
                expressions: [
                  {
                    type: 'Identifier',
                    name: 'x',
                  },
                  {
                    type: 'AssignmentExpression',
                    left: {
                      type: 'ArrayPattern',
                      elements: [
                        {
                          type: 'AssignmentPattern',
                          left: {
                            type: 'Identifier',
                            name: 'foo',
                          },
                          right: {
                            type: 'Identifier',
                            name: 'y',
                          },
                        },
                        {
                          type: 'Identifier',
                          name: 'bar',
                        },
                      ],
                    },
                    operator: '=',
                    right: {
                      type: 'Identifier',
                      name: 'doo',
                    },
                  },
                ],
              },
            },
          ],
        },
        tokens: [$IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $ASI],
      });
      test('that cant destruct in comma expr', {
        code: 'x, [foo + y, bar] = doo',
        throws: true,
      });
      test('inside assignment chain', {
        code: 'x = [a, b] = y',
        ast: {
          type: 'Program',
          body: [
            {
              type: 'ExpressionStatement',
              expression: {
                type: 'AssignmentExpression',
                left: {
                  type: 'Identifier',
                  name: 'x',
                },
                operator: '=',
                right: {
                  type: 'AssignmentExpression',
                  left: {
                    type: 'ArrayPattern',
                    elements: [
                      {
                        type: 'Identifier',
                        name: 'a',
                      },
                      {
                        type: 'Identifier',
                        name: 'b',
                      },
                    ],
                  },
                  operator: '=',
                  right: {
                    type: 'Identifier',
                    name: 'y',
                  },
                },
              },
            },
          ],
        },
        tokens: [$IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $ASI],
      });
      test('left of double assignment chain', {
        code: '[a, b] = c = d',
        ast: {
          type: 'Program',
          body: [
            {
              type: 'ExpressionStatement',
              expression: {
                type: 'AssignmentExpression',
                left: {
                  type: 'ArrayPattern',
                  elements: [
                    {
                      type: 'Identifier',
                      name: 'a',
                    },
                    {
                      type: 'Identifier',
                      name: 'b',
                    },
                  ],
                },
                operator: '=',
                right: {
                  type: 'AssignmentExpression',
                  left: {
                    type: 'Identifier',
                    name: 'c',
                  },
                  operator: '=',
                  right: {
                    type: 'Identifier',
                    name: 'd',
                  },
                },
              },
            },
          ],
        },
        tokens: [$PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $ASI],
      });
      describe('edge cases', _ => {
        test('should not transform the inner array to a arraydestruct', {
          code: '[a,b=[x,y]] = z',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'AssignmentExpression',
                  left: {
                    type: 'ArrayPattern',
                    elements: [
                      {
                        type: 'Identifier',
                        name: 'a',
                      },
                      {
                        type: 'AssignmentPattern',
                        left: {
                          type: 'Identifier',
                          name: 'b',
                        },
                        right: {
                          type: 'ArrayExpression',
                          elements: [
                            {
                              type: 'Identifier',
                              name: 'x',
                            },
                            {
                              type: 'Identifier',
                              name: 'y',
                            },
                          ],
                        },
                      },
                    ],
                  },
                  operator: '=',
                  right: {
                    type: 'Identifier',
                    name: 'z',
                  },
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $ASI],
        });
        test('assignment pattern can only have regular assignments 1', {
          code: '[a,b^=[x,y]] = z',
          throws: true,
        });
        test('assignment pattern can only have regular assignments 2', {
          code: '[a,b+=[x,y]] = z',
          throws: true,
        });
        test('arr destruct inside an arr lit', {
          code: '(foo, [bar, baz] = doo);',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'SequenceExpression',
                  expressions: [
                    {
                      type: 'Identifier',
                      name: 'foo',
                    },
                    {
                      type: 'AssignmentExpression',
                      left: {
                        type: 'ArrayPattern',
                        elements: [
                          {
                            type: 'Identifier',
                            name: 'bar',
                          },
                          {
                            type: 'Identifier',
                            name: 'baz',
                          },
                        ],
                      },
                      operator: '=',
                      right: {
                        type: 'Identifier',
                        name: 'doo',
                      },
                    },
                  ],
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR],
        });
      });
      describe('forward slash cases', _ => {
        test('spread with array-division', {
          code: '[...[x]/y]',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'ArrayExpression',
                  elements: [
                    {
                      type: 'SpreadElement',
                      argument: {
                        type: 'BinaryExpression',
                        left: {
                          type: 'ArrayExpression',
                          elements: [
                            {
                              type: 'Identifier',
                              name: 'x',
                            },
                          ],
                        },
                        operator: '/',
                        right: {
                          type: 'Identifier',
                          name: 'y',
                        },
                      },
                    },
                  ],
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $ASI],
        });
        test('spread with shorthand object-division will throw', {
          code: '[...{x}/y]',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'ArrayExpression',
                  elements: [
                    {
                      type: 'SpreadElement',
                      argument: {
                        type: 'BinaryExpression',
                        left: {
                          type: 'ObjectExpression',
                          properties: [
                            {
                              type: 'Property',
                              key: {
                                type: 'Identifier',
                                name: 'x',
                              },
                              kind: 'init',
                              method: false,
                              computed: false,
                              value: {
                                type: 'Identifier',
                                name: 'x',
                              },
                              shorthand: true,
                            },
                          ],
                        },
                        operator: '/',
                        right: {
                          type: 'Identifier',
                          name: 'y',
                        },
                      },
                    },
                  ],
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $ASI],
        });
        test('spread with object-division', {
          code: '[...{x:y}/y]',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'ArrayExpression',
                  elements: [
                    {
                      type: 'SpreadElement',
                      argument: {
                        type: 'BinaryExpression',
                        left: {
                          type: 'ObjectExpression',
                          properties: [
                            {
                              type: 'Property',
                              key: {
                                type: 'Identifier',
                                name: 'x',
                              },
                              kind: 'init',
                              method: false,
                              computed: false,
                              value: {
                                type: 'Identifier',
                                name: 'y',
                              },
                              shorthand: false,
                            },
                          ],
                        },
                        operator: '/',
                        right: {
                          type: 'Identifier',
                          name: 'y',
                        },
                      },
                    },
                  ],
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $ASI],
        });
        test('spread with just a regex', {
          code: '[.../x/]',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'ArrayExpression',
                  elements: [
                    {
                      type: 'SpreadElement',
                      argument: {
                        type: 'Literal',
                        value: null,
                        regex: {
                          pattern: 'x',
                          flags: '',
                        },
                        raw: '/x/',
                      },
                    },
                  ],
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $PUNCTUATOR, $REGEX, $PUNCTUATOR, $ASI],
        });
        test('spread with regex-plus', {
          code: '[.../x/+y]',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'ArrayExpression',
                  elements: [
                    {
                      type: 'SpreadElement',
                      argument: {
                        type: 'BinaryExpression',
                        left: {
                          type: 'Literal',
                          value: null,
                          regex: {
                            pattern: 'x',
                            flags: '',
                          },
                          raw: '/x/',
                        },
                        operator: '+',
                        right: {
                          type: 'Identifier',
                          name: 'y',
                        },
                      },
                    },
                  ],
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $PUNCTUATOR, $REGEX, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $ASI],
        });
        test('spread with regex-division', {
          code: '[.../x//y]',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'ArrayExpression',
                  elements: [
                    {
                      type: 'SpreadElement',
                      argument: {
                        type: 'BinaryExpression',
                        left: {
                          type: 'Literal',
                          value: null,
                          regex: {
                            pattern: 'x',
                            flags: '',
                          },
                          raw: '/x/',
                        },
                        operator: '/',
                        right: {
                          type: 'Identifier',
                          name: 'y',
                        },
                      },
                    },
                  ],
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $PUNCTUATOR, $REGEX, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $ASI],
        });
        test('spread with regex-flag-division', {
          code: '[.../x/g/y]',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'ArrayExpression',
                  elements: [
                    {
                      type: 'SpreadElement',
                      argument: {
                        type: 'BinaryExpression',
                        left: {
                          type: 'Literal',
                          value: null,
                          regex: {
                            pattern: 'x',
                            flags: 'g',
                          },
                          raw: '/x/g',
                        },
                        operator: '/',
                        right: {
                          type: 'Identifier',
                          name: 'y',
                        },
                      },
                    },
                  ],
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $PUNCTUATOR, $REGEX, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $ASI],
        });
        test.fail('spread with a regex and weird followu', {
          code: '[.../x/ y]',
        });
      });
      describe('member exprs', _ => {
        test('property of ident is assignable', {
          code: '[x.y] = z',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'AssignmentExpression',
                  left: {
                    type: 'ArrayPattern',
                    elements: [
                      {
                        type: 'MemberExpression',
                        object: {
                          type: 'Identifier',
                          name: 'x',
                        },
                        property: {
                          type: 'Identifier',
                          name: 'y',
                        },
                        computed: false,
                      },
                    ],
                  },
                  operator: '=',
                  right: {
                    type: 'Identifier',
                    name: 'z',
                  },
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $ASI],
        });
        test('property of call is assignable', {
          code: '[x().y] = z',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'AssignmentExpression',
                  left: {
                    type: 'ArrayPattern',
                    elements: [
                      {
                        type: 'MemberExpression',
                        object: {
                          type: 'CallExpression',
                          callee: {
                            type: 'Identifier',
                            name: 'x',
                          },
                          arguments: [],
                        },
                        property: {
                          type: 'Identifier',
                          name: 'y',
                        },
                        computed: false,
                      },
                    ],
                  },
                  operator: '=',
                  right: {
                    type: 'Identifier',
                    name: 'z',
                  },
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $ASI],
        });
        test('property of new is assignable', {
          code: '[new x().y] = z',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'AssignmentExpression',
                  left: {
                    type: 'ArrayPattern',
                    elements: [
                      {
                        type: 'MemberExpression',
                        object: {
                          type: 'NewExpression',
                          arguments: [],
                          callee: {
                            type: 'Identifier',
                            name: 'x',
                          },
                        },
                        property: {
                          type: 'Identifier',
                          name: 'y',
                        },
                        computed: false,
                      },
                    ],
                  },
                  operator: '=',
                  right: {
                    type: 'Identifier',
                    name: 'z',
                  },
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $IDENT, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $ASI],
        });
        test('dynamic property of ident is assignable', {
          code: '[a[x.y]] = z',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'AssignmentExpression',
                  left: {
                    type: 'ArrayPattern',
                    elements: [
                      {
                        type: 'MemberExpression',
                        object: {
                          type: 'Identifier',
                          name: 'a',
                        },
                        property: {
                          type: 'MemberExpression',
                          object: {
                            type: 'Identifier',
                            name: 'x',
                          },
                          property: {
                            type: 'Identifier',
                            name: 'y',
                          },
                          computed: false,
                        },
                        computed: true,
                      },
                    ],
                  },
                  operator: '=',
                  right: {
                    type: 'Identifier',
                    name: 'z',
                  },
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $ASI],
        });
        test('dynamic property of call is assignable', {
          code: '[x()[y]] = z',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'AssignmentExpression',
                  left: {
                    type: 'ArrayPattern',
                    elements: [
                      {
                        type: 'MemberExpression',
                        object: {
                          type: 'CallExpression',
                          callee: {
                            type: 'Identifier',
                            name: 'x',
                          },
                          arguments: [],
                        },
                        property: {
                          type: 'Identifier',
                          name: 'y',
                        },
                        computed: true,
                      },
                    ],
                  },
                  operator: '=',
                  right: {
                    type: 'Identifier',
                    name: 'z',
                  },
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $ASI],
        });
        test('dynamic property of new is assignable', {
          code: '[new x()[y]] = z',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'AssignmentExpression',
                  left: {
                    type: 'ArrayPattern',
                    elements: [
                      {
                        type: 'MemberExpression',
                        object: {
                          type: 'NewExpression',
                          arguments: [],
                          callee: {
                            type: 'Identifier',
                            name: 'x',
                          },
                        },
                        property: {
                          type: 'Identifier',
                          name: 'y',
                        },
                        computed: true,
                      },
                    ],
                  },
                  operator: '=',
                  right: {
                    type: 'Identifier',
                    name: 'z',
                  },
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $IDENT, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $ASI],
        });
        test('property of ident with a init is assignable', {
          code: '[x.y = a] = z',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'AssignmentExpression',
                  left: {
                    type: 'ArrayPattern',
                    elements: [
                      {
                        type: 'AssignmentPattern',
                        left: {
                          type: 'MemberExpression',
                          object: {
                            type: 'Identifier',
                            name: 'x',
                          },
                          property: {
                            type: 'Identifier',
                            name: 'y',
                          },
                          computed: false,
                        },
                        right: {
                          type: 'Identifier',
                          name: 'a',
                        },
                      },
                    ],
                  },
                  operator: '=',
                  right: {
                    type: 'Identifier',
                    name: 'z',
                  },
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $ASI],
        });
        test('property of call with a init is assignable', {
          code: '[x().y = a] = z',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'AssignmentExpression',
                  left: {
                    type: 'ArrayPattern',
                    elements: [
                      {
                        type: 'AssignmentPattern',
                        left: {
                          type: 'MemberExpression',
                          object: {
                            type: 'CallExpression',
                            callee: {
                              type: 'Identifier',
                              name: 'x',
                            },
                            arguments: [],
                          },
                          property: {
                            type: 'Identifier',
                            name: 'y',
                          },
                          computed: false,
                        },
                        right: {
                          type: 'Identifier',
                          name: 'a',
                        },
                      },
                    ],
                  },
                  operator: '=',
                  right: {
                    type: 'Identifier',
                    name: 'z',
                  },
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $ASI],
        });
        test('property of new with a init is assignable', {
          code: '[new x().y = a] = z',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'AssignmentExpression',
                  left: {
                    type: 'ArrayPattern',
                    elements: [
                      {
                        type: 'AssignmentPattern',
                        left: {
                          type: 'MemberExpression',
                          object: {
                            type: 'NewExpression',
                            arguments: [],
                            callee: {
                              type: 'Identifier',
                              name: 'x',
                            },
                          },
                          property: {
                            type: 'Identifier',
                            name: 'y',
                          },
                          computed: false,
                        },
                        right: {
                          type: 'Identifier',
                          name: 'a',
                        },
                      },
                    ],
                  },
                  operator: '=',
                  right: {
                    type: 'Identifier',
                    name: 'z',
                  },
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $IDENT, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $ASI],
        });
        test('dynamic property of ident with a init is assignable', {
          code: '[a[x.y] = a] = z',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'AssignmentExpression',
                  left: {
                    type: 'ArrayPattern',
                    elements: [
                      {
                        type: 'AssignmentPattern',
                        left: {
                          type: 'MemberExpression',
                          object: {
                            type: 'Identifier',
                            name: 'a',
                          },
                          property: {
                            type: 'MemberExpression',
                            object: {
                              type: 'Identifier',
                              name: 'x',
                            },
                            property: {
                              type: 'Identifier',
                              name: 'y',
                            },
                            computed: false,
                          },
                          computed: true,
                        },
                        right: {
                          type: 'Identifier',
                          name: 'a',
                        },
                      },
                    ],
                  },
                  operator: '=',
                  right: {
                    type: 'Identifier',
                    name: 'z',
                  },
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $ASI],
        });
        test('dynamic property of call with a init is assignable', {
          code: '[x()[y] = a ] = z',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'AssignmentExpression',
                  left: {
                    type: 'ArrayPattern',
                    elements: [
                      {
                        type: 'AssignmentPattern',
                        left: {
                          type: 'MemberExpression',
                          object: {
                            type: 'CallExpression',
                            callee: {
                              type: 'Identifier',
                              name: 'x',
                            },
                            arguments: [],
                          },
                          property: {
                            type: 'Identifier',
                            name: 'y',
                          },
                          computed: true,
                        },
                        right: {
                          type: 'Identifier',
                          name: 'a',
                        },
                      },
                    ],
                  },
                  operator: '=',
                  right: {
                    type: 'Identifier',
                    name: 'z',
                  },
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $ASI],
        });
        test('dynamic property of new with a init is assignable', {
          code: '[new x()[y] = a] = z',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'AssignmentExpression',
                  left: {
                    type: 'ArrayPattern',
                    elements: [
                      {
                        type: 'AssignmentPattern',
                        left: {
                          type: 'MemberExpression',
                          object: {
                            type: 'NewExpression',
                            arguments: [],
                            callee: {
                              type: 'Identifier',
                              name: 'x',
                            },
                          },
                          property: {
                            type: 'Identifier',
                            name: 'y',
                          },
                          computed: true,
                        },
                        right: {
                          type: 'Identifier',
                          name: 'a',
                        },
                      },
                    ],
                  },
                  operator: '=',
                  right: {
                    type: 'Identifier',
                    name: 'z',
                  },
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $IDENT, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $ASI],
        });
        test('property of ident with a+b init is assignable', {
          code: '[x.y = a + b] = z',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'AssignmentExpression',
                  left: {
                    type: 'ArrayPattern',
                    elements: [
                      {
                        type: 'AssignmentPattern',
                        left: {
                          type: 'MemberExpression',
                          object: {
                            type: 'Identifier',
                            name: 'x',
                          },
                          property: {
                            type: 'Identifier',
                            name: 'y',
                          },
                          computed: false,
                        },
                        right: {
                          type: 'BinaryExpression',
                          left: {
                            type: 'Identifier',
                            name: 'a',
                          },
                          operator: '+',
                          right: {
                            type: 'Identifier',
                            name: 'b',
                          },
                        },
                      },
                    ],
                  },
                  operator: '=',
                  right: {
                    type: 'Identifier',
                    name: 'z',
                  },
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $ASI],
        });
        test('property of call with a+b init is assignable', {
          code: '[x().y = a + b] = z',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'AssignmentExpression',
                  left: {
                    type: 'ArrayPattern',
                    elements: [
                      {
                        type: 'AssignmentPattern',
                        left: {
                          type: 'MemberExpression',
                          object: {
                            type: 'CallExpression',
                            callee: {
                              type: 'Identifier',
                              name: 'x',
                            },
                            arguments: [],
                          },
                          property: {
                            type: 'Identifier',
                            name: 'y',
                          },
                          computed: false,
                        },
                        right: {
                          type: 'BinaryExpression',
                          left: {
                            type: 'Identifier',
                            name: 'a',
                          },
                          operator: '+',
                          right: {
                            type: 'Identifier',
                            name: 'b',
                          },
                        },
                      },
                    ],
                  },
                  operator: '=',
                  right: {
                    type: 'Identifier',
                    name: 'z',
                  },
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $ASI],
        });
        test('property of new with a+b init is assignable', {
          code: '[new x().y = a + b] = z',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'AssignmentExpression',
                  left: {
                    type: 'ArrayPattern',
                    elements: [
                      {
                        type: 'AssignmentPattern',
                        left: {
                          type: 'MemberExpression',
                          object: {
                            type: 'NewExpression',
                            arguments: [],
                            callee: {
                              type: 'Identifier',
                              name: 'x',
                            },
                          },
                          property: {
                            type: 'Identifier',
                            name: 'y',
                          },
                          computed: false,
                        },
                        right: {
                          type: 'BinaryExpression',
                          left: {
                            type: 'Identifier',
                            name: 'a',
                          },
                          operator: '+',
                          right: {
                            type: 'Identifier',
                            name: 'b',
                          },
                        },
                      },
                    ],
                  },
                  operator: '=',
                  right: {
                    type: 'Identifier',
                    name: 'z',
                  },
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $IDENT, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $ASI],
        });
        test('dynamic property of ident with a+b init is assignable', {
          code: '[a[x.y] = a + b] = z',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'AssignmentExpression',
                  left: {
                    type: 'ArrayPattern',
                    elements: [
                      {
                        type: 'AssignmentPattern',
                        left: {
                          type: 'MemberExpression',
                          object: {
                            type: 'Identifier',
                            name: 'a',
                          },
                          property: {
                            type: 'MemberExpression',
                            object: {
                              type: 'Identifier',
                              name: 'x',
                            },
                            property: {
                              type: 'Identifier',
                              name: 'y',
                            },
                            computed: false,
                          },
                          computed: true,
                        },
                        right: {
                          type: 'BinaryExpression',
                          left: {
                            type: 'Identifier',
                            name: 'a',
                          },
                          operator: '+',
                          right: {
                            type: 'Identifier',
                            name: 'b',
                          },
                        },
                      },
                    ],
                  },
                  operator: '=',
                  right: {
                    type: 'Identifier',
                    name: 'z',
                  },
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $ASI],
        });
        test('dynamic property of call with a+b init is assignable', {
          code: '[x()[y] = a + b] = z',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'AssignmentExpression',
                  left: {
                    type: 'ArrayPattern',
                    elements: [
                      {
                        type: 'AssignmentPattern',
                        left: {
                          type: 'MemberExpression',
                          object: {
                            type: 'CallExpression',
                            callee: {
                              type: 'Identifier',
                              name: 'x',
                            },
                            arguments: [],
                          },
                          property: {
                            type: 'Identifier',
                            name: 'y',
                          },
                          computed: true,
                        },
                        right: {
                          type: 'BinaryExpression',
                          left: {
                            type: 'Identifier',
                            name: 'a',
                          },
                          operator: '+',
                          right: {
                            type: 'Identifier',
                            name: 'b',
                          },
                        },
                      },
                    ],
                  },
                  operator: '=',
                  right: {
                    type: 'Identifier',
                    name: 'z',
                  },
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $ASI],
        });
        test('dynamic property of new with a+b init is assignable', {
          code: '[new x()[y] = a + b] = z',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'AssignmentExpression',
                  left: {
                    type: 'ArrayPattern',
                    elements: [
                      {
                        type: 'AssignmentPattern',
                        left: {
                          type: 'MemberExpression',
                          object: {
                            type: 'NewExpression',
                            arguments: [],
                            callee: {
                              type: 'Identifier',
                              name: 'x',
                            },
                          },
                          property: {
                            type: 'Identifier',
                            name: 'y',
                          },
                          computed: true,
                        },
                        right: {
                          type: 'BinaryExpression',
                          left: {
                            type: 'Identifier',
                            name: 'a',
                          },
                          operator: '+',
                          right: {
                            type: 'Identifier',
                            name: 'b',
                          },
                        },
                      },
                    ],
                  },
                  operator: '=',
                  right: {
                    type: 'Identifier',
                    name: 'z',
                  },
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $IDENT, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $ASI],
        });
        test('can be a function', {
          code: '[function(){}.length] = x',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'AssignmentExpression',
                  left: {
                    type: 'ArrayPattern',
                    elements: [
                      {
                        type: 'MemberExpression',
                        object: {
                          type: 'FunctionExpression',
                          generator: false,
                          async: false,
                          id: null,
                          params: [],
                          body: {
                            type: 'BlockStatement',
                            body: [],
                          },
                        },
                        property: {
                          type: 'Identifier',
                          name: 'length',
                        },
                        computed: false,
                      },
                    ],
                  },
                  operator: '=',
                  right: {
                    type: 'Identifier',
                    name: 'x',
                  },
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $ASI],
        });
        test('can be a number', {
          code: '[5..length] = x',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'AssignmentExpression',
                  left: {
                    type: 'ArrayPattern',
                    elements: [
                      {
                        type: 'MemberExpression',
                        object: {
                          type: 'Literal',
                          value: 5,
                          raw: '5.',
                        },
                        property: {
                          type: 'Identifier',
                          name: 'length',
                        },
                        computed: false,
                      },
                    ],
                  },
                  operator: '=',
                  right: {
                    type: 'Identifier',
                    name: 'x',
                  },
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $NUMBER_DEC, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $ASI],
        });
        test('can be a string', {
          code: '["X".length] = x',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'AssignmentExpression',
                  left: {
                    type: 'ArrayPattern',
                    elements: [
                      {
                        type: 'MemberExpression',
                        object: {
                          type: 'Literal',
                          value: 'X',
                          raw: '"X"',
                        },
                        property: {
                          type: 'Identifier',
                          name: 'length',
                        },
                        computed: false,
                      },
                    ],
                  },
                  operator: '=',
                  right: {
                    type: 'Identifier',
                    name: 'x',
                  },
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $STRING_DOUBLE, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $ASI],
        });
        test('can be a simple template', {
          code: '[`x`.length] = x',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'AssignmentExpression',
                  left: {
                    type: 'ArrayPattern',
                    elements: [
                      {
                        type: 'MemberExpression',
                        object: {
                          type: 'TemplateLiteral',
                          expressions: [],
                          quasis: [
                            {
                              type: 'TemplateElement',
                              tail: true,
                              value: {
                                raw: '`x`',
                                cooked: '<TODO>',
                              },
                            },
                          ],
                        },
                        property: {
                          type: 'Identifier',
                          name: 'length',
                        },
                        computed: false,
                      },
                    ],
                  },
                  operator: '=',
                  right: {
                    type: 'Identifier',
                    name: 'x',
                  },
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $TICK_PURE, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $ASI],
        });
        test('can be a complex template', {
          code: '[`a${5}b`.length] = x',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'AssignmentExpression',
                  left: {
                    type: 'ArrayPattern',
                    elements: [
                      {
                        type: 'MemberExpression',
                        object: {
                          type: 'TemplateLiteral',
                          expressions: [
                            {
                              type: 'Literal',
                              value: 5,
                              raw: '5',
                            },
                          ],
                          quasis: [
                            {
                              type: 'TemplateElement',
                              tail: false,
                              value: {
                                raw: '`a${',
                                cooked: '<TODO>',
                              },
                            },
                            {
                              type: 'TemplateElement',
                              tail: true,
                              value: {
                                raw: '}b`',
                                cooked: '<TODO>',
                              },
                            },
                          ],
                        },
                        property: {
                          type: 'Identifier',
                          name: 'length',
                        },
                        computed: false,
                      },
                    ],
                  },
                  operator: '=',
                  right: {
                    type: 'Identifier',
                    name: 'x',
                  },
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $TICK_HEAD, $NUMBER_DEC, $TICK_TAIL, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $ASI],
        });
        test('can be a regex', {
          code: '[/foo/.length] = x',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'AssignmentExpression',
                  left: {
                    type: 'ArrayPattern',
                    elements: [
                      {
                        type: 'MemberExpression',
                        object: {
                          type: 'Literal',
                          value: null,
                          regex: {
                            pattern: 'foo',
                            flags: '',
                          },
                          raw: '/foo/',
                        },
                        property: {
                          type: 'Identifier',
                          name: 'length',
                        },
                        computed: false,
                      },
                    ],
                  },
                  operator: '=',
                  right: {
                    type: 'Identifier',
                    name: 'x',
                  },
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $REGEX, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $ASI],
        });
        test('can be a flagged regex', {
          code: '[/x/g.length] = x',
          ast: {
            type: 'Program',
            body: [
              {
                type: 'ExpressionStatement',
                expression: {
                  type: 'AssignmentExpression',
                  left: {
                    type: 'ArrayPattern',
                    elements: [
                      {
                        type: 'MemberExpression',
                        object: {
                          type: 'Literal',
                          value: null,
                          regex: {
                            pattern: 'x',
                            flags: 'g',
                          },
                          raw: '/x/g',
                        },
                        property: {
                          type: 'Identifier',
                          name: 'length',
                        },
                        computed: false,
                      },
                    ],
                  },
                  operator: '=',
                  right: {
                    type: 'Identifier',
                    name: 'x',
                  },
                },
              },
            ],
          },
          tokens: [$PUNCTUATOR, $REGEX, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $ASI],
        });
      });
      test('this cant destruct', {
        code: '[this] = obj',
        throws: 'destructible',
      });
      describe('spread mirror rest tests', _ => {
        // https://tc39.github.io/ecma262/#prod-SpreadElement
        // ...AssignmentExpression[+In, ?Yield, ?Await]
        // (in other words; any expression is fair game here)
        test('rest another value', {
          code: '[x, y, ...z] = obj',
          ast: true,
          tokens: true,
        });
        test('can not rest in the middle', {
          code: '[x, ...y, z] = obj',
          throws: true,
        });
        test('can not rest an assignment at the end 1', {
          code: '[x, y, ...z = arr] = obj',
          throws: true,
        });
        test('cant rest an assignment at the end', {
          code: '[x, y, ...z = arr] = x = obj',
          throws: true,
        });
        test('can not rest a call at the end 1', {
          code: '[x, y, ...z()] = obj',
          throws: true,
        });
        test('can not splat an expression at the end', {
          code: '[x, y, ...z + arr] = obj',
          throws: true,
        });
        test('can not rest an assignment at the end 2', {
          code: '[x, ...z = arr, y] = obj',
          throws: true,
        });
        test('can not rest a call at the end 2', {
          code: '[x, ...z(), y] = obj',
          throws: true,
        });
        test('can not rest an expression at the end', {
          code: '[x, ...z + arr, y] = obj',
          throws: true,
        });
        test('rest this cant destruct', {
          code: '[...this] = obj',
          throws: 'destructible',
        });
      });
      test('comma expression assignment', {
        code: '[(x, y)] = x;',
        throws: 'not destructible',
      });
      test('wrapped comma expression assignment', {
        code: '[[(x, y)]] = x;',
        throws: 'not destructible',
      });
      test('spreaded comma expression assignment', {
        code: '[...[(x, y)]] = x;',
        throws: 'not destructible',
      });
      test('destructuring an objlit with property in an array', {
        code: '[{}.x] = y',
        ast: {
          type: 'Program',
          body: [
            {
              type: 'ExpressionStatement',
              expression: {
                type: 'AssignmentExpression',
                left: {
                  type: 'ArrayPattern',
                  elements: [
                    {
                      type: 'MemberExpression',
                      object: {
                        type: 'ObjectExpression',
                        properties: [],
                      },
                      property: {
                        type: 'Identifier',
                        name: 'x',
                      },
                      computed: false,
                    },
                  ],
                },
                operator: '=',
                right: {
                  type: 'Identifier',
                  name: 'y',
                },
              },
            },
          ],
        },
        tokens: [$PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $ASI],
      });
      test('destructuring an objlit with computed property in an array', {
        code: '[{}[x]] = y',
        ast: {
          type: 'Program',
          body: [
            {
              type: 'ExpressionStatement',
              expression: {
                type: 'AssignmentExpression',
                left: {
                  type: 'ArrayPattern',
                  elements: [
                    {
                      type: 'MemberExpression',
                      object: {
                        type: 'ObjectExpression',
                        properties: [],
                      },
                      property: {
                        type: 'Identifier',
                        name: 'x',
                      },
                      computed: true,
                    },
                  ],
                },
                operator: '=',
                right: {
                  type: 'Identifier',
                  name: 'y',
                },
              },
            },
          ],
        },
        tokens: [$PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $PUNCTUATOR, $PUNCTUATOR, $PUNCTUATOR, $IDENT, $ASI],
      });
      test.pass('destructuring an arrlit with property in an array', {
        code: '[[].x] = y',
      });
      test.pass('destructuring an arrlit with computed property in an array', {
        code: '[[][x]] = y',
      });
      test('destruct to keyword', {
        code: '[true = x] = x',
        throws: 'keyword',
      });
      test('assignment to keyword without destruct', {
        code: '[true = x]',
        throws: 'keyword',
      });
      describe('spreadrest keywords', _ => {
        test.pass('spread a value keyword', {
          code: '[...true]',
          desc: 'runtime error',
        });
        test('destruct assign rest a value keyword', {
          code: '[...true] = x',
          throws: 'destructible',
        });
        test.fail('arrow rest a value keyword', {
          code: '[...true] => x',
        });
        test.fail('spread a bad keyword', {
          code: '[...new]',
        });
        test.fail('destruct assign rest a bad keyword', {
          code: '[...new] = x',
        });
        test.fail('arrow rest a bad keyword', {
          code: '[...new] => x',
        });
      });
      test('rest on string assignment to destruct assignment', {
        code: '[..."foo"=x] = x',
        throws: 'destructible',
      });
      test('spread on string property assignment to destruct assignment', {
        code: '[..."foo".foo=x] = x',
        throws: 'destructible',
      });
      test('rest on string assignment to arrow', {
        code: '([..."foo"=x]) => x',
        throws: 'destructible',
      });
      test('spread on string property assignment to arrow', {
        code: '([..."foo".foo=x]) => x',
        throws: 'destructible',
      });
      test.pass('destruct assignment to rest on a property', {
        code: '[..."foo".bar] = x',
      });
      test.fail('destruct assignment to rest on an addition', {
        code: '[..."foo"+bar] = x',
      });
      test.pass('destruct assignment that starts with number', {
        code: '[50..foo] = x',
      });
      test.pass('destruct assignment that starts with string', {
        code: '["foo".foo] = x',
      });
      test.pass('assignment should not copy rhs state', {
        code: '[x = true] = y',
        desc: 'the rhs is not assignable nor destructible but that should be reset due to the assignment',
      });
      test.pass('nested assignment should not copy rhs state', {
        code: '[[x] = true] = y',
      });
      test.pass('more nested assignment should not copy rhs state', {
        code: '[[x = true] = true] = y',
      });
      test.fail_strict('rest with yield default destructible assignment', {
        code: 'result = [...{ x = yield }] = y;',
      });
      test.pass('yield is not illegal in destruct assignment', {
        code: `function* g() {   [...{ x = yield }] = y   }`,
      });
      test.fail_strict('spread with await var', {
        code: '[...await]',
      });
      test.fail_strict('spread with yield var', {
        code: '[...yield]',
      });
      test.pass('spread with await keyword', {
        code: 'async x => [...await x]',
      });
      test.pass('spread with argless yield keyword', {
        code: 'function *f(){ return [...yield]; }',
      });
      test.pass('spread with arged yield keyword', {
        code: 'function *f(){ return [...yield x]; }',
      });
      test.fail_strict('spread with await in divison', {
        code: '[.../x//yield]',
      });
      test.pass('rest that is member expression is assignable', {
        code: '[...a.b] = c',
      });
      test.pass('spread an assignment in array', {
        code: '([...x=y])',
      });
      test.fail('assignment destruct rest an assignment in array', {
        code: '([...x=y]) = z',
      });
      test.fail('arrow destruct rest an assignment in array', {
        code: '([...x=y]) => z',
      });
      test.fail('let destruct rest an assignment in array', {
        code: 'let [...x=y] = z',
      });
    });
    describe('keywords should not parse as regular idents in awkward places', _ => {
      // see counter-test in arrow where this stuff is disallowed
      ['async ()=>x', 'class{}', 'delete x.y', 'false', 'function(){}', 'new x', 'null', 'true', 'this', 'typeof x', 'void x', 'x + y', '[].length', '[x].length', '{}.length', '{x: y}.length'].forEach(str => {
        test.fail('[' + str + '] in destructuring assignment as shorthand', {
          code: '[' + str + '] = x;',
          throws: str.includes('.length') ? undefined : true,
          ast: str.includes('.length') ? true : undefined,
          desc: `
            property is valid assignment target so should work
          `,
          tokens: str.includes('.length') ? true : undefined,
        });
        test.pass('[' + str + '] in array', {
          code: '[' + str + ']',
        });
        test.fail('[' + str + '] in arrow head', {
          code: '([' + str + ']) => x;',
        });
      });
    });
  });
