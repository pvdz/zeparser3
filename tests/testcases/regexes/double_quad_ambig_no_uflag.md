# ZeParser parser test case

- Path: tests/testcases/regexes/double_quad_ambig_no_uflag.md

> :: regexes
>
> ::> double quad ambig no uflag
>
> This attempts to test a derailing of the regex parser which has to decode a double quad as a potential code point while at the same time considering the second part as the start of a range in case there is no u-flag.
>
> Essentially it looks like this;
>
> A range consists of two parts and has the rule that the left side must be lower than the right side.
>
> With u-flag, a double quad can be a surrogate pair and have to be parsed as such.
>
> If there is no u-flag, then what would be a surrogate pair, will just be a single character leaving the second quad to be parsed separately.
>
> These surrogate pairs always have a left char of 0xD800~0xDBFF and the right side 0xDC00~0xDFFF.
>
> Consider these sequences;
>
> - `/[a-b]/`. This is simple
>
> - `/[\uD800-\uFFFF]/`. Also simple, can't go wrong.
>
> - `/[\uDC00-\uFFFF]/`. Also simple, can't go wrong.
>
> - `/[\uD800\uDC00-\uFFFF]/`. Hmm. With u-flag, this is now illegal because the surrogate pair will exceed xFFFF.
>
> - `/[\uD800\uDC00-\uDBFF]/`. Ah back to simple. This is illegal in both readings because xDBFF is lower than xDC00 as well as the surrogate pair.
>
> - `/[a-\uD800\uDC00-\uDBFF]/`. Oh, hummm. Now for u-flag we have to consume the second quad but without u-flag we have to remember it for the range.
>
> - `/[a-\uD800\uDC00-\uDBFF]/`. Drat. Now even with u-flag we have to parse the second quad, only to conclude we can't use it. But still remember it for the next range.
>
> - `/[a-\uD800\uDC00-\uDBFF]/`. Oh no. Not only do we have to remember it, it potentially starts another surrogate pair!
>
> - `/[a-\uD800\uD800\uDC00-\uFFFF]/`. And now it did. This case would be illegal with u-flag, because the surrogate pair string value will be greater than xFFFF. Without u-flag this is fine.
>
> 
>
> In this parser, the problem is that the result from the second quad is difficult to feed forward together with the result of the code point.
>
> 
>
> I think this is only a problem for regular expressions, due to ranges.
>
> 
>
> I think identifier cases are not ambiguous (a valid surrogate pair cannot be a valid ident part with and without u-flag)

## Input

`````js

`````

## Output

_Note: the whole output block is auto-generated. Manual changes will be overwritten!_

Below follow outputs in four parsing modes: sloppy mode, strict mode script goal, module goal, web compat mode (always sloppy).

Note that the output parts are auto-generated by the test runner to reflect actual result.

### Sloppy mode

Parsed with script goal and as if the code did not start with strict mode header.

`````
ast: {
  type: 'Program',
  loc:{start:{line:1,column:0},end:{line:1,column:0},source:''},
  body: []
}

tokens (1x):

`````

### Strict mode

Parsed with script goal but as if it was starting with `"use strict"` at the top.

_Output same as sloppy mode._

### Module goal

Parsed with the module goal.

_Output same as sloppy mode._

### Web compat mode

Parsed in sloppy script mode but with the web compat flag enabled.

_Output same as sloppy mode._

## AST Printer

Printer output was same as input [sloppy]